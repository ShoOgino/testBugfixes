{"path":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8","date":1328775259,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final AtomicReaderContext[] context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final AtomicReaderContext[] context = ReaderUtil.leaves(s.getTopReaderContext());\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"780a0d1ca6c3d6eb71331bb36a0f467051300e45","date":1335141654,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final AtomicReaderContext[] context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  // check that first skip on just created scorers always goes to the right doc\n  private static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final AtomicReaderContext[] context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ceb5bb30e401cb218b31197b1a9aa47e77cda17","date":1336330521,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final AtomicReaderContext[] context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final AtomicReaderContext[] context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final AtomicReaderContext[] context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context[leafPtr], true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":["64714133cf5ec732e3bbceee63351bb9af0117dc"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e18c86f811939bfa8cd24046c96ed026f2e9b34","date":1393893071,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"acf00221f44c5f08ccea014f2492b53af15ecd66","date":1394568293,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), true, false, liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), true, false, previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new Collector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public void setNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final AtomicReader lastReader[] = {null};\n    final List<AtomicReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final AtomicReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((AtomicReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n      @Override\n      public boolean acceptsDocsOutOfOrder() {\n        return false;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"781239fc84d36be12b84e4d3e2618f5f07a182e3","date":1423139668,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs, true);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs(), true);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs(), true);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":["c9fb5f46e264daf5ba3860defe623a89d202dd87","2e18c86f811939bfa8cd24046c96ed026f2e9b34"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb17639909a369c1e64866842e5c213440acc17e","date":1423238093,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs, true);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs(), true);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs(), true);\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"954e59be3da8dc1b046646ad7af4b466852009d3","date":1423482367,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, PostingsEnum.FLAG_FREQS);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, PostingsEnum.FLAG_FREQS);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, PostingsEnum.FLAG_FREQS);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6a47d642ab24da1a811adce4bda9cc52c520ca13","date":1423483323,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, PostingsEnum.FLAG_FREQS);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, PostingsEnum.FLAG_FREQS);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, PostingsEnum.FLAG_FREQS);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b52f4d438f568f7beafda3cf347790a4bfe32928","date":1425545677,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":["30a558487f2298c2c19ceca9103c1b6865d64708","f5d8d97303550346f85fd577f90d64cf196cebd1","facd440f562ba04187b82c36465181d6ba7030fa"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but skipTo(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but skipTo(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float skipToScore = scorer.score();\n            Assert.assertEquals(\"unstable skipTo(\"+i+\") score!\",skipToScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but skipTo(\"+i+\") has <\"+skipToScore+\">!\",score,skipToScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"485545da3b4429d6f138b4baac573a97820ee93b","date":1433876557,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = scorer.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = scorer.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = scorer.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = scorer.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      private Bits liveDocs;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n        liveDocs = context.reader().getLiveDocs();\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());\n      if (scorer != null) {\n        boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dd748bb245633a8195281556bb0e68a6ea97d18","date":1449755030,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = scorer.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = scorer.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = scorer.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = scorer.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","date":1457644139,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":["790e1fde4caa765b3faaad3fbcd25c6973450336"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e7bc21595222ae4f75509300fbb7726691f387f","date":1464078795,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff); \n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n            \n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      \n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, true);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public boolean needsScores() {\n        return true;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, true);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68d6cb7f0f019661a784bd0e5a21e85b5f812af6","date":1515075216,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity(true));\n      Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"475584d5e08a22ad3fc7babefe006d77bc744567","date":1523282824,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    Query rewritten = s.rewrite(q);\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58e44159788900f4a2113b84463dc3fbbf80f20","date":1523319203,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    Query rewritten = s.rewrite(q);\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285244982ce6aa163d1e60a707f0e6e121736ce5","date":1536055304,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    Query rewritten = s.rewrite(q);\n    s.search(q,new SimpleCollector() {\n      private Scorable scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorable scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    Query rewritten = s.rewrite(q);\n    s.search(q,new SimpleCollector() {\n      private Scorer scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorer scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkFirstSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    Query rewritten = s.rewrite(q);\n    s.search(q,new SimpleCollector() {\n      private Scorable scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorable scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","sourceOld":"  /** check that first skip on just created scorers always goes to the right doc */\n  public static void checkFirstSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"checkFirstSkipTo: \"+q);\n    final float maxDiff = 1e-3f;\n    final int lastDoc[] = {-1};\n    final LeafReader lastReader[] = {null};\n    final List<LeafReaderContext> context = s.getTopReaderContext().leaves();\n    Query rewritten = s.rewrite(q);\n    s.search(q,new SimpleCollector() {\n      private Scorable scorer;\n      private int leafPtr;\n      @Override\n      public void setScorer(Scorable scorer) {\n        this.scorer = scorer;\n      }\n      @Override\n      public void collect(int doc) throws IOException {\n        float score = scorer.score();\n        try {\n          long startMS = System.currentTimeMillis();\n          for (int i=lastDoc[0]+1; i<=doc; i++) {\n            Weight w = s.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n            Scorer scorer = w.scorer(context.get(leafPtr));\n            Assert.assertTrue(\"query collected \"+doc+\" but advance(\"+i+\") says no more docs!\",scorer.iterator().advance(i) != DocIdSetIterator.NO_MORE_DOCS);\n            Assert.assertEquals(\"query collected \"+doc+\" but advance(\"+i+\") got to \"+scorer.docID(),doc,scorer.docID());\n            float advanceScore = scorer.score();\n            Assert.assertEquals(\"unstable advance(\"+i+\") score!\",advanceScore,scorer.score(),maxDiff);\n            Assert.assertEquals(\"query assigned doc \"+doc+\" a score of <\"+score+\"> but advance(\"+i+\") has <\"+advanceScore+\">!\",score,advanceScore,maxDiff);\n\n            // Hurry things along if they are going slow (eg\n            // if you got SimpleText codec this will kick in):\n            if (i < doc && System.currentTimeMillis() - startMS > 5) {\n              i = doc-1;\n            }\n          }\n          lastDoc[0] = doc;\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public ScoreMode scoreMode() {\n        return ScoreMode.COMPLETE;\n      }\n\n      @Override\n      protected void doSetNextReader(LeafReaderContext context) throws IOException {\n        // confirm that skipping beyond the last doc, on the\n        // previous reader, hits NO_MORE_DOCS\n        if (lastReader[0] != null) {\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n          Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = context.reader().getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n          leafPtr++;\n        }\n\n        lastReader[0] = context.reader();\n        lastDoc[0] = -1;\n      }\n    });\n\n    if (lastReader[0] != null) {\n      // confirm that skipping beyond the last doc, on the\n      // previous reader, hits NO_MORE_DOCS\n      final LeafReader previousReader = lastReader[0];\n      IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n      indexSearcher.setSimilarity(s.getSimilarity());\n      Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n      Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext());\n      if (scorer != null) {\n        DocIdSetIterator iterator = scorer.iterator();\n        boolean more = false;\n        final Bits liveDocs = lastReader[0].getLiveDocs();\n        for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n          if (liveDocs == null || liveDocs.get(d)) {\n            more = true;\n            break;\n          }\n        }\n        Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6a47d642ab24da1a811adce4bda9cc52c520ca13":["954e59be3da8dc1b046646ad7af4b466852009d3"],"fb17639909a369c1e64866842e5c213440acc17e":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"b94236357aaa22b76c10629851fe4e376e0cea82":["417142ff08fda9cf0b72d5133e63097a166c6458","68d6cb7f0f019661a784bd0e5a21e85b5f812af6"],"475584d5e08a22ad3fc7babefe006d77bc744567":["b94236357aaa22b76c10629851fe4e376e0cea82"],"0ceb5bb30e401cb218b31197b1a9aa47e77cda17":["780a0d1ca6c3d6eb71331bb36a0f467051300e45"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"485545da3b4429d6f138b4baac573a97820ee93b":["b52f4d438f568f7beafda3cf347790a4bfe32928"],"780a0d1ca6c3d6eb71331bb36a0f467051300e45":["0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["ae73da626f97850c922c42736f808d0378e165f0"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["b94236357aaa22b76c10629851fe4e376e0cea82","475584d5e08a22ad3fc7babefe006d77bc744567"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["6a47d642ab24da1a811adce4bda9cc52c520ca13","b52f4d438f568f7beafda3cf347790a4bfe32928"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["acf00221f44c5f08ccea014f2492b53af15ecd66","ae73da626f97850c922c42736f808d0378e165f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["0e7bc21595222ae4f75509300fbb7726691f387f"],"2e18c86f811939bfa8cd24046c96ed026f2e9b34":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["0ceb5bb30e401cb218b31197b1a9aa47e77cda17"],"0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"954e59be3da8dc1b046646ad7af4b466852009d3":["fb17639909a369c1e64866842e5c213440acc17e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","0e7bc21595222ae4f75509300fbb7726691f387f"],"417142ff08fda9cf0b72d5133e63097a166c6458":["0e7bc21595222ae4f75509300fbb7726691f387f","9fc47cb7b4346802411bb432f501ed0673d7119e"],"68d6cb7f0f019661a784bd0e5a21e85b5f812af6":["417142ff08fda9cf0b72d5133e63097a166c6458"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["485545da3b4429d6f138b4baac573a97820ee93b"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"0e7bc21595222ae4f75509300fbb7726691f387f":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"ae73da626f97850c922c42736f808d0378e165f0":["acf00221f44c5f08ccea014f2492b53af15ecd66"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"acf00221f44c5f08ccea014f2492b53af15ecd66":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","2e18c86f811939bfa8cd24046c96ed026f2e9b34"],"b52f4d438f568f7beafda3cf347790a4bfe32928":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"]},"commit2Childs":{"6a47d642ab24da1a811adce4bda9cc52c520ca13":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b52f4d438f568f7beafda3cf347790a4bfe32928"],"fb17639909a369c1e64866842e5c213440acc17e":["954e59be3da8dc1b046646ad7af4b466852009d3"],"b94236357aaa22b76c10629851fe4e376e0cea82":["475584d5e08a22ad3fc7babefe006d77bc744567","d58e44159788900f4a2113b84463dc3fbbf80f20"],"475584d5e08a22ad3fc7babefe006d77bc744567":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"0ceb5bb30e401cb218b31197b1a9aa47e77cda17":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8"],"485545da3b4429d6f138b4baac573a97820ee93b":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"780a0d1ca6c3d6eb71331bb36a0f467051300e45":["0ceb5bb30e401cb218b31197b1a9aa47e77cda17"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0e7bc21595222ae4f75509300fbb7726691f387f"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["2e18c86f811939bfa8cd24046c96ed026f2e9b34","fe33227f6805edab2036cbb80645cc4e2d1fa424","acf00221f44c5f08ccea014f2492b53af15ecd66"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"2e18c86f811939bfa8cd24046c96ed026f2e9b34":["acf00221f44c5f08ccea014f2492b53af15ecd66"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["fb17639909a369c1e64866842e5c213440acc17e"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8":["780a0d1ca6c3d6eb71331bb36a0f467051300e45"],"954e59be3da8dc1b046646ad7af4b466852009d3":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"417142ff08fda9cf0b72d5133e63097a166c6458":["b94236357aaa22b76c10629851fe4e376e0cea82","68d6cb7f0f019661a784bd0e5a21e85b5f812af6"],"68d6cb7f0f019661a784bd0e5a21e85b5f812af6":["b94236357aaa22b76c10629851fe4e376e0cea82"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"ae73da626f97850c922c42736f808d0378e165f0":["c9fb5f46e264daf5ba3860defe623a89d202dd87","15e323346eac5e4685c0a9f2df85eb96b4239bbb"],"0e7bc21595222ae4f75509300fbb7726691f387f":["9fc47cb7b4346802411bb432f501ed0673d7119e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","417142ff08fda9cf0b72d5133e63097a166c6458"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"acf00221f44c5f08ccea014f2492b53af15ecd66":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae73da626f97850c922c42736f808d0378e165f0"],"b52f4d438f568f7beafda3cf347790a4bfe32928":["485545da3b4429d6f138b4baac573a97820ee93b","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","15e323346eac5e4685c0a9f2df85eb96b4239bbb","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}