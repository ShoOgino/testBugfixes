{"path":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","commits":[{"id":"a1b3a24d5d9b47345473ff564f5cc127a7b526b4","date":1306277076,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToChars(spare).toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToChars(spare).toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToChars(spare).toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b78fd44c119574bf1529f13e122a1ecfea5f83c0","date":1312160110,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms.iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToChars(spare).toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToChars(spare).toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":["e8dd2a69747e9f2922fd8b6970bd1661b26a692d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToChars(spare).toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms.iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToChars(spare).toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6e919043fa85ee891123768dd655a98edbbf63c","date":1322225413,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToChars(spare).toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToChars(spare).toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = new BytesRef(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da6c07e76d701edbcc45c3e83ad8464a5e44a4c0","date":1322229341,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        termAsString = candidateTerm.utf8ToChars(spare).toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab","date":1324934316,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1));\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["b78fd44c119574bf1529f13e122a1ecfea5f83c0"],"da6c07e76d701edbcc45c3e83ad8464a5e44a4c0":["e6e919043fa85ee891123768dd655a98edbbf63c"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab"],"b78fd44c119574bf1529f13e122a1ecfea5f83c0":["a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab":["da6c07e76d701edbcc45c3e83ad8464a5e44a4c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a1b3a24d5d9b47345473ff564f5cc127a7b526b4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e6e919043fa85ee891123768dd655a98edbbf63c":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"]},"commit2Childs":{"60ba444201d2570214b6fcf1d15600dc1a01f548":["e6e919043fa85ee891123768dd655a98edbbf63c"],"da6c07e76d701edbcc45c3e83ad8464a5e44a4c0":["3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b78fd44c119574bf1529f13e122a1ecfea5f83c0":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"3aecf04c2d454cf9e42c4dc50241a8df41f8e6ab":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","a1b3a24d5d9b47345473ff564f5cc127a7b526b4","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"a1b3a24d5d9b47345473ff564f5cc127a7b526b4":["b78fd44c119574bf1529f13e122a1ecfea5f83c0","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"e6e919043fa85ee891123768dd655a98edbbf63c":["da6c07e76d701edbcc45c3e83ad8464a5e44a4c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}