{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#uncompress(DataInput,int,BytesRef).mjava","commits":[{"id":"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa","date":1349450075,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#uncompress(DataInput,int,BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Uncompress at least <code>uncompressedLen</code> bytes into <code>destBytes</code>.\n   * Please note that <code>destBytes</code> must be large enough to be able to hold\n   * <b>all</b> uncompressed data plus 8 bytes (meaning that you need to know the total\n   * uncompressed length).\n   */\n  public static void uncompress(DataInput compressed, int uncompressedLen, BytesRef destBytes) throws IOException {\n    final byte[] dest = destBytes.bytes;\n    final int destEnd = dest.length;\n    int dOff = 0;\n\n    while (dOff < uncompressedLen) {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= uncompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make uncompression from 5% to 10% faster\n      final int fastLen = ((matchLen - 1) & 0xFFFFFFF8) + 8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    }\n    destBytes.offset = 0;\n    destBytes.length = dOff;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5af6a67fb827380f7fe2fdf3baa34b10b783f2f1","date":1351696336,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#decompress(DataInput,int,BytesRef).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#uncompress(DataInput,int,BytesRef).mjava","sourceNew":"  /**\n   * Decompress at least <code>decompressedLen</code> bytes into <code>destBytes</code>.\n   * Please note that <code>destBytes</code> must be large enough to be able to hold\n   * <b>all</b> decompressed data plus 8 bytes (meaning that you need to know the total\n   * decompressed length).\n   */\n  public static void decompress(DataInput compressed, int decompressedLen, BytesRef destBytes) throws IOException {\n    final byte[] dest = destBytes.bytes;\n    final int destEnd = dest.length;\n    int dOff = 0;\n\n    while (dOff < decompressedLen) {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= decompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make decompression from 5% to 10% faster\n      final int fastLen = ((matchLen - 1) & 0xFFFFFFF8) + 8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    }\n    destBytes.offset = 0;\n    destBytes.length = dOff;\n  }\n\n","sourceOld":"  /**\n   * Uncompress at least <code>uncompressedLen</code> bytes into <code>destBytes</code>.\n   * Please note that <code>destBytes</code> must be large enough to be able to hold\n   * <b>all</b> uncompressed data plus 8 bytes (meaning that you need to know the total\n   * uncompressed length).\n   */\n  public static void uncompress(DataInput compressed, int uncompressedLen, BytesRef destBytes) throws IOException {\n    final byte[] dest = destBytes.bytes;\n    final int destEnd = dest.length;\n    int dOff = 0;\n\n    while (dOff < uncompressedLen) {\n      // literals\n      final int token = compressed.readByte() & 0xFF;\n      int literalLen = token >>> 4;\n\n      if (literalLen != 0) {\n        if (literalLen == 0x0F) {\n          byte len;\n          while ((len = compressed.readByte()) == (byte) 0xFF) {\n            literalLen += 0xFF;\n          }\n          literalLen += len & 0xFF;\n        }\n        compressed.readBytes(dest, dOff, literalLen);\n        dOff += literalLen;\n      }\n\n      if (dOff >= uncompressedLen) {\n        break;\n      }\n\n      // matchs\n      final int matchDec = (compressed.readByte() & 0xFF) | ((compressed.readByte() & 0xFF) << 8);\n      assert matchDec > 0;\n\n      int matchLen = token & 0x0F;\n      if (matchLen == 0x0F) {\n        int len;\n        while ((len = compressed.readByte()) == (byte) 0xFF) {\n          matchLen += 0xFF;\n        }\n        matchLen += len & 0xFF;\n      }\n      matchLen += MIN_MATCH;\n\n      // copying a multiple of 8 bytes can make uncompression from 5% to 10% faster\n      final int fastLen = ((matchLen - 1) & 0xFFFFFFF8) + 8;\n      if (matchDec < matchLen || dOff + fastLen > destEnd) {\n        // overlap -> naive incremental copy\n        for (int ref = dOff - matchDec, end = dOff + matchLen; dOff < end; ++ref, ++dOff) {\n          dest[dOff] = dest[ref];\n        }\n      } else {\n        // no overlap -> arraycopy\n        System.arraycopy(dest, dOff - matchDec, dest, dOff, fastLen);\n        dOff += matchLen;\n      }\n    }\n    destBytes.offset = 0;\n    destBytes.length = dOff;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5af6a67fb827380f7fe2fdf3baa34b10b783f2f1":["7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa"],"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5af6a67fb827380f7fe2fdf3baa34b10b783f2f1"]},"commit2Childs":{"5af6a67fb827380f7fe2fdf3baa34b10b783f2f1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa":["5af6a67fb827380f7fe2fdf3baa34b10b783f2f1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}