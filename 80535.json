{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery.ContextCompletionWeight#setNextMatch(IntsRef).mjava","commits":[{"id":"8c33f6677a2078739058f81eca1df69d12cd62b0","date":1432799589,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery.ContextCompletionWeight#setNextMatch(IntsRef).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    protected void setNextMatch(IntsRef pathPrefix) {\n      IntsRef ref = pathPrefix.clone();\n\n      // check if the pathPrefix matches any\n      // defined context, longer context first\n      for (int contextLength : contextLengths) {\n        if (contextLength > pathPrefix.length) {\n          continue;\n        }\n        ref.length = contextLength;\n        if (contextMap.containsKey(ref)) {\n          currentBoost = contextMap.get(ref);\n          ref.length = pathPrefix.length;\n          ref.offset = contextLength;\n          while (ref.ints[ref.offset] != ContextSuggestField.CONTEXT_SEPARATOR) {\n            ref.offset++;\n            assert ref.offset < ref.length;\n          }\n          assert ref.ints[ref.offset] == ContextSuggestField.CONTEXT_SEPARATOR : \"expected CONTEXT_SEPARATOR at offset=\" + ref.offset;\n          if (ref.offset > pathPrefix.offset) {\n            currentContext = Util.toBytesRef(new IntsRef(pathPrefix.ints, pathPrefix.offset, ref.offset), scratch).utf8ToString();\n          } else {\n            currentContext = null;\n          }\n          ref.offset++;\n          if (ref.ints[ref.offset] == CompletionAnalyzer.SEP_LABEL) {\n            ref.offset++;\n          }\n          innerWeight.setNextMatch(ref);\n          return;\n        }\n      }\n      // unknown context\n      ref.length = pathPrefix.length;\n      currentBoost = contexts.get(\"*\").boost;\n      for (int i = pathPrefix.offset; i < pathPrefix.length; i++) {\n        if (pathPrefix.ints[i] == ContextSuggestField.CONTEXT_SEPARATOR) {\n          if (i > pathPrefix.offset) {\n            currentContext = Util.toBytesRef(new IntsRef(pathPrefix.ints, pathPrefix.offset, i), scratch).utf8ToString();\n          } else {\n            currentContext = null;\n          }\n          ref.offset = ++i;\n          assert ref.offset < ref.length : \"input should not end with the context separator\";\n          if (pathPrefix.ints[i] == CompletionAnalyzer.SEP_LABEL) {\n            ref.offset++;\n            assert ref.offset < ref.length : \"input should not end with a context separator followed by SEP_LABEL\";\n          }\n          ref.length -= ref.offset;\n          innerWeight.setNextMatch(ref);\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66756ce4574b3c2fdc15740945140daf28792f5f","date":1433261481,"type":3,"author":"Areek Zillur","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery.ContextCompletionWeight#setNextMatch(IntsRef).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery.ContextCompletionWeight#setNextMatch(IntsRef).mjava","sourceNew":"    @Override\n    protected void setNextMatch(IntsRef pathPrefix) {\n      IntsRef ref = pathPrefix.clone();\n\n      // check if the pathPrefix matches any\n      // defined context, longer context first\n      for (int contextLength : contextLengths) {\n        if (contextLength > pathPrefix.length) {\n          continue;\n        }\n        ref.length = contextLength;\n        if (contextMap.containsKey(ref)) {\n          currentBoost = contextMap.get(ref);\n          ref.length = pathPrefix.length;\n          ref.offset = contextLength;\n          while (ref.ints[ref.offset] != ContextSuggestField.CONTEXT_SEPARATOR) {\n            ref.offset++;\n            assert ref.offset < ref.length;\n          }\n          assert ref.ints[ref.offset] == ContextSuggestField.CONTEXT_SEPARATOR :\n              \"expected CONTEXT_SEPARATOR at offset=\" + ref.offset;\n          if (ref.offset > pathPrefix.offset) {\n            currentContext = Util.toBytesRef(new IntsRef(pathPrefix.ints, pathPrefix.offset, ref.offset), scratch).utf8ToString();\n          } else {\n            currentContext = null;\n          }\n          ref.offset++;\n          if (ref.ints[ref.offset] == CompletionAnalyzer.SEP_LABEL) {\n            ref.offset++;\n          }\n          innerWeight.setNextMatch(ref);\n          return;\n        }\n      }\n      // unknown context\n      ref.length = pathPrefix.length;\n      currentBoost = contexts.get(\"*\").boost;\n      for (int i = pathPrefix.offset; i < pathPrefix.length; i++) {\n        if (pathPrefix.ints[i] == ContextSuggestField.CONTEXT_SEPARATOR) {\n          if (i > pathPrefix.offset) {\n            currentContext = Util.toBytesRef(new IntsRef(pathPrefix.ints, pathPrefix.offset, i), scratch).utf8ToString();\n          } else {\n            currentContext = null;\n          }\n          ref.offset = ++i;\n          assert ref.offset < ref.length : \"input should not end with the context separator\";\n          if (pathPrefix.ints[i] == CompletionAnalyzer.SEP_LABEL) {\n            ref.offset++;\n            assert ref.offset < ref.length : \"input should not end with a context separator followed by SEP_LABEL\";\n          }\n          ref.length -= ref.offset;\n          innerWeight.setNextMatch(ref);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    protected void setNextMatch(IntsRef pathPrefix) {\n      IntsRef ref = pathPrefix.clone();\n\n      // check if the pathPrefix matches any\n      // defined context, longer context first\n      for (int contextLength : contextLengths) {\n        if (contextLength > pathPrefix.length) {\n          continue;\n        }\n        ref.length = contextLength;\n        if (contextMap.containsKey(ref)) {\n          currentBoost = contextMap.get(ref);\n          ref.length = pathPrefix.length;\n          ref.offset = contextLength;\n          while (ref.ints[ref.offset] != ContextSuggestField.CONTEXT_SEPARATOR) {\n            ref.offset++;\n            assert ref.offset < ref.length;\n          }\n          assert ref.ints[ref.offset] == ContextSuggestField.CONTEXT_SEPARATOR : \"expected CONTEXT_SEPARATOR at offset=\" + ref.offset;\n          if (ref.offset > pathPrefix.offset) {\n            currentContext = Util.toBytesRef(new IntsRef(pathPrefix.ints, pathPrefix.offset, ref.offset), scratch).utf8ToString();\n          } else {\n            currentContext = null;\n          }\n          ref.offset++;\n          if (ref.ints[ref.offset] == CompletionAnalyzer.SEP_LABEL) {\n            ref.offset++;\n          }\n          innerWeight.setNextMatch(ref);\n          return;\n        }\n      }\n      // unknown context\n      ref.length = pathPrefix.length;\n      currentBoost = contexts.get(\"*\").boost;\n      for (int i = pathPrefix.offset; i < pathPrefix.length; i++) {\n        if (pathPrefix.ints[i] == ContextSuggestField.CONTEXT_SEPARATOR) {\n          if (i > pathPrefix.offset) {\n            currentContext = Util.toBytesRef(new IntsRef(pathPrefix.ints, pathPrefix.offset, i), scratch).utf8ToString();\n          } else {\n            currentContext = null;\n          }\n          ref.offset = ++i;\n          assert ref.offset < ref.length : \"input should not end with the context separator\";\n          if (pathPrefix.ints[i] == CompletionAnalyzer.SEP_LABEL) {\n            ref.offset++;\n            assert ref.offset < ref.length : \"input should not end with a context separator followed by SEP_LABEL\";\n          }\n          ref.length -= ref.offset;\n          innerWeight.setNextMatch(ref);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3e870f9bab17325ebf91f7500d2c05596634741","date":1438287049,"type":3,"author":"Areek Zillur","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery.ContextCompletionWeight#setNextMatch(IntsRef).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/document/ContextQuery.ContextCompletionWeight#setNextMatch(IntsRef).mjava","sourceNew":"    @Override\n    protected void setNextMatch(final IntsRef pathPrefix) {\n      IntsRef ref = pathPrefix.clone();\n\n      // check if the pathPrefix matches any\n      // defined context, longer context first\n      for (int contextLength : contextLengths) {\n        if (contextLength > pathPrefix.length) {\n          continue;\n        }\n        ref.length = contextLength;\n        if (contextMap.containsKey(ref)) {\n          currentBoost = contextMap.get(ref);\n          ref.length = pathPrefix.length;\n          setInnerWeight(ref, contextLength);\n          return;\n        }\n      }\n      // unknown context\n      ref.length = pathPrefix.length;\n      currentBoost = 0f;\n      setInnerWeight(ref, 0);\n    }\n\n","sourceOld":"    @Override\n    protected void setNextMatch(IntsRef pathPrefix) {\n      IntsRef ref = pathPrefix.clone();\n\n      // check if the pathPrefix matches any\n      // defined context, longer context first\n      for (int contextLength : contextLengths) {\n        if (contextLength > pathPrefix.length) {\n          continue;\n        }\n        ref.length = contextLength;\n        if (contextMap.containsKey(ref)) {\n          currentBoost = contextMap.get(ref);\n          ref.length = pathPrefix.length;\n          ref.offset = contextLength;\n          while (ref.ints[ref.offset] != ContextSuggestField.CONTEXT_SEPARATOR) {\n            ref.offset++;\n            assert ref.offset < ref.length;\n          }\n          assert ref.ints[ref.offset] == ContextSuggestField.CONTEXT_SEPARATOR :\n              \"expected CONTEXT_SEPARATOR at offset=\" + ref.offset;\n          if (ref.offset > pathPrefix.offset) {\n            currentContext = Util.toBytesRef(new IntsRef(pathPrefix.ints, pathPrefix.offset, ref.offset), scratch).utf8ToString();\n          } else {\n            currentContext = null;\n          }\n          ref.offset++;\n          if (ref.ints[ref.offset] == CompletionAnalyzer.SEP_LABEL) {\n            ref.offset++;\n          }\n          innerWeight.setNextMatch(ref);\n          return;\n        }\n      }\n      // unknown context\n      ref.length = pathPrefix.length;\n      currentBoost = contexts.get(\"*\").boost;\n      for (int i = pathPrefix.offset; i < pathPrefix.length; i++) {\n        if (pathPrefix.ints[i] == ContextSuggestField.CONTEXT_SEPARATOR) {\n          if (i > pathPrefix.offset) {\n            currentContext = Util.toBytesRef(new IntsRef(pathPrefix.ints, pathPrefix.offset, i), scratch).utf8ToString();\n          } else {\n            currentContext = null;\n          }\n          ref.offset = ++i;\n          assert ref.offset < ref.length : \"input should not end with the context separator\";\n          if (pathPrefix.ints[i] == CompletionAnalyzer.SEP_LABEL) {\n            ref.offset++;\n            assert ref.offset < ref.length : \"input should not end with a context separator followed by SEP_LABEL\";\n          }\n          ref.length -= ref.offset;\n          innerWeight.setNextMatch(ref);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"66756ce4574b3c2fdc15740945140daf28792f5f":["8c33f6677a2078739058f81eca1df69d12cd62b0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d3e870f9bab17325ebf91f7500d2c05596634741":["66756ce4574b3c2fdc15740945140daf28792f5f"],"8c33f6677a2078739058f81eca1df69d12cd62b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d3e870f9bab17325ebf91f7500d2c05596634741"]},"commit2Childs":{"66756ce4574b3c2fdc15740945140daf28792f5f":["d3e870f9bab17325ebf91f7500d2c05596634741"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8c33f6677a2078739058f81eca1df69d12cd62b0"],"d3e870f9bab17325ebf91f7500d2c05596634741":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8c33f6677a2078739058f81eca1df69d12cd62b0":["66756ce4574b3c2fdc15740945140daf28792f5f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}