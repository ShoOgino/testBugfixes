{"path":"lucene/src/test-framework/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","commits":[{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ENGLISH);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ENGLISH);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ENGLISH);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ENGLISH);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["7b91922b55d15444d554721b352861d028eb8278"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7b91922b55d15444d554721b352861d028eb8278"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}