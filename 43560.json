{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","commits":[{"id":"6ce825e9276493231308229152c48f755ce1a0a5","date":1348871483,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = (new EscapingTokenStreamToAutomaton()).toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      automaton = Automaton.minimize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, num, weightComparator);\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["414aae1db83a83d247caa9514e383e4ca3d43da5","32eace34e207608926e4c83409c65d968e530bf2","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"65621ac5927a7c2f23e9cd59b09f56addd5ed2bf","date":1348876189,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = (new EscapingTokenStreamToAutomaton()).toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, num, weightComparator);\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = (new EscapingTokenStreamToAutomaton()).toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      automaton = Automaton.minimize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, num, weightComparator);\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f903593885012bb5d79809c44cb6dfcebb4a2c66","date":1349971647,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, num, weightComparator);\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = (new EscapingTokenStreamToAutomaton()).toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, num, weightComparator);\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc41b743423981e7ec17a024ce7e107096e472fe","date":1349975327,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n        final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectExact();   \n\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, num, weightComparator);\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectAll();\n//      System.out.println(key);\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n//        System.out.println(UnicodeUtil.newString(path.input.ints, path.input.offset, path.input.length));\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, num, weightComparator);\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"32eace34e207608926e4c83409c65d968e530bf2","date":1350054443,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, num, weightComparator);\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":["6ce825e9276493231308229152c48f755ce1a0a5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6efad415dcdbcca7d440f909743e6e3152eeb6c0","date":1350055371,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n        final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectExact();   \n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectAll();\n//      System.out.println(key);\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n//        System.out.println(UnicodeUtil.newString(path.input.ints, path.input.offset, path.input.length));\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n        final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectExact();   \n\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, num, weightComparator);\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectAll();\n//      System.out.println(key);\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n//        System.out.println(UnicodeUtil.newString(path.input.ints, path.input.offset, path.input.length));\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d82832af39f94dbb58a3130fd216ff1d49435589","date":1350147242,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, num, weightComparator);\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c2962f86226a02b0d61ca1f2b4e5f1820945fb6","date":1350673647,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n        final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectExact();   \n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            return !utf8Key.bytesEquals(output.output2);\n          }\n        }\n      };\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectAll();\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n        final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectExact();   \n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectAll();\n//      System.out.println(key);\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n//        System.out.println(UnicodeUtil.newString(path.input.ints, path.input.offset, path.input.length));\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"59aedb6464136dd3cd73d343e814ba8acf3da155","date":1350729779,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          //System.out.println(\"ACCEPT? path=\" + input);\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            //System.out.println(\"SKIP: dup\");\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":["414aae1db83a83d247caa9514e383e4ca3d43da5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"414aae1db83a83d247caa9514e383e4ca3d43da5","date":1350824365,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          //System.out.println(\"ACCEPT? path=\" + input);\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            //System.out.println(\"SKIP: dup\");\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            return CHARSEQUENCE_COMPARATOR.compare(spare, key) != 0;\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":["59aedb6464136dd3cd73d343e814ba8acf3da155","6ce825e9276493231308229152c48f755ce1a0a5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e54fda1eb029b24dd806a3b668c0d78b1625fd9","date":1350933798,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"62e52115b56781006682fd92c6938efaf174304d","date":1351014780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n        final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectExact();   \n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectAll();\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n        final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectExact();   \n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n          \n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            return !utf8Key.bytesEquals(output.output2);\n          }\n        }\n      };\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectAll();\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a4e61034e4aff7de8a98f9e093d324f23f610e1","date":1351015892,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n\n        // nocommit for fuzzy case would be nice to return\n        // how many edits were required...:\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n        final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectExact();   \n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = intersector.intersectAll();\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":["2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ba222c174ec1943d8d14d012d1d6e24a1cc4972","date":1351522220,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n\n        // nocommit for fuzzy case would be nice to return\n        // how many edits were required...:\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","date":1351615637,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n\n    try {\n\n      // TODO: is there a Reader from a CharSequence?\n      // Turn tokenstream into automaton:\n      TokenStream ts = queryAnalyzer.tokenStream(\"\", new StringReader(key.toString()));\n      Automaton automaton = getTokenStreamToAutomaton().toAutomaton(ts);\n      ts.end();\n      ts.close();\n\n      // TODO: we could use the end offset to \"guess\"\n      // whether the final token was a partial token; this\n      // would only be a heuristic ... but maybe an OK one.\n      // This way we could eg differentiate \"net\" from \"net \",\n      // which we can't today...\n\n      replaceSep(automaton);\n\n      // TODO: we can optimize this somewhat by determinizing\n      // while we convert\n      BasicOperations.determinize(automaton);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      final List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths;\n      prefixPaths = FSTUtil.intersectPrefixPaths(automaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          spare.grow(completion.output.output2.length);\n          UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n          if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            spare.grow(output.output2.length);\n            UnicodeUtil.UTF8toUTF16(output.output2, spare);\n            if (CHARSEQUENCE_COMPARATOR.compare(spare, key) == 0) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e0976cda1a864caa753e58d43b5b11b8b9d9fbef","date":1353438038,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"82557a475db3e0849171dc0be5b02e3ae0745ddb","date":1358195918,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader(0);\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a48377c9931ddb38c784846217ff68d7dcd0b44","date":1363202036,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          if (utf8Key.bytesEquals(completion.output.output2)) {\n            spare.grow(completion.output.output2.length);\n            UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n            results.add(new LookupResult(spare.toString(), decodeWeight(completion.output.output1)));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (utf8Key.bytesEquals(output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n        spare.grow(completion.output.output2.length);\n        UnicodeUtil.UTF8toUTF16(completion.output.output2, spare);\n        LookupResult result = new LookupResult(spare.toString(), decodeWeight(completion.output.output1));\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6","date":1374158194,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":["3a4e61034e4aff7de8a98f9e093d324f23f610e1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(lookupAutomaton, fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<Pair<Long,BytesRef>>();\n\n      final List<LookupResult> results = new ArrayList<LookupResult>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<BytesRef>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d245db17aaa41b338dae9da5d4edba4dd6f61612","date":1394644847,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      MinResult<Pair<Long,BytesRef>> completions[] = searcher.search();\n\n      for(MinResult<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b","date":1395588343,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,Set[BytesRef],boolean,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester#lookup(CharSequence,boolean,int).mjava","sourceNew":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (contexts != null) {\n      throw new IllegalArgumentException(\"this suggester doesn't support contexts\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","sourceOld":"  @Override\n  public List<LookupResult> lookup(final CharSequence key, boolean onlyMorePopular, int num) {\n    assert num > 0;\n\n    if (onlyMorePopular) {\n      throw new IllegalArgumentException(\"this suggester only works with onlyMorePopular=false\");\n    }\n    if (fst == null) {\n      return Collections.emptyList();\n    }\n\n    //System.out.println(\"lookup key=\" + key + \" num=\" + num);\n    for (int i = 0; i < key.length(); i++) {\n      if (key.charAt(i) == 0x1E) {\n        throw new IllegalArgumentException(\"lookup key cannot contain HOLE character U+001E; this character is reserved\");\n      }\n      if (key.charAt(i) == 0x1F) {\n        throw new IllegalArgumentException(\"lookup key cannot contain unit separator character U+001F; this character is reserved\");\n      }\n    }\n    final BytesRef utf8Key = new BytesRef(key);\n    try {\n\n      Automaton lookupAutomaton = toLookupAutomaton(key);\n\n      final CharsRef spare = new CharsRef();\n\n      //System.out.println(\"  now intersect exactFirst=\" + exactFirst);\n    \n      // Intersect automaton w/ suggest wFST and get all\n      // prefix starting nodes & their outputs:\n      //final PathIntersector intersector = getPathIntersector(lookupAutomaton, fst);\n\n      //System.out.println(\"  prefixPaths: \" + prefixPaths.size());\n\n      BytesReader bytesReader = fst.getBytesReader();\n\n      FST.Arc<Pair<Long,BytesRef>> scratchArc = new FST.Arc<>();\n\n      final List<LookupResult> results = new ArrayList<>();\n\n      List<FSTUtil.Path<Pair<Long,BytesRef>>> prefixPaths = FSTUtil.intersectPrefixPaths(convertAutomaton(lookupAutomaton), fst);\n\n      if (exactFirst) {\n\n        int count = 0;\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            count++;\n          }\n        }\n\n        // Searcher just to find the single exact only\n        // match, if present:\n        Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n        searcher = new Util.TopNSearcher<>(fst, count * maxSurfaceFormsPerAnalyzedForm, count * maxSurfaceFormsPerAnalyzedForm, weightComparator);\n\n        // NOTE: we could almost get away with only using\n        // the first start node.  The only catch is if\n        // maxSurfaceFormsPerAnalyzedForm had kicked in and\n        // pruned our exact match from one of these nodes\n        // ...:\n        for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n          if (fst.findTargetArc(END_BYTE, path.fstNode, scratchArc, bytesReader) != null) {\n            // This node has END_BYTE arc leaving, meaning it's an\n            // \"exact\" match:\n            searcher.addStartPaths(scratchArc, fst.outputs.add(path.output, scratchArc.output), false, path.input);\n          }\n        }\n\n        TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n        assert completions.isComplete;\n\n        // NOTE: this is rather inefficient: we enumerate\n        // every matching \"exactly the same analyzed form\"\n        // path, and then do linear scan to see if one of\n        // these exactly matches the input.  It should be\n        // possible (though hairy) to do something similar\n        // to getByOutput, since the surface form is encoded\n        // into the FST output, so we more efficiently hone\n        // in on the exact surface-form match.  Still, I\n        // suspect very little time is spent in this linear\n        // seach: it's bounded by how many prefix start\n        // nodes we have and the\n        // maxSurfaceFormsPerAnalyzedForm:\n        for(Result<Pair<Long,BytesRef>> completion : completions) {\n          BytesRef output2 = completion.output.output2;\n          if (sameSurfaceForm(utf8Key, output2)) {\n            results.add(getLookupResult(completion.output.output1, output2, spare));\n            break;\n          }\n        }\n\n        if (results.size() == num) {\n          // That was quick:\n          return results;\n        }\n      }\n\n      Util.TopNSearcher<Pair<Long,BytesRef>> searcher;\n      searcher = new Util.TopNSearcher<Pair<Long,BytesRef>>(fst,\n                                                            num - results.size(),\n                                                            num * maxAnalyzedPathsForOneInput,\n                                                            weightComparator) {\n        private final Set<BytesRef> seen = new HashSet<>();\n\n        @Override\n        protected boolean acceptResult(IntsRef input, Pair<Long,BytesRef> output) {\n\n          // Dedup: when the input analyzes to a graph we\n          // can get duplicate surface forms:\n          if (seen.contains(output.output2)) {\n            return false;\n          }\n          seen.add(output.output2);\n          \n          if (!exactFirst) {\n            return true;\n          } else {\n            // In exactFirst mode, don't accept any paths\n            // matching the surface form since that will\n            // create duplicate results:\n            if (sameSurfaceForm(utf8Key, output.output2)) {\n              // We found exact match, which means we should\n              // have already found it in the first search:\n              assert results.size() == 1;\n              return false;\n            } else {\n              return true;\n            }\n          }\n        }\n      };\n\n      prefixPaths = getFullPrefixPaths(prefixPaths, lookupAutomaton, fst);\n      \n      for (FSTUtil.Path<Pair<Long,BytesRef>> path : prefixPaths) {\n        searcher.addStartPaths(path.fstNode, path.output, true, path.input);\n      }\n\n      TopResults<Pair<Long,BytesRef>> completions = searcher.search();\n      assert completions.isComplete;\n\n      for(Result<Pair<Long,BytesRef>> completion : completions) {\n\n        LookupResult result = getLookupResult(completion.output.output1, completion.output.output2, spare);\n\n        // TODO: for fuzzy case would be nice to return\n        // how many edits were required\n\n        //System.out.println(\"    result=\" + result);\n        results.add(result);\n\n        if (results.size() == num) {\n          // In the exactFirst=true case the search may\n          // produce one extra path\n          break;\n        }\n      }\n\n      return results;\n    } catch (IOException bogus) {\n      throw new RuntimeException(bogus);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"82557a475db3e0849171dc0be5b02e3ae0745ddb":["e0976cda1a864caa753e58d43b5b11b8b9d9fbef"],"d245db17aaa41b338dae9da5d4edba4dd6f61612":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"e0976cda1a864caa753e58d43b5b11b8b9d9fbef":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"59aedb6464136dd3cd73d343e814ba8acf3da155":["32eace34e207608926e4c83409c65d968e530bf2"],"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b":["d245db17aaa41b338dae9da5d4edba4dd6f61612"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["407687e67faf6e1f02a211ca078d8e3eed631027","82557a475db3e0849171dc0be5b02e3ae0745ddb"],"2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6":["5a48377c9931ddb38c784846217ff68d7dcd0b44"],"414aae1db83a83d247caa9514e383e4ca3d43da5":["59aedb6464136dd3cd73d343e814ba8acf3da155"],"65621ac5927a7c2f23e9cd59b09f56addd5ed2bf":["6ce825e9276493231308229152c48f755ce1a0a5"],"d82832af39f94dbb58a3130fd216ff1d49435589":["f903593885012bb5d79809c44cb6dfcebb4a2c66","32eace34e207608926e4c83409c65d968e530bf2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0ba222c174ec1943d8d14d012d1d6e24a1cc4972":["3a4e61034e4aff7de8a98f9e093d324f23f610e1"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["5a48377c9931ddb38c784846217ff68d7dcd0b44"],"6ce825e9276493231308229152c48f755ce1a0a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f903593885012bb5d79809c44cb6dfcebb4a2c66":["65621ac5927a7c2f23e9cd59b09f56addd5ed2bf"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6"],"3a4e61034e4aff7de8a98f9e093d324f23f610e1":["62e52115b56781006682fd92c6938efaf174304d"],"3e54fda1eb029b24dd806a3b668c0d78b1625fd9":["414aae1db83a83d247caa9514e383e4ca3d43da5"],"407687e67faf6e1f02a211ca078d8e3eed631027":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","e0976cda1a864caa753e58d43b5b11b8b9d9fbef"],"6c2962f86226a02b0d61ca1f2b4e5f1820945fb6":["6efad415dcdbcca7d440f909743e6e3152eeb6c0"],"32eace34e207608926e4c83409c65d968e530bf2":["f903593885012bb5d79809c44cb6dfcebb4a2c66"],"6efad415dcdbcca7d440f909743e6e3152eeb6c0":["cc41b743423981e7ec17a024ce7e107096e472fe","32eace34e207608926e4c83409c65d968e530bf2"],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["3e54fda1eb029b24dd806a3b668c0d78b1625fd9","0ba222c174ec1943d8d14d012d1d6e24a1cc4972"],"62e52115b56781006682fd92c6938efaf174304d":["6c2962f86226a02b0d61ca1f2b4e5f1820945fb6","3e54fda1eb029b24dd806a3b668c0d78b1625fd9"],"cc41b743423981e7ec17a024ce7e107096e472fe":["f903593885012bb5d79809c44cb6dfcebb4a2c66"],"5a48377c9931ddb38c784846217ff68d7dcd0b44":["82557a475db3e0849171dc0be5b02e3ae0745ddb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b"]},"commit2Childs":{"82557a475db3e0849171dc0be5b02e3ae0745ddb":["c4015cd39dff8d4dec562d909f9766debac53aa6","5a48377c9931ddb38c784846217ff68d7dcd0b44"],"e0976cda1a864caa753e58d43b5b11b8b9d9fbef":["82557a475db3e0849171dc0be5b02e3ae0745ddb","407687e67faf6e1f02a211ca078d8e3eed631027"],"d245db17aaa41b338dae9da5d4edba4dd6f61612":["58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b"],"59aedb6464136dd3cd73d343e814ba8acf3da155":["414aae1db83a83d247caa9514e383e4ca3d43da5"],"58d0345a28bb6b4be59c38e6a77e2cc0e615ee4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c4015cd39dff8d4dec562d909f9766debac53aa6":[],"2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"414aae1db83a83d247caa9514e383e4ca3d43da5":["3e54fda1eb029b24dd806a3b668c0d78b1625fd9"],"65621ac5927a7c2f23e9cd59b09f56addd5ed2bf":["f903593885012bb5d79809c44cb6dfcebb4a2c66"],"d82832af39f94dbb58a3130fd216ff1d49435589":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6ce825e9276493231308229152c48f755ce1a0a5"],"0ba222c174ec1943d8d14d012d1d6e24a1cc4972":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"6ce825e9276493231308229152c48f755ce1a0a5":["65621ac5927a7c2f23e9cd59b09f56addd5ed2bf"],"f903593885012bb5d79809c44cb6dfcebb4a2c66":["d82832af39f94dbb58a3130fd216ff1d49435589","32eace34e207608926e4c83409c65d968e530bf2","cc41b743423981e7ec17a024ce7e107096e472fe"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["d245db17aaa41b338dae9da5d4edba4dd6f61612"],"3a4e61034e4aff7de8a98f9e093d324f23f610e1":["0ba222c174ec1943d8d14d012d1d6e24a1cc4972"],"3e54fda1eb029b24dd806a3b668c0d78b1625fd9":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","62e52115b56781006682fd92c6938efaf174304d"],"407687e67faf6e1f02a211ca078d8e3eed631027":["c4015cd39dff8d4dec562d909f9766debac53aa6"],"6c2962f86226a02b0d61ca1f2b4e5f1820945fb6":["62e52115b56781006682fd92c6938efaf174304d"],"32eace34e207608926e4c83409c65d968e530bf2":["59aedb6464136dd3cd73d343e814ba8acf3da155","d82832af39f94dbb58a3130fd216ff1d49435589","6efad415dcdbcca7d440f909743e6e3152eeb6c0"],"6efad415dcdbcca7d440f909743e6e3152eeb6c0":["6c2962f86226a02b0d61ca1f2b4e5f1820945fb6"],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["e0976cda1a864caa753e58d43b5b11b8b9d9fbef","407687e67faf6e1f02a211ca078d8e3eed631027"],"62e52115b56781006682fd92c6938efaf174304d":["3a4e61034e4aff7de8a98f9e093d324f23f610e1"],"cc41b743423981e7ec17a024ce7e107096e472fe":["6efad415dcdbcca7d440f909743e6e3152eeb6c0"],"5a48377c9931ddb38c784846217ff68d7dcd0b44":["2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c4015cd39dff8d4dec562d909f9766debac53aa6","d82832af39f94dbb58a3130fd216ff1d49435589","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}