{"path":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b43cc463de57963524b3835202575c1662c9e927","date":1346784739,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0a394130fcb854dc0880b48cc58a5ca049e591a","date":1348951569,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && rateLimiter == null && randomState.nextInt(50) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e8fbe4ce6e68a5b5f8936cf16786f6c37cc27090","date":1349125657,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n\n    RateLimiter thisRateLimiter;\n\n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && rateLimiter == null && randomState.nextInt(50) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      thisRateLimiter = rateLimiter;\n    } else {\n      thisRateLimiter = null;\n    }\n\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context)), name, thisRateLimiter);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    return io;\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && rateLimiter == null && randomState.nextInt(50) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09a37269f7ae6b4e61f0bfa661c642ad751e05c8","date":1349391311,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && rateLimiter == null && randomState.nextInt(50) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n\n    RateLimiter thisRateLimiter;\n\n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && rateLimiter == null && randomState.nextInt(50) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      thisRateLimiter = rateLimiter;\n    } else {\n      thisRateLimiter = null;\n    }\n\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context)), name, thisRateLimiter);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    return io;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e4583d4aac44f313f9af74ab6d81baab3f976232","date":1352409883,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(delegate instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && rateLimiter == null && randomState.nextInt(50) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(delegate instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && rateLimiter == null && randomState.nextInt(50) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb29b298ad7651ee722a0f5491b689232c26d2b4","date":1358930559,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(delegate instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(delegate instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b2d5244a676b83c2d551c3746e8181588ba619e1","date":1359031414,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(delegate instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput io = new MockIndexOutputWrapper(this, delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context)), name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(delegate instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30e0912f3a3069b115cfea44ff612c44d6906386","date":1365631344,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen();\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(delegate instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\"))\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name))\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    \n    if (crashed)\n      throw new IOException(\"cannot createOutput after crash\");\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite)\n        throw new IOException(\"file \" + name + \" already exists\");\n      else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(delegate instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":["527cc14542789f47d75da436cb4287d1ab887e34","11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bac2bd9d901ec1ee7111a77c8e616d745fb2a362","date":1368131212,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(delegate instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen();\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(delegate instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4","date":1368446242,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(delegate instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(delegate instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"399ef3ff6c22f0627c82ac65f32726f3587a2aa1","date":1379005174,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(in instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (delegate instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) delegate;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = delegate.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(delegate instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"527cc14542789f47d75da436cb4287d1ab887e34","date":1391705548,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(in instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (noDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(in instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":["30e0912f3a3069b115cfea44ff612c44d6906386","a05409176bd65129d67a785ee70e881e238a9aef"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"12320451a8cf581593c5eca6d2db98d299d693c7","date":1398969355,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0) && !(in instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(50) == 0) && !(in instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bce1e2aee8b16573bc0d091471e4660d140b5823","date":1400533696,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0) && !(in instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0) && !(in instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0) && !(in instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    if (randomState.nextInt(10) == 0){\n      // once in a while wrap the IO in a Buffered IO with random buffer sizes\n      delegateOutput = new BufferedIndexOutputWrapper(1+randomState.nextInt(BufferedIndexOutput.DEFAULT_BUFFER_SIZE), delegateOutput);\n    } \n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0) && !(in instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0) && !(in instanceof RateLimitedDirectoryWrapper)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3ce1ef883d26aa73919aa2d53991726e96caa13","date":1445421402,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    triedToDelete.remove(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    triedToDelete.remove(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if ((noDeleteOpenFile || assertNoDeleteOpenFile) && openFiles.containsKey(name)) {\n      if (!assertNoDeleteOpenFile) {\n        throw new IOException(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      } else {\n        throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n      }\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11c6df42fb3eba174c3ca0d9a5194eaecd893b77","date":1465931757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":["30e0912f3a3069b115cfea44ff612c44d6906386"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e12d86b6c563341330016a95710e4dedbfa7ef1","date":1466431399,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6aaba221b22442bdf0ef28770c25fe259dfb3f55","date":1466496193,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (preventDoubleWrite && createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    if (in instanceof RAMDirectory) {\n      RAMDirectory ramdir = (RAMDirectory) in;\n      RAMFile file = new RAMFile(ramdir);\n      RAMFile existing = ramdir.fileMap.get(name);\n    \n      // Enforce write once:\n      if (existing!=null && !name.equals(\"segments.gen\") && preventDoubleWrite) {\n        throw new IOException(\"file \" + name + \" already exists\");\n      } else {\n        if (existing!=null) {\n          ramdir.sizeInBytes.getAndAdd(-existing.sizeInBytes);\n          existing.directory = null;\n        }\n        ramdir.fileMap.put(name, file);\n      }\n    }\n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f3adea0022cffaaa592081efed775a7b8bf86b51","date":1532414870,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createOutput(String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n\n    if (createdFiles.contains(name)) {\n      throw new FileAlreadyExistsException(\"File \\\"\" + name + \"\\\" was already written to.\");\n    }\n\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    return maybeThrottle(name, io);\n\n\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createOutput(String name, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(name);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createOutput after crash\");\n    }\n    init();\n    synchronized(this) {\n      if (createdFiles.contains(name) && !name.equals(\"segments.gen\")) {\n        throw new IOException(\"file \\\"\" + name + \"\\\" was already written to\");\n      }\n    }\n    if (assertNoDeleteOpenFile && openFiles.containsKey(name)) {\n      throw new AssertionError(\"MockDirectoryWrapper: file \\\"\" + name + \"\\\" is still open: cannot overwrite\");\n    }\n    \n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    \n    //System.out.println(Thread.currentThread().getName() + \": MDW: create \" + name);\n    IndexOutput delegateOutput = in.createOutput(name, LuceneTestCase.newIOContext(randomState, context));\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5a207d19eac354d649c3f0e2cce070017c78125e":["e3ce1ef883d26aa73919aa2d53991726e96caa13","b470f36a9372c97283360b1304eacbde22df6c0d"],"399ef3ff6c22f0627c82ac65f32726f3587a2aa1":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"11c6df42fb3eba174c3ca0d9a5194eaecd893b77":["5a207d19eac354d649c3f0e2cce070017c78125e"],"b7605579001505896d48b07160075a5c8b8e128e":["12320451a8cf581593c5eca6d2db98d299d693c7","bce1e2aee8b16573bc0d091471e4660d140b5823"],"a0a394130fcb854dc0880b48cc58a5ca049e591a":["b43cc463de57963524b3835202575c1662c9e927"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["bac2bd9d901ec1ee7111a77c8e616d745fb2a362"],"e4583d4aac44f313f9af74ab6d81baab3f976232":["09a37269f7ae6b4e61f0bfa661c642ad751e05c8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"30e0912f3a3069b115cfea44ff612c44d6906386":["fb29b298ad7651ee722a0f5491b689232c26d2b4"],"09a37269f7ae6b4e61f0bfa661c642ad751e05c8":["e8fbe4ce6e68a5b5f8936cf16786f6c37cc27090"],"e8fbe4ce6e68a5b5f8936cf16786f6c37cc27090":["a0a394130fcb854dc0880b48cc58a5ca049e591a"],"527cc14542789f47d75da436cb4287d1ab887e34":["399ef3ff6c22f0627c82ac65f32726f3587a2aa1"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["0d49a158012a8ff48f328a4558e4bfcffbaed16f","b470f36a9372c97283360b1304eacbde22df6c0d"],"407687e67faf6e1f02a211ca078d8e3eed631027":["09a37269f7ae6b4e61f0bfa661c642ad751e05c8","e4583d4aac44f313f9af74ab6d81baab3f976232"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"bac2bd9d901ec1ee7111a77c8e616d745fb2a362":["30e0912f3a3069b115cfea44ff612c44d6906386"],"4e12d86b6c563341330016a95710e4dedbfa7ef1":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5a207d19eac354d649c3f0e2cce070017c78125e","6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"b2d5244a676b83c2d551c3746e8181588ba619e1":["407687e67faf6e1f02a211ca078d8e3eed631027","fb29b298ad7651ee722a0f5491b689232c26d2b4"],"bce1e2aee8b16573bc0d091471e4660d140b5823":["12320451a8cf581593c5eca6d2db98d299d693c7"],"12320451a8cf581593c5eca6d2db98d299d693c7":["527cc14542789f47d75da436cb4287d1ab887e34"],"b43cc463de57963524b3835202575c1662c9e927":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77","4e12d86b6c563341330016a95710e4dedbfa7ef1"],"fb29b298ad7651ee722a0f5491b689232c26d2b4":["e4583d4aac44f313f9af74ab6d81baab3f976232"],"b470f36a9372c97283360b1304eacbde22df6c0d":["e3ce1ef883d26aa73919aa2d53991726e96caa13","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["bce1e2aee8b16573bc0d091471e4660d140b5823"],"f3adea0022cffaaa592081efed775a7b8bf86b51":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f3adea0022cffaaa592081efed775a7b8bf86b51"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["e3ce1ef883d26aa73919aa2d53991726e96caa13"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["b43cc463de57963524b3835202575c1662c9e927"],"5a207d19eac354d649c3f0e2cce070017c78125e":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"399ef3ff6c22f0627c82ac65f32726f3587a2aa1":["527cc14542789f47d75da436cb4287d1ab887e34"],"11c6df42fb3eba174c3ca0d9a5194eaecd893b77":["4e12d86b6c563341330016a95710e4dedbfa7ef1","6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"b7605579001505896d48b07160075a5c8b8e128e":[],"a0a394130fcb854dc0880b48cc58a5ca049e591a":["e8fbe4ce6e68a5b5f8936cf16786f6c37cc27090"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["399ef3ff6c22f0627c82ac65f32726f3587a2aa1"],"e4583d4aac44f313f9af74ab6d81baab3f976232":["407687e67faf6e1f02a211ca078d8e3eed631027","fb29b298ad7651ee722a0f5491b689232c26d2b4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["b470f36a9372c97283360b1304eacbde22df6c0d"],"30e0912f3a3069b115cfea44ff612c44d6906386":["bac2bd9d901ec1ee7111a77c8e616d745fb2a362"],"09a37269f7ae6b4e61f0bfa661c642ad751e05c8":["e4583d4aac44f313f9af74ab6d81baab3f976232","407687e67faf6e1f02a211ca078d8e3eed631027"],"e8fbe4ce6e68a5b5f8936cf16786f6c37cc27090":["09a37269f7ae6b4e61f0bfa661c642ad751e05c8"],"527cc14542789f47d75da436cb4287d1ab887e34":["12320451a8cf581593c5eca6d2db98d299d693c7"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["b2d5244a676b83c2d551c3746e8181588ba619e1"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["5a207d19eac354d649c3f0e2cce070017c78125e","6bfe104fc023fadc9e709f8d17403d2cc61133fe","b470f36a9372c97283360b1304eacbde22df6c0d","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"bac2bd9d901ec1ee7111a77c8e616d745fb2a362":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"4e12d86b6c563341330016a95710e4dedbfa7ef1":["6aaba221b22442bdf0ef28770c25fe259dfb3f55"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"b2d5244a676b83c2d551c3746e8181588ba619e1":[],"12320451a8cf581593c5eca6d2db98d299d693c7":["b7605579001505896d48b07160075a5c8b8e128e","bce1e2aee8b16573bc0d091471e4660d140b5823"],"bce1e2aee8b16573bc0d091471e4660d140b5823":["b7605579001505896d48b07160075a5c8b8e128e","5faf65b6692f15cca0f87bf8666c87899afc619f"],"b43cc463de57963524b3835202575c1662c9e927":["a0a394130fcb854dc0880b48cc58a5ca049e591a"],"6aaba221b22442bdf0ef28770c25fe259dfb3f55":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","f3adea0022cffaaa592081efed775a7b8bf86b51"],"fb29b298ad7651ee722a0f5491b689232c26d2b4":["30e0912f3a3069b115cfea44ff612c44d6906386","b2d5244a676b83c2d551c3746e8181588ba619e1"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"f3adea0022cffaaa592081efed775a7b8bf86b51":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","1e6acbaae7af722f17204ceccf0f7db5753eccf3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","b2d5244a676b83c2d551c3746e8181588ba619e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}