{"path":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","commits":[{"id":"4350b17bd363cd13a95171b8df1ca62ea4c3e71c","date":1183562198,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Flush all pending docs to a new segment */\n  int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    if (segment == null)\n      // In case we are asked to flush an empty segment\n      segment = writer.newSegmentName();\n\n    newFiles = new ArrayList();\n\n    docStoreOffset += numDocsInRAM;\n\n    if (closeDocStore) {\n      assert docStoreSegment != null;\n      assert docStoreSegment.equals(segment);\n      newFiles.addAll(files());\n      closeDocStore();\n    }\n    \n    int docCount;\n\n    assert numDocsInRAM > 0;\n\n    if (infoStream != null)\n      infoStream.println(\"\\nflush postings as segment \" + segment + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      fieldInfos.write(directory, segment + \".fnm\");\n\n      docCount = numDocsInRAM;\n\n      newFiles.addAll(writeSegment());\n\n      success = true;\n\n    } finally {\n      if (!success)\n        abort();\n    }\n\n    return docCount;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1405362241b561f5590ff4a87d5d6e173bcd9cf","date":1190107634,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","sourceNew":"  /** Flush all pending docs to a new segment */\n  int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    if (segment == null)\n      // In case we are asked to flush an empty segment\n      segment = writer.newSegmentName();\n\n    newFiles = new ArrayList();\n\n    docStoreOffset = numDocsInStore;\n\n    if (closeDocStore) {\n      assert docStoreSegment != null;\n      assert docStoreSegment.equals(segment);\n      newFiles.addAll(files());\n      closeDocStore();\n    }\n    \n    int docCount;\n\n    assert numDocsInRAM > 0;\n\n    if (infoStream != null)\n      infoStream.println(\"\\nflush postings as segment \" + segment + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      fieldInfos.write(directory, segment + \".fnm\");\n\n      docCount = numDocsInRAM;\n\n      newFiles.addAll(writeSegment());\n\n      success = true;\n\n    } finally {\n      if (!success)\n        abort();\n    }\n\n    return docCount;\n  }\n\n","sourceOld":"  /** Flush all pending docs to a new segment */\n  int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    if (segment == null)\n      // In case we are asked to flush an empty segment\n      segment = writer.newSegmentName();\n\n    newFiles = new ArrayList();\n\n    docStoreOffset += numDocsInRAM;\n\n    if (closeDocStore) {\n      assert docStoreSegment != null;\n      assert docStoreSegment.equals(segment);\n      newFiles.addAll(files());\n      closeDocStore();\n    }\n    \n    int docCount;\n\n    assert numDocsInRAM > 0;\n\n    if (infoStream != null)\n      infoStream.println(\"\\nflush postings as segment \" + segment + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      fieldInfos.write(directory, segment + \".fnm\");\n\n      docCount = numDocsInRAM;\n\n      newFiles.addAll(writeSegment());\n\n      success = true;\n\n    } finally {\n      if (!success)\n        abort();\n    }\n\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83bbb041887bbef07b8a98d08a0e1713ce137039","date":1200330381,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","sourceNew":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    if (segment == null)\n      // In case we are asked to flush an empty segment\n      segment = writer.newSegmentName();\n\n    newFiles = new ArrayList();\n\n    docStoreOffset = numDocsInStore;\n\n    int docCount;\n\n    assert numDocsInRAM > 0;\n\n    if (infoStream != null)\n      infoStream.println(\"\\nflush postings as segment \" + segment + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert docStoreSegment != null;\n        assert docStoreSegment.equals(segment);\n        newFiles.addAll(files());\n        closeDocStore();\n      }\n    \n      fieldInfos.write(directory, segment + \".fnm\");\n\n      docCount = numDocsInRAM;\n\n      newFiles.addAll(writeSegment());\n\n      success = true;\n\n    } finally {\n      if (!success)\n        abort(null);\n    }\n\n    return docCount;\n  }\n\n","sourceOld":"  /** Flush all pending docs to a new segment */\n  int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    if (segment == null)\n      // In case we are asked to flush an empty segment\n      segment = writer.newSegmentName();\n\n    newFiles = new ArrayList();\n\n    docStoreOffset = numDocsInStore;\n\n    if (closeDocStore) {\n      assert docStoreSegment != null;\n      assert docStoreSegment.equals(segment);\n      newFiles.addAll(files());\n      closeDocStore();\n    }\n    \n    int docCount;\n\n    assert numDocsInRAM > 0;\n\n    if (infoStream != null)\n      infoStream.println(\"\\nflush postings as segment \" + segment + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      fieldInfos.write(directory, segment + \".fnm\");\n\n      docCount = numDocsInRAM;\n\n      newFiles.addAll(writeSegment());\n\n      success = true;\n\n    } finally {\n      if (!success)\n        abort();\n    }\n\n    return docCount;\n  }\n\n","bugFix":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be","date":1204801324,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","sourceNew":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    if (segment == null)\n      // In case we are asked to flush an empty segment\n      segment = writer.newSegmentName();\n\n    newFiles = new ArrayList();\n\n    docStoreOffset = numDocsInStore;\n\n    int docCount;\n\n    assert numDocsInRAM > 0;\n\n    if (infoStream != null)\n      infoStream.println(\"\\nflush postings as segment \" + segment + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert docStoreSegment != null;\n        assert docStoreSegment.equals(segment);\n        newFiles.addAll(files());\n        closeDocStore();\n      }\n    \n      fieldInfos.write(directory, segment + \".fnm\");\n\n      docCount = numDocsInRAM;\n\n      newFiles.addAll(writeSegment());\n\n      flushedDocCount += docCount;\n\n      success = true;\n\n    } finally {\n      if (!success)\n        abort(null);\n    }\n\n    return docCount;\n  }\n\n","sourceOld":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    if (segment == null)\n      // In case we are asked to flush an empty segment\n      segment = writer.newSegmentName();\n\n    newFiles = new ArrayList();\n\n    docStoreOffset = numDocsInStore;\n\n    int docCount;\n\n    assert numDocsInRAM > 0;\n\n    if (infoStream != null)\n      infoStream.println(\"\\nflush postings as segment \" + segment + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert docStoreSegment != null;\n        assert docStoreSegment.equals(segment);\n        newFiles.addAll(files());\n        closeDocStore();\n      }\n    \n      fieldInfos.write(directory, segment + \".fnm\");\n\n      docCount = numDocsInRAM;\n\n      newFiles.addAll(writeSegment());\n\n      success = true;\n\n    } finally {\n      if (!success)\n        abort(null);\n    }\n\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84acdfa12c18361ff932244db20470fce117e52d","date":1206384355,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","sourceNew":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    if (segment == null)\n      // In case we are asked to flush an empty segment\n      segment = writer.newSegmentName();\n\n    newFiles = new ArrayList();\n\n    docStoreOffset = numDocsInStore;\n\n    int docCount;\n\n    assert numDocsInRAM > 0;\n\n    if (infoStream != null)\n      message(\"flush postings as segment \" + segment + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert docStoreSegment != null;\n        assert docStoreSegment.equals(segment);\n        newFiles.addAll(files());\n        closeDocStore();\n      }\n    \n      fieldInfos.write(directory, segment + \".fnm\");\n\n      docCount = numDocsInRAM;\n\n      newFiles.addAll(writeSegment());\n\n      flushedDocCount += docCount;\n\n      success = true;\n\n    } finally {\n      if (!success)\n        abort(null);\n    }\n\n    return docCount;\n  }\n\n","sourceOld":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    if (segment == null)\n      // In case we are asked to flush an empty segment\n      segment = writer.newSegmentName();\n\n    newFiles = new ArrayList();\n\n    docStoreOffset = numDocsInStore;\n\n    int docCount;\n\n    assert numDocsInRAM > 0;\n\n    if (infoStream != null)\n      infoStream.println(\"\\nflush postings as segment \" + segment + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert docStoreSegment != null;\n        assert docStoreSegment.equals(segment);\n        newFiles.addAll(files());\n        closeDocStore();\n      }\n    \n      fieldInfos.write(directory, segment + \".fnm\");\n\n      docCount = numDocsInRAM;\n\n      newFiles.addAll(writeSegment());\n\n      flushedDocCount += docCount;\n\n      success = true;\n\n    } finally {\n      if (!success)\n        abort(null);\n    }\n\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5350389bf83287111f7760b9e3db3af8e3648474","date":1216372812,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","sourceNew":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    assert numDocsInRAM > 0;\n\n    assert nextDocID == numDocsInRAM;\n    assert waitQueue.numWaiting == 0;\n    assert waitQueue.waitingBytes == 0;\n\n    initFlushState(false);\n\n    docStoreOffset = numDocsInStore;\n\n    if (infoStream != null)\n      message(\"flush postings as segment \" + flushState.segmentName + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert flushState.docStoreSegmentName != null;\n        assert flushState.docStoreSegmentName.equals(flushState.segmentName);\n        closeDocStore();\n        flushState.numDocsInStore = 0;\n      }\n\n      Collection threads = new HashSet();\n      for(int i=0;i<threadStates.length;i++)\n        threads.add(threadStates[i].consumer);\n      consumer.flush(threads, flushState);\n\n      if (infoStream != null) {\n        final long newSegmentSize = segmentSize(flushState.segmentName);\n        String message = \"  oldRAMSize=\" + numBytesUsed +\n          \" newFlushedSize=\" + newSegmentSize +\n          \" docs/MB=\" + nf.format(numDocsInRAM/(newSegmentSize/1024./1024.)) +\n          \" new/old=\" + nf.format(100.0*newSegmentSize/numBytesUsed) + \"%\";\n        message(message);\n      }\n\n      flushedDocCount += flushState.numDocsInRAM;\n\n      doAfterFlush();\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n\n    assert waitQueue.waitingBytes == 0;\n\n    return flushState.numDocsInRAM;\n  }\n\n","sourceOld":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    if (segment == null)\n      // In case we are asked to flush an empty segment\n      segment = writer.newSegmentName();\n\n    newFiles = new ArrayList();\n\n    docStoreOffset = numDocsInStore;\n\n    int docCount;\n\n    assert numDocsInRAM > 0;\n\n    if (infoStream != null)\n      message(\"flush postings as segment \" + segment + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert docStoreSegment != null;\n        assert docStoreSegment.equals(segment);\n        newFiles.addAll(files());\n        closeDocStore();\n      }\n    \n      fieldInfos.write(directory, segment + \".fnm\");\n\n      docCount = numDocsInRAM;\n\n      newFiles.addAll(writeSegment());\n\n      flushedDocCount += docCount;\n\n      success = true;\n\n    } finally {\n      if (!success)\n        abort(null);\n    }\n\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d17492f26096e19670d947d1be5e9adc52b1d3d","date":1224931200,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","sourceNew":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    assert numDocsInRAM > 0;\n\n    assert nextDocID == numDocsInRAM;\n    assert waitQueue.numWaiting == 0;\n    assert waitQueue.waitingBytes == 0;\n\n    initFlushState(false);\n\n    docStoreOffset = numDocsInStore;\n\n    if (infoStream != null)\n      message(\"flush postings as segment \" + flushState.segmentName + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert flushState.docStoreSegmentName != null;\n        assert flushState.docStoreSegmentName.equals(flushState.segmentName);\n        closeDocStore();\n        flushState.numDocsInStore = 0;\n      }\n\n      Collection threads = new HashSet();\n      for(int i=0;i<threadStates.length;i++)\n        threads.add(threadStates[i].consumer);\n      consumer.flush(threads, flushState);\n\n      if (infoStream != null) {\n        final long newSegmentSize = segmentSize(flushState.segmentName);\n        String message = \"  oldRAMSize=\" + numBytesUsed +\n          \" newFlushedSize=\" + newSegmentSize +\n          \" docs/MB=\" + nf.format(numDocsInRAM/(newSegmentSize/1024./1024.)) +\n          \" new/old=\" + nf.format(100.0*newSegmentSize/numBytesUsed) + \"%\";\n        message(message);\n      }\n\n      flushedDocCount += flushState.numDocs;\n\n      doAfterFlush();\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n\n    assert waitQueue.waitingBytes == 0;\n\n    return flushState.numDocs;\n  }\n\n","sourceOld":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    assert numDocsInRAM > 0;\n\n    assert nextDocID == numDocsInRAM;\n    assert waitQueue.numWaiting == 0;\n    assert waitQueue.waitingBytes == 0;\n\n    initFlushState(false);\n\n    docStoreOffset = numDocsInStore;\n\n    if (infoStream != null)\n      message(\"flush postings as segment \" + flushState.segmentName + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert flushState.docStoreSegmentName != null;\n        assert flushState.docStoreSegmentName.equals(flushState.segmentName);\n        closeDocStore();\n        flushState.numDocsInStore = 0;\n      }\n\n      Collection threads = new HashSet();\n      for(int i=0;i<threadStates.length;i++)\n        threads.add(threadStates[i].consumer);\n      consumer.flush(threads, flushState);\n\n      if (infoStream != null) {\n        final long newSegmentSize = segmentSize(flushState.segmentName);\n        String message = \"  oldRAMSize=\" + numBytesUsed +\n          \" newFlushedSize=\" + newSegmentSize +\n          \" docs/MB=\" + nf.format(numDocsInRAM/(newSegmentSize/1024./1024.)) +\n          \" new/old=\" + nf.format(100.0*newSegmentSize/numBytesUsed) + \"%\";\n        message(message);\n      }\n\n      flushedDocCount += flushState.numDocsInRAM;\n\n      doAfterFlush();\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n\n    assert waitQueue.waitingBytes == 0;\n\n    return flushState.numDocsInRAM;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa27b750ee9a51ec4bed93ef328aef9ca1e2153d","date":1255859449,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","sourceNew":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    assert numDocsInRAM > 0;\n\n    assert nextDocID == numDocsInRAM;\n    assert waitQueue.numWaiting == 0;\n    assert waitQueue.waitingBytes == 0;\n\n    initFlushState(false);\n\n    docStoreOffset = numDocsInStore;\n\n    if (infoStream != null)\n      message(\"flush postings as segment \" + flushState.segmentName + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert flushState.docStoreSegmentName != null;\n        assert flushState.docStoreSegmentName.equals(flushState.segmentName);\n        closeDocStore();\n        flushState.numDocsInStore = 0;\n      }\n\n      Collection<DocConsumerPerThread> threads = new HashSet<DocConsumerPerThread>();\n      for(int i=0;i<threadStates.length;i++)\n        threads.add(threadStates[i].consumer);\n      consumer.flush(threads, flushState);\n\n      if (infoStream != null) {\n        final long newSegmentSize = segmentSize(flushState.segmentName);\n        String message = \"  oldRAMSize=\" + numBytesUsed +\n          \" newFlushedSize=\" + newSegmentSize +\n          \" docs/MB=\" + nf.format(numDocsInRAM/(newSegmentSize/1024./1024.)) +\n          \" new/old=\" + nf.format(100.0*newSegmentSize/numBytesUsed) + \"%\";\n        message(message);\n      }\n\n      flushedDocCount += flushState.numDocs;\n\n      doAfterFlush();\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n\n    assert waitQueue.waitingBytes == 0;\n\n    return flushState.numDocs;\n  }\n\n","sourceOld":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    assert numDocsInRAM > 0;\n\n    assert nextDocID == numDocsInRAM;\n    assert waitQueue.numWaiting == 0;\n    assert waitQueue.waitingBytes == 0;\n\n    initFlushState(false);\n\n    docStoreOffset = numDocsInStore;\n\n    if (infoStream != null)\n      message(\"flush postings as segment \" + flushState.segmentName + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert flushState.docStoreSegmentName != null;\n        assert flushState.docStoreSegmentName.equals(flushState.segmentName);\n        closeDocStore();\n        flushState.numDocsInStore = 0;\n      }\n\n      Collection threads = new HashSet();\n      for(int i=0;i<threadStates.length;i++)\n        threads.add(threadStates[i].consumer);\n      consumer.flush(threads, flushState);\n\n      if (infoStream != null) {\n        final long newSegmentSize = segmentSize(flushState.segmentName);\n        String message = \"  oldRAMSize=\" + numBytesUsed +\n          \" newFlushedSize=\" + newSegmentSize +\n          \" docs/MB=\" + nf.format(numDocsInRAM/(newSegmentSize/1024./1024.)) +\n          \" new/old=\" + nf.format(100.0*newSegmentSize/numBytesUsed) + \"%\";\n        message(message);\n      }\n\n      flushedDocCount += flushState.numDocs;\n\n      doAfterFlush();\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n\n    assert waitQueue.waitingBytes == 0;\n\n    return flushState.numDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9c5e65cdd19cdd7d69a21b097f17724d5b9ccf2","date":1257694556,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","sourceNew":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    assert numDocsInRAM > 0;\n\n    assert nextDocID == numDocsInRAM;\n    assert waitQueue.numWaiting == 0;\n    assert waitQueue.waitingBytes == 0;\n\n    initFlushState(false);\n\n    docStoreOffset = numDocsInStore;\n\n    if (infoStream != null)\n      message(\"flush postings as segment \" + flushState.segmentName + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert flushState.docStoreSegmentName != null;\n        assert flushState.docStoreSegmentName.equals(flushState.segmentName);\n        closeDocStore();\n        flushState.numDocsInStore = 0;\n      }\n\n      Collection<DocConsumerPerThread> threads = new HashSet<DocConsumerPerThread>();\n      for(int i=0;i<threadStates.length;i++)\n        threads.add(threadStates[i].consumer);\n      consumer.flush(threads, flushState);\n\n      if (infoStream != null) {\n        SegmentInfo si = new SegmentInfo(flushState.segmentName, flushState.numDocs, directory);\n        final long newSegmentSize = si.sizeInBytes();\n        String message = \"  oldRAMSize=\" + numBytesUsed +\n          \" newFlushedSize=\" + newSegmentSize +\n          \" docs/MB=\" + nf.format(numDocsInRAM/(newSegmentSize/1024./1024.)) +\n          \" new/old=\" + nf.format(100.0*newSegmentSize/numBytesUsed) + \"%\";\n        message(message);\n      }\n\n      flushedDocCount += flushState.numDocs;\n\n      doAfterFlush();\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n\n    assert waitQueue.waitingBytes == 0;\n\n    return flushState.numDocs;\n  }\n\n","sourceOld":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    assert numDocsInRAM > 0;\n\n    assert nextDocID == numDocsInRAM;\n    assert waitQueue.numWaiting == 0;\n    assert waitQueue.waitingBytes == 0;\n\n    initFlushState(false);\n\n    docStoreOffset = numDocsInStore;\n\n    if (infoStream != null)\n      message(\"flush postings as segment \" + flushState.segmentName + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert flushState.docStoreSegmentName != null;\n        assert flushState.docStoreSegmentName.equals(flushState.segmentName);\n        closeDocStore();\n        flushState.numDocsInStore = 0;\n      }\n\n      Collection<DocConsumerPerThread> threads = new HashSet<DocConsumerPerThread>();\n      for(int i=0;i<threadStates.length;i++)\n        threads.add(threadStates[i].consumer);\n      consumer.flush(threads, flushState);\n\n      if (infoStream != null) {\n        final long newSegmentSize = segmentSize(flushState.segmentName);\n        String message = \"  oldRAMSize=\" + numBytesUsed +\n          \" newFlushedSize=\" + newSegmentSize +\n          \" docs/MB=\" + nf.format(numDocsInRAM/(newSegmentSize/1024./1024.)) +\n          \" new/old=\" + nf.format(100.0*newSegmentSize/numBytesUsed) + \"%\";\n        message(message);\n      }\n\n      flushedDocCount += flushState.numDocs;\n\n      doAfterFlush();\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n\n    assert waitQueue.waitingBytes == 0;\n\n    return flushState.numDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#flush(boolean).mjava","sourceNew":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    assert numDocsInRAM > 0;\n\n    assert nextDocID == numDocsInRAM;\n    assert waitQueue.numWaiting == 0;\n    assert waitQueue.waitingBytes == 0;\n\n    initFlushState(false);\n\n    docStoreOffset = numDocsInStore;\n\n    if (infoStream != null)\n      message(\"flush postings as segment \" + flushState.segmentName + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert flushState.docStoreSegmentName != null;\n        assert flushState.docStoreSegmentName.equals(flushState.segmentName);\n        closeDocStore();\n        flushState.numDocsInStore = 0;\n      }\n\n      Collection<DocConsumerPerThread> threads = new HashSet<DocConsumerPerThread>();\n      for(int i=0;i<threadStates.length;i++)\n        threads.add(threadStates[i].consumer);\n      consumer.flush(threads, flushState);\n\n      if (infoStream != null) {\n        SegmentInfo si = new SegmentInfo(flushState.segmentName, flushState.numDocs, directory);\n        final long newSegmentSize = si.sizeInBytes();\n        String message = \"  oldRAMSize=\" + numBytesUsed +\n          \" newFlushedSize=\" + newSegmentSize +\n          \" docs/MB=\" + nf.format(numDocsInRAM/(newSegmentSize/1024./1024.)) +\n          \" new/old=\" + nf.format(100.0*newSegmentSize/numBytesUsed) + \"%\";\n        message(message);\n      }\n\n      flushedDocCount += flushState.numDocs;\n\n      doAfterFlush();\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n\n    assert waitQueue.waitingBytes == 0;\n\n    return flushState.numDocs;\n  }\n\n","sourceOld":"  /** Flush all pending docs to a new segment */\n  synchronized int flush(boolean closeDocStore) throws IOException {\n\n    assert allThreadsIdle();\n\n    assert numDocsInRAM > 0;\n\n    assert nextDocID == numDocsInRAM;\n    assert waitQueue.numWaiting == 0;\n    assert waitQueue.waitingBytes == 0;\n\n    initFlushState(false);\n\n    docStoreOffset = numDocsInStore;\n\n    if (infoStream != null)\n      message(\"flush postings as segment \" + flushState.segmentName + \" numDocs=\" + numDocsInRAM);\n    \n    boolean success = false;\n\n    try {\n\n      if (closeDocStore) {\n        assert flushState.docStoreSegmentName != null;\n        assert flushState.docStoreSegmentName.equals(flushState.segmentName);\n        closeDocStore();\n        flushState.numDocsInStore = 0;\n      }\n\n      Collection<DocConsumerPerThread> threads = new HashSet<DocConsumerPerThread>();\n      for(int i=0;i<threadStates.length;i++)\n        threads.add(threadStates[i].consumer);\n      consumer.flush(threads, flushState);\n\n      if (infoStream != null) {\n        SegmentInfo si = new SegmentInfo(flushState.segmentName, flushState.numDocs, directory);\n        final long newSegmentSize = si.sizeInBytes();\n        String message = \"  oldRAMSize=\" + numBytesUsed +\n          \" newFlushedSize=\" + newSegmentSize +\n          \" docs/MB=\" + nf.format(numDocsInRAM/(newSegmentSize/1024./1024.)) +\n          \" new/old=\" + nf.format(100.0*newSegmentSize/numBytesUsed) + \"%\";\n        message(message);\n      }\n\n      flushedDocCount += flushState.numDocs;\n\n      doAfterFlush();\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        abort();\n      }\n    }\n\n    assert waitQueue.waitingBytes == 0;\n\n    return flushState.numDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f9c5e65cdd19cdd7d69a21b097f17724d5b9ccf2":["fa27b750ee9a51ec4bed93ef328aef9ca1e2153d"],"83bbb041887bbef07b8a98d08a0e1713ce137039":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"fa27b750ee9a51ec4bed93ef328aef9ca1e2153d":["4d17492f26096e19670d947d1be5e9adc52b1d3d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4d17492f26096e19670d947d1be5e9adc52b1d3d":["5350389bf83287111f7760b9e3db3af8e3648474"],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"5350389bf83287111f7760b9e3db3af8e3648474":["84acdfa12c18361ff932244db20470fce117e52d"],"84acdfa12c18361ff932244db20470fce117e52d":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["f9c5e65cdd19cdd7d69a21b097f17724d5b9ccf2"]},"commit2Childs":{"f9c5e65cdd19cdd7d69a21b097f17724d5b9ccf2":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"83bbb041887bbef07b8a98d08a0e1713ce137039":["a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be"],"b1405362241b561f5590ff4a87d5d6e173bcd9cf":["83bbb041887bbef07b8a98d08a0e1713ce137039"],"fa27b750ee9a51ec4bed93ef328aef9ca1e2153d":["f9c5e65cdd19cdd7d69a21b097f17724d5b9ccf2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4350b17bd363cd13a95171b8df1ca62ea4c3e71c"],"4d17492f26096e19670d947d1be5e9adc52b1d3d":["fa27b750ee9a51ec4bed93ef328aef9ca1e2153d"],"a2fc4b864a5dc2c630bb1fa94091e89e69f8f8be":["84acdfa12c18361ff932244db20470fce117e52d"],"4350b17bd363cd13a95171b8df1ca62ea4c3e71c":["b1405362241b561f5590ff4a87d5d6e173bcd9cf"],"5350389bf83287111f7760b9e3db3af8e3648474":["4d17492f26096e19670d947d1be5e9adc52b1d3d"],"84acdfa12c18361ff932244db20470fce117e52d":["5350389bf83287111f7760b9e3db3af8e3648474"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}