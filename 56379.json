{"path":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","commits":[{"id":"802a334e6d4a20dcfbb4061fd25c74375368534b","date":1348220248,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n          \n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, writer, directory);\n     \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9de3cc9f996773789b2e99fd1ebd8498ddaf6b52","date":1348223570,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","sourceNew":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n          \n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, writer, directory);\n     \n  }\n\n","sourceOld":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n          \n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, writer, directory);\n     \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b9f056598bc578796f7c2eaa4b2bb8eaab5c23a","date":1363294103,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","sourceNew":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n          \n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, writer, directory);\n     \n  }\n\n","sourceOld":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n          \n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, writer, directory);\n     \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","sourceNew":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n          \n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","sourceOld":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close ();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n          \n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, writer, directory);\n     \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ea8c8c94ae9da9a366175e2abbe1dde3aa0453","date":1402659583,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","sourceNew":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","sourceOld":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n          \n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","sourceNew":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","sourceOld":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n          \n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","sourceNew":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","sourceOld":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","sourceNew":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","sourceOld":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.shutdown();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","sourceNew":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final LeafReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","sourceOld":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","sourceNew":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final LeafReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final PostingsEnum termPostingsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termPostingsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termPostingsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termPostingsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termPostingsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termPostingsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","sourceOld":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final LeafReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final DocsEnum termDocsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termDocsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termDocsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termDocsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termDocsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termDocsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6","date":1424027250,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","sourceNew":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final LeafReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final PostingsEnum termPostingsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termPostingsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termPostingsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termPostingsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termPostingsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termPostingsEnum.cost();\n              } \n            };\n          }\n          \n          \n        };\n        \n      }\n      @Override\n      public String toString(String field) {\n        return \"filterField0\";\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","sourceOld":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final LeafReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final PostingsEnum termPostingsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termPostingsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termPostingsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termPostingsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termPostingsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termPostingsEnum.cost();\n              } \n            };\n          }\n          \n        };\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e73063b92d958076ef4ae8beb5f493e8ccdcecb4","date":1424177215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","sourceNew":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final LeafReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final PostingsEnum termPostingsEnum = context.reader().postings(new Term(\"field\", \"0\"));\n            if (termPostingsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termPostingsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termPostingsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termPostingsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termPostingsEnum.cost();\n              } \n            };\n          }\n          \n          \n        };\n        \n      }\n      @Override\n      public String toString(String field) {\n        return \"filterField0\";\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","sourceOld":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final LeafReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final PostingsEnum termPostingsEnum = context.reader().termDocsEnum(new Term(\"field\", \"0\"));\n            if (termPostingsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termPostingsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termPostingsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termPostingsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termPostingsEnum.cost();\n              } \n            };\n          }\n          \n          \n        };\n        \n      }\n      @Override\n      public String toString(String field) {\n        return \"filterField0\";\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery#testLeapFrogStrategy().mjava","sourceNew":null,"sourceOld":"  /*\n   * Test if the leapfrog strategy works correctly in terms\n   * of advancing / next the right thing first\n   */\n  public void testLeapFrogStrategy() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter (random(), directory, newIndexWriterConfig(new MockAnalyzer(random())));\n    int numDocs = atLeast(50);\n    int totalDocsWithZero = 0;\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      int num = random().nextInt(10);\n      if (num == 0) {\n        totalDocsWithZero++;\n      }\n      doc.add (newTextField(\"field\", \"\"+num, Field.Store.YES));\n      writer.addDocument (doc);  \n    }\n    IndexReader reader = writer.getReader();\n    writer.close();\n    final boolean queryFirst = random().nextBoolean();\n    IndexSearcher searcher = newSearcher(reader);\n    Query query = new FilteredQuery(new TermQuery(new Term(\"field\", \"0\")), new Filter() {\n      @Override\n      public DocIdSet getDocIdSet(final LeafReaderContext context, Bits acceptDocs)\n          throws IOException {\n        return new DocIdSet() {\n\n          @Override\n          public long ramBytesUsed() {\n            return 0L;\n          }\n\n          @Override\n          public Bits bits() throws IOException {\n             return null;\n          }\n          @Override\n          public DocIdSetIterator iterator() throws IOException {\n            final PostingsEnum termPostingsEnum = context.reader().postings(new Term(\"field\", \"0\"));\n            if (termPostingsEnum == null) {\n              return null;\n            }\n            return new DocIdSetIterator() {\n              boolean nextCalled;\n              boolean advanceCalled;\n              @Override\n              public int nextDoc() throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  \n                nextCalled = true;\n                return termPostingsEnum.nextDoc();\n              }\n              \n              @Override\n              public int docID() {\n                return termPostingsEnum.docID();\n              }\n              \n              @Override\n              public int advance(int target) throws IOException {\n                assertTrue(\"queryFirst: \"+ queryFirst + \" advanced: \" + advanceCalled + \" next: \"+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  \n                advanceCalled = true;\n                return termPostingsEnum.advance(target);\n              }\n              \n              @Override\n              public long cost() {\n                return termPostingsEnum.cost();\n              } \n            };\n          }\n          \n          \n        };\n        \n      }\n      @Override\n      public String toString(String field) {\n        return \"filterField0\";\n      }\n        }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()\n            .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY\n            : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null\n    \n    TopDocs search = searcher.search(query, 10);\n    assertEquals(totalDocsWithZero, search.totalHits);\n    IOUtils.close(reader, directory);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["54ea8c8c94ae9da9a366175e2abbe1dde3aa0453"],"54ea8c8c94ae9da9a366175e2abbe1dde3aa0453":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"7b9f056598bc578796f7c2eaa4b2bb8eaab5c23a":["9de3cc9f996773789b2e99fd1ebd8498ddaf6b52"],"802a334e6d4a20dcfbb4061fd25c74375368534b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","54ea8c8c94ae9da9a366175e2abbe1dde3aa0453"],"51f5280f31484820499077f41fcdfe92d527d9dc":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6":["51f5280f31484820499077f41fcdfe92d527d9dc"],"1db68e96dd908fcd79ef809095822736aa601d08":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6"],"9de3cc9f996773789b2e99fd1ebd8498ddaf6b52":["802a334e6d4a20dcfbb4061fd25c74375368534b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["7b9f056598bc578796f7c2eaa4b2bb8eaab5c23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1db68e96dd908fcd79ef809095822736aa601d08"]},"commit2Childs":{"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"54ea8c8c94ae9da9a366175e2abbe1dde3aa0453":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","c6f080a2ab37c464dd98db173f6cbf10dc74f211"],"7b9f056598bc578796f7c2eaa4b2bb8eaab5c23a":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"802a334e6d4a20dcfbb4061fd25c74375368534b":["9de3cc9f996773789b2e99fd1ebd8498ddaf6b52"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"51f5280f31484820499077f41fcdfe92d527d9dc":["fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["51f5280f31484820499077f41fcdfe92d527d9dc"],"fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"9de3cc9f996773789b2e99fd1ebd8498ddaf6b52":["7b9f056598bc578796f7c2eaa4b2bb8eaab5c23a"],"1db68e96dd908fcd79ef809095822736aa601d08":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["1db68e96dd908fcd79ef809095822736aa601d08"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["802a334e6d4a20dcfbb4061fd25c74375368534b"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54ea8c8c94ae9da9a366175e2abbe1dde3aa0453","c6f080a2ab37c464dd98db173f6cbf10dc74f211"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}