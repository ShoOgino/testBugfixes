{"path":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderDBQsTest().mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderDBQsTest().mjava","pathOld":"/dev/null","sourceNew":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void outOfOrderDBQsTest() throws Exception {\n    \n    del(\"*:*\");\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"outOfOrderDeleteUpdatesIndividualReplicaTest: This test passed fine...\");\n    del(\"*:*\");\n    commit();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["08807474e48bac766abf10459c3c25e4a5e4d7cc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderDBQsTest().mjava","pathOld":"/dev/null","sourceNew":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void outOfOrderDBQsTest() throws Exception {\n    \n    del(\"*:*\");\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"outOfOrderDeleteUpdatesIndividualReplicaTest: This test passed fine...\");\n    del(\"*:*\");\n    commit();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5048c558f8802f1689d38203111379406b171418","date":1486467652,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderDBQsTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderDBQsTest().mjava","sourceNew":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void outOfOrderDBQsTest() throws Exception {\n    \n    clearIndex();\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"outOfOrderDeleteUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void outOfOrderDBQsTest() throws Exception {\n    \n    del(\"*:*\");\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"outOfOrderDeleteUpdatesIndividualReplicaTest: This test passed fine...\");\n    del(\"*:*\");\n    commit();\n  }\n\n","bugFix":null,"bugIntro":["08807474e48bac766abf10459c3c25e4a5e4d7cc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e11e54ce6015434b2aaadb49ca5071dbe7be50c","date":1489404389,"type":5,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#reorderedDBQsSimpleTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestInPlaceUpdatesDistrib#outOfOrderDBQsTest().mjava","sourceNew":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void reorderedDBQsSimpleTest() throws Exception {\n    \n    clearIndex();\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 15 secs\", threadpool.awaitTermination(15, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"reorderedDBQsSimpleTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","sourceOld":"  // The following should work: full update to doc 0, in-place update for doc 0, delete doc 0\n  private void outOfOrderDBQsTest() throws Exception {\n    \n    clearIndex();\n    commit();\n    \n    buildRandomIndex(0);\n\n    float inplace_updatable_float = 1;\n\n    // update doc, set\n    index(\"id\", 0, \"inplace_updatable_float\", map(\"set\", inplace_updatable_float));\n\n    LEADER.commit();\n    SolrDocument sdoc = LEADER.getById(\"0\");  // RTG straight from the index\n    assertEquals(inplace_updatable_float, sdoc.get(\"inplace_updatable_float\"));\n    assertEquals(\"title0\", sdoc.get(\"title_s\"));\n    long version0 = (long) sdoc.get(\"_version_\");\n\n    // put replica out of sync\n    float newinplace_updatable_float = 100;\n    List<UpdateRequest> updates = new ArrayList<>();\n    updates.add(simulatedUpdateRequest(null, \"id\", 0, \"title_s\", \"title0_new\", \"inplace_updatable_float\", newinplace_updatable_float, \"_version_\", version0 + 1)); // full update\n    updates.add(simulatedUpdateRequest(version0 + 1, \"id\", 0, \"inplace_updatable_float\", newinplace_updatable_float + 1, \"_version_\", version0 + 2)); // inplace_updatable_float=101\n    updates.add(simulatedDeleteRequest(0, version0 + 3));\n\n    // order the updates correctly for NONLEADER 1\n    for (UpdateRequest update : updates) {\n      log.info(\"Issuing well ordered update: \" + update.getDocuments());\n      NONLEADERS.get(1).request(update);\n    }\n\n    // Reordering needs to happen using parallel threads\n    ExecutorService threadpool = \n        ExecutorUtil.newMDCAwareFixedThreadPool(updates.size() + 1, new DefaultSolrThreadFactory(getTestName()));\n\n    // re-order the updates for NONLEADER 0\n    List<UpdateRequest> reorderedUpdates = new ArrayList<>(updates);\n    Collections.shuffle(reorderedUpdates, random());\n    List<Future<UpdateResponse>> updateResponses = new ArrayList<>();\n    for (UpdateRequest update : reorderedUpdates) {\n      AsyncUpdateWithRandomCommit task = new AsyncUpdateWithRandomCommit(update, NONLEADERS.get(0), random().nextLong());\n      updateResponses.add(threadpool.submit(task));\n      // while we can't guarantee/trust what order the updates are executed in, since multiple threads\n      // are involved, but we're trying to bias the thread scheduling to run them in the order submitted\n      Thread.sleep(10);\n    }\n    \n    threadpool.shutdown();\n    assertTrue(\"Thread pool didn't terminate within 10 secs\", threadpool.awaitTermination(10, TimeUnit.SECONDS));\n    \n    // assert all requests were successful\n    for (Future<UpdateResponse> resp: updateResponses) {\n      assertEquals(0, resp.get().getStatus());\n    }\n\n    // assert both replicas have same effect\n    for (SolrClient client : NONLEADERS) { // 0th is re-ordered replica, 1st is well-ordered replica\n      SolrDocument doc = client.getById(String.valueOf(0), params(\"distrib\", \"false\"));\n      assertNull(\"This doc was supposed to have been deleted, but was: \" + doc, doc);\n    }\n\n    log.info(\"outOfOrderDeleteUpdatesIndividualReplicaTest: This test passed fine...\");\n    clearIndex();\n    commit();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"2e11e54ce6015434b2aaadb49ca5071dbe7be50c":["5048c558f8802f1689d38203111379406b171418"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5048c558f8802f1689d38203111379406b171418":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","5048c558f8802f1689d38203111379406b171418"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"2e11e54ce6015434b2aaadb49ca5071dbe7be50c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"5048c558f8802f1689d38203111379406b171418":["2e11e54ce6015434b2aaadb49ca5071dbe7be50c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}