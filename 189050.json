{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"/dev/null","sourceNew":"  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      // TODO: in the future (7.0?  sigh) we can use this to throw IndexFormatTooOldException ... or just rely on the\n      // minSegmentLuceneVersion check instead:\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else compute the min version down below in the for loop\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (format >= VERSION_53) {\n      if (numSegments > 0) {\n        infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n        if (infos.minSegmentLuceneVersion.onOrAfter(Version.LUCENE_5_0_0) == false) {\n          throw new IndexFormatTooOldException(input, \"this index contains a too-old segment (version: \" + infos.minSegmentLuceneVersion + \")\");\n        }\n      } else {\n        // else leave as null: no segments\n      }\n    } else {\n      // else we recompute it below as we visit segments; it can't be used for throwing IndexFormatTooOldExc, but consumers of\n      // SegmentInfos can maybe still use it for other reasons\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      if (format >= VERSION_51) {\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      } else {\n        siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n      }\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          if (format >= VERSION_51) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          } else {\n            map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n          }\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n      if (format < VERSION_53) {\n        if (infos.minSegmentLuceneVersion == null || segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          infos.minSegmentLuceneVersion = segmentVersion;\n        }\n      } else if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    if (format >= VERSION_51) {\n      infos.userData = input.readMapOfStrings();\n    } else {\n      infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n    }\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0617d2d25b13b9a49450ea49ceb06123ebd6542a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2b844e2ae5435a8d4d925003c10027c25e26e02d","date":1455044345,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      // TODO: in the future (7.0?  sigh) we can use this to throw IndexFormatTooOldException ... or just rely on the\n      // minSegmentLuceneVersion check instead:\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else compute the min version down below in the for loop\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (format >= VERSION_53) {\n      if (numSegments > 0) {\n        infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n        if (infos.minSegmentLuceneVersion.onOrAfter(Version.LUCENE_5_0_0) == false) {\n          throw new IndexFormatTooOldException(input, \"this index contains a too-old segment (version: \" + infos.minSegmentLuceneVersion + \")\");\n        }\n      } else {\n        // else leave as null: no segments\n      }\n    } else {\n      // else we recompute it below as we visit segments; it can't be used for throwing IndexFormatTooOldExc, but consumers of\n      // SegmentInfos can maybe still use it for other reasons\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      if (format >= VERSION_51) {\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      } else {\n        siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n      }\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          if (format >= VERSION_51) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          } else {\n            map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n          }\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n      if (format < VERSION_53) {\n        if (infos.minSegmentLuceneVersion == null || segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          infos.minSegmentLuceneVersion = segmentVersion;\n        }\n      } else if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    if (format >= VERSION_51) {\n      infos.userData = input.readMapOfStrings();\n    } else {\n      infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n    }\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      // TODO: in the future (7.0?  sigh) we can use this to throw IndexFormatTooOldException ... or just rely on the\n      // minSegmentLuceneVersion check instead:\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else compute the min version down below in the for loop\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (format >= VERSION_53) {\n      if (numSegments > 0) {\n        infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n        if (infos.minSegmentLuceneVersion.onOrAfter(Version.LUCENE_5_0_0) == false) {\n          throw new IndexFormatTooOldException(input, \"this index contains a too-old segment (version: \" + infos.minSegmentLuceneVersion + \")\");\n        }\n      } else {\n        // else leave as null: no segments\n      }\n    } else {\n      // else we recompute it below as we visit segments; it can't be used for throwing IndexFormatTooOldExc, but consumers of\n      // SegmentInfos can maybe still use it for other reasons\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      if (format >= VERSION_51) {\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      } else {\n        siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n      }\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          if (format >= VERSION_51) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          } else {\n            map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n          }\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n      if (format < VERSION_53) {\n        if (infos.minSegmentLuceneVersion == null || segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          infos.minSegmentLuceneVersion = segmentVersion;\n        }\n      } else if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    if (format >= VERSION_51) {\n      infos.userData = input.readMapOfStrings();\n    } else {\n      infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n    }\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"/dev/null","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      // TODO: in the future (7.0?  sigh) we can use this to throw IndexFormatTooOldException ... or just rely on the\n      // minSegmentLuceneVersion check instead:\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else compute the min version down below in the for loop\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (format >= VERSION_53) {\n      if (numSegments > 0) {\n        infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n        if (infos.minSegmentLuceneVersion.onOrAfter(Version.LUCENE_5_0_0) == false) {\n          throw new IndexFormatTooOldException(input, \"this index contains a too-old segment (version: \" + infos.minSegmentLuceneVersion + \")\");\n        }\n      } else {\n        // else leave as null: no segments\n      }\n    } else {\n      // else we recompute it below as we visit segments; it can't be used for throwing IndexFormatTooOldExc, but consumers of\n      // SegmentInfos can maybe still use it for other reasons\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      if (format >= VERSION_51) {\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      } else {\n        siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n      }\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          if (format >= VERSION_51) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          } else {\n            map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n          }\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n      if (format < VERSION_53) {\n        if (infos.minSegmentLuceneVersion == null || segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          infos.minSegmentLuceneVersion = segmentVersion;\n        }\n      } else if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    if (format >= VERSION_51) {\n      infos.userData = input.readMapOfStrings();\n    } else {\n      infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n    }\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9de8327534b7bb8072a8534f55d0b680fb2e9cb3","date":1456917053,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      if (infos.luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n        throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + infos.luceneVersion + \")\");\n      }\n    } else {\n      throw new IndexFormatTooOldException(input, \"this index segments file is too old (segment infos format: \" + format + \")\");\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      if (format >= VERSION_51) {\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      } else {\n        siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n      }\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          if (format >= VERSION_51) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          } else {\n            map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n          }\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    if (format >= VERSION_51) {\n      infos.userData = input.readMapOfStrings();\n    } else {\n      infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n    }\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      // TODO: in the future (7.0?  sigh) we can use this to throw IndexFormatTooOldException ... or just rely on the\n      // minSegmentLuceneVersion check instead:\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else compute the min version down below in the for loop\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (format >= VERSION_53) {\n      if (numSegments > 0) {\n        infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n        if (infos.minSegmentLuceneVersion.onOrAfter(Version.LUCENE_5_0_0) == false) {\n          throw new IndexFormatTooOldException(input, \"this index contains a too-old segment (version: \" + infos.minSegmentLuceneVersion + \")\");\n        }\n      } else {\n        // else leave as null: no segments\n      }\n    } else {\n      // else we recompute it below as we visit segments; it can't be used for throwing IndexFormatTooOldExc, but consumers of\n      // SegmentInfos can maybe still use it for other reasons\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      if (format >= VERSION_51) {\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      } else {\n        siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n      }\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          if (format >= VERSION_51) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          } else {\n            map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n          }\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n      if (format < VERSION_53) {\n        if (infos.minSegmentLuceneVersion == null || segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          infos.minSegmentLuceneVersion = segmentVersion;\n        }\n      } else if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    if (format >= VERSION_51) {\n      infos.userData = input.readMapOfStrings();\n    } else {\n      infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n    }\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      if (infos.luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n        throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + infos.luceneVersion + \")\");\n      }\n    } else {\n      throw new IndexFormatTooOldException(input, \"this index segments file is too old (segment infos format: \" + format + \")\");\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      if (format >= VERSION_51) {\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      } else {\n        siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n      }\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          if (format >= VERSION_51) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          } else {\n            map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n          }\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    if (format >= VERSION_51) {\n      infos.userData = input.readMapOfStrings();\n    } else {\n      infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n    }\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      // TODO: in the future (7.0?  sigh) we can use this to throw IndexFormatTooOldException ... or just rely on the\n      // minSegmentLuceneVersion check instead:\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else compute the min version down below in the for loop\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (format >= VERSION_53) {\n      if (numSegments > 0) {\n        infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n        if (infos.minSegmentLuceneVersion.onOrAfter(Version.LUCENE_5_0_0) == false) {\n          throw new IndexFormatTooOldException(input, \"this index contains a too-old segment (version: \" + infos.minSegmentLuceneVersion + \")\");\n        }\n      } else {\n        // else leave as null: no segments\n      }\n    } else {\n      // else we recompute it below as we visit segments; it can't be used for throwing IndexFormatTooOldExc, but consumers of\n      // SegmentInfos can maybe still use it for other reasons\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      if (format >= VERSION_51) {\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      } else {\n        siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n      }\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          if (format >= VERSION_51) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          } else {\n            map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n          }\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n      if (format < VERSION_53) {\n        if (infos.minSegmentLuceneVersion == null || segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          infos.minSegmentLuceneVersion = segmentVersion;\n        }\n      } else if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    if (format >= VERSION_51) {\n      infos.userData = input.readMapOfStrings();\n    } else {\n      infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n    }\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c850d2a2bc88f4751bf05e1ee6799940462331eb","date":1472140972,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      if (infos.luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n        throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + infos.luceneVersion + \")\");\n      }\n    } else {\n      throw new IndexFormatTooOldException(input, \"this index segments file is too old (segment infos format: \" + format + \")\");\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      if (infos.luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n        throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + infos.luceneVersion + \")\");\n      }\n    } else {\n      throw new IndexFormatTooOldException(input, \"this index segments file is too old (segment infos format: \" + format + \")\");\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      if (format >= VERSION_51) {\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      } else {\n        siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n      }\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          if (format >= VERSION_51) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          } else {\n            map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n          }\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    if (format >= VERSION_51) {\n      infos.userData = input.readMapOfStrings();\n    } else {\n      infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n    }\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","date":1472163016,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      if (infos.luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n        throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + infos.luceneVersion + \")\");\n      }\n    } else {\n      throw new IndexFormatTooOldException(input, \"this index segments file is too old (segment infos format: \" + format + \")\");\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      if (infos.luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n        throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + infos.luceneVersion + \")\");\n      }\n    } else {\n      throw new IndexFormatTooOldException(input, \"this index segments file is too old (segment infos format: \" + format + \")\");\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      if (format >= VERSION_51) {\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      } else {\n        siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n      }\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          if (format >= VERSION_51) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          } else {\n            map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n          }\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    if (format >= VERSION_51) {\n      infos.userData = input.readMapOfStrings();\n    } else {\n      infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n    }\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      if (infos.luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n        throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + infos.luceneVersion + \")\");\n      }\n    } else {\n      throw new IndexFormatTooOldException(input, \"this index segments file is too old (segment infos format: \" + format + \")\");\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_50, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      if (infos.luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n        throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + infos.luceneVersion + \")\");\n      }\n    } else {\n      throw new IndexFormatTooOldException(input, \"this index segments file is too old (segment infos format: \" + format + \")\");\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      if (format >= VERSION_51) {\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      } else {\n        siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));\n      }\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          if (format >= VERSION_51) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          } else {\n            map.put(input.readInt(), Collections.unmodifiableSet(input.readStringSet()));\n          }\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    if (format >= VERSION_51) {\n      infos.userData = input.readMapOfStrings();\n    } else {\n      infos.userData = Collections.unmodifiableMap(input.readStringStringMap());\n    }\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d97ba94eef1fc33c5451259a7aa2ac682646c1af","date":1488285427,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    Version indexCreatedVersion;\n    if (format >= VERSION_70) {\n      byte b = input.readByte();\n      switch (b) {\n        case 0:\n          // version is not known: pre-7.0 index that has been modified since the 7.0 upgrade\n          indexCreatedVersion = null;\n          break;\n        case 1:\n          // version is known: index has been created on or after 7.0\n          indexCreatedVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n          break;\n        default:\n          throw new CorruptIndexException(\"Illegal byte value for a boolean: \" + b + \", expected 0 or 1\", input);\n      }\n    } else {\n      // pre-7.0 index that has not been modified since the 7.0 upgrade\n      indexCreatedVersion = null;\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    SegmentInfos infos = new SegmentInfos();\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    if (format >= VERSION_53) {\n      infos.luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      if (infos.luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n        throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + infos.luceneVersion + \")\");\n      }\n    } else {\n      throw new IndexFormatTooOldException(input, \"this index segments file is too old (segment infos format: \" + format + \")\");\n    }\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = 6;\n    if (format >= VERSION_70) {\n      indexCreatedVersion = input.readVInt();\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    Version indexCreatedVersion;\n    if (format >= VERSION_70) {\n      byte b = input.readByte();\n      switch (b) {\n        case 0:\n          // version is not known: pre-7.0 index that has been modified since the 7.0 upgrade\n          indexCreatedVersion = null;\n          break;\n        case 1:\n          // version is known: index has been created on or after 7.0\n          indexCreatedVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n          break;\n        default:\n          throw new CorruptIndexException(\"Illegal byte value for a boolean: \" + b + \", expected 0 or 1\", input);\n      }\n    } else {\n      // pre-7.0 index that has not been modified since the 7.0 upgrade\n      indexCreatedVersion = null;\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = 6;\n    if (format >= VERSION_70) {\n      indexCreatedVersion = input.readVInt();\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    Version indexCreatedVersion;\n    if (format >= VERSION_70) {\n      byte b = input.readByte();\n      switch (b) {\n        case 0:\n          // version is not known: pre-7.0 index that has been modified since the 7.0 upgrade\n          indexCreatedVersion = null;\n          break;\n        case 1:\n          // version is known: index has been created on or after 7.0\n          indexCreatedVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n          break;\n        default:\n          throw new CorruptIndexException(\"Illegal byte value for a boolean: \" + b + \", expected 0 or 1\", input);\n      }\n    } else {\n      // pre-7.0 index that has not been modified since the 7.0 upgrade\n      indexCreatedVersion = null;\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4","date":1499084229,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_7_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = 6;\n    if (format >= VERSION_70) {\n      indexCreatedVersion = input.readVInt();\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = 6;\n    if (format >= VERSION_70) {\n      indexCreatedVersion = input.readVInt();\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc018b79379c67835b40b1259cd3dc931df60944","date":1499109112,"type":3,"author":"Anshum Gupta","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_7_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = 6;\n    if (format >= VERSION_70) {\n      indexCreatedVersion = input.readVInt();\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = 6;\n    if (format >= VERSION_70) {\n      indexCreatedVersion = input.readVInt();\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_7_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = 6;\n    if (format >= VERSION_70) {\n      indexCreatedVersion = input.readVInt();\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_6_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = 6;\n    if (format >= VERSION_70) {\n      indexCreatedVersion = input.readVInt();\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"433e23dec73b7ea0552ae1ff3d85d80d7d07f7ba","date":1499240590,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_7_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = 6;\n    if (format >= VERSION_70) {\n      indexCreatedVersion = input.readVInt();\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      if (format < VERSION_70) {\n        byte hasID = input.readByte();\n        if (hasID == 0) {\n          throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n        } else if (hasID != 1) {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n      }\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_7_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = 6;\n    if (format >= VERSION_70) {\n      indexCreatedVersion = input.readVInt();\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8868235e83be924ba37d8335b9a6c965b2bc6ce","date":1499350960,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_7_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = input.readVInt();\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_7_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = 6;\n    if (format >= VERSION_70) {\n      indexCreatedVersion = input.readVInt();\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      if (format < VERSION_70) {\n        byte hasID = input.readByte();\n        if (hasID == 0) {\n          throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n        } else if (hasID != 1) {\n          throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n        }\n      }\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0fee37a4b8516d5b7e54543babf408847510735","date":1499351961,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_7_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = input.readVInt();\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e73d8d559120669b47658108d818b637df5456ea","date":1499401413,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    if (luceneVersion.onOrAfter(Version.LUCENE_7_0_0) == false) {\n      // TODO: should we check indexCreatedVersion instead?\n      throw new IndexFormatTooOldException(input, \"this index is too old (version: \" + luceneVersion + \")\");\n    }\n\n    int indexCreatedVersion = 6;\n    if (format >= VERSION_70) {\n      indexCreatedVersion = input.readVInt();\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      final byte segmentID[];\n      byte hasID = input.readByte();\n      if (hasID == 1) {\n        segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n      } else if (hasID == 0) {\n        throw new IndexFormatTooOldException(input, \"Segment is from Lucene 4.x\");\n      } else {\n        throw new CorruptIndexException(\"invalid hasID byte, got: \" + hasID, input);\n      }\n      Codec codec = readCodec(input, format < VERSION_53);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0617d2d25b13b9a49450ea49ceb06123ebd6542a","date":1508865221,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    if (format > VERSION_70) {\n      infos.counter = input.readVLong();\n    } else {\n      infos.counter = input.readInt();\n    }\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    infos.counter = input.readInt();\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f2203cb8ae87188877cfbf6ad170c5738a0aad5","date":1528117512,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    if (format > VERSION_70) {\n      infos.counter = input.readVLong();\n    } else {\n      infos.counter = input.readInt();\n    }\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      int softDelCount = format > VERSION_72 ? input.readInt() : 0;\n      if (softDelCount < 0 || softDelCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      if (softDelCount + delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, softDelCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    if (format > VERSION_70) {\n      infos.counter = input.readVLong();\n    } else {\n      infos.counter = input.readInt();\n    }\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    if (format > VERSION_70) {\n      infos.counter = input.readVLong();\n    } else {\n      infos.counter = input.readInt();\n    }\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      int softDelCount = format > VERSION_72 ? input.readInt() : 0;\n      if (softDelCount < 0 || softDelCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      if (softDelCount + delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, softDelCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    if (format > VERSION_70) {\n      infos.counter = input.readVLong();\n    } else {\n      infos.counter = input.readInt();\n    }\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    if (format > VERSION_70) {\n      infos.counter = input.readVLong();\n    } else {\n      infos.counter = input.readInt();\n    }\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      int softDelCount = format > VERSION_72 ? input.readInt() : 0;\n      if (softDelCount < 0 || softDelCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      if (softDelCount + delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, softDelCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    if (format > VERSION_70) {\n      infos.counter = input.readVLong();\n    } else {\n      infos.counter = input.readInt();\n    }\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14654be3f7a82c9a3c52169e365baa55bfe64f66","date":1587212697,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    if (format > VERSION_70) {\n      infos.counter = input.readVLong();\n    } else {\n      infos.counter = input.readInt();\n    }\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      int softDelCount = format > VERSION_72 ? input.readInt() : 0;\n      if (softDelCount < 0 || softDelCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      if (softDelCount + delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      final byte[] sciId;\n      if (format > VERSION_74) {\n        byte marker = input.readByte();\n        switch (marker) {\n          case 1:\n            sciId = new byte[StringHelper.ID_LENGTH];\n            input.readBytes(sciId, 0, sciId.length);\n            break;\n          case 0:\n            sciId = null;\n            break;\n          default:\n            throw new CorruptIndexException(\"invalid SegmentCommitInfo ID marker: \" + marker, input);\n        }\n      } else {\n        sciId = null;\n      }\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, softDelCount, delGen, fieldInfosGen, dvGen, sciId);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    if (format > VERSION_70) {\n      infos.counter = input.readVLong();\n    } else {\n      infos.counter = input.readInt();\n    }\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      int softDelCount = format > VERSION_72 ? input.readInt() : 0;\n      if (softDelCount < 0 || softDelCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      if (softDelCount + delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, softDelCount, delGen, fieldInfosGen, dvGen);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a490d7ce18bee8274e513491417782768950258a","date":1590757176,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n    Throwable priorE = null;\n    try {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n      Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      int indexCreatedVersion = input.readVInt();\n      if (luceneVersion.major < indexCreatedVersion) {\n        throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n            + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n      }\n\n      if (indexCreatedVersion < Version.LATEST.major - 1) {\n        throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n            + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n            + \" and Lucene only supports reading the current and previous major versions.\");\n      }\n\n      SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.luceneVersion = luceneVersion;\n\n      infos.version = input.readLong();\n      //System.out.println(\"READ sis version=\" + infos.version);\n      if (format > VERSION_70) {\n        infos.counter = input.readVLong();\n      } else {\n        infos.counter = input.readInt();\n      }\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n\n      if (numSegments > 0) {\n        infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      } else {\n        // else leave as null: no segments\n      }\n\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n        Codec codec = readCodec(input);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        int softDelCount = format > VERSION_72 ? input.readInt() : 0;\n        if (softDelCount < 0 || softDelCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        if (softDelCount + delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        final byte[] sciId;\n        if (format > VERSION_74) {\n          byte marker = input.readByte();\n          switch (marker) {\n            case 1:\n              sciId = new byte[StringHelper.ID_LENGTH];\n              input.readBytes(sciId, 0, sciId.length);\n              break;\n            case 0:\n              sciId = null;\n              break;\n            default:\n              throw new CorruptIndexException(\"invalid SegmentCommitInfo ID marker: \" + marker, input);\n          }\n        } else {\n          sciId = null;\n        }\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, softDelCount, delGen, fieldInfosGen, dvGen, sciId);\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n\n        Version segmentVersion = info.getVersion();\n\n        if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n        }\n\n        if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n          throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n        }\n\n        if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n          throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n        }\n      }\n\n      infos.userData = input.readMapOfStrings();\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n\n      return infos;\n    } catch (Throwable t) {\n      priorE = t;\n    } finally {\n      CodecUtil.checkFooter(input, priorE);\n    }\n    throw new Error(\"Unreachable code\");\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    if (format > VERSION_70) {\n      infos.counter = input.readVLong();\n    } else {\n      infos.counter = input.readInt();\n    }\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      int softDelCount = format > VERSION_72 ? input.readInt() : 0;\n      if (softDelCount < 0 || softDelCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      if (softDelCount + delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      final byte[] sciId;\n      if (format > VERSION_74) {\n        byte marker = input.readByte();\n        switch (marker) {\n          case 1:\n            sciId = new byte[StringHelper.ID_LENGTH];\n            input.readBytes(sciId, 0, sciId.length);\n            break;\n          case 0:\n            sciId = null;\n            break;\n          default:\n            throw new CorruptIndexException(\"invalid SegmentCommitInfo ID marker: \" + marker, input);\n        }\n      } else {\n        sciId = null;\n      }\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, softDelCount, delGen, fieldInfosGen, dvGen, sciId);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f8652918b4c62d30cbc4af2d62c2b944cb7fd17","date":1590759951,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    if (format > VERSION_70) {\n      infos.counter = input.readVLong();\n    } else {\n      infos.counter = input.readInt();\n    }\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      int softDelCount = format > VERSION_72 ? input.readInt() : 0;\n      if (softDelCount < 0 || softDelCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      if (softDelCount + delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      final byte[] sciId;\n      if (format > VERSION_74) {\n        byte marker = input.readByte();\n        switch (marker) {\n          case 1:\n            sciId = new byte[StringHelper.ID_LENGTH];\n            input.readBytes(sciId, 0, sciId.length);\n            break;\n          case 0:\n            sciId = null;\n            break;\n          default:\n            throw new CorruptIndexException(\"invalid SegmentCommitInfo ID marker: \" + marker, input);\n        }\n      } else {\n        sciId = null;\n      }\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, softDelCount, delGen, fieldInfosGen, dvGen, sciId);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n    Throwable priorE = null;\n    try {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n      Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      int indexCreatedVersion = input.readVInt();\n      if (luceneVersion.major < indexCreatedVersion) {\n        throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n            + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n      }\n\n      if (indexCreatedVersion < Version.LATEST.major - 1) {\n        throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n            + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n            + \" and Lucene only supports reading the current and previous major versions.\");\n      }\n\n      SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.luceneVersion = luceneVersion;\n\n      infos.version = input.readLong();\n      //System.out.println(\"READ sis version=\" + infos.version);\n      if (format > VERSION_70) {\n        infos.counter = input.readVLong();\n      } else {\n        infos.counter = input.readInt();\n      }\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n\n      if (numSegments > 0) {\n        infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      } else {\n        // else leave as null: no segments\n      }\n\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n        Codec codec = readCodec(input);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        int softDelCount = format > VERSION_72 ? input.readInt() : 0;\n        if (softDelCount < 0 || softDelCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        if (softDelCount + delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        final byte[] sciId;\n        if (format > VERSION_74) {\n          byte marker = input.readByte();\n          switch (marker) {\n            case 1:\n              sciId = new byte[StringHelper.ID_LENGTH];\n              input.readBytes(sciId, 0, sciId.length);\n              break;\n            case 0:\n              sciId = null;\n              break;\n            default:\n              throw new CorruptIndexException(\"invalid SegmentCommitInfo ID marker: \" + marker, input);\n          }\n        } else {\n          sciId = null;\n        }\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, softDelCount, delGen, fieldInfosGen, dvGen, sciId);\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n\n        Version segmentVersion = info.getVersion();\n\n        if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n        }\n\n        if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n          throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n        }\n\n        if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n          throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n        }\n      }\n\n      infos.userData = input.readMapOfStrings();\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n\n      return infos;\n    } catch (Throwable t) {\n      priorE = t;\n    } finally {\n      CodecUtil.checkFooter(input, priorE);\n    }\n    throw new Error(\"Unreachable code\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"814d2f5bda7af5560ba72150a2df22f38276b794","date":1590761146,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n    Throwable priorE = null;\n    int format = -1;\n    try {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n      Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      int indexCreatedVersion = input.readVInt();\n      if (luceneVersion.major < indexCreatedVersion) {\n        throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n            + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n      }\n\n      if (indexCreatedVersion < Version.LATEST.major - 1) {\n        throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n            + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n            + \" and Lucene only supports reading the current and previous major versions.\");\n      }\n\n      SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.luceneVersion = luceneVersion;\n\n      infos.version = input.readLong();\n      //System.out.println(\"READ sis version=\" + infos.version);\n      if (format > VERSION_70) {\n        infos.counter = input.readVLong();\n      } else {\n        infos.counter = input.readInt();\n      }\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n\n      if (numSegments > 0) {\n        infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      } else {\n        // else leave as null: no segments\n      }\n\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n        Codec codec = readCodec(input);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        int softDelCount = format > VERSION_72 ? input.readInt() : 0;\n        if (softDelCount < 0 || softDelCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        if (softDelCount + delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        final byte[] sciId;\n        if (format > VERSION_74) {\n          byte marker = input.readByte();\n          switch (marker) {\n            case 1:\n              sciId = new byte[StringHelper.ID_LENGTH];\n              input.readBytes(sciId, 0, sciId.length);\n              break;\n            case 0:\n              sciId = null;\n              break;\n            default:\n              throw new CorruptIndexException(\"invalid SegmentCommitInfo ID marker: \" + marker, input);\n          }\n        } else {\n          sciId = null;\n        }\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, softDelCount, delGen, fieldInfosGen, dvGen, sciId);\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n\n        Version segmentVersion = info.getVersion();\n\n        if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n        }\n\n        if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n          throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n        }\n\n        if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n          throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n        }\n      }\n\n      infos.userData = input.readMapOfStrings();\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n\n      return infos;\n    } catch (Throwable t) {\n      priorE = t;\n    } finally {\n      if (format >= VERSION_70) { // oldest supported version\n        CodecUtil.checkFooter(input, priorE);\n      } else {\n        throw IOUtils.rethrowAlways(priorE);\n      }\n    }\n    throw new Error(\"Unreachable code\");\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n\n    // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n    // to read the magic ourselves.\n    int magic = input.readInt();\n    if (magic != CodecUtil.CODEC_MAGIC) {\n      throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n    }\n    int format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n    byte id[] = new byte[StringHelper.ID_LENGTH];\n    input.readBytes(id, 0, id.length);\n    CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n    Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    int indexCreatedVersion = input.readVInt();\n    if (luceneVersion.major < indexCreatedVersion) {\n      throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n          + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n    }\n\n    if (indexCreatedVersion < Version.LATEST.major - 1) {\n      throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n          + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n          + \" and Lucene only supports reading the current and previous major versions.\");\n    }\n\n    SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n    infos.id = id;\n    infos.generation = generation;\n    infos.lastGeneration = generation;\n    infos.luceneVersion = luceneVersion;\n\n    infos.version = input.readLong();\n    //System.out.println(\"READ sis version=\" + infos.version);\n    if (format > VERSION_70) {\n      infos.counter = input.readVLong();\n    } else {\n      infos.counter = input.readInt();\n    }\n    int numSegments = input.readInt();\n    if (numSegments < 0) {\n      throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n    }\n\n    if (numSegments > 0) {\n      infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n    } else {\n      // else leave as null: no segments\n    }\n\n    long totalDocs = 0;\n    for (int seg = 0; seg < numSegments; seg++) {\n      String segName = input.readString();\n      byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(segmentID, 0, segmentID.length);\n      Codec codec = readCodec(input);\n      SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n      info.setCodec(codec);\n      totalDocs += info.maxDoc();\n      long delGen = input.readLong();\n      int delCount = input.readInt();\n      if (delCount < 0 || delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      long fieldInfosGen = input.readLong();\n      long dvGen = input.readLong();\n      int softDelCount = format > VERSION_72 ? input.readInt() : 0;\n      if (softDelCount < 0 || softDelCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      if (softDelCount + delCount > info.maxDoc()) {\n        throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n      }\n      final byte[] sciId;\n      if (format > VERSION_74) {\n        byte marker = input.readByte();\n        switch (marker) {\n          case 1:\n            sciId = new byte[StringHelper.ID_LENGTH];\n            input.readBytes(sciId, 0, sciId.length);\n            break;\n          case 0:\n            sciId = null;\n            break;\n          default:\n            throw new CorruptIndexException(\"invalid SegmentCommitInfo ID marker: \" + marker, input);\n        }\n      } else {\n        sciId = null;\n      }\n      SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, softDelCount, delGen, fieldInfosGen, dvGen, sciId);\n      siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n      final Map<Integer,Set<String>> dvUpdateFiles;\n      final int numDVFields = input.readInt();\n      if (numDVFields == 0) {\n        dvUpdateFiles = Collections.emptyMap();\n      } else {\n        Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n        for (int i = 0; i < numDVFields; i++) {\n          map.put(input.readInt(), input.readSetOfStrings());\n        }\n        dvUpdateFiles = Collections.unmodifiableMap(map);\n      }\n      siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n      infos.add(siPerCommit);\n\n      Version segmentVersion = info.getVersion();\n\n      if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n        throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n        throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n      }\n\n      if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n        throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n      }\n    }\n\n    infos.userData = input.readMapOfStrings();\n\n    CodecUtil.checkFooter(input);\n\n    // LUCENE-6299: check we are in bounds\n    if (totalDocs > IndexWriter.getActualMaxDocs()) {\n      throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n    }\n\n    return infos;\n  }\n\n","bugFix":null,"bugIntro":["875d34b08bd41c8371900b24aa3ee9917153c4ac"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"875d34b08bd41c8371900b24aa3ee9917153c4ac","date":1599405051,"type":3,"author":"LWY","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#readCommit(Directory,ChecksumIndexInput,long).mjava","sourceNew":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n    Throwable priorE = null;\n    int format = -1;\n    try {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n      Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      int indexCreatedVersion = input.readVInt();\n      if (luceneVersion.major < indexCreatedVersion) {\n        throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n            + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n      }\n\n      if (indexCreatedVersion < Version.LATEST.major - 1) {\n        throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n            + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n            + \" and Lucene only supports reading the current and previous major versions.\");\n      }\n\n      SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.luceneVersion = luceneVersion;\n\n      infos.version = input.readLong();\n      //System.out.println(\"READ sis version=\" + infos.version);\n      if (format > VERSION_70) {\n        infos.counter = input.readVLong();\n      } else {\n        infos.counter = input.readInt();\n      }\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n\n      if (numSegments > 0) {\n        infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      } else {\n        // else leave as null: no segments\n      }\n\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n        Codec codec = readCodec(input);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        int softDelCount = format > VERSION_72 ? input.readInt() : 0;\n        if (softDelCount < 0 || softDelCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        if (softDelCount + delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + (softDelCount + delCount) + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        final byte[] sciId;\n        if (format > VERSION_74) {\n          byte marker = input.readByte();\n          switch (marker) {\n            case 1:\n              sciId = new byte[StringHelper.ID_LENGTH];\n              input.readBytes(sciId, 0, sciId.length);\n              break;\n            case 0:\n              sciId = null;\n              break;\n            default:\n              throw new CorruptIndexException(\"invalid SegmentCommitInfo ID marker: \" + marker, input);\n          }\n        } else {\n          sciId = null;\n        }\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, softDelCount, delGen, fieldInfosGen, dvGen, sciId);\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n\n        Version segmentVersion = info.getVersion();\n\n        if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n        }\n\n        if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n          throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n        }\n\n        if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n          throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n        }\n      }\n\n      infos.userData = input.readMapOfStrings();\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n\n      return infos;\n    } catch (Throwable t) {\n      priorE = t;\n    } finally {\n      if (format >= VERSION_70) { // oldest supported version\n        CodecUtil.checkFooter(input, priorE);\n      } else {\n        throw IOUtils.rethrowAlways(priorE);\n      }\n    }\n    throw new Error(\"Unreachable code\");\n  }\n\n","sourceOld":"  /** Read the commit from the provided {@link ChecksumIndexInput}. */\n  public static final SegmentInfos readCommit(Directory directory, ChecksumIndexInput input, long generation) throws IOException {\n    Throwable priorE = null;\n    int format = -1;\n    try {\n      // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need\n      // to read the magic ourselves.\n      int magic = input.readInt();\n      if (magic != CodecUtil.CODEC_MAGIC) {\n        throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n      }\n      format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_70, VERSION_CURRENT);\n      byte id[] = new byte[StringHelper.ID_LENGTH];\n      input.readBytes(id, 0, id.length);\n      CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));\n\n      Version luceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      int indexCreatedVersion = input.readVInt();\n      if (luceneVersion.major < indexCreatedVersion) {\n        throw new CorruptIndexException(\"Creation version [\" + indexCreatedVersion\n            + \".x] can't be greater than the version that wrote the segment infos: [\" + luceneVersion + \"]\" , input);\n      }\n\n      if (indexCreatedVersion < Version.LATEST.major - 1) {\n        throw new IndexFormatTooOldException(input, \"This index was initially created with Lucene \"\n            + indexCreatedVersion + \".x while the current version is \" + Version.LATEST\n            + \" and Lucene only supports reading the current and previous major versions.\");\n      }\n\n      SegmentInfos infos = new SegmentInfos(indexCreatedVersion);\n      infos.id = id;\n      infos.generation = generation;\n      infos.lastGeneration = generation;\n      infos.luceneVersion = luceneVersion;\n\n      infos.version = input.readLong();\n      //System.out.println(\"READ sis version=\" + infos.version);\n      if (format > VERSION_70) {\n        infos.counter = input.readVLong();\n      } else {\n        infos.counter = input.readInt();\n      }\n      int numSegments = input.readInt();\n      if (numSegments < 0) {\n        throw new CorruptIndexException(\"invalid segment count: \" + numSegments, input);\n      }\n\n      if (numSegments > 0) {\n        infos.minSegmentLuceneVersion = Version.fromBits(input.readVInt(), input.readVInt(), input.readVInt());\n      } else {\n        // else leave as null: no segments\n      }\n\n      long totalDocs = 0;\n      for (int seg = 0; seg < numSegments; seg++) {\n        String segName = input.readString();\n        byte[] segmentID = new byte[StringHelper.ID_LENGTH];\n        input.readBytes(segmentID, 0, segmentID.length);\n        Codec codec = readCodec(input);\n        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);\n        info.setCodec(codec);\n        totalDocs += info.maxDoc();\n        long delGen = input.readLong();\n        int delCount = input.readInt();\n        if (delCount < 0 || delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        long fieldInfosGen = input.readLong();\n        long dvGen = input.readLong();\n        int softDelCount = format > VERSION_72 ? input.readInt() : 0;\n        if (softDelCount < 0 || softDelCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        if (softDelCount + delCount > info.maxDoc()) {\n          throw new CorruptIndexException(\"invalid deletion count: \" + softDelCount + delCount + \" vs maxDoc=\" + info.maxDoc(), input);\n        }\n        final byte[] sciId;\n        if (format > VERSION_74) {\n          byte marker = input.readByte();\n          switch (marker) {\n            case 1:\n              sciId = new byte[StringHelper.ID_LENGTH];\n              input.readBytes(sciId, 0, sciId.length);\n              break;\n            case 0:\n              sciId = null;\n              break;\n            default:\n              throw new CorruptIndexException(\"invalid SegmentCommitInfo ID marker: \" + marker, input);\n          }\n        } else {\n          sciId = null;\n        }\n        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, softDelCount, delGen, fieldInfosGen, dvGen, sciId);\n        siPerCommit.setFieldInfosFiles(input.readSetOfStrings());\n        final Map<Integer,Set<String>> dvUpdateFiles;\n        final int numDVFields = input.readInt();\n        if (numDVFields == 0) {\n          dvUpdateFiles = Collections.emptyMap();\n        } else {\n          Map<Integer,Set<String>> map = new HashMap<>(numDVFields);\n          for (int i = 0; i < numDVFields; i++) {\n            map.put(input.readInt(), input.readSetOfStrings());\n          }\n          dvUpdateFiles = Collections.unmodifiableMap(map);\n        }\n        siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);\n        infos.add(siPerCommit);\n\n        Version segmentVersion = info.getVersion();\n\n        if (segmentVersion.onOrAfter(infos.minSegmentLuceneVersion) == false) {\n          throw new CorruptIndexException(\"segments file recorded minSegmentLuceneVersion=\" + infos.minSegmentLuceneVersion + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n        }\n\n        if (infos.indexCreatedVersionMajor >= 7 && segmentVersion.major < infos.indexCreatedVersionMajor) {\n          throw new CorruptIndexException(\"segments file recorded indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor + \" but segment=\" + info + \" has older version=\" + segmentVersion, input);\n        }\n\n        if (infos.indexCreatedVersionMajor >= 7 && info.getMinVersion() == null) {\n          throw new CorruptIndexException(\"segments infos must record minVersion with indexCreatedVersionMajor=\" + infos.indexCreatedVersionMajor, input);\n        }\n      }\n\n      infos.userData = input.readMapOfStrings();\n\n      // LUCENE-6299: check we are in bounds\n      if (totalDocs > IndexWriter.getActualMaxDocs()) {\n        throw new CorruptIndexException(\"Too many documents: an index cannot exceed \" + IndexWriter.getActualMaxDocs() + \" but readers have total maxDoc=\" + totalDocs, input);\n      }\n\n      return infos;\n    } catch (Throwable t) {\n      priorE = t;\n    } finally {\n      if (format >= VERSION_70) { // oldest supported version\n        CodecUtil.checkFooter(input, priorE);\n      } else {\n        throw IOUtils.rethrowAlways(priorE);\n      }\n    }\n    throw new Error(\"Unreachable code\");\n  }\n\n","bugFix":["814d2f5bda7af5560ba72150a2df22f38276b794"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9de8327534b7bb8072a8534f55d0b680fb2e9cb3":["68496c2200e559fb7802f7575427b7a482659afb"],"875d34b08bd41c8371900b24aa3ee9917153c4ac":["814d2f5bda7af5560ba72150a2df22f38276b794"],"814d2f5bda7af5560ba72150a2df22f38276b794":["7f8652918b4c62d30cbc4af2d62c2b944cb7fd17"],"d0fee37a4b8516d5b7e54543babf408847510735":["d8868235e83be924ba37d8335b9a6c965b2bc6ce"],"a490d7ce18bee8274e513491417782768950258a":["14654be3f7a82c9a3c52169e365baa55bfe64f66"],"0617d2d25b13b9a49450ea49ceb06123ebd6542a":["d0fee37a4b8516d5b7e54543babf408847510735"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["d97ba94eef1fc33c5451259a7aa2ac682646c1af"],"cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["0617d2d25b13b9a49450ea49ceb06123ebd6542a","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"cc018b79379c67835b40b1259cd3dc931df60944":["31741cf1390044e38a2ec3127cf302ba841bfd75","cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4"],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2b844e2ae5435a8d4d925003c10027c25e26e02d"],"d97ba94eef1fc33c5451259a7aa2ac682646c1af":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["d97ba94eef1fc33c5451259a7aa2ac682646c1af"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","c850d2a2bc88f4751bf05e1ee6799940462331eb"],"7f8652918b4c62d30cbc4af2d62c2b944cb7fd17":["a490d7ce18bee8274e513491417782768950258a"],"30c8e5574b55d57947e989443dfde611646530ee":["92212fd254551a0b1156aafc3a1a6ed1a43932ad","cc018b79379c67835b40b1259cd3dc931df60944"],"433e23dec73b7ea0552ae1ff3d85d80d7d07f7ba":["cc018b79379c67835b40b1259cd3dc931df60944"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"2b844e2ae5435a8d4d925003c10027c25e26e02d":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"14654be3f7a82c9a3c52169e365baa55bfe64f66":["8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"d8868235e83be924ba37d8335b9a6c965b2bc6ce":["433e23dec73b7ea0552ae1ff3d85d80d7d07f7ba"],"c850d2a2bc88f4751bf05e1ee6799940462331eb":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"e73d8d559120669b47658108d818b637df5456ea":["30c8e5574b55d57947e989443dfde611646530ee","d0fee37a4b8516d5b7e54543babf408847510735"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["68496c2200e559fb7802f7575427b7a482659afb","9de8327534b7bb8072a8534f55d0b680fb2e9cb3"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["0617d2d25b13b9a49450ea49ceb06123ebd6542a"],"f592209545c71895260367152601e9200399776d":["0617d2d25b13b9a49450ea49ceb06123ebd6542a","8f2203cb8ae87188877cfbf6ad170c5738a0aad5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["875d34b08bd41c8371900b24aa3ee9917153c4ac"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"9de8327534b7bb8072a8534f55d0b680fb2e9cb3":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"875d34b08bd41c8371900b24aa3ee9917153c4ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"814d2f5bda7af5560ba72150a2df22f38276b794":["875d34b08bd41c8371900b24aa3ee9917153c4ac"],"d0fee37a4b8516d5b7e54543babf408847510735":["0617d2d25b13b9a49450ea49ceb06123ebd6542a","e73d8d559120669b47658108d818b637df5456ea"],"a490d7ce18bee8274e513491417782768950258a":["7f8652918b4c62d30cbc4af2d62c2b944cb7fd17"],"0617d2d25b13b9a49450ea49ceb06123ebd6542a":["b70042a8a492f7054d480ccdd2be9796510d4327","8f2203cb8ae87188877cfbf6ad170c5738a0aad5","f592209545c71895260367152601e9200399776d"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4","cc018b79379c67835b40b1259cd3dc931df60944"],"cd7538cbbd9c304bc5396980e9802cd3a5bcf8e4":["cc018b79379c67835b40b1259cd3dc931df60944"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"cc018b79379c67835b40b1259cd3dc931df60944":["30c8e5574b55d57947e989443dfde611646530ee","433e23dec73b7ea0552ae1ff3d85d80d7d07f7ba"],"68496c2200e559fb7802f7575427b7a482659afb":["9de8327534b7bb8072a8534f55d0b680fb2e9cb3","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"d97ba94eef1fc33c5451259a7aa2ac682646c1af":["31741cf1390044e38a2ec3127cf302ba841bfd75","92212fd254551a0b1156aafc3a1a6ed1a43932ad"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["30c8e5574b55d57947e989443dfde611646530ee"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["d97ba94eef1fc33c5451259a7aa2ac682646c1af","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"7f8652918b4c62d30cbc4af2d62c2b944cb7fd17":["814d2f5bda7af5560ba72150a2df22f38276b794"],"30c8e5574b55d57947e989443dfde611646530ee":["e73d8d559120669b47658108d818b637df5456ea"],"433e23dec73b7ea0552ae1ff3d85d80d7d07f7ba":["d8868235e83be924ba37d8335b9a6c965b2bc6ce"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"2b844e2ae5435a8d4d925003c10027c25e26e02d":["68496c2200e559fb7802f7575427b7a482659afb"],"d8868235e83be924ba37d8335b9a6c965b2bc6ce":["d0fee37a4b8516d5b7e54543babf408847510735"],"14654be3f7a82c9a3c52169e365baa55bfe64f66":["a490d7ce18bee8274e513491417782768950258a"],"c850d2a2bc88f4751bf05e1ee6799940462331eb":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"e73d8d559120669b47658108d818b637df5456ea":[],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c850d2a2bc88f4751bf05e1ee6799940462331eb"],"8f2203cb8ae87188877cfbf6ad170c5738a0aad5":["b70042a8a492f7054d480ccdd2be9796510d4327","14654be3f7a82c9a3c52169e365baa55bfe64f66","f592209545c71895260367152601e9200399776d"],"f592209545c71895260367152601e9200399776d":[],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["2b844e2ae5435a8d4d925003c10027c25e26e02d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e73d8d559120669b47658108d818b637df5456ea","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}