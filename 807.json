{"path":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","commits":[{"id":"57131fa4ce09b8042f56ebbbd65dfe28c51d2ad7","date":1445955220,"type":0,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster(true);\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, true);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.updateClusterState();\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.updateClusterState();\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54","date":1446047031,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, true);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.updateClusterState();\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.updateClusterState();\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster(true);\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, true);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.updateClusterState();\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.updateClusterState();\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"26fc9c59806c587f9b96f0ea15fa9a0aa8001568","date":1452027155,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.updateClusterState();\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.updateClusterState();\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, true);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.updateClusterState();\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.updateClusterState();\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f1a5871b8ff5e2e0c0bf62340337c7f3801cffe","date":1452379366,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.updateClusterState();\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.updateClusterState();\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.updateClusterState();\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.updateClusterState();\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.forceUpdateCollection(collectionName);\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.forceUpdateCollection(collectionName);\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.updateClusterState();\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.updateClusterState();\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e89a32cc825033ebae8bb9e1c6877c2d9d76749e","date":1476790453,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.forceUpdateCollection(collectionName);\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.forceUpdateCollection(collectionName);\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.forceUpdateCollection(collectionName);\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.forceUpdateCollection(collectionName);\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.forceUpdateCollection(collectionName);\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.forceUpdateCollection(collectionName);\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.forceUpdateCollection(collectionName);\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.forceUpdateCollection(collectionName);\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5719bfb2650ba43855e20564d39873bbbdc7f02c","date":1500676092,"type":4,"author":"Steve Rowe","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.forceUpdateCollection(collectionName);\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.forceUpdateCollection(collectionName);\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":4,"author":"Cao Manh Dat","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.forceUpdateCollection(collectionName);\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.forceUpdateCollection(collectionName);\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a52341299179de5479672f7cf518bf4b173f34b3","date":1501079746,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.forceUpdateCollection(collectionName);\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getSlices(collectionName)) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.forceUpdateCollection(collectionName);\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.forceUpdateCollection(collectionName);\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getCollection(collectionName).getSlices()) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.forceUpdateCollection(collectionName);\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c717efc76ccf2ea435c52fa36a4774056fe8b4d4","date":1501575440,"type":4,"author":"Cao Manh Dat","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testStopAllStartAll().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testStopAllStartAll() throws Exception {\n\n    final String collectionName = \"testStopAllStartAllCollection\";\n\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n\n    try {\n      assertNotNull(miniCluster.getZkServer());\n      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n      assertEquals(NUM_SERVERS, jettys.size());\n      for (JettySolrRunner jetty : jettys) {\n        assertTrue(jetty.isRunning());\n      }\n\n      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);\n      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n      cloudSolrClient.setDefaultCollection(collectionName);\n      final SolrQuery query = new SolrQuery(\"*:*\");\n      final SolrInputDocument doc = new SolrInputDocument();\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, AbstractZkTestCase.TIMEOUT, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        zkStateReader.createClusterStateWatchersAndUpdate();\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // modify collection\n        final int numDocs = 1 + random().nextInt(10);\n        for (int ii = 1; ii <= numDocs; ++ii) {\n          doc.setField(\"id\", \"\"+ii);\n          cloudSolrClient.add(doc);\n          if (ii*2 == numDocs) cloudSolrClient.commit();\n        }\n        cloudSolrClient.commit();\n        // query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n        // the test itself\n        zkStateReader.forceUpdateCollection(collectionName);\n        final ClusterState clusterState = zkStateReader.getClusterState();\n\n        final HashSet<Integer> leaderIndices = new HashSet<Integer>();\n        final HashSet<Integer> followerIndices = new HashSet<Integer>();\n        {\n          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();\n          for (final Slice slice : clusterState.getCollection(collectionName).getSlices()) {\n            for (final Replica replica : slice.getReplicas()) {\n              shardLeaderMap.put(replica.getNodeName().replace(\"_solr\", \"/solr\"), Boolean.FALSE);\n            }\n            shardLeaderMap.put(slice.getLeader().getNodeName().replace(\"_solr\", \"/solr\"), Boolean.TRUE);\n          }\n          for (int ii = 0; ii < jettys.size(); ++ii) {\n            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();\n            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + \"://\").length());\n            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);\n            if (Boolean.TRUE.equals(isLeader)) {\n              leaderIndices.add(new Integer(ii));\n            } else if (Boolean.FALSE.equals(isLeader)) {\n              followerIndices.add(new Integer(ii));\n            } // else neither leader nor follower i.e. node without a replica (for our collection)\n          }\n        }\n        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);\n        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);\n\n        // first stop the followers (in no particular order)\n        Collections.shuffle(followerIndicesList, random());\n        for (Integer ii : followerIndicesList) {\n          if (!leaderIndices.contains(ii)) {\n            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n          }\n        }\n\n        // then stop the leaders (again in no particular order)\n        Collections.shuffle(leaderIndicesList, random());\n        for (Integer ii : leaderIndicesList) {\n          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));\n        }\n\n        // calculate restart order\n        final List<Integer> restartIndicesList = new ArrayList<Integer>();\n        Collections.shuffle(leaderIndicesList, random());\n        restartIndicesList.addAll(leaderIndicesList);\n        Collections.shuffle(followerIndicesList, random());\n        restartIndicesList.addAll(followerIndicesList);\n        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());\n\n        // and then restart jettys in that order\n        for (Integer ii : restartIndicesList) {\n          final JettySolrRunner jetty = jettys.get(ii.intValue());\n          if (!jetty.isRunning()) {\n            miniCluster.startJettySolrRunner(jetty);\n            assertTrue(jetty.isRunning());\n          }\n        }\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        zkStateReader.forceUpdateCollection(collectionName);\n\n        // re-query collection\n        {\n          final QueryResponse rsp = cloudSolrClient.query(query);\n          assertEquals(numDocs, rsp.getResults().getNumFound());\n        }\n\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"c717efc76ccf2ea435c52fa36a4774056fe8b4d4":["344b0840364d990b29b97467bfcc766ff8325d11"],"344b0840364d990b29b97467bfcc766ff8325d11":["a52341299179de5479672f7cf518bf4b173f34b3"],"9f1a5871b8ff5e2e0c0bf62340337c7f3801cffe":["26fc9c59806c587f9b96f0ea15fa9a0aa8001568"],"936cdd5882761db3b844afd6f84ab81cbb011a75":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e","5719bfb2650ba43855e20564d39873bbbdc7f02c"],"5719bfb2650ba43855e20564d39873bbbdc7f02c":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54":["57131fa4ce09b8042f56ebbbd65dfe28c51d2ad7"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["9f1a5871b8ff5e2e0c0bf62340337c7f3801cffe"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"26fc9c59806c587f9b96f0ea15fa9a0aa8001568":["f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54"],"a52341299179de5479672f7cf518bf4b173f34b3":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e","5719bfb2650ba43855e20564d39873bbbdc7f02c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"57131fa4ce09b8042f56ebbbd65dfe28c51d2ad7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c717efc76ccf2ea435c52fa36a4774056fe8b4d4"]},"commit2Childs":{"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["936cdd5882761db3b844afd6f84ab81cbb011a75","5719bfb2650ba43855e20564d39873bbbdc7f02c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a52341299179de5479672f7cf518bf4b173f34b3"],"c717efc76ccf2ea435c52fa36a4774056fe8b4d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"344b0840364d990b29b97467bfcc766ff8325d11":["c717efc76ccf2ea435c52fa36a4774056fe8b4d4"],"9f1a5871b8ff5e2e0c0bf62340337c7f3801cffe":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"936cdd5882761db3b844afd6f84ab81cbb011a75":[],"5719bfb2650ba43855e20564d39873bbbdc7f02c":["936cdd5882761db3b844afd6f84ab81cbb011a75","a52341299179de5479672f7cf518bf4b173f34b3"],"f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54":["26fc9c59806c587f9b96f0ea15fa9a0aa8001568"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"26fc9c59806c587f9b96f0ea15fa9a0aa8001568":["9f1a5871b8ff5e2e0c0bf62340337c7f3801cffe"],"a52341299179de5479672f7cf518bf4b173f34b3":["344b0840364d990b29b97467bfcc766ff8325d11"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["57131fa4ce09b8042f56ebbbd65dfe28c51d2ad7"],"57131fa4ce09b8042f56ebbbd65dfe28c51d2ad7":["f0c130ec24cbb2eef3d8e7f0e971736f0bea8f54"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["936cdd5882761db3b844afd6f84ab81cbb011a75","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}