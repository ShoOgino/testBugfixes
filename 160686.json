{"path":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#getBoostDocs(SolrIndexSearcher,Set[BytesRef],Map).mjava","commits":[{"id":"2ad458affd82a1d762eb506003907d9363a333cb","date":1528558344,"type":0,"author":"broustant","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#getBoostDocs(SolrIndexSearcher,Set[BytesRef],Map).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Resolves a set of boosted docs by uniqueKey to a map of docIds mapped to a priority value &gt; 0.\n   * @param indexSearcher the SolrIndexSearcher; required\n   * @param boosted are the set of uniqueKey values to be boosted in priority order.  If null; returns null.\n   * @param context the {@link SolrQueryRequest#getContext()} or null if none.  We'll cache our results here.\n   */\n  //TODO consider simplifying to remove \"boosted\" arg which can be looked up in context via BOOSTED key?\n  public static IntIntHashMap getBoostDocs(SolrIndexSearcher indexSearcher, Set<BytesRef> boosted, Map context) throws IOException {\n\n    IntIntHashMap boostDocs = null;\n\n    if (boosted != null) {\n\n      //First see if it's already in the request context. Could have been put there by another caller.\n      if (context != null) {\n        boostDocs = (IntIntHashMap) context.get(BOOSTED_DOCIDS);\n        if (boostDocs != null) {\n          return boostDocs;\n        }\n      }\n\n      //Not in the context yet so load it.\n      boostDocs = new IntIntHashMap(boosted.size()); // docId to boost\n      int priority = boosted.size() + 1; // the corresponding priority for each boosted key (starts at this; decrements down)\n      for (BytesRef uniqueKey : boosted) {\n        priority--; // therefore first == bosted.size(); last will be 1\n        long segAndId = indexSearcher.lookupId(uniqueKey); // higher 32 bits == segment ID, low 32 bits == doc ID\n        if (segAndId == -1) { // not found\n          continue;\n        }\n        int seg = (int) (segAndId >> 32);\n        int localDocId = (int) segAndId;\n        final IndexReaderContext indexReaderContext = indexSearcher.getTopReaderContext().children().get(seg);\n        int docId = indexReaderContext.docBaseInParent + localDocId;\n        boostDocs.put(docId, priority);\n      }\n      assert priority == 1; // the last priority (lowest)\n    }\n\n    if (context != null) {\n      //noinspection unchecked\n      context.put(BOOSTED_DOCIDS, boostDocs);\n    }\n\n    return boostDocs;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#getBoostDocs(SolrIndexSearcher,Set[BytesRef],Map).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Resolves a set of boosted docs by uniqueKey to a map of docIds mapped to a priority value &gt; 0.\n   * @param indexSearcher the SolrIndexSearcher; required\n   * @param boosted are the set of uniqueKey values to be boosted in priority order.  If null; returns null.\n   * @param context the {@link SolrQueryRequest#getContext()} or null if none.  We'll cache our results here.\n   */\n  //TODO consider simplifying to remove \"boosted\" arg which can be looked up in context via BOOSTED key?\n  public static IntIntHashMap getBoostDocs(SolrIndexSearcher indexSearcher, Set<BytesRef> boosted, Map context) throws IOException {\n\n    IntIntHashMap boostDocs = null;\n\n    if (boosted != null) {\n\n      //First see if it's already in the request context. Could have been put there by another caller.\n      if (context != null) {\n        boostDocs = (IntIntHashMap) context.get(BOOSTED_DOCIDS);\n        if (boostDocs != null) {\n          return boostDocs;\n        }\n      }\n\n      //Not in the context yet so load it.\n      boostDocs = new IntIntHashMap(boosted.size()); // docId to boost\n      int priority = boosted.size() + 1; // the corresponding priority for each boosted key (starts at this; decrements down)\n      for (BytesRef uniqueKey : boosted) {\n        priority--; // therefore first == bosted.size(); last will be 1\n        long segAndId = indexSearcher.lookupId(uniqueKey); // higher 32 bits == segment ID, low 32 bits == doc ID\n        if (segAndId == -1) { // not found\n          continue;\n        }\n        int seg = (int) (segAndId >> 32);\n        int localDocId = (int) segAndId;\n        final IndexReaderContext indexReaderContext = indexSearcher.getTopReaderContext().children().get(seg);\n        int docId = indexReaderContext.docBaseInParent + localDocId;\n        boostDocs.put(docId, priority);\n      }\n      assert priority == 1; // the last priority (lowest)\n    }\n\n    if (context != null) {\n      //noinspection unchecked\n      context.put(BOOSTED_DOCIDS, boostDocs);\n    }\n\n    return boostDocs;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#getBoostDocs(SolrIndexSearcher,Set[BytesRef],Map).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Resolves a set of boosted docs by uniqueKey to a map of docIds mapped to a priority value &gt; 0.\n   * @param indexSearcher the SolrIndexSearcher; required\n   * @param boosted are the set of uniqueKey values to be boosted in priority order.  If null; returns null.\n   * @param context the {@link SolrQueryRequest#getContext()} or null if none.  We'll cache our results here.\n   */\n  //TODO consider simplifying to remove \"boosted\" arg which can be looked up in context via BOOSTED key?\n  public static IntIntHashMap getBoostDocs(SolrIndexSearcher indexSearcher, Set<BytesRef> boosted, Map context) throws IOException {\n\n    IntIntHashMap boostDocs = null;\n\n    if (boosted != null) {\n\n      //First see if it's already in the request context. Could have been put there by another caller.\n      if (context != null) {\n        boostDocs = (IntIntHashMap) context.get(BOOSTED_DOCIDS);\n        if (boostDocs != null) {\n          return boostDocs;\n        }\n      }\n\n      //Not in the context yet so load it.\n      boostDocs = new IntIntHashMap(boosted.size()); // docId to boost\n      int priority = boosted.size() + 1; // the corresponding priority for each boosted key (starts at this; decrements down)\n      for (BytesRef uniqueKey : boosted) {\n        priority--; // therefore first == bosted.size(); last will be 1\n        long segAndId = indexSearcher.lookupId(uniqueKey); // higher 32 bits == segment ID, low 32 bits == doc ID\n        if (segAndId == -1) { // not found\n          continue;\n        }\n        int seg = (int) (segAndId >> 32);\n        int localDocId = (int) segAndId;\n        final IndexReaderContext indexReaderContext = indexSearcher.getTopReaderContext().children().get(seg);\n        int docId = indexReaderContext.docBaseInParent + localDocId;\n        boostDocs.put(docId, priority);\n      }\n      assert priority == 1; // the last priority (lowest)\n    }\n\n    if (context != null) {\n      //noinspection unchecked\n      context.put(BOOSTED_DOCIDS, boostDocs);\n    }\n\n    return boostDocs;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#getBoostDocs(SolrIndexSearcher,Set[BytesRef],Map).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#getBoostDocs(SolrIndexSearcher,Set[BytesRef],Map).mjava","sourceNew":"  /**\n   * Resolves a set of boosted docs by uniqueKey to a map of docIds mapped to a priority value &gt; 0.\n   * @param indexSearcher the SolrIndexSearcher; required\n   * @param boosted are the set of uniqueKey values to be boosted in priority order.  If null; returns null.\n   * @param context the {@link SolrQueryRequest#getContext()} or null if none.  We'll cache our results here.\n   */\n  //TODO consider simplifying to remove \"boosted\" arg which can be looked up in context via BOOSTED key?\n  @SuppressWarnings({\"unchecked\"})\n  public static IntIntHashMap getBoostDocs(SolrIndexSearcher indexSearcher, Set<BytesRef> boosted,\n                                           @SuppressWarnings({\"rawtypes\"})Map context) throws IOException {\n\n    IntIntHashMap boostDocs = null;\n\n    if (boosted != null) {\n\n      //First see if it's already in the request context. Could have been put there by another caller.\n      if (context != null) {\n        boostDocs = (IntIntHashMap) context.get(BOOSTED_DOCIDS);\n        if (boostDocs != null) {\n          return boostDocs;\n        }\n      }\n\n      //Not in the context yet so load it.\n      boostDocs = new IntIntHashMap(boosted.size()); // docId to boost\n      int priority = boosted.size() + 1; // the corresponding priority for each boosted key (starts at this; decrements down)\n      for (BytesRef uniqueKey : boosted) {\n        priority--; // therefore first == bosted.size(); last will be 1\n        long segAndId = indexSearcher.lookupId(uniqueKey); // higher 32 bits == segment ID, low 32 bits == doc ID\n        if (segAndId == -1) { // not found\n          continue;\n        }\n        int seg = (int) (segAndId >> 32);\n        int localDocId = (int) segAndId;\n        final IndexReaderContext indexReaderContext = indexSearcher.getTopReaderContext().children().get(seg);\n        int docId = indexReaderContext.docBaseInParent + localDocId;\n        boostDocs.put(docId, priority);\n      }\n      assert priority == 1; // the last priority (lowest)\n    }\n\n    if (context != null) {\n      //noinspection unchecked\n      context.put(BOOSTED_DOCIDS, boostDocs);\n    }\n\n    return boostDocs;\n  }\n\n","sourceOld":"  /**\n   * Resolves a set of boosted docs by uniqueKey to a map of docIds mapped to a priority value &gt; 0.\n   * @param indexSearcher the SolrIndexSearcher; required\n   * @param boosted are the set of uniqueKey values to be boosted in priority order.  If null; returns null.\n   * @param context the {@link SolrQueryRequest#getContext()} or null if none.  We'll cache our results here.\n   */\n  //TODO consider simplifying to remove \"boosted\" arg which can be looked up in context via BOOSTED key?\n  public static IntIntHashMap getBoostDocs(SolrIndexSearcher indexSearcher, Set<BytesRef> boosted, Map context) throws IOException {\n\n    IntIntHashMap boostDocs = null;\n\n    if (boosted != null) {\n\n      //First see if it's already in the request context. Could have been put there by another caller.\n      if (context != null) {\n        boostDocs = (IntIntHashMap) context.get(BOOSTED_DOCIDS);\n        if (boostDocs != null) {\n          return boostDocs;\n        }\n      }\n\n      //Not in the context yet so load it.\n      boostDocs = new IntIntHashMap(boosted.size()); // docId to boost\n      int priority = boosted.size() + 1; // the corresponding priority for each boosted key (starts at this; decrements down)\n      for (BytesRef uniqueKey : boosted) {\n        priority--; // therefore first == bosted.size(); last will be 1\n        long segAndId = indexSearcher.lookupId(uniqueKey); // higher 32 bits == segment ID, low 32 bits == doc ID\n        if (segAndId == -1) { // not found\n          continue;\n        }\n        int seg = (int) (segAndId >> 32);\n        int localDocId = (int) segAndId;\n        final IndexReaderContext indexReaderContext = indexSearcher.getTopReaderContext().children().get(seg);\n        int docId = indexReaderContext.docBaseInParent + localDocId;\n        boostDocs.put(docId, priority);\n      }\n      assert priority == 1; // the last priority (lowest)\n    }\n\n    if (context != null) {\n      //noinspection unchecked\n      context.put(BOOSTED_DOCIDS, boostDocs);\n    }\n\n    return boostDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eba8995e4d085569e201ecf8bf75d1cb02fa74bf","date":1592955411,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#getBoostDocs(SolrIndexSearcher,Set[BytesRef],Map).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#getBoostDocs(SolrIndexSearcher,Set[BytesRef],Map).mjava","sourceNew":"  /**\n   * Resolves a set of boosted docs by uniqueKey to a map of docIds mapped to a priority value &gt; 0.\n   * @param indexSearcher the SolrIndexSearcher; required\n   * @param boosted are the set of uniqueKey values to be boosted in priority order.  If null; returns null.\n   * @param context the {@link SolrQueryRequest#getContext()} or null if none.  We'll cache our results here.\n   */\n  //TODO consider simplifying to remove \"boosted\" arg which can be looked up in context via BOOSTED key?\n  @SuppressWarnings({\"unchecked\"})\n  public static IntIntHashMap getBoostDocs(SolrIndexSearcher indexSearcher, Set<BytesRef> boosted,\n                                           @SuppressWarnings({\"rawtypes\"})Map context) throws IOException {\n\n    IntIntHashMap boostDocs = null;\n\n    if (boosted != null) {\n\n      //First see if it's already in the request context. Could have been put there by another caller.\n      if (context != null) {\n        boostDocs = (IntIntHashMap) context.get(BOOSTED_DOCIDS);\n        if (boostDocs != null) {\n          return boostDocs;\n        }\n      }\n\n      //Not in the context yet so load it.\n      boostDocs = new IntIntHashMap(boosted.size()); // docId to boost\n      int priority = boosted.size() + 1; // the corresponding priority for each boosted key (starts at this; decrements down)\n      for (BytesRef uniqueKey : boosted) {\n        priority--; // therefore first == bosted.size(); last will be 1\n        long segAndId = indexSearcher.lookupId(uniqueKey); // higher 32 bits == segment ID, low 32 bits == doc ID\n        if (segAndId == -1) { // not found\n          continue;\n        }\n        int seg = (int) (segAndId >> 32);\n        int localDocId = (int) segAndId;\n        final IndexReaderContext indexReaderContext = indexSearcher.getTopReaderContext().children().get(seg);\n        int docId = indexReaderContext.docBaseInParent + localDocId;\n        boostDocs.put(docId, priority);\n      }\n      assert priority == 1; // the last priority (lowest)\n    }\n\n    if (context != null) {\n      context.put(BOOSTED_DOCIDS, boostDocs);\n    }\n\n    return boostDocs;\n  }\n\n","sourceOld":"  /**\n   * Resolves a set of boosted docs by uniqueKey to a map of docIds mapped to a priority value &gt; 0.\n   * @param indexSearcher the SolrIndexSearcher; required\n   * @param boosted are the set of uniqueKey values to be boosted in priority order.  If null; returns null.\n   * @param context the {@link SolrQueryRequest#getContext()} or null if none.  We'll cache our results here.\n   */\n  //TODO consider simplifying to remove \"boosted\" arg which can be looked up in context via BOOSTED key?\n  @SuppressWarnings({\"unchecked\"})\n  public static IntIntHashMap getBoostDocs(SolrIndexSearcher indexSearcher, Set<BytesRef> boosted,\n                                           @SuppressWarnings({\"rawtypes\"})Map context) throws IOException {\n\n    IntIntHashMap boostDocs = null;\n\n    if (boosted != null) {\n\n      //First see if it's already in the request context. Could have been put there by another caller.\n      if (context != null) {\n        boostDocs = (IntIntHashMap) context.get(BOOSTED_DOCIDS);\n        if (boostDocs != null) {\n          return boostDocs;\n        }\n      }\n\n      //Not in the context yet so load it.\n      boostDocs = new IntIntHashMap(boosted.size()); // docId to boost\n      int priority = boosted.size() + 1; // the corresponding priority for each boosted key (starts at this; decrements down)\n      for (BytesRef uniqueKey : boosted) {\n        priority--; // therefore first == bosted.size(); last will be 1\n        long segAndId = indexSearcher.lookupId(uniqueKey); // higher 32 bits == segment ID, low 32 bits == doc ID\n        if (segAndId == -1) { // not found\n          continue;\n        }\n        int seg = (int) (segAndId >> 32);\n        int localDocId = (int) segAndId;\n        final IndexReaderContext indexReaderContext = indexSearcher.getTopReaderContext().children().get(seg);\n        int docId = indexReaderContext.docBaseInParent + localDocId;\n        boostDocs.put(docId, priority);\n      }\n      assert priority == 1; // the last priority (lowest)\n    }\n\n    if (context != null) {\n      //noinspection unchecked\n      context.put(BOOSTED_DOCIDS, boostDocs);\n    }\n\n    return boostDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2ad458affd82a1d762eb506003907d9363a333cb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2ad458affd82a1d762eb506003907d9363a333cb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"eba8995e4d085569e201ecf8bf75d1cb02fa74bf":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eba8995e4d085569e201ecf8bf75d1cb02fa74bf"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["2ad458affd82a1d762eb506003907d9363a333cb"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2ad458affd82a1d762eb506003907d9363a333cb"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","2ad458affd82a1d762eb506003907d9363a333cb","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"2ad458affd82a1d762eb506003907d9363a333cb":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","8582f07e9350eaeb33bf6c4617b8c9895d99c839","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"eba8995e4d085569e201ecf8bf75d1cb02fa74bf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["eba8995e4d085569e201ecf8bf75d1cb02fa74bf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}