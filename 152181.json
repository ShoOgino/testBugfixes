{"path":"src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","commits":[{"id":"e8f450af7a7b034413833ed2a9508f99264ea49a","date":1211042958,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"/dev/null","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = new Random(1);\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      boolean debug = false;\n\n      for(int iter=0;iter<10000;iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (debug)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (debug)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (debug)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (debug)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (debug)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb1066f2afe9450585d0d10063ea4450085236f1","date":1233870820,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      boolean debug = false;\n\n      for(int iter=0;iter<10000;iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (debug)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (debug)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (debug)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (debug)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (debug)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = new Random(1);\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      boolean debug = false;\n\n      for(int iter=0;iter<10000;iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (debug)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (debug)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (debug)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (debug)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (debug)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"42607aa380c892dc1ec0ab26e86a575c28e13618","date":1268641604,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000;iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      boolean debug = false;\n\n      for(int iter=0;iter<10000;iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (debug)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (debug)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (debug)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (debug)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (debug)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":["7b90dce9d2510a4adffa447c4dbb85717693b5c3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000;iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000;iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e8f450af7a7b034413833ed2a9508f99264ea49a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cb1066f2afe9450585d0d10063ea4450085236f1":["e8f450af7a7b034413833ed2a9508f99264ea49a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"42607aa380c892dc1ec0ab26e86a575c28e13618":["cb1066f2afe9450585d0d10063ea4450085236f1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["42607aa380c892dc1ec0ab26e86a575c28e13618"]},"commit2Childs":{"e8f450af7a7b034413833ed2a9508f99264ea49a":["cb1066f2afe9450585d0d10063ea4450085236f1"],"cb1066f2afe9450585d0d10063ea4450085236f1":["42607aa380c892dc1ec0ab26e86a575c28e13618"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e8f450af7a7b034413833ed2a9508f99264ea49a"],"42607aa380c892dc1ec0ab26e86a575c28e13618":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}