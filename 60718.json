{"path":"solr/core/src/test/org/apache/solr/schema/TestSchemalessBufferedUpdates#test().mjava","commits":[{"id":"3620d9ae0597bc9732d139dc0a9dcab381e998e7","date":1483825160,"type":0,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestSchemalessBufferedUpdates#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(TIMEOUT, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      // Invalid date will be normalized by ParseDateField URP\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"1\", \"f_dt\",\"2017-01-04\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==1\");\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // If the ParseDateField URP isn't ahead of the DUP, then the date won't be normalized in the buffered tlog entry,\n      // and the doc won't be indexed on the replaying replica - a warning is logged as follows:\n      // WARN [...] o.a.s.u.UpdateLog REYPLAY_ERR: IOException reading log\n      //            org.apache.solr.common.SolrException: Invalid Date String:'2017-01-05'\n      //              at org.apache.solr.util.DateMathParser.parseMath(DateMathParser.java:234)\n      //              at org.apache.solr.schema.TrieField.createField(TrieField.java:725) [...]\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"2\", \"f_dt\",\"2017-01-05\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==2\");\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n      req().close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestSchemalessBufferedUpdates#test().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void test() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(TIMEOUT, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      // Invalid date will be normalized by ParseDateField URP\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"1\", \"f_dt\",\"2017-01-04\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==1\");\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // If the ParseDateField URP isn't ahead of the DUP, then the date won't be normalized in the buffered tlog entry,\n      // and the doc won't be indexed on the replaying replica - a warning is logged as follows:\n      // WARN [...] o.a.s.u.UpdateLog REYPLAY_ERR: IOException reading log\n      //            org.apache.solr.common.SolrException: Invalid Date String:'2017-01-05'\n      //              at org.apache.solr.util.DateMathParser.parseMath(DateMathParser.java:234)\n      //              at org.apache.solr.schema.TrieField.createField(TrieField.java:725) [...]\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"2\", \"f_dt\",\"2017-01-05\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==2\");\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n      req().close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94a0eda7dbad12579530df39279403d27344ebcb","date":1500511909,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestSchemalessBufferedUpdates#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestSchemalessBufferedUpdates#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(TIMEOUT, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      // Invalid date will be normalized by ParseDateField URP\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"1\", \"f_dt\",\"2017-01-04\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==1\");\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // If the ParseDateField URP isn't ahead of the DUP, then the date won't be normalized in the buffered tlog entry,\n      // and the doc won't be indexed on the replaying replica - a warning is logged as follows:\n      // WARN [...] o.a.s.u.UpdateLog REYPLAY_ERR: IOException reading log\n      //            org.apache.solr.common.SolrException: Invalid Date String:'2017-01-05'\n      //              at org.apache.solr.util.DateMathParser.parseMath(DateMathParser.java:234)\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"2\", \"f_dt\",\"2017-01-05\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==2\");\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n      req().close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(TIMEOUT, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      // Invalid date will be normalized by ParseDateField URP\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"1\", \"f_dt\",\"2017-01-04\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==1\");\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // If the ParseDateField URP isn't ahead of the DUP, then the date won't be normalized in the buffered tlog entry,\n      // and the doc won't be indexed on the replaying replica - a warning is logged as follows:\n      // WARN [...] o.a.s.u.UpdateLog REYPLAY_ERR: IOException reading log\n      //            org.apache.solr.common.SolrException: Invalid Date String:'2017-01-05'\n      //              at org.apache.solr.util.DateMathParser.parseMath(DateMathParser.java:234)\n      //              at org.apache.solr.schema.TrieField.createField(TrieField.java:725) [...]\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"2\", \"f_dt\",\"2017-01-05\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==2\");\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n      req().close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestSchemalessBufferedUpdates#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestSchemalessBufferedUpdates#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(TIMEOUT, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      // Invalid date will be normalized by ParseDateField URP\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"1\", \"f_dt\",\"2017-01-04\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==1\");\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // If the ParseDateField URP isn't ahead of the DUP, then the date won't be normalized in the buffered tlog entry,\n      // and the doc won't be indexed on the replaying replica - a warning is logged as follows:\n      // WARN [...] o.a.s.u.UpdateLog REYPLAY_ERR: IOException reading log\n      //            org.apache.solr.common.SolrException: Invalid Date String:'2017-01-05'\n      //              at org.apache.solr.util.DateMathParser.parseMath(DateMathParser.java:234)\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"2\", \"f_dt\",\"2017-01-05\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==2\");\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n      req().close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(TIMEOUT, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      // Invalid date will be normalized by ParseDateField URP\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"1\", \"f_dt\",\"2017-01-04\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==1\");\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // If the ParseDateField URP isn't ahead of the DUP, then the date won't be normalized in the buffered tlog entry,\n      // and the doc won't be indexed on the replaying replica - a warning is logged as follows:\n      // WARN [...] o.a.s.u.UpdateLog REYPLAY_ERR: IOException reading log\n      //            org.apache.solr.common.SolrException: Invalid Date String:'2017-01-05'\n      //              at org.apache.solr.util.DateMathParser.parseMath(DateMathParser.java:234)\n      //              at org.apache.solr.schema.TrieField.createField(TrieField.java:725) [...]\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"2\", \"f_dt\",\"2017-01-05\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==2\");\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n      req().close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1","date":1579200426,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestSchemalessBufferedUpdates#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestSchemalessBufferedUpdates#test().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    TestInjection.skipIndexWriterCommitOnClose = true;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(TIMEOUT, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      // Invalid date will be normalized by ParseDateField URP\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"1\", \"f_dt\",\"2017-01-04\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==1\");\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // If the ParseDateField URP isn't ahead of the DUP, then the date won't be normalized in the buffered tlog entry,\n      // and the doc won't be indexed on the replaying replica - a warning is logged as follows:\n      // WARN [...] o.a.s.u.UpdateLog REYPLAY_ERR: IOException reading log\n      //            org.apache.solr.common.SolrException: Invalid Date String:'2017-01-05'\n      //              at org.apache.solr.util.DateMathParser.parseMath(DateMathParser.java:234)\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"2\", \"f_dt\",\"2017-01-05\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==2\");\n    } finally {\n      TestInjection.reset();\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n      req().close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void test() throws Exception {\n    DirectUpdateHandler2.commitOnClose = false;\n    final Semaphore logReplay = new Semaphore(0);\n    final Semaphore logReplayFinish = new Semaphore(0);\n    UpdateLog.testing_logReplayHook = () -> {\n      try {\n        assertTrue(logReplay.tryAcquire(TIMEOUT, TimeUnit.SECONDS));\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    };\n    UpdateLog.testing_logReplayFinishHook = logReplayFinish::release;\n\n    SolrQueryRequest req = req();\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n\n    try {\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      // Invalid date will be normalized by ParseDateField URP\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"1\", \"f_dt\",\"2017-01-04\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==1\");\n\n      ulog.bufferUpdates();\n      assertEquals(UpdateLog.State.BUFFERING, ulog.getState());\n\n      // If the ParseDateField URP isn't ahead of the DUP, then the date won't be normalized in the buffered tlog entry,\n      // and the doc won't be indexed on the replaying replica - a warning is logged as follows:\n      // WARN [...] o.a.s.u.UpdateLog REYPLAY_ERR: IOException reading log\n      //            org.apache.solr.common.SolrException: Invalid Date String:'2017-01-05'\n      //              at org.apache.solr.util.DateMathParser.parseMath(DateMathParser.java:234)\n      updateJ(jsonAdd(processAdd(sdoc(\"id\",\"2\", \"f_dt\",\"2017-01-05\"))), params(DISTRIB_UPDATE_PARAM,FROM_LEADER));\n\n      Future<UpdateLog.RecoveryInfo> rinfoFuture = ulog.applyBufferedUpdates();\n\n      assertTrue(rinfoFuture != null);\n\n      assertEquals(UpdateLog.State.APPLYING_BUFFERED, ulog.getState());\n\n      logReplay.release(1000);\n\n      UpdateLog.RecoveryInfo rinfo = rinfoFuture.get();\n      assertEquals(UpdateLog.State.ACTIVE, ulog.getState());\n\n      assertU(commit());\n      assertJQ(req(\"q\", \"*:*\"), \"/response/numFound==2\");\n    } finally {\n      DirectUpdateHandler2.commitOnClose = true;\n      UpdateLog.testing_logReplayHook = null;\n      UpdateLog.testing_logReplayFinishHook = null;\n      req().close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"94a0eda7dbad12579530df39279403d27344ebcb":["3620d9ae0597bc9732d139dc0a9dcab381e998e7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"936cdd5882761db3b844afd6f84ab81cbb011a75":["3620d9ae0597bc9732d139dc0a9dcab381e998e7","94a0eda7dbad12579530df39279403d27344ebcb"],"3620d9ae0597bc9732d139dc0a9dcab381e998e7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3620d9ae0597bc9732d139dc0a9dcab381e998e7"],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["94a0eda7dbad12579530df39279403d27344ebcb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1"]},"commit2Childs":{"94a0eda7dbad12579530df39279403d27344ebcb":["936cdd5882761db3b844afd6f84ab81cbb011a75","b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3620d9ae0597bc9732d139dc0a9dcab381e998e7","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"936cdd5882761db3b844afd6f84ab81cbb011a75":[],"3620d9ae0597bc9732d139dc0a9dcab381e998e7":["94a0eda7dbad12579530df39279403d27344ebcb","936cdd5882761db3b844afd6f84ab81cbb011a75","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"b6a0ad05ae2af8aa028b1a6099a8222fad0bc8c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["936cdd5882761db3b844afd6f84ab81cbb011a75","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}