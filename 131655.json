{"path":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocument(SolrCore,BytesRef,AtomicLong,boolean,Set[String],boolean).mjava","commits":[{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":0,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocument(SolrCore,BytesRef,AtomicLong,boolean,Set[String],boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Obtains the latest document for a given id from the tlog or through the realtime searcher (if not found in the tlog). \n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param avoidRetrievingStoredFields Setting this to true avoids fetching stored fields through the realtime searcher,\n   *                  however has no effect on documents obtained from the tlog. \n   *                  Non-stored docValues fields are populated anyway, and are not affected by this parameter. Note that if\n   *                  the id field is a stored field, it will not be populated if this parameter is true and the document is\n   *                  obtained from the index.\n   * @param onlyTheseNonStoredDVs If not-null, populate only these DV fields in the document fetched through the realtime searcher. \n   *                  If this is null, decorate all non-stored  DVs (that are not targets of copy fields) from the searcher.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocument(SolrCore core, BytesRef idBytes, AtomicLong versionReturned, boolean avoidRetrievingStoredFields,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) throws IOException {\n    SolrInputDocument sid = null;\n    RefCounted<SolrIndexSearcher> searcherHolder = null;\n    try {\n      SolrIndexSearcher searcher = null;\n      sid = getInputDocumentFromTlog(core, idBytes, versionReturned, onlyTheseNonStoredDVs, resolveFullDocument);\n      if (sid == DELETED) {\n        return null;\n      }\n\n      if (sid == null) {\n        // didn't find it in the update log, so it should be in the newest searcher opened\n        if (searcher == null) {\n          searcherHolder = core.getRealtimeSearcher();\n          searcher = searcherHolder.get();\n        }\n\n        // SolrCore.verbose(\"RealTimeGet using searcher \", searcher);\n        SchemaField idField = core.getLatestSchema().getUniqueKeyField();\n\n        int docid = searcher.getFirstMatch(new Term(idField.getName(), idBytes));\n        if (docid < 0) return null;\n        \n        if (avoidRetrievingStoredFields) {\n          sid = new SolrInputDocument();\n        } else {\n          Document luceneDocument = searcher.doc(docid);\n          sid = toSolrInputDocument(luceneDocument, core.getLatestSchema());\n        }\n        if (onlyTheseNonStoredDVs != null) {\n          searcher.decorateDocValueFields(sid, docid, onlyTheseNonStoredDVs);\n        } else {\n          searcher.decorateDocValueFields(sid, docid, searcher.getNonStoredDVsWithoutCopyTargets());\n        }\n      }\n    } finally {\n      if (searcherHolder != null) {\n        searcherHolder.decref();\n      }\n    }\n\n    if (versionReturned != null) {\n      if (sid.containsKey(DistributedUpdateProcessor.VERSION_FIELD)) {\n        versionReturned.set((long)sid.getFieldValue(DistributedUpdateProcessor.VERSION_FIELD));\n      }\n    }\n    return sid;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocument(SolrCore,BytesRef,AtomicLong,boolean,Set[String],boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Obtains the latest document for a given id from the tlog or through the realtime searcher (if not found in the tlog). \n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param avoidRetrievingStoredFields Setting this to true avoids fetching stored fields through the realtime searcher,\n   *                  however has no effect on documents obtained from the tlog. \n   *                  Non-stored docValues fields are populated anyway, and are not affected by this parameter. Note that if\n   *                  the id field is a stored field, it will not be populated if this parameter is true and the document is\n   *                  obtained from the index.\n   * @param onlyTheseNonStoredDVs If not-null, populate only these DV fields in the document fetched through the realtime searcher. \n   *                  If this is null, decorate all non-stored  DVs (that are not targets of copy fields) from the searcher.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocument(SolrCore core, BytesRef idBytes, AtomicLong versionReturned, boolean avoidRetrievingStoredFields,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) throws IOException {\n    SolrInputDocument sid = null;\n    RefCounted<SolrIndexSearcher> searcherHolder = null;\n    try {\n      SolrIndexSearcher searcher = null;\n      sid = getInputDocumentFromTlog(core, idBytes, versionReturned, onlyTheseNonStoredDVs, resolveFullDocument);\n      if (sid == DELETED) {\n        return null;\n      }\n\n      if (sid == null) {\n        // didn't find it in the update log, so it should be in the newest searcher opened\n        if (searcher == null) {\n          searcherHolder = core.getRealtimeSearcher();\n          searcher = searcherHolder.get();\n        }\n\n        // SolrCore.verbose(\"RealTimeGet using searcher \", searcher);\n        SchemaField idField = core.getLatestSchema().getUniqueKeyField();\n\n        int docid = searcher.getFirstMatch(new Term(idField.getName(), idBytes));\n        if (docid < 0) return null;\n        \n        if (avoidRetrievingStoredFields) {\n          sid = new SolrInputDocument();\n        } else {\n          Document luceneDocument = searcher.doc(docid);\n          sid = toSolrInputDocument(luceneDocument, core.getLatestSchema());\n        }\n        if (onlyTheseNonStoredDVs != null) {\n          searcher.decorateDocValueFields(sid, docid, onlyTheseNonStoredDVs);\n        } else {\n          searcher.decorateDocValueFields(sid, docid, searcher.getNonStoredDVsWithoutCopyTargets());\n        }\n      }\n    } finally {\n      if (searcherHolder != null) {\n        searcherHolder.decref();\n      }\n    }\n\n    if (versionReturned != null) {\n      if (sid.containsKey(DistributedUpdateProcessor.VERSION_FIELD)) {\n        versionReturned.set((long)sid.getFieldValue(DistributedUpdateProcessor.VERSION_FIELD));\n      }\n    }\n    return sid;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocument(SolrCore,BytesRef,AtomicLong,boolean,Set[String],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocument(SolrCore,BytesRef,AtomicLong,boolean,Set[String],boolean).mjava","sourceNew":"  /**\n   * Obtains the latest document for a given id from the tlog or through the realtime searcher (if not found in the tlog). \n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param avoidRetrievingStoredFields Setting this to true avoids fetching stored fields through the realtime searcher,\n   *                  however has no effect on documents obtained from the tlog. \n   *                  Non-stored docValues fields are populated anyway, and are not affected by this parameter. Note that if\n   *                  the id field is a stored field, it will not be populated if this parameter is true and the document is\n   *                  obtained from the index.\n   * @param onlyTheseNonStoredDVs If not-null, populate only these DV fields in the document fetched through the realtime searcher. \n   *                  If this is null, decorate all non-stored  DVs (that are not targets of copy fields) from the searcher.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocument(SolrCore core, BytesRef idBytes, AtomicLong versionReturned, boolean avoidRetrievingStoredFields,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) throws IOException {\n    SolrInputDocument sid = null;\n    RefCounted<SolrIndexSearcher> searcherHolder = null;\n    try {\n      SolrIndexSearcher searcher = null;\n      sid = getInputDocumentFromTlog(core, idBytes, versionReturned, onlyTheseNonStoredDVs, resolveFullDocument);\n      if (sid == DELETED) {\n        return null;\n      }\n\n      if (sid == null) {\n        // didn't find it in the update log, so it should be in the newest searcher opened\n        if (searcher == null) {\n          searcherHolder = core.getRealtimeSearcher();\n          searcher = searcherHolder.get();\n        }\n\n        // SolrCore.verbose(\"RealTimeGet using searcher \", searcher);\n        SchemaField idField = core.getLatestSchema().getUniqueKeyField();\n\n        int docid = searcher.getFirstMatch(new Term(idField.getName(), idBytes));\n        if (docid < 0) return null;\n        \n        if (avoidRetrievingStoredFields) {\n          sid = new SolrInputDocument();\n        } else {\n          Document luceneDocument = searcher.doc(docid);\n          sid = toSolrInputDocument(luceneDocument, core.getLatestSchema());\n        }\n        if (onlyTheseNonStoredDVs != null) {\n          searcher.decorateDocValueFields(sid, docid, onlyTheseNonStoredDVs);\n        } else {\n          searcher.decorateDocValueFields(sid, docid, searcher.getNonStoredDVsWithoutCopyTargets());\n        }\n      }\n    } finally {\n      if (searcherHolder != null) {\n        searcherHolder.decref();\n      }\n    }\n\n    if (versionReturned != null) {\n      if (sid.containsKey(VERSION_FIELD)) {\n        versionReturned.set((long)sid.getFieldValue(VERSION_FIELD));\n      }\n    }\n    return sid;\n  }\n\n","sourceOld":"  /**\n   * Obtains the latest document for a given id from the tlog or through the realtime searcher (if not found in the tlog). \n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param avoidRetrievingStoredFields Setting this to true avoids fetching stored fields through the realtime searcher,\n   *                  however has no effect on documents obtained from the tlog. \n   *                  Non-stored docValues fields are populated anyway, and are not affected by this parameter. Note that if\n   *                  the id field is a stored field, it will not be populated if this parameter is true and the document is\n   *                  obtained from the index.\n   * @param onlyTheseNonStoredDVs If not-null, populate only these DV fields in the document fetched through the realtime searcher. \n   *                  If this is null, decorate all non-stored  DVs (that are not targets of copy fields) from the searcher.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocument(SolrCore core, BytesRef idBytes, AtomicLong versionReturned, boolean avoidRetrievingStoredFields,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) throws IOException {\n    SolrInputDocument sid = null;\n    RefCounted<SolrIndexSearcher> searcherHolder = null;\n    try {\n      SolrIndexSearcher searcher = null;\n      sid = getInputDocumentFromTlog(core, idBytes, versionReturned, onlyTheseNonStoredDVs, resolveFullDocument);\n      if (sid == DELETED) {\n        return null;\n      }\n\n      if (sid == null) {\n        // didn't find it in the update log, so it should be in the newest searcher opened\n        if (searcher == null) {\n          searcherHolder = core.getRealtimeSearcher();\n          searcher = searcherHolder.get();\n        }\n\n        // SolrCore.verbose(\"RealTimeGet using searcher \", searcher);\n        SchemaField idField = core.getLatestSchema().getUniqueKeyField();\n\n        int docid = searcher.getFirstMatch(new Term(idField.getName(), idBytes));\n        if (docid < 0) return null;\n        \n        if (avoidRetrievingStoredFields) {\n          sid = new SolrInputDocument();\n        } else {\n          Document luceneDocument = searcher.doc(docid);\n          sid = toSolrInputDocument(luceneDocument, core.getLatestSchema());\n        }\n        if (onlyTheseNonStoredDVs != null) {\n          searcher.decorateDocValueFields(sid, docid, onlyTheseNonStoredDVs);\n        } else {\n          searcher.decorateDocValueFields(sid, docid, searcher.getNonStoredDVsWithoutCopyTargets());\n        }\n      }\n    } finally {\n      if (searcherHolder != null) {\n        searcherHolder.decref();\n      }\n    }\n\n    if (versionReturned != null) {\n      if (sid.containsKey(DistributedUpdateProcessor.VERSION_FIELD)) {\n        versionReturned.set((long)sid.getFieldValue(DistributedUpdateProcessor.VERSION_FIELD));\n      }\n    }\n    return sid;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocument(SolrCore,BytesRef,AtomicLong,boolean,Set[String],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocument(SolrCore,BytesRef,AtomicLong,boolean,Set[String],boolean).mjava","sourceNew":"  /**\n   * Obtains the latest document for a given id from the tlog or through the realtime searcher (if not found in the tlog). \n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param avoidRetrievingStoredFields Setting this to true avoids fetching stored fields through the realtime searcher,\n   *                  however has no effect on documents obtained from the tlog. \n   *                  Non-stored docValues fields are populated anyway, and are not affected by this parameter. Note that if\n   *                  the id field is a stored field, it will not be populated if this parameter is true and the document is\n   *                  obtained from the index.\n   * @param onlyTheseNonStoredDVs If not-null, populate only these DV fields in the document fetched through the realtime searcher. \n   *                  If this is null, decorate all non-stored  DVs (that are not targets of copy fields) from the searcher.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocument(SolrCore core, BytesRef idBytes, AtomicLong versionReturned, boolean avoidRetrievingStoredFields,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) throws IOException {\n    SolrInputDocument sid = null;\n    RefCounted<SolrIndexSearcher> searcherHolder = null;\n    try {\n      SolrIndexSearcher searcher = null;\n      sid = getInputDocumentFromTlog(core, idBytes, versionReturned, onlyTheseNonStoredDVs, resolveFullDocument);\n      if (sid == DELETED) {\n        return null;\n      }\n\n      if (sid == null) {\n        // didn't find it in the update log, so it should be in the newest searcher opened\n        if (searcher == null) {\n          searcherHolder = core.getRealtimeSearcher();\n          searcher = searcherHolder.get();\n        }\n\n        // SolrCore.verbose(\"RealTimeGet using searcher \", searcher);\n        SchemaField idField = core.getLatestSchema().getUniqueKeyField();\n\n        int docid = searcher.getFirstMatch(new Term(idField.getName(), idBytes));\n        if (docid < 0) return null;\n        \n        if (avoidRetrievingStoredFields) {\n          sid = new SolrInputDocument();\n        } else {\n          Document luceneDocument = searcher.doc(docid);\n          sid = toSolrInputDocument(luceneDocument, core.getLatestSchema());\n        }\n        if (onlyTheseNonStoredDVs != null) {\n          searcher.decorateDocValueFields(sid, docid, onlyTheseNonStoredDVs);\n        } else {\n          searcher.decorateDocValueFields(sid, docid, searcher.getNonStoredDVsWithoutCopyTargets());\n        }\n      }\n    } finally {\n      if (searcherHolder != null) {\n        searcherHolder.decref();\n      }\n    }\n\n    if (versionReturned != null) {\n      if (sid.containsKey(VERSION_FIELD)) {\n        versionReturned.set((long)sid.getFieldValue(VERSION_FIELD));\n      }\n    }\n    return sid;\n  }\n\n","sourceOld":"  /**\n   * Obtains the latest document for a given id from the tlog or through the realtime searcher (if not found in the tlog). \n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param avoidRetrievingStoredFields Setting this to true avoids fetching stored fields through the realtime searcher,\n   *                  however has no effect on documents obtained from the tlog. \n   *                  Non-stored docValues fields are populated anyway, and are not affected by this parameter. Note that if\n   *                  the id field is a stored field, it will not be populated if this parameter is true and the document is\n   *                  obtained from the index.\n   * @param onlyTheseNonStoredDVs If not-null, populate only these DV fields in the document fetched through the realtime searcher. \n   *                  If this is null, decorate all non-stored  DVs (that are not targets of copy fields) from the searcher.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocument(SolrCore core, BytesRef idBytes, AtomicLong versionReturned, boolean avoidRetrievingStoredFields,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) throws IOException {\n    SolrInputDocument sid = null;\n    RefCounted<SolrIndexSearcher> searcherHolder = null;\n    try {\n      SolrIndexSearcher searcher = null;\n      sid = getInputDocumentFromTlog(core, idBytes, versionReturned, onlyTheseNonStoredDVs, resolveFullDocument);\n      if (sid == DELETED) {\n        return null;\n      }\n\n      if (sid == null) {\n        // didn't find it in the update log, so it should be in the newest searcher opened\n        if (searcher == null) {\n          searcherHolder = core.getRealtimeSearcher();\n          searcher = searcherHolder.get();\n        }\n\n        // SolrCore.verbose(\"RealTimeGet using searcher \", searcher);\n        SchemaField idField = core.getLatestSchema().getUniqueKeyField();\n\n        int docid = searcher.getFirstMatch(new Term(idField.getName(), idBytes));\n        if (docid < 0) return null;\n        \n        if (avoidRetrievingStoredFields) {\n          sid = new SolrInputDocument();\n        } else {\n          Document luceneDocument = searcher.doc(docid);\n          sid = toSolrInputDocument(luceneDocument, core.getLatestSchema());\n        }\n        if (onlyTheseNonStoredDVs != null) {\n          searcher.decorateDocValueFields(sid, docid, onlyTheseNonStoredDVs);\n        } else {\n          searcher.decorateDocValueFields(sid, docid, searcher.getNonStoredDVsWithoutCopyTargets());\n        }\n      }\n    } finally {\n      if (searcherHolder != null) {\n        searcherHolder.decref();\n      }\n    }\n\n    if (versionReturned != null) {\n      if (sid.containsKey(DistributedUpdateProcessor.VERSION_FIELD)) {\n        versionReturned.set((long)sid.getFieldValue(DistributedUpdateProcessor.VERSION_FIELD));\n      }\n    }\n    return sid;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"63a9344cff6a72bc4c1ef080c69e10ad0635b811","date":1490410892,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocument(SolrCore,BytesRef,AtomicLong,boolean,Set[String],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocument(SolrCore,BytesRef,AtomicLong,boolean,Set[String],boolean).mjava","sourceNew":"  /**\n   * Obtains the latest document for a given id from the tlog or through the realtime searcher (if not found in the tlog). \n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param avoidRetrievingStoredFields Setting this to true avoids fetching stored fields through the realtime searcher,\n   *                  however has no effect on documents obtained from the tlog. \n   *                  Non-stored docValues fields are populated anyway, and are not affected by this parameter. Note that if\n   *                  the id field is a stored field, it will not be populated if this parameter is true and the document is\n   *                  obtained from the index.\n   * @param onlyTheseNonStoredDVs If not-null, populate only these DV fields in the document fetched through the realtime searcher. \n   *                  If this is null, decorate all non-stored  DVs (that are not targets of copy fields) from the searcher.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocument(SolrCore core, BytesRef idBytes, AtomicLong versionReturned, boolean avoidRetrievingStoredFields,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) throws IOException {\n    SolrInputDocument sid = null;\n    RefCounted<SolrIndexSearcher> searcherHolder = null;\n    try {\n      SolrIndexSearcher searcher = null;\n      sid = getInputDocumentFromTlog(core, idBytes, versionReturned, onlyTheseNonStoredDVs, resolveFullDocument);\n      if (sid == DELETED) {\n        return null;\n      }\n\n      if (sid == null) {\n        // didn't find it in the update log, so it should be in the newest searcher opened\n        if (searcher == null) {\n          searcherHolder = core.getRealtimeSearcher();\n          searcher = searcherHolder.get();\n        }\n\n        // SolrCore.verbose(\"RealTimeGet using searcher \", searcher);\n        SchemaField idField = core.getLatestSchema().getUniqueKeyField();\n\n        int docid = searcher.getFirstMatch(new Term(idField.getName(), idBytes));\n        if (docid < 0) return null;\n\n        SolrDocumentFetcher docFetcher = searcher.getDocFetcher();\n        if (avoidRetrievingStoredFields) {\n          sid = new SolrInputDocument();\n        } else {\n          Document luceneDocument = docFetcher.doc(docid);\n          sid = toSolrInputDocument(luceneDocument, core.getLatestSchema());\n        }\n        if (onlyTheseNonStoredDVs != null) {\n          docFetcher.decorateDocValueFields(sid, docid, onlyTheseNonStoredDVs);\n        } else {\n          docFetcher.decorateDocValueFields(sid, docid, docFetcher.getNonStoredDVsWithoutCopyTargets());\n        }\n      }\n    } finally {\n      if (searcherHolder != null) {\n        searcherHolder.decref();\n      }\n    }\n\n    if (versionReturned != null) {\n      if (sid.containsKey(VERSION_FIELD)) {\n        versionReturned.set((long)sid.getFieldValue(VERSION_FIELD));\n      }\n    }\n    return sid;\n  }\n\n","sourceOld":"  /**\n   * Obtains the latest document for a given id from the tlog or through the realtime searcher (if not found in the tlog). \n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param avoidRetrievingStoredFields Setting this to true avoids fetching stored fields through the realtime searcher,\n   *                  however has no effect on documents obtained from the tlog. \n   *                  Non-stored docValues fields are populated anyway, and are not affected by this parameter. Note that if\n   *                  the id field is a stored field, it will not be populated if this parameter is true and the document is\n   *                  obtained from the index.\n   * @param onlyTheseNonStoredDVs If not-null, populate only these DV fields in the document fetched through the realtime searcher. \n   *                  If this is null, decorate all non-stored  DVs (that are not targets of copy fields) from the searcher.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocument(SolrCore core, BytesRef idBytes, AtomicLong versionReturned, boolean avoidRetrievingStoredFields,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) throws IOException {\n    SolrInputDocument sid = null;\n    RefCounted<SolrIndexSearcher> searcherHolder = null;\n    try {\n      SolrIndexSearcher searcher = null;\n      sid = getInputDocumentFromTlog(core, idBytes, versionReturned, onlyTheseNonStoredDVs, resolveFullDocument);\n      if (sid == DELETED) {\n        return null;\n      }\n\n      if (sid == null) {\n        // didn't find it in the update log, so it should be in the newest searcher opened\n        if (searcher == null) {\n          searcherHolder = core.getRealtimeSearcher();\n          searcher = searcherHolder.get();\n        }\n\n        // SolrCore.verbose(\"RealTimeGet using searcher \", searcher);\n        SchemaField idField = core.getLatestSchema().getUniqueKeyField();\n\n        int docid = searcher.getFirstMatch(new Term(idField.getName(), idBytes));\n        if (docid < 0) return null;\n        \n        if (avoidRetrievingStoredFields) {\n          sid = new SolrInputDocument();\n        } else {\n          Document luceneDocument = searcher.doc(docid);\n          sid = toSolrInputDocument(luceneDocument, core.getLatestSchema());\n        }\n        if (onlyTheseNonStoredDVs != null) {\n          searcher.decorateDocValueFields(sid, docid, onlyTheseNonStoredDVs);\n        } else {\n          searcher.decorateDocValueFields(sid, docid, searcher.getNonStoredDVsWithoutCopyTargets());\n        }\n      }\n    } finally {\n      if (searcherHolder != null) {\n        searcherHolder.decref();\n      }\n    }\n\n    if (versionReturned != null) {\n      if (sid.containsKey(VERSION_FIELD)) {\n        versionReturned.set((long)sid.getFieldValue(VERSION_FIELD));\n      }\n    }\n    return sid;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de548de3ce5405595899f548152d4b93ac9eb9cc","date":1490594650,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocument(SolrCore,BytesRef,AtomicLong,boolean,Set[String],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocument(SolrCore,BytesRef,AtomicLong,boolean,Set[String],boolean).mjava","sourceNew":"  /**\n   * Obtains the latest document for a given id from the tlog or through the realtime searcher (if not found in the tlog). \n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param avoidRetrievingStoredFields Setting this to true avoids fetching stored fields through the realtime searcher,\n   *                  however has no effect on documents obtained from the tlog. \n   *                  Non-stored docValues fields are populated anyway, and are not affected by this parameter. Note that if\n   *                  the id field is a stored field, it will not be populated if this parameter is true and the document is\n   *                  obtained from the index.\n   * @param onlyTheseNonStoredDVs If not-null, populate only these DV fields in the document fetched through the realtime searcher. \n   *                  If this is null, decorate all non-stored  DVs (that are not targets of copy fields) from the searcher.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocument(SolrCore core, BytesRef idBytes, AtomicLong versionReturned, boolean avoidRetrievingStoredFields,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) throws IOException {\n    SolrInputDocument sid = null;\n    RefCounted<SolrIndexSearcher> searcherHolder = null;\n    try {\n      SolrIndexSearcher searcher = null;\n      sid = getInputDocumentFromTlog(core, idBytes, versionReturned, onlyTheseNonStoredDVs, resolveFullDocument);\n      if (sid == DELETED) {\n        return null;\n      }\n\n      if (sid == null) {\n        // didn't find it in the update log, so it should be in the newest searcher opened\n        if (searcher == null) {\n          searcherHolder = core.getRealtimeSearcher();\n          searcher = searcherHolder.get();\n        }\n\n        // SolrCore.verbose(\"RealTimeGet using searcher \", searcher);\n        SchemaField idField = core.getLatestSchema().getUniqueKeyField();\n\n        int docid = searcher.getFirstMatch(new Term(idField.getName(), idBytes));\n        if (docid < 0) return null;\n\n        SolrDocumentFetcher docFetcher = searcher.getDocFetcher();\n        if (avoidRetrievingStoredFields) {\n          sid = new SolrInputDocument();\n        } else {\n          Document luceneDocument = docFetcher.doc(docid);\n          sid = toSolrInputDocument(luceneDocument, core.getLatestSchema());\n        }\n        if (onlyTheseNonStoredDVs != null) {\n          docFetcher.decorateDocValueFields(sid, docid, onlyTheseNonStoredDVs);\n        } else {\n          docFetcher.decorateDocValueFields(sid, docid, docFetcher.getNonStoredDVsWithoutCopyTargets());\n        }\n      }\n    } finally {\n      if (searcherHolder != null) {\n        searcherHolder.decref();\n      }\n    }\n\n    if (versionReturned != null) {\n      if (sid.containsKey(VERSION_FIELD)) {\n        versionReturned.set((long)sid.getFieldValue(VERSION_FIELD));\n      }\n    }\n    return sid;\n  }\n\n","sourceOld":"  /**\n   * Obtains the latest document for a given id from the tlog or through the realtime searcher (if not found in the tlog). \n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param avoidRetrievingStoredFields Setting this to true avoids fetching stored fields through the realtime searcher,\n   *                  however has no effect on documents obtained from the tlog. \n   *                  Non-stored docValues fields are populated anyway, and are not affected by this parameter. Note that if\n   *                  the id field is a stored field, it will not be populated if this parameter is true and the document is\n   *                  obtained from the index.\n   * @param onlyTheseNonStoredDVs If not-null, populate only these DV fields in the document fetched through the realtime searcher. \n   *                  If this is null, decorate all non-stored  DVs (that are not targets of copy fields) from the searcher.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocument(SolrCore core, BytesRef idBytes, AtomicLong versionReturned, boolean avoidRetrievingStoredFields,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) throws IOException {\n    SolrInputDocument sid = null;\n    RefCounted<SolrIndexSearcher> searcherHolder = null;\n    try {\n      SolrIndexSearcher searcher = null;\n      sid = getInputDocumentFromTlog(core, idBytes, versionReturned, onlyTheseNonStoredDVs, resolveFullDocument);\n      if (sid == DELETED) {\n        return null;\n      }\n\n      if (sid == null) {\n        // didn't find it in the update log, so it should be in the newest searcher opened\n        if (searcher == null) {\n          searcherHolder = core.getRealtimeSearcher();\n          searcher = searcherHolder.get();\n        }\n\n        // SolrCore.verbose(\"RealTimeGet using searcher \", searcher);\n        SchemaField idField = core.getLatestSchema().getUniqueKeyField();\n\n        int docid = searcher.getFirstMatch(new Term(idField.getName(), idBytes));\n        if (docid < 0) return null;\n        \n        if (avoidRetrievingStoredFields) {\n          sid = new SolrInputDocument();\n        } else {\n          Document luceneDocument = searcher.doc(docid);\n          sid = toSolrInputDocument(luceneDocument, core.getLatestSchema());\n        }\n        if (onlyTheseNonStoredDVs != null) {\n          searcher.decorateDocValueFields(sid, docid, onlyTheseNonStoredDVs);\n        } else {\n          searcher.decorateDocValueFields(sid, docid, searcher.getNonStoredDVsWithoutCopyTargets());\n        }\n      }\n    } finally {\n      if (searcherHolder != null) {\n        searcherHolder.decref();\n      }\n    }\n\n    if (versionReturned != null) {\n      if (sid.containsKey(VERSION_FIELD)) {\n        versionReturned.set((long)sid.getFieldValue(VERSION_FIELD));\n      }\n    }\n    return sid;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07749612bed4eb54dd05255c1434c301133310c1","date":1554879779,"type":5,"author":"Moshe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocument(SolrCore,BytesRef,AtomicLong,Set[String],Resolution).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/RealTimeGetComponent#getInputDocument(SolrCore,BytesRef,AtomicLong,boolean,Set[String],boolean).mjava","sourceNew":"  /**\n   * Obtains the latest document for a given id from the tlog or through the realtime searcher (if not found in the tlog). \n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param onlyTheseNonStoredDVs If not-null, populate only these DV fields in the document fetched through the realtime searcher. \n   *                  If this is null, decorate all non-stored  DVs (that are not targets of copy fields) from the searcher.\n   *                  When non-null, stored fields are not fetched.\n   * @param resolveStrategy The strategy to resolve the the document.\n   * @see Resolution\n   */\n  public static SolrInputDocument getInputDocument(SolrCore core, BytesRef idBytes, AtomicLong versionReturned,\n      Set<String> onlyTheseNonStoredDVs, Resolution resolveStrategy) throws IOException {\n    SolrInputDocument sid = null;\n    RefCounted<SolrIndexSearcher> searcherHolder = null;\n    try {\n      SolrIndexSearcher searcher = null;\n      sid = getInputDocumentFromTlog(core, idBytes, versionReturned, onlyTheseNonStoredDVs, true);\n      if (sid == DELETED) {\n        return null;\n      }\n\n      if (sid == null) {\n        // didn't find it in the update log, so it should be in the newest searcher opened\n        if (searcher == null) {\n          searcherHolder = core.getRealtimeSearcher();\n          searcher = searcherHolder.get();\n        }\n\n        // SolrCore.verbose(\"RealTimeGet using searcher \", searcher);\n        final IndexSchema schema = core.getLatestSchema();\n        SchemaField idField = schema.getUniqueKeyField();\n\n        int docid = searcher.getFirstMatch(new Term(idField.getName(), idBytes));\n        if (docid < 0) return null;\n\n        SolrDocumentFetcher docFetcher = searcher.getDocFetcher();\n        if (onlyTheseNonStoredDVs != null) {\n          sid = new SolrInputDocument();\n        } else {\n          Document luceneDocument = docFetcher.doc(docid);\n          sid = toSolrInputDocument(luceneDocument, schema);\n        }\n        final boolean isNestedRequest = resolveStrategy == Resolution.DOC_WITH_CHILDREN || resolveStrategy == Resolution.ROOT_WITH_CHILDREN;\n        decorateDocValueFields(docFetcher, sid, docid, onlyTheseNonStoredDVs, isNestedRequest || schema.hasExplicitField(IndexSchema.NEST_PATH_FIELD_NAME));\n        SolrInputField rootField = sid.getField(IndexSchema.ROOT_FIELD_NAME);\n        if((isNestedRequest) && schema.isUsableForChildDocs() && schema.hasExplicitField(IndexSchema.NEST_PATH_FIELD_NAME) && rootField!=null) {\n          // doc is part of a nested structure\n          final boolean resolveRootDoc = resolveStrategy == Resolution.ROOT_WITH_CHILDREN;\n          String id = resolveRootDoc? (String) rootField.getFirstValue(): (String) sid.getField(idField.getName()).getFirstValue();\n          ModifiableSolrParams params = new ModifiableSolrParams()\n              .set(\"fl\", \"*, _nest_path_, [child]\")\n              .set(\"limit\", \"-1\");\n          SolrQueryRequest nestedReq = new LocalSolrQueryRequest(core, params);\n          final BytesRef rootIdBytes = new BytesRef(id);\n          final int rootDocId = searcher.getFirstMatch(new Term(idField.getName(), rootIdBytes));\n          final DocTransformer childDocTransformer = core.getTransformerFactory(\"child\").create(\"child\", params, nestedReq);\n          final ResultContext resultContext = new RTGResultContext(new SolrReturnFields(nestedReq), searcher, nestedReq);\n          childDocTransformer.setContext(resultContext);\n          final SolrDocument nestedDoc;\n          if(resolveRootDoc && rootIdBytes.equals(idBytes)) {\n            nestedDoc = toSolrDoc(sid, schema);\n          } else {\n            nestedDoc = toSolrDoc(docFetcher.doc(rootDocId), schema);\n            decorateDocValueFields(docFetcher, nestedDoc, rootDocId, onlyTheseNonStoredDVs, true);\n          }\n          childDocTransformer.transform(nestedDoc, rootDocId);\n          sid = toSolrInputDocument(nestedDoc, schema);\n        }\n      }\n    } finally {\n      if (searcherHolder != null) {\n        searcherHolder.decref();\n      }\n    }\n\n    if (versionReturned != null) {\n      if (sid.containsKey(VERSION_FIELD)) {\n        versionReturned.set((long)sid.getFieldValue(VERSION_FIELD));\n      }\n    }\n    return sid;\n  }\n\n","sourceOld":"  /**\n   * Obtains the latest document for a given id from the tlog or through the realtime searcher (if not found in the tlog). \n   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.\n   * @param avoidRetrievingStoredFields Setting this to true avoids fetching stored fields through the realtime searcher,\n   *                  however has no effect on documents obtained from the tlog. \n   *                  Non-stored docValues fields are populated anyway, and are not affected by this parameter. Note that if\n   *                  the id field is a stored field, it will not be populated if this parameter is true and the document is\n   *                  obtained from the index.\n   * @param onlyTheseNonStoredDVs If not-null, populate only these DV fields in the document fetched through the realtime searcher. \n   *                  If this is null, decorate all non-stored  DVs (that are not targets of copy fields) from the searcher.\n   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update\n   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following\n   *                  back prevPointer/prevVersion)?\n   */\n  public static SolrInputDocument getInputDocument(SolrCore core, BytesRef idBytes, AtomicLong versionReturned, boolean avoidRetrievingStoredFields,\n      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) throws IOException {\n    SolrInputDocument sid = null;\n    RefCounted<SolrIndexSearcher> searcherHolder = null;\n    try {\n      SolrIndexSearcher searcher = null;\n      sid = getInputDocumentFromTlog(core, idBytes, versionReturned, onlyTheseNonStoredDVs, resolveFullDocument);\n      if (sid == DELETED) {\n        return null;\n      }\n\n      if (sid == null) {\n        // didn't find it in the update log, so it should be in the newest searcher opened\n        if (searcher == null) {\n          searcherHolder = core.getRealtimeSearcher();\n          searcher = searcherHolder.get();\n        }\n\n        // SolrCore.verbose(\"RealTimeGet using searcher \", searcher);\n        SchemaField idField = core.getLatestSchema().getUniqueKeyField();\n\n        int docid = searcher.getFirstMatch(new Term(idField.getName(), idBytes));\n        if (docid < 0) return null;\n\n        SolrDocumentFetcher docFetcher = searcher.getDocFetcher();\n        if (avoidRetrievingStoredFields) {\n          sid = new SolrInputDocument();\n        } else {\n          Document luceneDocument = docFetcher.doc(docid);\n          sid = toSolrInputDocument(luceneDocument, core.getLatestSchema());\n        }\n        if (onlyTheseNonStoredDVs != null) {\n          docFetcher.decorateDocValueFields(sid, docid, onlyTheseNonStoredDVs);\n        } else {\n          docFetcher.decorateDocValueFields(sid, docid, docFetcher.getNonStoredDVsWithoutCopyTargets());\n        }\n      }\n    } finally {\n      if (searcherHolder != null) {\n        searcherHolder.decref();\n      }\n    }\n\n    if (versionReturned != null) {\n      if (sid.containsKey(VERSION_FIELD)) {\n        versionReturned.set((long)sid.getFieldValue(VERSION_FIELD));\n      }\n    }\n    return sid;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","415bbbe7da8065dd3c477bdc3c703c6425622998"],"de548de3ce5405595899f548152d4b93ac9eb9cc":["e5fa6615014cd2288fe930f8c8bb726f9504961d"],"63a9344cff6a72bc4c1ef080c69e10ad0635b811":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"07749612bed4eb54dd05255c1434c301133310c1":["63a9344cff6a72bc4c1ef080c69e10ad0635b811"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["07749612bed4eb54dd05255c1434c301133310c1"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["e5fa6615014cd2288fe930f8c8bb726f9504961d","598b5d23aa7c9732bf473c21a9cd309c44599394","6d2dadc1f5ca8703d8659f4964961f9967935d75"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["de548de3ce5405595899f548152d4b93ac9eb9cc"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"de548de3ce5405595899f548152d4b93ac9eb9cc":[],"63a9344cff6a72bc4c1ef080c69e10ad0635b811":["07749612bed4eb54dd05255c1434c301133310c1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["63a9344cff6a72bc4c1ef080c69e10ad0635b811"],"07749612bed4eb54dd05255c1434c301133310c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","de548de3ce5405595899f548152d4b93ac9eb9cc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}