{"path":"lucene/tools/src/java/org/apache/lucene/validation/ivyde/IvyNodeElementAdapter#adapt(ResolveReport).mjava","commits":[{"id":"b3e4bd3aed493904d0bbb6c6e0394f619e175087","date":1401446035,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ivyde/IvyNodeElementAdapter#adapt(ResolveReport).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adapt all dependencies and evictions from the ResolveReport.\n   * @return the root node adapted from the ResolveReport\n   */\n  public static IvyNodeElement adapt(ResolveReport report) {\n    Map<ModuleRevisionId,IvyNodeElement> resolvedNodes = new HashMap<>();\n\n    IvyNodeElement root = new IvyNodeElement();\n    root.setModuleRevisionId(report.getModuleDescriptor().getModuleRevisionId());\n    resolvedNodes.put(report.getModuleDescriptor().getModuleRevisionId(), root);\n\n    @SuppressWarnings(\"unchecked\") List<IvyNode> dependencies = report.getDependencies();\n\n    // First pass - build the map of resolved nodes by revision id\n    for (Iterator iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = (IvyNode) iter.next();\n      if (node.getAllEvictingNodes() != null) {\n        // Nodes that are evicted as a result of conf inheritance still appear\n        // as dependencies, but with eviction data. They also appear as evictions.\n        // We map them as evictions rather than dependencies.\n        continue;\n      }\n      IvyNodeElement nodeElement = new IvyNodeElement();\n      nodeElement.setModuleRevisionId(node.getResolvedId());\n      resolvedNodes.put(node.getResolvedId(), nodeElement);\n    }\n\n    // Second pass - establish relationships between the resolved nodes\n    for (Iterator iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = (IvyNode) iter.next();\n      if (node.getAllEvictingNodes() != null) {\n        continue; // see note above\n      }\n\n      IvyNodeElement nodeElement = resolvedNodes.get(node.getResolvedId());\n      IvyNodeCallers.Caller[] callers = node.getAllRealCallers();\n      for (int i = 0; i < callers.length; i++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[i].getModuleRevisionId());\n        if (caller != null) {\n          nodeElement.addCaller(caller);\n          nodeElement.setCallerConfigurations(caller, callers[i].getCallerConfigurations());\n        }\n      }\n    }\n\n    IvyNode[] evictions = report.getEvictedNodes();\n    for (int i = 0; i < evictions.length; i++) {\n      IvyNode eviction = evictions[i];\n      IvyNodeElement evictionElement = new IvyNodeElement();\n      evictionElement.setModuleRevisionId(eviction.getResolvedId());\n      evictionElement.setEvicted(true);\n\n      IvyNodeCallers.Caller[] callers = eviction.getAllCallers();\n      for (int j = 0; j < callers.length; j++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[j].getModuleRevisionId());\n        if (caller != null) {\n          evictionElement.addCaller(caller);\n          evictionElement.setCallerConfigurations(caller, callers[j].getCallerConfigurations());\n        }\n      }\n    }\n\n    // Recursively set depth starting at root\n    root.setDepth(0);\n    findConflictsBeneathNode(root);\n\n    return root;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec1a71fbd0f533ceb6c940816637d33e90394dc1","date":1439660103,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ivyde/IvyNodeElementAdapter#adapt(ResolveReport).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ivyde/IvyNodeElementAdapter#adapt(ResolveReport).mjava","sourceNew":"  /**\n   * Adapt all dependencies and evictions from the ResolveReport.\n   * @return the root node adapted from the ResolveReport\n   */\n  public static IvyNodeElement adapt(ResolveReport report) {\n    Map<ModuleRevisionId,IvyNodeElement> resolvedNodes = new HashMap<>();\n\n    IvyNodeElement root = new IvyNodeElement();\n    root.setModuleRevisionId(report.getModuleDescriptor().getModuleRevisionId());\n    resolvedNodes.put(report.getModuleDescriptor().getModuleRevisionId(), root);\n\n    @SuppressWarnings(\"unchecked\") List<IvyNode> dependencies = report.getDependencies();\n\n    // First pass - build the map of resolved nodes by revision id\n    for (Iterator<IvyNode> iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = iter.next();\n      if (node.getAllEvictingNodes() != null) {\n        // Nodes that are evicted as a result of conf inheritance still appear\n        // as dependencies, but with eviction data. They also appear as evictions.\n        // We map them as evictions rather than dependencies.\n        continue;\n      }\n      IvyNodeElement nodeElement = new IvyNodeElement();\n      nodeElement.setModuleRevisionId(node.getResolvedId());\n      resolvedNodes.put(node.getResolvedId(), nodeElement);\n    }\n\n    // Second pass - establish relationships between the resolved nodes\n    for (Iterator<IvyNode> iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = iter.next();\n      if (node.getAllEvictingNodes() != null) {\n        continue; // see note above\n      }\n\n      IvyNodeElement nodeElement = resolvedNodes.get(node.getResolvedId());\n      IvyNodeCallers.Caller[] callers = node.getAllRealCallers();\n      for (int i = 0; i < callers.length; i++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[i].getModuleRevisionId());\n        if (caller != null) {\n          nodeElement.addCaller(caller);\n          nodeElement.setCallerConfigurations(caller, callers[i].getCallerConfigurations());\n        }\n      }\n    }\n\n    IvyNode[] evictions = report.getEvictedNodes();\n    for (int i = 0; i < evictions.length; i++) {\n      IvyNode eviction = evictions[i];\n      IvyNodeElement evictionElement = new IvyNodeElement();\n      evictionElement.setModuleRevisionId(eviction.getResolvedId());\n      evictionElement.setEvicted(true);\n\n      IvyNodeCallers.Caller[] callers = eviction.getAllCallers();\n      for (int j = 0; j < callers.length; j++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[j].getModuleRevisionId());\n        if (caller != null) {\n          evictionElement.addCaller(caller);\n          evictionElement.setCallerConfigurations(caller, callers[j].getCallerConfigurations());\n        }\n      }\n    }\n\n    // Recursively set depth starting at root\n    root.setDepth(0);\n    findConflictsBeneathNode(root);\n\n    return root;\n  }\n\n","sourceOld":"  /**\n   * Adapt all dependencies and evictions from the ResolveReport.\n   * @return the root node adapted from the ResolveReport\n   */\n  public static IvyNodeElement adapt(ResolveReport report) {\n    Map<ModuleRevisionId,IvyNodeElement> resolvedNodes = new HashMap<>();\n\n    IvyNodeElement root = new IvyNodeElement();\n    root.setModuleRevisionId(report.getModuleDescriptor().getModuleRevisionId());\n    resolvedNodes.put(report.getModuleDescriptor().getModuleRevisionId(), root);\n\n    @SuppressWarnings(\"unchecked\") List<IvyNode> dependencies = report.getDependencies();\n\n    // First pass - build the map of resolved nodes by revision id\n    for (Iterator iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = (IvyNode) iter.next();\n      if (node.getAllEvictingNodes() != null) {\n        // Nodes that are evicted as a result of conf inheritance still appear\n        // as dependencies, but with eviction data. They also appear as evictions.\n        // We map them as evictions rather than dependencies.\n        continue;\n      }\n      IvyNodeElement nodeElement = new IvyNodeElement();\n      nodeElement.setModuleRevisionId(node.getResolvedId());\n      resolvedNodes.put(node.getResolvedId(), nodeElement);\n    }\n\n    // Second pass - establish relationships between the resolved nodes\n    for (Iterator iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = (IvyNode) iter.next();\n      if (node.getAllEvictingNodes() != null) {\n        continue; // see note above\n      }\n\n      IvyNodeElement nodeElement = resolvedNodes.get(node.getResolvedId());\n      IvyNodeCallers.Caller[] callers = node.getAllRealCallers();\n      for (int i = 0; i < callers.length; i++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[i].getModuleRevisionId());\n        if (caller != null) {\n          nodeElement.addCaller(caller);\n          nodeElement.setCallerConfigurations(caller, callers[i].getCallerConfigurations());\n        }\n      }\n    }\n\n    IvyNode[] evictions = report.getEvictedNodes();\n    for (int i = 0; i < evictions.length; i++) {\n      IvyNode eviction = evictions[i];\n      IvyNodeElement evictionElement = new IvyNodeElement();\n      evictionElement.setModuleRevisionId(eviction.getResolvedId());\n      evictionElement.setEvicted(true);\n\n      IvyNodeCallers.Caller[] callers = eviction.getAllCallers();\n      for (int j = 0; j < callers.length; j++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[j].getModuleRevisionId());\n        if (caller != null) {\n          evictionElement.addCaller(caller);\n          evictionElement.setCallerConfigurations(caller, callers[j].getCallerConfigurations());\n        }\n      }\n    }\n\n    // Recursively set depth starting at root\n    root.setDepth(0);\n    findConflictsBeneathNode(root);\n\n    return root;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fa75aa4c057ce99897cc92f867734664926152c","date":1598037592,"type":4,"author":"Erick Erickson","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ivyde/IvyNodeElementAdapter#adapt(ResolveReport).mjava","sourceNew":null,"sourceOld":"  /**\n   * Adapt all dependencies and evictions from the ResolveReport.\n   * @return the root node adapted from the ResolveReport\n   */\n  public static IvyNodeElement adapt(ResolveReport report) {\n    Map<ModuleRevisionId,IvyNodeElement> resolvedNodes = new HashMap<>();\n\n    IvyNodeElement root = new IvyNodeElement();\n    root.setModuleRevisionId(report.getModuleDescriptor().getModuleRevisionId());\n    resolvedNodes.put(report.getModuleDescriptor().getModuleRevisionId(), root);\n\n    @SuppressWarnings(\"unchecked\") List<IvyNode> dependencies = report.getDependencies();\n\n    // First pass - build the map of resolved nodes by revision id\n    for (Iterator<IvyNode> iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = iter.next();\n      if (node.getAllEvictingNodes() != null) {\n        // Nodes that are evicted as a result of conf inheritance still appear\n        // as dependencies, but with eviction data. They also appear as evictions.\n        // We map them as evictions rather than dependencies.\n        continue;\n      }\n      IvyNodeElement nodeElement = new IvyNodeElement();\n      nodeElement.setModuleRevisionId(node.getResolvedId());\n      resolvedNodes.put(node.getResolvedId(), nodeElement);\n    }\n\n    // Second pass - establish relationships between the resolved nodes\n    for (Iterator<IvyNode> iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = iter.next();\n      if (node.getAllEvictingNodes() != null) {\n        continue; // see note above\n      }\n\n      IvyNodeElement nodeElement = resolvedNodes.get(node.getResolvedId());\n      IvyNodeCallers.Caller[] callers = node.getAllRealCallers();\n      for (int i = 0; i < callers.length; i++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[i].getModuleRevisionId());\n        if (caller != null) {\n          nodeElement.addCaller(caller);\n          nodeElement.setCallerConfigurations(caller, callers[i].getCallerConfigurations());\n        }\n      }\n    }\n\n    IvyNode[] evictions = report.getEvictedNodes();\n    for (int i = 0; i < evictions.length; i++) {\n      IvyNode eviction = evictions[i];\n      IvyNodeElement evictionElement = new IvyNodeElement();\n      evictionElement.setModuleRevisionId(eviction.getResolvedId());\n      evictionElement.setEvicted(true);\n\n      IvyNodeCallers.Caller[] callers = eviction.getAllCallers();\n      for (int j = 0; j < callers.length; j++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[j].getModuleRevisionId());\n        if (caller != null) {\n          evictionElement.addCaller(caller);\n          evictionElement.setCallerConfigurations(caller, callers[j].getCallerConfigurations());\n        }\n      }\n    }\n\n    // Recursively set depth starting at root\n    root.setDepth(0);\n    findConflictsBeneathNode(root);\n\n    return root;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7bb030802697db4b7a61bfa93c54ba39679032b6","date":1598043478,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/validation/ivyde/IvyNodeElementAdapter#adapt(ResolveReport).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Adapt all dependencies and evictions from the ResolveReport.\n   * @return the root node adapted from the ResolveReport\n   */\n  public static IvyNodeElement adapt(ResolveReport report) {\n    Map<ModuleRevisionId,IvyNodeElement> resolvedNodes = new HashMap<>();\n\n    IvyNodeElement root = new IvyNodeElement();\n    root.setModuleRevisionId(report.getModuleDescriptor().getModuleRevisionId());\n    resolvedNodes.put(report.getModuleDescriptor().getModuleRevisionId(), root);\n\n    @SuppressWarnings(\"unchecked\") List<IvyNode> dependencies = report.getDependencies();\n\n    // First pass - build the map of resolved nodes by revision id\n    for (Iterator<IvyNode> iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = iter.next();\n      if (node.getAllEvictingNodes() != null) {\n        // Nodes that are evicted as a result of conf inheritance still appear\n        // as dependencies, but with eviction data. They also appear as evictions.\n        // We map them as evictions rather than dependencies.\n        continue;\n      }\n      IvyNodeElement nodeElement = new IvyNodeElement();\n      nodeElement.setModuleRevisionId(node.getResolvedId());\n      resolvedNodes.put(node.getResolvedId(), nodeElement);\n    }\n\n    // Second pass - establish relationships between the resolved nodes\n    for (Iterator<IvyNode> iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = iter.next();\n      if (node.getAllEvictingNodes() != null) {\n        continue; // see note above\n      }\n\n      IvyNodeElement nodeElement = resolvedNodes.get(node.getResolvedId());\n      IvyNodeCallers.Caller[] callers = node.getAllRealCallers();\n      for (int i = 0; i < callers.length; i++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[i].getModuleRevisionId());\n        if (caller != null) {\n          nodeElement.addCaller(caller);\n          nodeElement.setCallerConfigurations(caller, callers[i].getCallerConfigurations());\n        }\n      }\n    }\n\n    IvyNode[] evictions = report.getEvictedNodes();\n    for (int i = 0; i < evictions.length; i++) {\n      IvyNode eviction = evictions[i];\n      IvyNodeElement evictionElement = new IvyNodeElement();\n      evictionElement.setModuleRevisionId(eviction.getResolvedId());\n      evictionElement.setEvicted(true);\n\n      IvyNodeCallers.Caller[] callers = eviction.getAllCallers();\n      for (int j = 0; j < callers.length; j++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[j].getModuleRevisionId());\n        if (caller != null) {\n          evictionElement.addCaller(caller);\n          evictionElement.setCallerConfigurations(caller, callers[j].getCallerConfigurations());\n        }\n      }\n    }\n\n    // Recursively set depth starting at root\n    root.setDepth(0);\n    findConflictsBeneathNode(root);\n\n    return root;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"64cc3a6df6159ad66d60c3ce53ecfbaf044dea90","date":1598621476,"type":4,"author":"Erick Erickson","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/tools/src/java/org/apache/lucene/validation/ivyde/IvyNodeElementAdapter#adapt(ResolveReport).mjava","sourceNew":null,"sourceOld":"  /**\n   * Adapt all dependencies and evictions from the ResolveReport.\n   * @return the root node adapted from the ResolveReport\n   */\n  public static IvyNodeElement adapt(ResolveReport report) {\n    Map<ModuleRevisionId,IvyNodeElement> resolvedNodes = new HashMap<>();\n\n    IvyNodeElement root = new IvyNodeElement();\n    root.setModuleRevisionId(report.getModuleDescriptor().getModuleRevisionId());\n    resolvedNodes.put(report.getModuleDescriptor().getModuleRevisionId(), root);\n\n    @SuppressWarnings(\"unchecked\") List<IvyNode> dependencies = report.getDependencies();\n\n    // First pass - build the map of resolved nodes by revision id\n    for (Iterator<IvyNode> iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = iter.next();\n      if (node.getAllEvictingNodes() != null) {\n        // Nodes that are evicted as a result of conf inheritance still appear\n        // as dependencies, but with eviction data. They also appear as evictions.\n        // We map them as evictions rather than dependencies.\n        continue;\n      }\n      IvyNodeElement nodeElement = new IvyNodeElement();\n      nodeElement.setModuleRevisionId(node.getResolvedId());\n      resolvedNodes.put(node.getResolvedId(), nodeElement);\n    }\n\n    // Second pass - establish relationships between the resolved nodes\n    for (Iterator<IvyNode> iter = dependencies.iterator(); iter.hasNext();) {\n      IvyNode node = iter.next();\n      if (node.getAllEvictingNodes() != null) {\n        continue; // see note above\n      }\n\n      IvyNodeElement nodeElement = resolvedNodes.get(node.getResolvedId());\n      IvyNodeCallers.Caller[] callers = node.getAllRealCallers();\n      for (int i = 0; i < callers.length; i++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[i].getModuleRevisionId());\n        if (caller != null) {\n          nodeElement.addCaller(caller);\n          nodeElement.setCallerConfigurations(caller, callers[i].getCallerConfigurations());\n        }\n      }\n    }\n\n    IvyNode[] evictions = report.getEvictedNodes();\n    for (int i = 0; i < evictions.length; i++) {\n      IvyNode eviction = evictions[i];\n      IvyNodeElement evictionElement = new IvyNodeElement();\n      evictionElement.setModuleRevisionId(eviction.getResolvedId());\n      evictionElement.setEvicted(true);\n\n      IvyNodeCallers.Caller[] callers = eviction.getAllCallers();\n      for (int j = 0; j < callers.length; j++) {\n        IvyNodeElement caller = resolvedNodes.get(callers[j].getModuleRevisionId());\n        if (caller != null) {\n          evictionElement.addCaller(caller);\n          evictionElement.setCallerConfigurations(caller, callers[j].getCallerConfigurations());\n        }\n      }\n    }\n\n    // Recursively set depth starting at root\n    root.setDepth(0);\n    findConflictsBeneathNode(root);\n\n    return root;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7bb030802697db4b7a61bfa93c54ba39679032b6":["1fa75aa4c057ce99897cc92f867734664926152c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1fa75aa4c057ce99897cc92f867734664926152c":["ec1a71fbd0f533ceb6c940816637d33e90394dc1"],"ec1a71fbd0f533ceb6c940816637d33e90394dc1":["b3e4bd3aed493904d0bbb6c6e0394f619e175087"],"64cc3a6df6159ad66d60c3ce53ecfbaf044dea90":["7bb030802697db4b7a61bfa93c54ba39679032b6"],"b3e4bd3aed493904d0bbb6c6e0394f619e175087":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["64cc3a6df6159ad66d60c3ce53ecfbaf044dea90"]},"commit2Childs":{"7bb030802697db4b7a61bfa93c54ba39679032b6":["64cc3a6df6159ad66d60c3ce53ecfbaf044dea90"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b3e4bd3aed493904d0bbb6c6e0394f619e175087"],"1fa75aa4c057ce99897cc92f867734664926152c":["7bb030802697db4b7a61bfa93c54ba39679032b6"],"ec1a71fbd0f533ceb6c940816637d33e90394dc1":["1fa75aa4c057ce99897cc92f867734664926152c"],"b3e4bd3aed493904d0bbb6c6e0394f619e175087":["ec1a71fbd0f533ceb6c940816637d33e90394dc1"],"64cc3a6df6159ad66d60c3ce53ecfbaf044dea90":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}