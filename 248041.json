{"path":"solr/src/java/org/apache/solr/util/PrimUtils#sort(int,int,int[],IntComparator).mjava","commits":[{"id":"222ea1c48b8e68b304965aced7ce915aa78588ca","date":1282780459,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/util/PrimUtils#sort(int,int,int[],IntComparator).mjava","pathOld":"/dev/null","sourceNew":"  /** Sort the integer array from \"start\" inclusive to \"end\" exclusive in ascending order,\n   *  using the provided comparator.\n   */\n  public static void sort(int start, int end, int[] array, IntComparator comparator) {\n    // This code was copied from Apache Harmony's Arrays.sort(double[]) and modified\n    // to use a comparator, in addition to other small efficiency enhancements\n    // like replacing divisions with shifts.\n\n    int temp;\n    int length = end - start;\n    if (length < 7) {\n      for (int i = start + 1; i < end; i++) {\n        for (int j = i; j > start && comparator.lessThan(array[j], array[j - 1]); j--) {\n          temp = array[j];\n          array[j] = array[j - 1];\n          array[j - 1] = temp;\n        }\n      }\n      return;\n    }\n    int middle = (start + end) >>> 1;\n    if (length > 7) {\n      int bottom = start;\n      int top = end - 1;\n      if (length > 40) {\n        length >>= 3;\n        bottom = med3(array, bottom, bottom + length, bottom\n            + (length<<1), comparator);\n        middle = med3(array, middle - length, middle, middle + length, comparator);\n        top = med3(array, top - (length<<1), top - length, top, comparator);\n      }\n      middle = med3(array, bottom, middle, top, comparator);\n    }\n    int partionValue = array[middle];\n    int a, b, c, d;\n    a = b = start;\n    c = d = end - 1;\n    while (true) {\n      while (b <= c && !comparator.lessThan(partionValue, array[b])) {\n        if (comparator.equals(array[b], partionValue)) {\n          temp = array[a];\n          array[a++] = array[b];\n          array[b] = temp;\n        }\n        b++;\n      }\n      while (c >= b && !comparator.lessThan(array[c], partionValue)) {\n        if (comparator.equals(array[c], partionValue)) {\n          temp = array[c];\n          array[c] = array[d];\n          array[d--] = temp;\n        }\n        c--;\n      }\n      if (b > c) {\n        break;\n      }\n      temp = array[b];\n      array[b++] = array[c];\n      array[c--] = temp;\n    }\n    length = a - start < b - a ? a - start : b - a;\n    int l = start;\n    int h = b - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    length = d - c < end - 1 - d ? d - c : end - 1 - d;\n    l = b;\n    h = end - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    if ((length = b - a) > 0) {\n      sort(start, start + length, array, comparator);\n    }\n    if ((length = d - c) > 0) {\n      sort(end - length, end, array, comparator);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d7e8df47af69cc678152ff806d9636658477c61","date":1282782039,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/util/PrimUtils#sort(int,int,int[],IntComparator).mjava","pathOld":"solr/src/java/org/apache/solr/util/PrimUtils#sort(int,int,int[],IntComparator).mjava","sourceNew":"  /** Sort the integer array from \"start\" inclusive to \"end\" exclusive in ascending order,\n   *  using the provided comparator.\n   * TODO: is this an unstable sort?\n   */\n  public static void sort(int start, int end, int[] array, IntComparator comparator) {\n    // This code was copied from Apache Harmony's Arrays.sort(double[]) and modified\n    // to use a comparator, in addition to other small efficiency enhancements\n    // like replacing divisions with shifts.\n\n    int temp;\n    int length = end - start;\n    if (length < 7) {\n      for (int i = start + 1; i < end; i++) {\n        for (int j = i; j > start && comparator.lessThan(array[j], array[j - 1]); j--) {\n          temp = array[j];\n          array[j] = array[j - 1];\n          array[j - 1] = temp;\n        }\n      }\n      return;\n    }\n    int middle = (start + end) >>> 1;\n    if (length > 7) {\n      int bottom = start;\n      int top = end - 1;\n      if (length > 40) {\n        length >>= 3;\n        bottom = med3(array, bottom, bottom + length, bottom\n            + (length<<1), comparator);\n        middle = med3(array, middle - length, middle, middle + length, comparator);\n        top = med3(array, top - (length<<1), top - length, top, comparator);\n      }\n      middle = med3(array, bottom, middle, top, comparator);\n    }\n    int partionValue = array[middle];\n    int a, b, c, d;\n    a = b = start;\n    c = d = end - 1;\n    while (true) {\n      while (b <= c && !comparator.lessThan(partionValue, array[b])) {\n        if (comparator.equals(array[b], partionValue)) {\n          temp = array[a];\n          array[a++] = array[b];\n          array[b] = temp;\n        }\n        b++;\n      }\n      while (c >= b && !comparator.lessThan(array[c], partionValue)) {\n        if (comparator.equals(array[c], partionValue)) {\n          temp = array[c];\n          array[c] = array[d];\n          array[d--] = temp;\n        }\n        c--;\n      }\n      if (b > c) {\n        break;\n      }\n      temp = array[b];\n      array[b++] = array[c];\n      array[c--] = temp;\n    }\n    length = a - start < b - a ? a - start : b - a;\n    int l = start;\n    int h = b - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    length = d - c < end - 1 - d ? d - c : end - 1 - d;\n    l = b;\n    h = end - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    if ((length = b - a) > 0) {\n      sort(start, start + length, array, comparator);\n    }\n    if ((length = d - c) > 0) {\n      sort(end - length, end, array, comparator);\n    }\n  }\n\n","sourceOld":"  /** Sort the integer array from \"start\" inclusive to \"end\" exclusive in ascending order,\n   *  using the provided comparator.\n   */\n  public static void sort(int start, int end, int[] array, IntComparator comparator) {\n    // This code was copied from Apache Harmony's Arrays.sort(double[]) and modified\n    // to use a comparator, in addition to other small efficiency enhancements\n    // like replacing divisions with shifts.\n\n    int temp;\n    int length = end - start;\n    if (length < 7) {\n      for (int i = start + 1; i < end; i++) {\n        for (int j = i; j > start && comparator.lessThan(array[j], array[j - 1]); j--) {\n          temp = array[j];\n          array[j] = array[j - 1];\n          array[j - 1] = temp;\n        }\n      }\n      return;\n    }\n    int middle = (start + end) >>> 1;\n    if (length > 7) {\n      int bottom = start;\n      int top = end - 1;\n      if (length > 40) {\n        length >>= 3;\n        bottom = med3(array, bottom, bottom + length, bottom\n            + (length<<1), comparator);\n        middle = med3(array, middle - length, middle, middle + length, comparator);\n        top = med3(array, top - (length<<1), top - length, top, comparator);\n      }\n      middle = med3(array, bottom, middle, top, comparator);\n    }\n    int partionValue = array[middle];\n    int a, b, c, d;\n    a = b = start;\n    c = d = end - 1;\n    while (true) {\n      while (b <= c && !comparator.lessThan(partionValue, array[b])) {\n        if (comparator.equals(array[b], partionValue)) {\n          temp = array[a];\n          array[a++] = array[b];\n          array[b] = temp;\n        }\n        b++;\n      }\n      while (c >= b && !comparator.lessThan(array[c], partionValue)) {\n        if (comparator.equals(array[c], partionValue)) {\n          temp = array[c];\n          array[c] = array[d];\n          array[d--] = temp;\n        }\n        c--;\n      }\n      if (b > c) {\n        break;\n      }\n      temp = array[b];\n      array[b++] = array[c];\n      array[c--] = temp;\n    }\n    length = a - start < b - a ? a - start : b - a;\n    int l = start;\n    int h = b - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    length = d - c < end - 1 - d ? d - c : end - 1 - d;\n    l = b;\n    h = end - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    if ((length = b - a) > 0) {\n      sort(start, start + length, array, comparator);\n    }\n    if ((length = d - c) > 0) {\n      sort(end - length, end, array, comparator);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/util/PrimUtils#sort(int,int,int[],IntComparator).mjava","pathOld":"/dev/null","sourceNew":"  /** Sort the integer array from \"start\" inclusive to \"end\" exclusive in ascending order,\n   *  using the provided comparator.\n   * TODO: is this an unstable sort?\n   */\n  public static void sort(int start, int end, int[] array, IntComparator comparator) {\n    // This code was copied from Apache Harmony's Arrays.sort(double[]) and modified\n    // to use a comparator, in addition to other small efficiency enhancements\n    // like replacing divisions with shifts.\n\n    int temp;\n    int length = end - start;\n    if (length < 7) {\n      for (int i = start + 1; i < end; i++) {\n        for (int j = i; j > start && comparator.lessThan(array[j], array[j - 1]); j--) {\n          temp = array[j];\n          array[j] = array[j - 1];\n          array[j - 1] = temp;\n        }\n      }\n      return;\n    }\n    int middle = (start + end) >>> 1;\n    if (length > 7) {\n      int bottom = start;\n      int top = end - 1;\n      if (length > 40) {\n        length >>= 3;\n        bottom = med3(array, bottom, bottom + length, bottom\n            + (length<<1), comparator);\n        middle = med3(array, middle - length, middle, middle + length, comparator);\n        top = med3(array, top - (length<<1), top - length, top, comparator);\n      }\n      middle = med3(array, bottom, middle, top, comparator);\n    }\n    int partionValue = array[middle];\n    int a, b, c, d;\n    a = b = start;\n    c = d = end - 1;\n    while (true) {\n      while (b <= c && !comparator.lessThan(partionValue, array[b])) {\n        if (comparator.equals(array[b], partionValue)) {\n          temp = array[a];\n          array[a++] = array[b];\n          array[b] = temp;\n        }\n        b++;\n      }\n      while (c >= b && !comparator.lessThan(array[c], partionValue)) {\n        if (comparator.equals(array[c], partionValue)) {\n          temp = array[c];\n          array[c] = array[d];\n          array[d--] = temp;\n        }\n        c--;\n      }\n      if (b > c) {\n        break;\n      }\n      temp = array[b];\n      array[b++] = array[c];\n      array[c--] = temp;\n    }\n    length = a - start < b - a ? a - start : b - a;\n    int l = start;\n    int h = b - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    length = d - c < end - 1 - d ? d - c : end - 1 - d;\n    l = b;\n    h = end - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    if ((length = b - a) > 0) {\n      sort(start, start + length, array, comparator);\n    }\n    if ((length = d - c) > 0) {\n      sort(end - length, end, array, comparator);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/PrimUtils#sort(int,int,int[],IntComparator).mjava","pathOld":"solr/src/java/org/apache/solr/util/PrimUtils#sort(int,int,int[],IntComparator).mjava","sourceNew":"  /** Sort the integer array from \"start\" inclusive to \"end\" exclusive in ascending order,\n   *  using the provided comparator.\n   * TODO: is this an unstable sort?\n   */\n  public static void sort(int start, int end, int[] array, IntComparator comparator) {\n    // This code was copied from Apache Harmony's Arrays.sort(double[]) and modified\n    // to use a comparator, in addition to other small efficiency enhancements\n    // like replacing divisions with shifts.\n\n    int temp;\n    int length = end - start;\n    if (length < 7) {\n      for (int i = start + 1; i < end; i++) {\n        for (int j = i; j > start && comparator.lessThan(array[j], array[j - 1]); j--) {\n          temp = array[j];\n          array[j] = array[j - 1];\n          array[j - 1] = temp;\n        }\n      }\n      return;\n    }\n    int middle = (start + end) >>> 1;\n    if (length > 7) {\n      int bottom = start;\n      int top = end - 1;\n      if (length > 40) {\n        length >>= 3;\n        bottom = med3(array, bottom, bottom + length, bottom\n            + (length<<1), comparator);\n        middle = med3(array, middle - length, middle, middle + length, comparator);\n        top = med3(array, top - (length<<1), top - length, top, comparator);\n      }\n      middle = med3(array, bottom, middle, top, comparator);\n    }\n    int partionValue = array[middle];\n    int a, b, c, d;\n    a = b = start;\n    c = d = end - 1;\n    while (true) {\n      while (b <= c && !comparator.lessThan(partionValue, array[b])) {\n        if (comparator.equals(array[b], partionValue)) {\n          temp = array[a];\n          array[a++] = array[b];\n          array[b] = temp;\n        }\n        b++;\n      }\n      while (c >= b && !comparator.lessThan(array[c], partionValue)) {\n        if (comparator.equals(array[c], partionValue)) {\n          temp = array[c];\n          array[c] = array[d];\n          array[d--] = temp;\n        }\n        c--;\n      }\n      if (b > c) {\n        break;\n      }\n      temp = array[b];\n      array[b++] = array[c];\n      array[c--] = temp;\n    }\n    length = a - start < b - a ? a - start : b - a;\n    int l = start;\n    int h = b - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    length = d - c < end - 1 - d ? d - c : end - 1 - d;\n    l = b;\n    h = end - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    if ((length = b - a) > 0) {\n      sort(start, start + length, array, comparator);\n    }\n    if ((length = d - c) > 0) {\n      sort(end - length, end, array, comparator);\n    }\n  }\n\n","sourceOld":"  /** Sort the integer array from \"start\" inclusive to \"end\" exclusive in ascending order,\n   *  using the provided comparator.\n   * TODO: is this an unstable sort?\n   */\n  public static void sort(int start, int end, int[] array, IntComparator comparator) {\n    // This code was copied from Apache Harmony's Arrays.sort(double[]) and modified\n    // to use a comparator, in addition to other small efficiency enhancements\n    // like replacing divisions with shifts.\n\n    int temp;\n    int length = end - start;\n    if (length < 7) {\n      for (int i = start + 1; i < end; i++) {\n        for (int j = i; j > start && comparator.lessThan(array[j], array[j - 1]); j--) {\n          temp = array[j];\n          array[j] = array[j - 1];\n          array[j - 1] = temp;\n        }\n      }\n      return;\n    }\n    int middle = (start + end) >>> 1;\n    if (length > 7) {\n      int bottom = start;\n      int top = end - 1;\n      if (length > 40) {\n        length >>= 3;\n        bottom = med3(array, bottom, bottom + length, bottom\n            + (length<<1), comparator);\n        middle = med3(array, middle - length, middle, middle + length, comparator);\n        top = med3(array, top - (length<<1), top - length, top, comparator);\n      }\n      middle = med3(array, bottom, middle, top, comparator);\n    }\n    int partionValue = array[middle];\n    int a, b, c, d;\n    a = b = start;\n    c = d = end - 1;\n    while (true) {\n      while (b <= c && !comparator.lessThan(partionValue, array[b])) {\n        if (comparator.equals(array[b], partionValue)) {\n          temp = array[a];\n          array[a++] = array[b];\n          array[b] = temp;\n        }\n        b++;\n      }\n      while (c >= b && !comparator.lessThan(array[c], partionValue)) {\n        if (comparator.equals(array[c], partionValue)) {\n          temp = array[c];\n          array[c] = array[d];\n          array[d--] = temp;\n        }\n        c--;\n      }\n      if (b > c) {\n        break;\n      }\n      temp = array[b];\n      array[b++] = array[c];\n      array[c--] = temp;\n    }\n    length = a - start < b - a ? a - start : b - a;\n    int l = start;\n    int h = b - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    length = d - c < end - 1 - d ? d - c : end - 1 - d;\n    l = b;\n    h = end - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    if ((length = b - a) > 0) {\n      sort(start, start + length, array, comparator);\n    }\n    if ((length = d - c) > 0) {\n      sort(end - length, end, array, comparator);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/PrimUtils#sort(int,int,int[],IntComparator).mjava","pathOld":"solr/src/java/org/apache/solr/util/PrimUtils#sort(int,int,int[],IntComparator).mjava","sourceNew":"  /** Sort the integer array from \"start\" inclusive to \"end\" exclusive in ascending order,\n   *  using the provided comparator.\n   * TODO: is this an unstable sort?\n   */\n  public static void sort(int start, int end, int[] array, IntComparator comparator) {\n    // This code was copied from Apache Harmony's Arrays.sort(double[]) and modified\n    // to use a comparator, in addition to other small efficiency enhancements\n    // like replacing divisions with shifts.\n\n    int temp;\n    int length = end - start;\n    if (length < 7) {\n      for (int i = start + 1; i < end; i++) {\n        for (int j = i; j > start && comparator.lessThan(array[j], array[j - 1]); j--) {\n          temp = array[j];\n          array[j] = array[j - 1];\n          array[j - 1] = temp;\n        }\n      }\n      return;\n    }\n    int middle = (start + end) >>> 1;\n    if (length > 7) {\n      int bottom = start;\n      int top = end - 1;\n      if (length > 40) {\n        length >>= 3;\n        bottom = med3(array, bottom, bottom + length, bottom\n            + (length<<1), comparator);\n        middle = med3(array, middle - length, middle, middle + length, comparator);\n        top = med3(array, top - (length<<1), top - length, top, comparator);\n      }\n      middle = med3(array, bottom, middle, top, comparator);\n    }\n    int partionValue = array[middle];\n    int a, b, c, d;\n    a = b = start;\n    c = d = end - 1;\n    while (true) {\n      while (b <= c && !comparator.lessThan(partionValue, array[b])) {\n        if (comparator.equals(array[b], partionValue)) {\n          temp = array[a];\n          array[a++] = array[b];\n          array[b] = temp;\n        }\n        b++;\n      }\n      while (c >= b && !comparator.lessThan(array[c], partionValue)) {\n        if (comparator.equals(array[c], partionValue)) {\n          temp = array[c];\n          array[c] = array[d];\n          array[d--] = temp;\n        }\n        c--;\n      }\n      if (b > c) {\n        break;\n      }\n      temp = array[b];\n      array[b++] = array[c];\n      array[c--] = temp;\n    }\n    length = a - start < b - a ? a - start : b - a;\n    int l = start;\n    int h = b - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    length = d - c < end - 1 - d ? d - c : end - 1 - d;\n    l = b;\n    h = end - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    if ((length = b - a) > 0) {\n      sort(start, start + length, array, comparator);\n    }\n    if ((length = d - c) > 0) {\n      sort(end - length, end, array, comparator);\n    }\n  }\n\n","sourceOld":"  /** Sort the integer array from \"start\" inclusive to \"end\" exclusive in ascending order,\n   *  using the provided comparator.\n   * TODO: is this an unstable sort?\n   */\n  public static void sort(int start, int end, int[] array, IntComparator comparator) {\n    // This code was copied from Apache Harmony's Arrays.sort(double[]) and modified\n    // to use a comparator, in addition to other small efficiency enhancements\n    // like replacing divisions with shifts.\n\n    int temp;\n    int length = end - start;\n    if (length < 7) {\n      for (int i = start + 1; i < end; i++) {\n        for (int j = i; j > start && comparator.lessThan(array[j], array[j - 1]); j--) {\n          temp = array[j];\n          array[j] = array[j - 1];\n          array[j - 1] = temp;\n        }\n      }\n      return;\n    }\n    int middle = (start + end) >>> 1;\n    if (length > 7) {\n      int bottom = start;\n      int top = end - 1;\n      if (length > 40) {\n        length >>= 3;\n        bottom = med3(array, bottom, bottom + length, bottom\n            + (length<<1), comparator);\n        middle = med3(array, middle - length, middle, middle + length, comparator);\n        top = med3(array, top - (length<<1), top - length, top, comparator);\n      }\n      middle = med3(array, bottom, middle, top, comparator);\n    }\n    int partionValue = array[middle];\n    int a, b, c, d;\n    a = b = start;\n    c = d = end - 1;\n    while (true) {\n      while (b <= c && !comparator.lessThan(partionValue, array[b])) {\n        if (comparator.equals(array[b], partionValue)) {\n          temp = array[a];\n          array[a++] = array[b];\n          array[b] = temp;\n        }\n        b++;\n      }\n      while (c >= b && !comparator.lessThan(array[c], partionValue)) {\n        if (comparator.equals(array[c], partionValue)) {\n          temp = array[c];\n          array[c] = array[d];\n          array[d--] = temp;\n        }\n        c--;\n      }\n      if (b > c) {\n        break;\n      }\n      temp = array[b];\n      array[b++] = array[c];\n      array[c--] = temp;\n    }\n    length = a - start < b - a ? a - start : b - a;\n    int l = start;\n    int h = b - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    length = d - c < end - 1 - d ? d - c : end - 1 - d;\n    l = b;\n    h = end - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    if ((length = b - a) > 0) {\n      sort(start, start + length, array, comparator);\n    }\n    if ((length = d - c) > 0) {\n      sort(end - length, end, array, comparator);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/PrimUtils#sort(int,int,int[],IntComparator).mjava","pathOld":"solr/src/java/org/apache/solr/util/PrimUtils#sort(int,int,int[],IntComparator).mjava","sourceNew":"  /** Sort the integer array from \"start\" inclusive to \"end\" exclusive in ascending order,\n   *  using the provided comparator.\n   * TODO: is this an unstable sort?\n   */\n  public static void sort(int start, int end, int[] array, IntComparator comparator) {\n    // This code was copied from Apache Harmony's Arrays.sort(double[]) and modified\n    // to use a comparator, in addition to other small efficiency enhancements\n    // like replacing divisions with shifts.\n\n    int temp;\n    int length = end - start;\n    if (length < 7) {\n      for (int i = start + 1; i < end; i++) {\n        for (int j = i; j > start && comparator.lessThan(array[j], array[j - 1]); j--) {\n          temp = array[j];\n          array[j] = array[j - 1];\n          array[j - 1] = temp;\n        }\n      }\n      return;\n    }\n    int middle = (start + end) >>> 1;\n    if (length > 7) {\n      int bottom = start;\n      int top = end - 1;\n      if (length > 40) {\n        length >>= 3;\n        bottom = med3(array, bottom, bottom + length, bottom\n            + (length<<1), comparator);\n        middle = med3(array, middle - length, middle, middle + length, comparator);\n        top = med3(array, top - (length<<1), top - length, top, comparator);\n      }\n      middle = med3(array, bottom, middle, top, comparator);\n    }\n    int partionValue = array[middle];\n    int a, b, c, d;\n    a = b = start;\n    c = d = end - 1;\n    while (true) {\n      while (b <= c && !comparator.lessThan(partionValue, array[b])) {\n        if (comparator.equals(array[b], partionValue)) {\n          temp = array[a];\n          array[a++] = array[b];\n          array[b] = temp;\n        }\n        b++;\n      }\n      while (c >= b && !comparator.lessThan(array[c], partionValue)) {\n        if (comparator.equals(array[c], partionValue)) {\n          temp = array[c];\n          array[c] = array[d];\n          array[d--] = temp;\n        }\n        c--;\n      }\n      if (b > c) {\n        break;\n      }\n      temp = array[b];\n      array[b++] = array[c];\n      array[c--] = temp;\n    }\n    length = a - start < b - a ? a - start : b - a;\n    int l = start;\n    int h = b - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    length = d - c < end - 1 - d ? d - c : end - 1 - d;\n    l = b;\n    h = end - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    if ((length = b - a) > 0) {\n      sort(start, start + length, array, comparator);\n    }\n    if ((length = d - c) > 0) {\n      sort(end - length, end, array, comparator);\n    }\n  }\n\n","sourceOld":"  /** Sort the integer array from \"start\" inclusive to \"end\" exclusive in ascending order,\n   *  using the provided comparator.\n   * TODO: is this an unstable sort?\n   */\n  public static void sort(int start, int end, int[] array, IntComparator comparator) {\n    // This code was copied from Apache Harmony's Arrays.sort(double[]) and modified\n    // to use a comparator, in addition to other small efficiency enhancements\n    // like replacing divisions with shifts.\n\n    int temp;\n    int length = end - start;\n    if (length < 7) {\n      for (int i = start + 1; i < end; i++) {\n        for (int j = i; j > start && comparator.lessThan(array[j], array[j - 1]); j--) {\n          temp = array[j];\n          array[j] = array[j - 1];\n          array[j - 1] = temp;\n        }\n      }\n      return;\n    }\n    int middle = (start + end) >>> 1;\n    if (length > 7) {\n      int bottom = start;\n      int top = end - 1;\n      if (length > 40) {\n        length >>= 3;\n        bottom = med3(array, bottom, bottom + length, bottom\n            + (length<<1), comparator);\n        middle = med3(array, middle - length, middle, middle + length, comparator);\n        top = med3(array, top - (length<<1), top - length, top, comparator);\n      }\n      middle = med3(array, bottom, middle, top, comparator);\n    }\n    int partionValue = array[middle];\n    int a, b, c, d;\n    a = b = start;\n    c = d = end - 1;\n    while (true) {\n      while (b <= c && !comparator.lessThan(partionValue, array[b])) {\n        if (comparator.equals(array[b], partionValue)) {\n          temp = array[a];\n          array[a++] = array[b];\n          array[b] = temp;\n        }\n        b++;\n      }\n      while (c >= b && !comparator.lessThan(array[c], partionValue)) {\n        if (comparator.equals(array[c], partionValue)) {\n          temp = array[c];\n          array[c] = array[d];\n          array[d--] = temp;\n        }\n        c--;\n      }\n      if (b > c) {\n        break;\n      }\n      temp = array[b];\n      array[b++] = array[c];\n      array[c--] = temp;\n    }\n    length = a - start < b - a ? a - start : b - a;\n    int l = start;\n    int h = b - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    length = d - c < end - 1 - d ? d - c : end - 1 - d;\n    l = b;\n    h = end - length;\n    while (length-- > 0) {\n      temp = array[l];\n      array[l++] = array[h];\n      array[h++] = temp;\n    }\n    if ((length = b - a) > 0) {\n      sort(start, start + length, array, comparator);\n    }\n    if ((length = d - c) > 0) {\n      sort(end - length, end, array, comparator);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["2d7e8df47af69cc678152ff806d9636658477c61"],"c26f00b574427b55127e869b935845554afde1fa":["2d7e8df47af69cc678152ff806d9636658477c61","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["2d7e8df47af69cc678152ff806d9636658477c61"],"2d7e8df47af69cc678152ff806d9636658477c61":["222ea1c48b8e68b304965aced7ce915aa78588ca"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2d7e8df47af69cc678152ff806d9636658477c61"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"],"222ea1c48b8e68b304965aced7ce915aa78588ca":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","222ea1c48b8e68b304965aced7ce915aa78588ca"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"2d7e8df47af69cc678152ff806d9636658477c61":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"222ea1c48b8e68b304965aced7ce915aa78588ca":["2d7e8df47af69cc678152ff806d9636658477c61"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}