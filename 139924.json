{"path":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","sourceNew":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c20f636a5e90cf0d26ad89a6d2de37d8f3403247","date":1358259818,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","sourceNew":"  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug,\n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41b45c1354293d442c7ae1d25b611b5e7c4f73d1","date":1358344076,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","sourceNew":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug,\n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","sourceNew":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  private Collection<ScoreTerm> suggestSimilar(Term term, int numSug, \n      IndexReader ir, int docfreq, int editDistance, float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","sourceNew":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRefBuilder).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,int,int,float,CharsRef).mjava","sourceNew":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRefBuilder spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        spare.copyUTF8Bytes(candidateTerm);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","sourceOld":"  /**\n   * Provide spelling corrections based on several parameters.\n   *\n   * @param term The term to suggest spelling corrections for\n   * @param numSug The maximum number of spelling corrections\n   * @param ir The index reader to fetch the candidate spelling corrections from\n   * @param docfreq The minimum document frequency a potential suggestion need to have in order to be included\n   * @param editDistance The maximum edit distance candidates are allowed to have\n   * @param accuracy The minimum accuracy a suggested spelling correction needs to have in order to be included\n   * @param spare a chars scratch\n   * @return a collection of spelling corrections sorted by <code>ScoreTerm</code>'s natural order.\n   * @throws IOException If I/O related errors occur\n   */\n  protected Collection<ScoreTerm> suggestSimilar(Term term, int numSug, IndexReader ir, int docfreq, int editDistance,\n                                                 float accuracy, final CharsRef spare) throws IOException {\n    \n    AttributeSource atts = new AttributeSource();\n    MaxNonCompetitiveBoostAttribute maxBoostAtt =\n      atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);\n    Terms terms = MultiFields.getTerms(ir, term.field());\n    if (terms == null) {\n      return Collections.emptyList();\n    }\n    FuzzyTermsEnum e = new FuzzyTermsEnum(terms, atts, term, editDistance, Math.max(minPrefix, editDistance-1), true);\n    final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<>();\n    \n    BytesRef queryTerm = new BytesRef(term.text());\n    BytesRef candidateTerm;\n    ScoreTerm st = new ScoreTerm();\n    BoostAttribute boostAtt =\n      e.attributes().addAttribute(BoostAttribute.class);\n    while ((candidateTerm = e.next()) != null) {\n      final float boost = boostAtt.getBoost();\n      // ignore uncompetitive hits\n      if (stQueue.size() >= numSug && boost <= stQueue.peek().boost)\n        continue;\n      \n      // ignore exact match of the same term\n      if (queryTerm.bytesEquals(candidateTerm))\n        continue;\n      \n      int df = e.docFreq();\n      \n      // check docFreq if required\n      if (df <= docfreq)\n        continue;\n      \n      final float score;\n      final String termAsString;\n      if (distance == INTERNAL_LEVENSHTEIN) {\n        // delay creating strings until the end\n        termAsString = null;\n        // undo FuzzyTermsEnum's scale factor for a real scaled lev score\n        score = boost / e.getScaleFactor() + e.getMinSimilarity();\n      } else {\n        UnicodeUtil.UTF8toUTF16(candidateTerm, spare);\n        termAsString = spare.toString();\n        score = distance.getDistance(term.text(), termAsString);\n      }\n      \n      if (score < accuracy)\n        continue;\n      \n      // add new entry in PQ\n      st.term = BytesRef.deepCopyOf(candidateTerm);\n      st.boost = boost;\n      st.docfreq = df;\n      st.termAsString = termAsString;\n      st.score = score;\n      stQueue.offer(st);\n      // possibly drop entries from queue\n      st = (stQueue.size() > numSug) ? stQueue.poll() : new ScoreTerm();\n      maxBoostAtt.setMaxNonCompetitiveBoost((stQueue.size() >= numSug) ? stQueue.peek().boost : Float.NEGATIVE_INFINITY);\n    }\n      \n    return stQueue;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["41b45c1354293d442c7ae1d25b611b5e7c4f73d1"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"41b45c1354293d442c7ae1d25b611b5e7c4f73d1":["c20f636a5e90cf0d26ad89a6d2de37d8f3403247"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["b89678825b68eccaf09e6ab71675fc0b0af1e099","41b45c1354293d442c7ae1d25b611b5e7c4f73d1"],"c20f636a5e90cf0d26ad89a6d2de37d8f3403247":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["c4015cd39dff8d4dec562d909f9766debac53aa6","c20f636a5e90cf0d26ad89a6d2de37d8f3403247"],"41b45c1354293d442c7ae1d25b611b5e7c4f73d1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","c4015cd39dff8d4dec562d909f9766debac53aa6"],"c4015cd39dff8d4dec562d909f9766debac53aa6":[],"c20f636a5e90cf0d26ad89a6d2de37d8f3403247":["41b45c1354293d442c7ae1d25b611b5e7c4f73d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c4015cd39dff8d4dec562d909f9766debac53aa6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}