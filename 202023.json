{"path":"lucene/src/java/org/apache/lucene/index/codecs/FixedGapTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","commits":[{"id":"99cf56f3a650b908f7017a72f9d23940418f8a52","date":1284891529,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/FixedGapTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/standard/SimpleStandardTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n              upto++;\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n              upto++;\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":1,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/FixedGapTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/standard/SimpleStandardTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n              upto++;\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n              upto++;\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56da903869515527852ee21ea7ef7bfe414cd40d","date":1294224724,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/FixedGapTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n              upto++;\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":4,"author":"Simon Willnauer","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/FixedGapTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":null,"sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n              upto++;\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/FixedGapTermsIndexReader.FieldIndexReader.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":null,"sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n              upto++;\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["99cf56f3a650b908f7017a72f9d23940418f8a52","56da903869515527852ee21ea7ef7bfe414cd40d"],"56da903869515527852ee21ea7ef7bfe414cd40d":["99cf56f3a650b908f7017a72f9d23940418f8a52"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","99cf56f3a650b908f7017a72f9d23940418f8a52"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","56da903869515527852ee21ea7ef7bfe414cd40d"],"99cf56f3a650b908f7017a72f9d23940418f8a52":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["56da903869515527852ee21ea7ef7bfe414cd40d"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":[],"56da903869515527852ee21ea7ef7bfe414cd40d":["70ad682703b8585f5d0a637efec044d57ec05efb","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","99cf56f3a650b908f7017a72f9d23940418f8a52"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"99cf56f3a650b908f7017a72f9d23940418f8a52":["70ad682703b8585f5d0a637efec044d57ec05efb","56da903869515527852ee21ea7ef7bfe414cd40d","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["70ad682703b8585f5d0a637efec044d57ec05efb","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}