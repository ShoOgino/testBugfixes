{"path":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,String,SolrQueryRequest).mjava","commits":[{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,String,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(StoredDocument,String,SolrQueryRequest).mjava","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, String fieldName, SolrQueryRequest req) {\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(StoredDocument doc, String fieldName, SolrQueryRequest req) {\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n    StorableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (StorableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1807cf7ff48453a48bc28608f557e16b6a1f7fa8","date":1464474872,"type":5,"author":"Jan HÃ¸ydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,String,SolrQueryRequest).mjava","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, String fieldName, SolrQueryRequest req) {\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da8a02bef7458089240404614139b53c9f875ec7","date":1464597207,"type":5,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,String,SolrQueryRequest).mjava","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true) && !alternateField.equals(fieldName)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, String fieldName, SolrQueryRequest req) {\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b8ee93140fd0efef7e101786e3ed5160a700b5f","date":1464820111,"type":5,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,int,String,FvhContainer,Query,IndexReader,SolrQueryRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,String,SolrQueryRequest).mjava","sourceNew":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, int docId, String fieldName, FvhContainer fvhContainer, Query query,\n                                  IndexReader reader, SolrQueryRequest req) throws IOException {\n    IndexSchema schema = req.getSearcher().getSchema();\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n\n    if (params.getFieldBool(fieldName, HighlightParams.HIGHLIGHT_ALTERNATE, true) && !alternateField.equals(fieldName)) {\n      // Try to highlight alternate field\n      Object fieldHighlights = null;\n      SchemaField schemaField = schema.getFieldOrNull(alternateField);\n      if (schemaField != null) {\n        HashMap<String, String> invariants = new HashMap<>();\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.SNIPPETS, \"1\");\n        // Enforce maxAlternateFieldLength by FRAGSIZE. Minimum 18 due to FVH limitations\n        invariants.put(\"f.\" + alternateField + \".\" + HighlightParams.FRAGSIZE,\n            alternateFieldLen > 0 ? String.valueOf(Math.max(18, alternateFieldLen)) : String.valueOf(Integer.MAX_VALUE));\n        SolrParams origParams = req.getParams();\n        req.setParams(SolrParams.wrapDefaults(new MapSolrParams(invariants), origParams));\n        fieldHighlights = doHighlightingOfField(doc, docId, schemaField, fvhContainer, query, reader, req, params);\n        req.setParams(origParams);\n        if (fieldHighlights != null) {\n          return fieldHighlights;\n        }\n      }\n    }\n\n\n    // Fallback to static non-highlighted\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","sourceOld":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, String fieldName, SolrQueryRequest req) {\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/highlight/DefaultSolrHighlighter#alternateField(Document,String,SolrQueryRequest).mjava","sourceNew":null,"sourceOld":"  /** Returns the alternate highlight object for this field -- a String[] by default.  Null if none. */\n  @SuppressWarnings(\"unchecked\")\n  protected Object alternateField(Document doc, String fieldName, SolrQueryRequest req) {\n    SolrParams params = req.getParams();\n    String alternateField = params.getFieldParam(fieldName, HighlightParams.ALTERNATE_FIELD);\n    if (alternateField == null || alternateField.length() == 0) {\n      return null;\n    }\n    IndexableField[] docFields = doc.getFields(alternateField);\n    if (docFields.length == 0) {\n      // The alternate field did not exist, treat the original field as fallback instead\n      docFields = doc.getFields(fieldName);\n    }\n    List<String> listFields = new ArrayList<>();\n    for (IndexableField field : docFields) {\n      if (field.binaryValue() == null)\n        listFields.add(field.stringValue());\n    }\n\n    if (listFields.isEmpty()) {\n      return null;\n    }\n    String[] altTexts = listFields.toArray(new String[listFields.size()]);\n\n    Encoder encoder = getEncoder(fieldName, params);\n    int alternateFieldLen = params.getFieldInt(fieldName, HighlightParams.ALTERNATE_FIELD_LENGTH, 0);\n    List<String> altList = new ArrayList<>();\n    int len = 0;\n    for( String altText: altTexts ){\n      if( alternateFieldLen <= 0 ){\n        altList.add(encoder.encodeText(altText));\n      } else{\n        //note: seemingly redundant new String(...) releases memory to the larger text. But is copying better?\n        altList.add( len + altText.length() > alternateFieldLen ?\n            encoder.encodeText(new String(altText.substring( 0, alternateFieldLen - len ))) :\n            encoder.encodeText(altText) );\n        len += altText.length();\n        if( len >= alternateFieldLen ) break;\n      }\n    }\n    return altList;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"da8a02bef7458089240404614139b53c9f875ec7":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","1807cf7ff48453a48bc28608f557e16b6a1f7fa8"],"1807cf7ff48453a48bc28608f557e16b6a1f7fa8":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","1807cf7ff48453a48bc28608f557e16b6a1f7fa8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","1807cf7ff48453a48bc28608f557e16b6a1f7fa8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1807cf7ff48453a48bc28608f557e16b6a1f7fa8"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"da8a02bef7458089240404614139b53c9f875ec7":[],"1807cf7ff48453a48bc28608f557e16b6a1f7fa8":["da8a02bef7458089240404614139b53c9f875ec7","5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["da8a02bef7458089240404614139b53c9f875ec7","1807cf7ff48453a48bc28608f557e16b6a1f7fa8","5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["da8a02bef7458089240404614139b53c9f875ec7","5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}