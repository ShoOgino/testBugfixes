{"path":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","commits":[{"id":"81d0720146de53dd3a4a023d2a3d1089d86d748d","date":1442268215,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      Similarity.SimScorer simScorer = similarity.simScorer(simWeight, context);\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termContexts[i].get(context.ord);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          subScorers.add(new TermScorer(this, postings, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c3119ed4143b91eaf5ac74a4dc4625f5036d472c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3119ed4143b91eaf5ac74a4dc4625f5036d472c","date":1509409932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      Similarity.SimScorer simScorer = null;\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termContexts[i].get(context.ord);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          // lazy init sim, in case no terms exist\n          if (simScorer == null) {\n            simScorer = similarity.simScorer(simWeight, context);\n          }\n          subScorers.add(new TermScorer(this, postings, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      Similarity.SimScorer simScorer = similarity.simScorer(simWeight, context);\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termContexts[i].get(context.ord);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          subScorers.add(new TermScorer(this, postings, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","bugFix":["81d0720146de53dd3a4a023d2a3d1089d86d748d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      Similarity.SimScorer simScorer = null;\n      IndexOptions indexOptions = IndexOptions.NONE;\n      if (terms.length > 0) {\n        FieldInfo info = context.reader()\n            .getFieldInfos()\n            .fieldInfo(terms[0].field());\n        if (info != null) {\n          indexOptions = info.getIndexOptions();\n        }\n      }\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      long maxFreq = 0;\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termContexts[i].get(context.ord);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n\n          maxFreq += getMaxFreq(indexOptions, termsEnum.totalTermFreq(), termsEnum.docFreq());\n\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          // lazy init sim, in case no terms exist\n          if (simScorer == null) {\n            simScorer = similarity.simScorer(simWeight, context);\n          }\n          subScorers.add(new TermScorer(this, postings, simScorer, Float.POSITIVE_INFINITY));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        return new SynonymScorer(simScorer, this, subScorers, maxFreq);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      Similarity.SimScorer simScorer = null;\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termContexts[i].get(context.ord);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          // lazy init sim, in case no terms exist\n          if (simScorer == null) {\n            simScorer = similarity.simScorer(simWeight, context);\n          }\n          subScorers.add(new TermScorer(this, postings, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      Similarity.SimScorer simScorer = null;\n      IndexOptions indexOptions = IndexOptions.NONE;\n      if (terms.length > 0) {\n        FieldInfo info = context.reader()\n            .getFieldInfos()\n            .fieldInfo(terms[0].field());\n        if (info != null) {\n          indexOptions = info.getIndexOptions();\n        }\n      }\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      long maxFreq = 0;\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termContexts[i].get(context.ord);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n\n          maxFreq += getMaxFreq(indexOptions, termsEnum.totalTermFreq(), termsEnum.docFreq());\n\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          // lazy init sim, in case no terms exist\n          if (simScorer == null) {\n            simScorer = similarity.simScorer(simWeight, context);\n          }\n          subScorers.add(new TermScorer(this, postings, simScorer, Float.POSITIVE_INFINITY));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        return new SynonymScorer(simScorer, this, subScorers, maxFreq);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      Similarity.SimScorer simScorer = null;\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termContexts[i].get(context.ord);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          // lazy init sim, in case no terms exist\n          if (simScorer == null) {\n            simScorer = similarity.simScorer(simWeight, context);\n          }\n          subScorers.add(new TermScorer(this, postings, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68d6cb7f0f019661a784bd0e5a21e85b5f812af6","date":1515075216,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      IndexOptions indexOptions = IndexOptions.NONE;\n      if (terms.length > 0) {\n        FieldInfo info = context.reader()\n            .getFieldInfos()\n            .fieldInfo(terms[0].field());\n        if (info != null) {\n          indexOptions = info.getIndexOptions();\n        }\n      }\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      long totalMaxFreq = 0;\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termContexts[i].get(context.ord);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          long termMaxFreq = getMaxFreq(indexOptions, termsEnum.totalTermFreq(), termsEnum.docFreq());\n          totalMaxFreq += termMaxFreq;\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, termMaxFreq);\n          subScorers.add(new TermScorer(this, postings, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, totalMaxFreq);\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      Similarity.SimScorer simScorer = null;\n      IndexOptions indexOptions = IndexOptions.NONE;\n      if (terms.length > 0) {\n        FieldInfo info = context.reader()\n            .getFieldInfos()\n            .fieldInfo(terms[0].field());\n        if (info != null) {\n          indexOptions = info.getIndexOptions();\n        }\n      }\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      long maxFreq = 0;\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termContexts[i].get(context.ord);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n\n          maxFreq += getMaxFreq(indexOptions, termsEnum.totalTermFreq(), termsEnum.docFreq());\n\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          // lazy init sim, in case no terms exist\n          if (simScorer == null) {\n            simScorer = similarity.simScorer(simWeight, context);\n          }\n          subScorers.add(new TermScorer(this, postings, simScorer, Float.POSITIVE_INFINITY));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        return new SynonymScorer(simScorer, this, subScorers, maxFreq);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6e9f769521480a623f897c0d59089b919fa4239","date":1515161835,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      IndexOptions indexOptions = IndexOptions.NONE;\n      if (terms.length > 0) {\n        FieldInfo info = context.reader()\n            .getFieldInfos()\n            .fieldInfo(terms[0].field());\n        if (info != null) {\n          indexOptions = info.getIndexOptions();\n        }\n      }\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      long totalMaxFreq = 0;\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termStates[i].get(context);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          long termMaxFreq = getMaxFreq(indexOptions, termsEnum.totalTermFreq(), termsEnum.docFreq());\n          totalMaxFreq += termMaxFreq;\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, termMaxFreq);\n          subScorers.add(new TermScorer(this, postings, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, totalMaxFreq);\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      IndexOptions indexOptions = IndexOptions.NONE;\n      if (terms.length > 0) {\n        FieldInfo info = context.reader()\n            .getFieldInfos()\n            .fieldInfo(terms[0].field());\n        if (info != null) {\n          indexOptions = info.getIndexOptions();\n        }\n      }\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      long totalMaxFreq = 0;\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termContexts[i].get(context.ord);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          long termMaxFreq = getMaxFreq(indexOptions, termsEnum.totalTermFreq(), termsEnum.docFreq());\n          totalMaxFreq += termMaxFreq;\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, termMaxFreq);\n          subScorers.add(new TermScorer(this, postings, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, totalMaxFreq);\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      IndexOptions indexOptions = IndexOptions.NONE;\n      if (terms.length > 0) {\n        FieldInfo info = context.reader()\n            .getFieldInfos()\n            .fieldInfo(terms[0].field());\n        if (info != null) {\n          indexOptions = info.getIndexOptions();\n        }\n      }\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      long totalMaxFreq = 0;\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termStates[i].get(context);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          long termMaxFreq = getMaxFreq(indexOptions, termsEnum.totalTermFreq(), termsEnum.docFreq());\n          totalMaxFreq += termMaxFreq;\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, termMaxFreq);\n          subScorers.add(new TermScorer(this, postings, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, totalMaxFreq);\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      Similarity.SimScorer simScorer = null;\n      IndexOptions indexOptions = IndexOptions.NONE;\n      if (terms.length > 0) {\n        FieldInfo info = context.reader()\n            .getFieldInfos()\n            .fieldInfo(terms[0].field());\n        if (info != null) {\n          indexOptions = info.getIndexOptions();\n        }\n      }\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      long maxFreq = 0;\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termContexts[i].get(context.ord);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n\n          maxFreq += getMaxFreq(indexOptions, termsEnum.totalTermFreq(), termsEnum.docFreq());\n\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          // lazy init sim, in case no terms exist\n          if (simScorer == null) {\n            simScorer = similarity.simScorer(simWeight, context);\n          }\n          subScorers.add(new TermScorer(this, postings, simScorer, Float.POSITIVE_INFINITY));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        return new SynonymScorer(simScorer, this, subScorers, maxFreq);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"622a708571e534680618b3c5e0c28ac539a47776","date":1517406892,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      IndexOptions indexOptions = IndexOptions.NONE;\n      if (terms.length > 0) {\n        FieldInfo info = context.reader()\n            .getFieldInfos()\n            .fieldInfo(terms[0].field());\n        if (info != null) {\n          indexOptions = info.getIndexOptions();\n        }\n      }\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      long totalMaxFreq = 0;\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termStates[i].get(context);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          long termMaxFreq = getMaxFreq(indexOptions, termsEnum.totalTermFreq(), termsEnum.docFreq());\n          totalMaxFreq += termMaxFreq;\n          LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, termMaxFreq);\n          subScorers.add(new TermScorer(this, termsEnum, ScoreMode.COMPLETE, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, totalMaxFreq);\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      IndexOptions indexOptions = IndexOptions.NONE;\n      if (terms.length > 0) {\n        FieldInfo info = context.reader()\n            .getFieldInfos()\n            .fieldInfo(terms[0].field());\n        if (info != null) {\n          indexOptions = info.getIndexOptions();\n        }\n      }\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      long totalMaxFreq = 0;\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termStates[i].get(context);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          long termMaxFreq = getMaxFreq(indexOptions, termsEnum.totalTermFreq(), termsEnum.docFreq());\n          totalMaxFreq += termMaxFreq;\n          PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);\n          LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, termMaxFreq);\n          subScorers.add(new TermScorer(this, postings, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, totalMaxFreq);\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6ea90bc076fbe82be472db33fc80b00eb0bff44f","date":1526486036,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termStates[i].get(context);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), terms[0].field(), true);\n          subScorers.add(new TermScorer(this, termsEnum, ScoreMode.COMPLETE, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), terms[0].field(), true);\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      IndexOptions indexOptions = IndexOptions.NONE;\n      if (terms.length > 0) {\n        FieldInfo info = context.reader()\n            .getFieldInfos()\n            .fieldInfo(terms[0].field());\n        if (info != null) {\n          indexOptions = info.getIndexOptions();\n        }\n      }\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      long totalMaxFreq = 0;\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termStates[i].get(context);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          long termMaxFreq = getMaxFreq(indexOptions, termsEnum.totalTermFreq(), termsEnum.docFreq());\n          totalMaxFreq += termMaxFreq;\n          LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, termMaxFreq);\n          subScorers.add(new TermScorer(this, termsEnum, ScoreMode.COMPLETE, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), true, totalMaxFreq);\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2f2c13220a828a78007cedb364e22dd8986ed650","date":1527233410,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      List<PostingsEnum> iterators = new ArrayList<>();\n      List<ImpactsEnum> impacts = new ArrayList<>();\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termStates[i].get(context);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          if (scoreMode == ScoreMode.TOP_SCORES) {\n            ImpactsEnum impactsEnum = termsEnum.impacts(PostingsEnum.FREQS);\n            iterators.add(impactsEnum);\n            impacts.add(impactsEnum);\n          } else {\n            PostingsEnum postingsEnum = termsEnum.postings(null, PostingsEnum.FREQS);\n            iterators.add(postingsEnum);\n            impacts.add(new SlowImpactsEnum(postingsEnum));\n          }\n        }\n      }\n\n      if (iterators.isEmpty()) {\n        return null;\n      }\n\n      LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), terms[0].field(), true);\n\n      // we must optimize this case (term not in segment), disjunctions require >= 2 subs\n      if (iterators.size() == 1) {\n        if (scoreMode == ScoreMode.TOP_SCORES) {\n          return new TermScorer(this, impacts.get(0), simScorer);\n        } else {\n          return new TermScorer(this, iterators.get(0), simScorer);\n        }\n      }\n\n      // we use termscorers + disjunction as an impl detail\n      DisiPriorityQueue queue = new DisiPriorityQueue(iterators.size());\n      for (PostingsEnum postings : iterators) {\n        queue.add(new DisiWrapper(new TermScorer(this, postings, simScorer)));\n      }\n      // Even though it is called approximation, it is accurate since none of\n      // the sub iterators are two-phase iterators.\n      DocIdSetIterator iterator = new DisjunctionDISIApproximation(queue);\n\n      ImpactsSource impactsSource = mergeImpacts(impacts.toArray(new ImpactsEnum[0]));\n      ImpactsDISI impactsDisi = new ImpactsDISI(iterator, impactsSource, simScorer.getSimScorer());\n\n      if (scoreMode == ScoreMode.TOP_SCORES) {\n        iterator = impactsDisi;\n      }\n\n      return new SynonymScorer(this, queue, iterator, impactsDisi, simScorer);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      // we use termscorers + disjunction as an impl detail\n      List<Scorer> subScorers = new ArrayList<>();\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termStates[i].get(context);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), terms[0].field(), true);\n          subScorers.add(new TermScorer(this, termsEnum, ScoreMode.COMPLETE, simScorer));\n        }\n      }\n      if (subScorers.isEmpty()) {\n        return null;\n      } else if (subScorers.size() == 1) {\n        // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs\n        return subScorers.get(0);\n      } else {\n        LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), terms[0].field(), true);\n        return new SynonymScorer(simScorer, this, subScorers);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df25592b82060bc1c800e87bf019444bf0ddf9d4","date":1552296011,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/SynonymQuery.SynonymWeight#scorer(LeafReaderContext).mjava","sourceNew":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      List<PostingsEnum> iterators = new ArrayList<>();\n      List<ImpactsEnum> impacts = new ArrayList<>();\n      List<Float> termBoosts = new ArrayList<> ();\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termStates[i].get(context);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].term.field()).iterator();\n          termsEnum.seekExact(terms[i].term.bytes(), state);\n          if (scoreMode == ScoreMode.TOP_SCORES) {\n            ImpactsEnum impactsEnum = termsEnum.impacts(PostingsEnum.FREQS);\n            iterators.add(impactsEnum);\n            impacts.add(impactsEnum);\n          } else {\n            PostingsEnum postingsEnum = termsEnum.postings(null, PostingsEnum.FREQS);\n            iterators.add(postingsEnum);\n            impacts.add(new SlowImpactsEnum(postingsEnum));\n          }\n          termBoosts.add(terms[i].boost);\n        }\n      }\n\n      if (iterators.isEmpty()) {\n        return null;\n      }\n\n      LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), terms[0].term.field(), true);\n\n      // we must optimize this case (term not in segment), disjunctions require >= 2 subs\n      if (iterators.size() == 1) {\n        final TermScorer scorer;\n        if (scoreMode == ScoreMode.TOP_SCORES) {\n          scorer = new TermScorer(this, impacts.get(0), simScorer);\n        } else {\n          scorer = new TermScorer(this, iterators.get(0), simScorer);\n        }\n        float boost = termBoosts.get(0);\n        return scoreMode == ScoreMode.COMPLETE_NO_SCORES || boost == 1f ? scorer : new FreqBoostTermScorer(boost, scorer, simScorer);\n      }\n\n      // we use termscorers + disjunction as an impl detail\n      DisiPriorityQueue queue = new DisiPriorityQueue(iterators.size());\n      for (int i = 0; i < iterators.size(); i++) {\n        PostingsEnum postings = iterators.get(i);\n        final TermScorer termScorer = new TermScorer(this, postings, simScorer);\n        float boost = termBoosts.get(i);\n        final DisiWrapperFreq wrapper = new DisiWrapperFreq(termScorer, boost);\n        queue.add(wrapper);\n      }\n      // Even though it is called approximation, it is accurate since none of\n      // the sub iterators are two-phase iterators.\n      DocIdSetIterator iterator = new DisjunctionDISIApproximation(queue);\n\n      float[] boosts = new float[impacts.size()];\n      for (int i = 0; i < boosts.length; i++) {\n        boosts[i] = termBoosts.get(i);\n      }\n      ImpactsSource impactsSource = mergeImpacts(impacts.toArray(new ImpactsEnum[0]), boosts);\n      ImpactsDISI impactsDisi = new ImpactsDISI(iterator, impactsSource, simScorer.getSimScorer());\n\n      if (scoreMode == ScoreMode.TOP_SCORES) {\n        iterator = impactsDisi;\n      }\n\n      return new SynonymScorer(this, queue, iterator, impactsDisi, simScorer);\n    }\n\n","sourceOld":"    @Override\n    public Scorer scorer(LeafReaderContext context) throws IOException {\n      List<PostingsEnum> iterators = new ArrayList<>();\n      List<ImpactsEnum> impacts = new ArrayList<>();\n      for (int i = 0; i < terms.length; i++) {\n        TermState state = termStates[i].get(context);\n        if (state != null) {\n          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();\n          termsEnum.seekExact(terms[i].bytes(), state);\n          if (scoreMode == ScoreMode.TOP_SCORES) {\n            ImpactsEnum impactsEnum = termsEnum.impacts(PostingsEnum.FREQS);\n            iterators.add(impactsEnum);\n            impacts.add(impactsEnum);\n          } else {\n            PostingsEnum postingsEnum = termsEnum.postings(null, PostingsEnum.FREQS);\n            iterators.add(postingsEnum);\n            impacts.add(new SlowImpactsEnum(postingsEnum));\n          }\n        }\n      }\n\n      if (iterators.isEmpty()) {\n        return null;\n      }\n\n      LeafSimScorer simScorer = new LeafSimScorer(simWeight, context.reader(), terms[0].field(), true);\n\n      // we must optimize this case (term not in segment), disjunctions require >= 2 subs\n      if (iterators.size() == 1) {\n        if (scoreMode == ScoreMode.TOP_SCORES) {\n          return new TermScorer(this, impacts.get(0), simScorer);\n        } else {\n          return new TermScorer(this, iterators.get(0), simScorer);\n        }\n      }\n\n      // we use termscorers + disjunction as an impl detail\n      DisiPriorityQueue queue = new DisiPriorityQueue(iterators.size());\n      for (PostingsEnum postings : iterators) {\n        queue.add(new DisiWrapper(new TermScorer(this, postings, simScorer)));\n      }\n      // Even though it is called approximation, it is accurate since none of\n      // the sub iterators are two-phase iterators.\n      DocIdSetIterator iterator = new DisjunctionDISIApproximation(queue);\n\n      ImpactsSource impactsSource = mergeImpacts(impacts.toArray(new ImpactsEnum[0]));\n      ImpactsDISI impactsDisi = new ImpactsDISI(iterator, impactsSource, simScorer.getSimScorer());\n\n      if (scoreMode == ScoreMode.TOP_SCORES) {\n        iterator = impactsDisi;\n      }\n\n      return new SynonymScorer(this, queue, iterator, impactsDisi, simScorer);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["417142ff08fda9cf0b72d5133e63097a166c6458","a6e9f769521480a623f897c0d59089b919fa4239"],"df25592b82060bc1c800e87bf019444bf0ddf9d4":["2f2c13220a828a78007cedb364e22dd8986ed650"],"2f2c13220a828a78007cedb364e22dd8986ed650":["6ea90bc076fbe82be472db33fc80b00eb0bff44f"],"81d0720146de53dd3a4a023d2a3d1089d86d748d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"417142ff08fda9cf0b72d5133e63097a166c6458":["c3119ed4143b91eaf5ac74a4dc4625f5036d472c","9fc47cb7b4346802411bb432f501ed0673d7119e"],"68d6cb7f0f019661a784bd0e5a21e85b5f812af6":["417142ff08fda9cf0b72d5133e63097a166c6458"],"a6e9f769521480a623f897c0d59089b919fa4239":["68d6cb7f0f019661a784bd0e5a21e85b5f812af6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"622a708571e534680618b3c5e0c28ac539a47776":["b94236357aaa22b76c10629851fe4e376e0cea82"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["c3119ed4143b91eaf5ac74a4dc4625f5036d472c"],"6ea90bc076fbe82be472db33fc80b00eb0bff44f":["622a708571e534680618b3c5e0c28ac539a47776"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["df25592b82060bc1c800e87bf019444bf0ddf9d4"],"c3119ed4143b91eaf5ac74a4dc4625f5036d472c":["81d0720146de53dd3a4a023d2a3d1089d86d748d"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["622a708571e534680618b3c5e0c28ac539a47776"],"df25592b82060bc1c800e87bf019444bf0ddf9d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2f2c13220a828a78007cedb364e22dd8986ed650":["df25592b82060bc1c800e87bf019444bf0ddf9d4"],"81d0720146de53dd3a4a023d2a3d1089d86d748d":["c3119ed4143b91eaf5ac74a4dc4625f5036d472c"],"417142ff08fda9cf0b72d5133e63097a166c6458":["b94236357aaa22b76c10629851fe4e376e0cea82","68d6cb7f0f019661a784bd0e5a21e85b5f812af6"],"68d6cb7f0f019661a784bd0e5a21e85b5f812af6":["a6e9f769521480a623f897c0d59089b919fa4239"],"a6e9f769521480a623f897c0d59089b919fa4239":["b94236357aaa22b76c10629851fe4e376e0cea82"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["81d0720146de53dd3a4a023d2a3d1089d86d748d"],"622a708571e534680618b3c5e0c28ac539a47776":["6ea90bc076fbe82be472db33fc80b00eb0bff44f"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"6ea90bc076fbe82be472db33fc80b00eb0bff44f":["2f2c13220a828a78007cedb364e22dd8986ed650"],"c3119ed4143b91eaf5ac74a4dc4625f5036d472c":["417142ff08fda9cf0b72d5133e63097a166c6458","9fc47cb7b4346802411bb432f501ed0673d7119e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}