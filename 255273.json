{"path":"lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsCollectorTest#beforeClassCountingFacetsCollectorTest().mjava","commits":[{"id":"f96e4a056f7ee1bafbfb8a06c5bd93f7708e560d","date":1358784296,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsCollectorTest#beforeClassCountingFacetsCollectorTest().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  public static void beforeClassCountingFacetsCollectorTest() throws Exception {\n    indexDir = newDirectory();\n    taxoDir = newDirectory();\n    \n    // create an index which has:\n    // 1. Segment with no categories, but matching results\n    // 2. Segment w/ categories, but no results\n    // 3. Segment w/ categories and results\n    // 4. Segment w/ categories, but only some results\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges, so we can control the index segments\n    IndexWriter indexWriter = new IndexWriter(indexDir, conf);\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    \n    allExpectedCounts = newCounts();\n    termExpectedCounts = newCounts();\n    \n    // segment w/ no categories\n    indexDocsNoFacets(indexWriter);\n\n    // segment w/ categories, no content\n    indexDocsWithFacetsNoTerms(indexWriter, taxoWriter, allExpectedCounts);\n\n    // segment w/ categories and content\n    indexDocsWithFacetsAndTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // segment w/ categories and some content\n    indexDocsWithFacetsAndSomeTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // set num children indexed from each dimension\n    for (CategoryPath cp : CATEGORIES_A) {\n      if (termExpectedCounts.get(cp) > 0) {\n        ++numChildrenIndexedA;\n      }\n    }\n    for (CategoryPath cp : CATEGORIES_B) {\n      if (termExpectedCounts.get(cp) > 0) {\n        ++numChildrenIndexedB;\n      }\n    }\n    \n    IOUtils.close(indexWriter, taxoWriter);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"07155cdd910937cdf6877e48884d5782845c8b8b","date":1358796205,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsCollectorTest#beforeClassCountingFacetsCollectorTest().mjava","pathOld":"/dev/null","sourceNew":"  @BeforeClass\n  public static void beforeClassCountingFacetsCollectorTest() throws Exception {\n    indexDir = newDirectory();\n    taxoDir = newDirectory();\n    \n    // create an index which has:\n    // 1. Segment with no categories, but matching results\n    // 2. Segment w/ categories, but no results\n    // 3. Segment w/ categories and results\n    // 4. Segment w/ categories, but only some results\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges, so we can control the index segments\n    IndexWriter indexWriter = new IndexWriter(indexDir, conf);\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    \n    allExpectedCounts = newCounts();\n    termExpectedCounts = newCounts();\n    \n    // segment w/ no categories\n    indexDocsNoFacets(indexWriter);\n\n    // segment w/ categories, no content\n    indexDocsWithFacetsNoTerms(indexWriter, taxoWriter, allExpectedCounts);\n\n    // segment w/ categories and content\n    indexDocsWithFacetsAndTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // segment w/ categories and some content\n    indexDocsWithFacetsAndSomeTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // set num children indexed from each dimension\n    for (CategoryPath cp : CATEGORIES_A) {\n      if (termExpectedCounts.get(cp) > 0) {\n        ++numChildrenIndexedA;\n      }\n    }\n    for (CategoryPath cp : CATEGORIES_B) {\n      if (termExpectedCounts.get(cp) > 0) {\n        ++numChildrenIndexedB;\n      }\n    }\n    \n    IOUtils.close(indexWriter, taxoWriter);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc0a6cdc2cfb2407dce68d524fb63993c0209a2d","date":1359020450,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsCollectorTest#beforeClassCountingFacetsCollectorTest().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsCollectorTest#beforeClassCountingFacetsCollectorTest().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClassCountingFacetsCollectorTest() throws Exception {\n    indexDir = newDirectory();\n    taxoDir = newDirectory();\n    \n    // create an index which has:\n    // 1. Segment with no categories, but matching results\n    // 2. Segment w/ categories, but no results\n    // 3. Segment w/ categories and results\n    // 4. Segment w/ categories, but only some results\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges, so we can control the index segments\n    IndexWriter indexWriter = new IndexWriter(indexDir, conf);\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    CategoryListParams allParents = new CategoryListParams();\n    CategoryListParams noParents = new CategoryListParams(\"no_parents\") {\n      @Override\n      public OrdinalPolicy getOrdinalPolicy() {\n        return OrdinalPolicy.NO_PARENTS;\n      }\n    };\n    Map<CategoryPath,CategoryListParams> params = new HashMap<CategoryPath,CategoryListParams>();\n    params.put(CP_A, allParents);\n    params.put(CP_B, allParents);\n    params.put(CP_C, noParents);\n    params.put(CP_D, noParents);\n    fip = new PerDimensionIndexingParams(params);\n    \n    allExpectedCounts = newCounts();\n    termExpectedCounts = newCounts();\n    \n    // segment w/ no categories\n    indexDocsNoFacets(indexWriter);\n\n    // segment w/ categories, no content\n    indexDocsWithFacetsNoTerms(indexWriter, taxoWriter, allExpectedCounts);\n\n    // segment w/ categories and content\n    indexDocsWithFacetsAndTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // segment w/ categories and some content\n    indexDocsWithFacetsAndSomeTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    IOUtils.close(indexWriter, taxoWriter);\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClassCountingFacetsCollectorTest() throws Exception {\n    indexDir = newDirectory();\n    taxoDir = newDirectory();\n    \n    // create an index which has:\n    // 1. Segment with no categories, but matching results\n    // 2. Segment w/ categories, but no results\n    // 3. Segment w/ categories and results\n    // 4. Segment w/ categories, but only some results\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges, so we can control the index segments\n    IndexWriter indexWriter = new IndexWriter(indexDir, conf);\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    \n    allExpectedCounts = newCounts();\n    termExpectedCounts = newCounts();\n    \n    // segment w/ no categories\n    indexDocsNoFacets(indexWriter);\n\n    // segment w/ categories, no content\n    indexDocsWithFacetsNoTerms(indexWriter, taxoWriter, allExpectedCounts);\n\n    // segment w/ categories and content\n    indexDocsWithFacetsAndTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // segment w/ categories and some content\n    indexDocsWithFacetsAndSomeTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // set num children indexed from each dimension\n    for (CategoryPath cp : CATEGORIES_A) {\n      if (termExpectedCounts.get(cp) > 0) {\n        ++numChildrenIndexedA;\n      }\n    }\n    for (CategoryPath cp : CATEGORIES_B) {\n      if (termExpectedCounts.get(cp) > 0) {\n        ++numChildrenIndexedB;\n      }\n    }\n    \n    IOUtils.close(indexWriter, taxoWriter);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2d5244a676b83c2d551c3746e8181588ba619e1","date":1359031414,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsCollectorTest#beforeClassCountingFacetsCollectorTest().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsCollectorTest#beforeClassCountingFacetsCollectorTest().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClassCountingFacetsCollectorTest() throws Exception {\n    indexDir = newDirectory();\n    taxoDir = newDirectory();\n    \n    // create an index which has:\n    // 1. Segment with no categories, but matching results\n    // 2. Segment w/ categories, but no results\n    // 3. Segment w/ categories and results\n    // 4. Segment w/ categories, but only some results\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges, so we can control the index segments\n    IndexWriter indexWriter = new IndexWriter(indexDir, conf);\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    CategoryListParams allParents = new CategoryListParams();\n    CategoryListParams noParents = new CategoryListParams(\"no_parents\") {\n      @Override\n      public OrdinalPolicy getOrdinalPolicy() {\n        return OrdinalPolicy.NO_PARENTS;\n      }\n    };\n    Map<CategoryPath,CategoryListParams> params = new HashMap<CategoryPath,CategoryListParams>();\n    params.put(CP_A, allParents);\n    params.put(CP_B, allParents);\n    params.put(CP_C, noParents);\n    params.put(CP_D, noParents);\n    fip = new PerDimensionIndexingParams(params);\n    \n    allExpectedCounts = newCounts();\n    termExpectedCounts = newCounts();\n    \n    // segment w/ no categories\n    indexDocsNoFacets(indexWriter);\n\n    // segment w/ categories, no content\n    indexDocsWithFacetsNoTerms(indexWriter, taxoWriter, allExpectedCounts);\n\n    // segment w/ categories and content\n    indexDocsWithFacetsAndTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // segment w/ categories and some content\n    indexDocsWithFacetsAndSomeTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    IOUtils.close(indexWriter, taxoWriter);\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClassCountingFacetsCollectorTest() throws Exception {\n    indexDir = newDirectory();\n    taxoDir = newDirectory();\n    \n    // create an index which has:\n    // 1. Segment with no categories, but matching results\n    // 2. Segment w/ categories, but no results\n    // 3. Segment w/ categories and results\n    // 4. Segment w/ categories, but only some results\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges, so we can control the index segments\n    IndexWriter indexWriter = new IndexWriter(indexDir, conf);\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    \n    allExpectedCounts = newCounts();\n    termExpectedCounts = newCounts();\n    \n    // segment w/ no categories\n    indexDocsNoFacets(indexWriter);\n\n    // segment w/ categories, no content\n    indexDocsWithFacetsNoTerms(indexWriter, taxoWriter, allExpectedCounts);\n\n    // segment w/ categories and content\n    indexDocsWithFacetsAndTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // segment w/ categories and some content\n    indexDocsWithFacetsAndSomeTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // set num children indexed from each dimension\n    for (CategoryPath cp : CATEGORIES_A) {\n      if (termExpectedCounts.get(cp) > 0) {\n        ++numChildrenIndexedA;\n      }\n    }\n    for (CategoryPath cp : CATEGORIES_B) {\n      if (termExpectedCounts.get(cp) > 0) {\n        ++numChildrenIndexedB;\n      }\n    }\n    \n    IOUtils.close(indexWriter, taxoWriter);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"239f79ed06f0979cfe1911ec5fba32b94fda43c1","date":1359553898,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsCollectorTest#beforeClassCountingFacetsCollectorTest().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsCollectorTest#beforeClassCountingFacetsCollectorTest().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClassCountingFacetsCollectorTest() throws Exception {\n    indexDir = newDirectory();\n    taxoDir = newDirectory();\n    \n    // create an index which has:\n    // 1. Segment with no categories, but matching results\n    // 2. Segment w/ categories, but no results\n    // 3. Segment w/ categories and results\n    // 4. Segment w/ categories, but only some results\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges, so we can control the index segments\n    IndexWriter indexWriter = new IndexWriter(indexDir, conf);\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n\n    Map<String,OrdinalPolicy> policies = new HashMap<String,CategoryListParams.OrdinalPolicy>();\n    policies.put(CP_B.components[0], OrdinalPolicy.ALL_PARENTS);\n    policies.put(CP_C.components[0], OrdinalPolicy.NO_PARENTS);\n    policies.put(CP_D.components[0], OrdinalPolicy.NO_PARENTS);\n    CategoryListParams clp = new PerDimensionOrdinalPolicy(policies);\n    fip = new FacetIndexingParams(clp);\n    \n    allExpectedCounts = newCounts();\n    termExpectedCounts = newCounts();\n    \n    // segment w/ no categories\n    indexDocsNoFacets(indexWriter);\n\n    // segment w/ categories, no content\n    indexDocsWithFacetsNoTerms(indexWriter, taxoWriter, allExpectedCounts);\n\n    // segment w/ categories and content\n    indexDocsWithFacetsAndTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // segment w/ categories and some content\n    indexDocsWithFacetsAndSomeTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    IOUtils.close(indexWriter, taxoWriter);\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClassCountingFacetsCollectorTest() throws Exception {\n    indexDir = newDirectory();\n    taxoDir = newDirectory();\n    \n    // create an index which has:\n    // 1. Segment with no categories, but matching results\n    // 2. Segment w/ categories, but no results\n    // 3. Segment w/ categories and results\n    // 4. Segment w/ categories, but only some results\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges, so we can control the index segments\n    IndexWriter indexWriter = new IndexWriter(indexDir, conf);\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    CategoryListParams allParents = new CategoryListParams();\n    CategoryListParams noParents = new CategoryListParams(\"no_parents\") {\n      @Override\n      public OrdinalPolicy getOrdinalPolicy() {\n        return OrdinalPolicy.NO_PARENTS;\n      }\n    };\n    Map<CategoryPath,CategoryListParams> params = new HashMap<CategoryPath,CategoryListParams>();\n    params.put(CP_A, allParents);\n    params.put(CP_B, allParents);\n    params.put(CP_C, noParents);\n    params.put(CP_D, noParents);\n    fip = new PerDimensionIndexingParams(params);\n    \n    allExpectedCounts = newCounts();\n    termExpectedCounts = newCounts();\n    \n    // segment w/ no categories\n    indexDocsNoFacets(indexWriter);\n\n    // segment w/ categories, no content\n    indexDocsWithFacetsNoTerms(indexWriter, taxoWriter, allExpectedCounts);\n\n    // segment w/ categories and content\n    indexDocsWithFacetsAndTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // segment w/ categories and some content\n    indexDocsWithFacetsAndSomeTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    IOUtils.close(indexWriter, taxoWriter);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61d5f95d14e5b9b046998c51e16709a398c15226","date":1359603451,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsCollectorTest#beforeClassCountingFacetsCollectorTest().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsCollectorTest#beforeClassCountingFacetsCollectorTest().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClassCountingFacetsCollectorTest() throws Exception {\n    indexDir = newDirectory();\n    taxoDir = newDirectory();\n    \n    // create an index which has:\n    // 1. Segment with no categories, but matching results\n    // 2. Segment w/ categories, but no results\n    // 3. Segment w/ categories and results\n    // 4. Segment w/ categories, but only some results\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges, so we can control the index segments\n    IndexWriter indexWriter = new IndexWriter(indexDir, conf);\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n\n    Map<String,OrdinalPolicy> policies = new HashMap<String,CategoryListParams.OrdinalPolicy>();\n    policies.put(CP_B.components[0], OrdinalPolicy.ALL_PARENTS);\n    policies.put(CP_C.components[0], OrdinalPolicy.NO_PARENTS);\n    policies.put(CP_D.components[0], OrdinalPolicy.NO_PARENTS);\n    CategoryListParams clp = new PerDimensionOrdinalPolicy(policies);\n    fip = new FacetIndexingParams(clp);\n    \n    allExpectedCounts = newCounts();\n    termExpectedCounts = newCounts();\n    \n    // segment w/ no categories\n    indexDocsNoFacets(indexWriter);\n\n    // segment w/ categories, no content\n    indexDocsWithFacetsNoTerms(indexWriter, taxoWriter, allExpectedCounts);\n\n    // segment w/ categories and content\n    indexDocsWithFacetsAndTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // segment w/ categories and some content\n    indexDocsWithFacetsAndSomeTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    IOUtils.close(indexWriter, taxoWriter);\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClassCountingFacetsCollectorTest() throws Exception {\n    indexDir = newDirectory();\n    taxoDir = newDirectory();\n    \n    // create an index which has:\n    // 1. Segment with no categories, but matching results\n    // 2. Segment w/ categories, but no results\n    // 3. Segment w/ categories and results\n    // 4. Segment w/ categories, but only some results\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges, so we can control the index segments\n    IndexWriter indexWriter = new IndexWriter(indexDir, conf);\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n    CategoryListParams allParents = new CategoryListParams();\n    CategoryListParams noParents = new CategoryListParams(\"no_parents\") {\n      @Override\n      public OrdinalPolicy getOrdinalPolicy() {\n        return OrdinalPolicy.NO_PARENTS;\n      }\n    };\n    Map<CategoryPath,CategoryListParams> params = new HashMap<CategoryPath,CategoryListParams>();\n    params.put(CP_A, allParents);\n    params.put(CP_B, allParents);\n    params.put(CP_C, noParents);\n    params.put(CP_D, noParents);\n    fip = new PerDimensionIndexingParams(params);\n    \n    allExpectedCounts = newCounts();\n    termExpectedCounts = newCounts();\n    \n    // segment w/ no categories\n    indexDocsNoFacets(indexWriter);\n\n    // segment w/ categories, no content\n    indexDocsWithFacetsNoTerms(indexWriter, taxoWriter, allExpectedCounts);\n\n    // segment w/ categories and content\n    indexDocsWithFacetsAndTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // segment w/ categories and some content\n    indexDocsWithFacetsAndSomeTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    IOUtils.close(indexWriter, taxoWriter);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"571abba77e55fea386a38c0024f72ffa5b37a9ad","date":1360272747,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsAggregatorTest#beforeClassCountingFacetsAggregatorTest().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/search/CountingFacetsCollectorTest#beforeClassCountingFacetsCollectorTest().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClassCountingFacetsAggregatorTest() throws Exception {\n    indexDir = newDirectory();\n    taxoDir = newDirectory();\n    \n    // create an index which has:\n    // 1. Segment with no categories, but matching results\n    // 2. Segment w/ categories, but no results\n    // 3. Segment w/ categories and results\n    // 4. Segment w/ categories, but only some results\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges, so we can control the index segments\n    IndexWriter indexWriter = new IndexWriter(indexDir, conf);\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n\n    Map<String,OrdinalPolicy> policies = new HashMap<String,CategoryListParams.OrdinalPolicy>();\n    policies.put(CP_B.components[0], OrdinalPolicy.ALL_PARENTS);\n    policies.put(CP_C.components[0], OrdinalPolicy.NO_PARENTS);\n    policies.put(CP_D.components[0], OrdinalPolicy.NO_PARENTS);\n    CategoryListParams clp = new PerDimensionOrdinalPolicy(policies);\n    fip = new FacetIndexingParams(clp);\n    \n    allExpectedCounts = newCounts();\n    termExpectedCounts = newCounts();\n    \n    // segment w/ no categories\n    indexDocsNoFacets(indexWriter);\n\n    // segment w/ categories, no content\n    indexDocsWithFacetsNoTerms(indexWriter, taxoWriter, allExpectedCounts);\n\n    // segment w/ categories and content\n    indexDocsWithFacetsAndTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // segment w/ categories and some content\n    indexDocsWithFacetsAndSomeTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    IOUtils.close(indexWriter, taxoWriter);\n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClassCountingFacetsCollectorTest() throws Exception {\n    indexDir = newDirectory();\n    taxoDir = newDirectory();\n    \n    // create an index which has:\n    // 1. Segment with no categories, but matching results\n    // 2. Segment w/ categories, but no results\n    // 3. Segment w/ categories and results\n    // 4. Segment w/ categories, but only some results\n    \n    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    conf.setMergePolicy(NoMergePolicy.COMPOUND_FILES); // prevent merges, so we can control the index segments\n    IndexWriter indexWriter = new IndexWriter(indexDir, conf);\n    TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);\n\n    Map<String,OrdinalPolicy> policies = new HashMap<String,CategoryListParams.OrdinalPolicy>();\n    policies.put(CP_B.components[0], OrdinalPolicy.ALL_PARENTS);\n    policies.put(CP_C.components[0], OrdinalPolicy.NO_PARENTS);\n    policies.put(CP_D.components[0], OrdinalPolicy.NO_PARENTS);\n    CategoryListParams clp = new PerDimensionOrdinalPolicy(policies);\n    fip = new FacetIndexingParams(clp);\n    \n    allExpectedCounts = newCounts();\n    termExpectedCounts = newCounts();\n    \n    // segment w/ no categories\n    indexDocsNoFacets(indexWriter);\n\n    // segment w/ categories, no content\n    indexDocsWithFacetsNoTerms(indexWriter, taxoWriter, allExpectedCounts);\n\n    // segment w/ categories and content\n    indexDocsWithFacetsAndTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    // segment w/ categories and some content\n    indexDocsWithFacetsAndSomeTerms(indexWriter, taxoWriter, allExpectedCounts);\n    \n    IOUtils.close(indexWriter, taxoWriter);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f96e4a056f7ee1bafbfb8a06c5bd93f7708e560d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"61d5f95d14e5b9b046998c51e16709a398c15226":["b2d5244a676b83c2d551c3746e8181588ba619e1","239f79ed06f0979cfe1911ec5fba32b94fda43c1"],"cc0a6cdc2cfb2407dce68d524fb63993c0209a2d":["f96e4a056f7ee1bafbfb8a06c5bd93f7708e560d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"239f79ed06f0979cfe1911ec5fba32b94fda43c1":["cc0a6cdc2cfb2407dce68d524fb63993c0209a2d"],"07155cdd910937cdf6877e48884d5782845c8b8b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f96e4a056f7ee1bafbfb8a06c5bd93f7708e560d"],"571abba77e55fea386a38c0024f72ffa5b37a9ad":["239f79ed06f0979cfe1911ec5fba32b94fda43c1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["571abba77e55fea386a38c0024f72ffa5b37a9ad"],"b2d5244a676b83c2d551c3746e8181588ba619e1":["07155cdd910937cdf6877e48884d5782845c8b8b","cc0a6cdc2cfb2407dce68d524fb63993c0209a2d"]},"commit2Childs":{"f96e4a056f7ee1bafbfb8a06c5bd93f7708e560d":["cc0a6cdc2cfb2407dce68d524fb63993c0209a2d","07155cdd910937cdf6877e48884d5782845c8b8b"],"61d5f95d14e5b9b046998c51e16709a398c15226":[],"cc0a6cdc2cfb2407dce68d524fb63993c0209a2d":["239f79ed06f0979cfe1911ec5fba32b94fda43c1","b2d5244a676b83c2d551c3746e8181588ba619e1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f96e4a056f7ee1bafbfb8a06c5bd93f7708e560d","07155cdd910937cdf6877e48884d5782845c8b8b"],"239f79ed06f0979cfe1911ec5fba32b94fda43c1":["61d5f95d14e5b9b046998c51e16709a398c15226","571abba77e55fea386a38c0024f72ffa5b37a9ad"],"07155cdd910937cdf6877e48884d5782845c8b8b":["b2d5244a676b83c2d551c3746e8181588ba619e1"],"571abba77e55fea386a38c0024f72ffa5b37a9ad":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b2d5244a676b83c2d551c3746e8181588ba619e1":["61d5f95d14e5b9b046998c51e16709a398c15226"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["61d5f95d14e5b9b046998c51e16709a398c15226","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}