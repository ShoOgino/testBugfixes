{"path":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","commits":[{"id":"f56ba5d8fecfb0b8bfdca8c0b630372d998131a9","date":1400353720,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","pathOld":"/dev/null","sourceNew":"  // Stresses out many-terms-in-root-block case:\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = 10000;\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random())));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<10000;termCount++) {\n      System.out.println(\"\\nTEST: termCount=\" + termCount);\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator(null);\n      System.out.println(\"te=\" + te);\n      for(int i=0;i<=termCount;i++) {\n        //System.out.println(\"TEST: lookup (should exist) \" + termsList.get(i));\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        //System.out.println(\"TEST: lookup (should not exist) \" + termsList.get(i));\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.shutdown();\n    }\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19aeadf1fb6c63b76ee4828b087b1ff7256b228","date":1400363857,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","sourceNew":"  // Stresses out many-terms-in-root-block case:\n  @Nightly\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<10000;termCount++) {\n      System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator(null);\n      System.out.println(\"te=\" + te);\n      for(int i=0;i<=termCount;i++) {\n        //System.out.println(\"TEST: lookup (should exist) \" + termsList.get(i));\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        //System.out.println(\"TEST: lookup (should not exist) \" + termsList.get(i));\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.shutdown();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // Stresses out many-terms-in-root-block case:\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = 10000;\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random())));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<10000;termCount++) {\n      System.out.println(\"\\nTEST: termCount=\" + termCount);\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator(null);\n      System.out.println(\"te=\" + te);\n      for(int i=0;i<=termCount;i++) {\n        //System.out.println(\"TEST: lookup (should exist) \" + termsList.get(i));\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        //System.out.println(\"TEST: lookup (should not exist) \" + termsList.get(i));\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.shutdown();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3251bdaf728baf81f779183e464984bc769ed9c7","date":1400494940,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","sourceNew":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator(null);\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.shutdown();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // Stresses out many-terms-in-root-block case:\n  @Nightly\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<10000;termCount++) {\n      System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator(null);\n      System.out.println(\"te=\" + te);\n      for(int i=0;i<=termCount;i++) {\n        //System.out.println(\"TEST: lookup (should exist) \" + termsList.get(i));\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        //System.out.println(\"TEST: lookup (should not exist) \" + termsList.get(i));\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.shutdown();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d637064d608752565d4f9f41b2497dfdfdde50e","date":1400798123,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","pathOld":"/dev/null","sourceNew":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator(null);\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.shutdown();\n    }\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","sourceNew":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator(null);\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.shutdown();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator(null);\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.shutdown();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","sourceNew":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator(null);\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator(null);\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.shutdown();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","sourceNew":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator();\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator(null);\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b","date":1497408244,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","sourceNew":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().terms(\"field\").iterator();\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator();\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","sourceNew":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().terms(\"field\").iterator();\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator();\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","sourceNew":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().terms(\"field\").iterator();\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().fields().terms(\"field\").iterator();\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","date":1579652839,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testVaryingTermsPerSegment().mjava","sourceNew":"  // Stresses out many-terms-in-root-block case:\n  @Nightly\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().terms(\"field\").iterator();\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.close();\n    }\n    dir.close();\n  }\n\n","sourceOld":"  // Stresses out many-terms-in-root-block case:\n  @Slow\n  public void testVaryingTermsPerSegment() throws Exception {\n    Directory dir = newDirectory();\n    Set<BytesRef> terms = new HashSet<BytesRef>();\n    int MAX_TERMS = atLeast(1000);\n    while (terms.size() < MAX_TERMS) {\n      terms.add(new BytesRef(TestUtil.randomSimpleString(random(), 1, 40)));\n    }\n    List<BytesRef> termsList = new ArrayList<>(terms);\n    StringBuilder sb = new StringBuilder();\n    for(int termCount=0;termCount<MAX_TERMS;termCount++) {\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: termCount=\" + termCount + \" add term=\" + termsList.get(termCount).utf8ToString());\n      }\n      sb.append(' ');\n      sb.append(termsList.get(termCount).utf8ToString());\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      iwc.setOpenMode(IndexWriterConfig.OpenMode.CREATE);\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      Document doc = new Document();\n      doc.add(newTextField(\"field\", sb.toString(), Field.Store.NO));\n      w.addDocument(doc);\n      IndexReader r = w.getReader();\n      assertEquals(1, r.leaves().size());\n      TermsEnum te = r.leaves().get(0).reader().terms(\"field\").iterator();\n      for(int i=0;i<=termCount;i++) {\n        assertTrue(\"term '\" + termsList.get(i).utf8ToString() + \"' should exist but doesn't\", te.seekExact(termsList.get(i)));\n      }\n      for(int i=termCount+1;i<termsList.size();i++) {\n        assertFalse(\"term '\" + termsList.get(i) + \"' shouldn't exist but does\", te.seekExact(termsList.get(i)));\n      }\n      r.close();\n      w.close();\n    }\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["28288370235ed02234a64753cdbf0c6ec096304a"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"28288370235ed02234a64753cdbf0c6ec096304a":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b"],"f56ba5d8fecfb0b8bfdca8c0b630372d998131a9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3251bdaf728baf81f779183e464984bc769ed9c7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"e19aeadf1fb6c63b76ee4828b087b1ff7256b228":["f56ba5d8fecfb0b8bfdca8c0b630372d998131a9"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"3251bdaf728baf81f779183e464984bc769ed9c7":["e19aeadf1fb6c63b76ee4828b087b1ff7256b228"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"e588e8c82e32e29ef3837c0b06a2ad34f3c51a2b":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"28288370235ed02234a64753cdbf0c6ec096304a":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"f56ba5d8fecfb0b8bfdca8c0b630372d998131a9":["e19aeadf1fb6c63b76ee4828b087b1ff7256b228"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f56ba5d8fecfb0b8bfdca8c0b630372d998131a9","4d637064d608752565d4f9f41b2497dfdfdde50e"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"e19aeadf1fb6c63b76ee4828b087b1ff7256b228":["3251bdaf728baf81f779183e464984bc769ed9c7"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"3251bdaf728baf81f779183e464984bc769ed9c7":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}