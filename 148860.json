{"path":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","commits":[{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestDimensionalQueries#rectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = DimensionalLatLonField.encodeLat(rect.minLat);\n    int rectLatMaxEnc = DimensionalLatLonField.encodeLat(rect.maxLat);\n    int rectLonMinEnc = DimensionalLatLonField.encodeLon(rect.minLon);\n    int rectLonMaxEnc = DimensionalLatLonField.encodeLon(rect.maxLon);\n\n    int pointLatEnc = DimensionalLatLonField.encodeLat(pointLat);\n    int pointLonEnc = DimensionalLatLonField.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04995b00da1e08edb88b14c5a9789d741de5c51d","date":1453863716,"type":3,"author":"Nick Knize","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    // false positive/negatives due to quantization error exist for both rectangles and polygons\n    if (compare(pointLat, rect.minLat) == 0\n        || compare(pointLat, rect.maxLat) == 0\n        || compare(pointLon, rect.minLon) == 0\n        || compare(pointLon, rect.maxLon) == 0) {\n      return null;\n    }\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    // false positive/negatives due to quantization error exist for both rectangles and polygons\n    if (compare(pointLat, rect.minLat) == 0\n        || compare(pointLat, rect.maxLat) == 0\n        || compare(pointLon, rect.minLon) == 0\n        || compare(pointLon, rect.maxLon) == 0) {\n      return null;\n    }\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2331aada47d7da50e6835b59445dadc1bd456c39","date":1456778709,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc < rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc < rectLonMaxEnc);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    // false positive/negatives due to quantization error exist for both rectangles and polygons\n    if (compare(pointLat, rect.minLat) == 0\n        || compare(pointLat, rect.maxLat) == 0\n        || compare(pointLon, rect.minLon) == 0\n        || compare(pointLon, rect.maxLon) == 0) {\n      return null;\n    }\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","bugFix":null,"bugIntro":["1800b996d8677670482a071dcb7a48b08c423ace"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc < rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc < rectLonMaxEnc);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    // false positive/negatives due to quantization error exist for both rectangles and polygons\n    if (compare(pointLat, rect.minLat) == 0\n        || compare(pointLat, rect.maxLat) == 0\n        || compare(pointLon, rect.minLon) == 0\n        || compare(pointLon, rect.maxLon) == 0) {\n      return null;\n    }\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"94ee361295fb38310ac4d53cb4773d1622423d68","date":1456833885,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLatitude(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLatitude(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLongitude(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLongitude(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLatitude(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLongitude(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc < rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc < rectLonMaxEnc);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc < rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc < rectLonMaxEnc);\n    }\n  }\n\n","bugFix":null,"bugIntro":["3be488b3c9121cfbcdc017c60ad93550b640fb02"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1800b996d8677670482a071dcb7a48b08c423ace","date":1456955558,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLatitude(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLatitude(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLongitude(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLongitude(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLatitude(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLongitude(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLatitude(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLatitude(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLongitude(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLongitude(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLatitude(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLongitude(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc < rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc < rectLonMaxEnc);\n    }\n  }\n\n","bugFix":["2331aada47d7da50e6835b59445dadc1bd456c39"],"bugIntro":["3be488b3c9121cfbcdc017c60ad93550b640fb02"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c422e924212367b334b4938f1fd3e44438e88c40","date":1456962933,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLatitude(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLatitude(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLongitude(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLongitude(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLatitude(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLongitude(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLatitude(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLatitude(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLongitude(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLongitude(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLatitude(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLongitude(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc < rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc < rectLonMaxEnc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLatitude(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLatitude(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLongitude(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLongitude(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLatitude(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLongitude(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLat(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLat(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLon(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLon(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLat(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLon(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc < rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc < rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc < rectLonMaxEnc);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3be488b3c9121cfbcdc017c60ad93550b640fb02","date":1458614851,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    assert Double.isNaN(pointLat) == false;\n\n    if (rect.minLon < rect.maxLon) {\n      return GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, rect.minLon, rect.minLat, rect.maxLon, rect.maxLat);\n    } else {\n      // Rect crosses dateline:\n      return GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, -180.0, rect.minLat, rect.maxLon, rect.maxLat)\n          || GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, rect.minLon, rect.minLat, 180.0, rect.maxLat);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n\n    assert Double.isNaN(pointLat) == false;\n\n    int rectLatMinEnc = LatLonPoint.encodeLatitude(rect.minLat);\n    int rectLatMaxEnc = LatLonPoint.encodeLatitude(rect.maxLat);\n    int rectLonMinEnc = LatLonPoint.encodeLongitude(rect.minLon);\n    int rectLonMaxEnc = LatLonPoint.encodeLongitude(rect.maxLon);\n\n    int pointLatEnc = LatLonPoint.encodeLatitude(pointLat);\n    int pointLonEnc = LatLonPoint.encodeLongitude(pointLon);\n\n    if (rect.minLon < rect.maxLon) {\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        pointLonEnc >= rectLonMinEnc &&\n        pointLonEnc <= rectLonMaxEnc;\n    } else {\n      // Rect crosses dateline:\n      return pointLatEnc >= rectLatMinEnc &&\n        pointLatEnc <= rectLatMaxEnc &&\n        (pointLonEnc >= rectLonMinEnc ||\n         pointLonEnc <= rectLonMaxEnc);\n    }\n  }\n\n","bugFix":["1800b996d8677670482a071dcb7a48b08c423ace","cab7a79353f33d1a94cd307bf33aa5148601ebe6","94ee361295fb38310ac4d53cb4773d1622423d68"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec996bf2daff09d61a876319e8fae4aebbea58e3","date":1458661946,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","sourceNew":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    assert Double.isNaN(pointLat) == false;\n\n    if (rect.minLon < rect.maxLon) {\n      return GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n    } else {\n      // Rect crosses dateline:\n      return GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, -180.0, rect.maxLon)\n        || GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, rect.minLon, 180.0);\n    }\n  }\n\n","sourceOld":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    assert Double.isNaN(pointLat) == false;\n\n    if (rect.minLon < rect.maxLon) {\n      return GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, rect.minLon, rect.minLat, rect.maxLon, rect.maxLat);\n    } else {\n      // Rect crosses dateline:\n      return GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, -180.0, rect.minLat, rect.maxLon, rect.maxLat)\n          || GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, rect.minLon, rect.minLat, 180.0, rect.maxLat);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb4875e9db9b77346c36b7fe0d4b8759a1e095d3","date":1458680048,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries#rectContainsPoint(GeoRect,double,double).mjava","sourceNew":null,"sourceOld":"  @Override\n  protected Boolean rectContainsPoint(GeoRect rect, double pointLat, double pointLon) {\n    assert Double.isNaN(pointLat) == false;\n\n    if (rect.minLon < rect.maxLon) {\n      return GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n    } else {\n      // Rect crosses dateline:\n      return GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, -180.0, rect.maxLon)\n        || GeoRelationUtils.pointInRectPrecise(pointLat, pointLon, rect.minLat, rect.maxLat, rect.minLon, 180.0);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["04995b00da1e08edb88b14c5a9789d741de5c51d","2331aada47d7da50e6835b59445dadc1bd456c39"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["cab7a79353f33d1a94cd307bf33aa5148601ebe6","04995b00da1e08edb88b14c5a9789d741de5c51d"],"2331aada47d7da50e6835b59445dadc1bd456c39":["04995b00da1e08edb88b14c5a9789d741de5c51d"],"c422e924212367b334b4938f1fd3e44438e88c40":["94ee361295fb38310ac4d53cb4773d1622423d68","1800b996d8677670482a071dcb7a48b08c423ace"],"1800b996d8677670482a071dcb7a48b08c423ace":["94ee361295fb38310ac4d53cb4773d1622423d68"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["3be488b3c9121cfbcdc017c60ad93550b640fb02"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"94ee361295fb38310ac4d53cb4773d1622423d68":["2331aada47d7da50e6835b59445dadc1bd456c39"],"3be488b3c9121cfbcdc017c60ad93550b640fb02":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["af2638813028b254a88b418ebeafb541afb49653","c422e924212367b334b4938f1fd3e44438e88c40"],"cb4875e9db9b77346c36b7fe0d4b8759a1e095d3":["ec996bf2daff09d61a876319e8fae4aebbea58e3"],"04995b00da1e08edb88b14c5a9789d741de5c51d":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cb4875e9db9b77346c36b7fe0d4b8759a1e095d3"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","04995b00da1e08edb88b14c5a9789d741de5c51d"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"2331aada47d7da50e6835b59445dadc1bd456c39":["af2638813028b254a88b418ebeafb541afb49653","94ee361295fb38310ac4d53cb4773d1622423d68"],"c422e924212367b334b4938f1fd3e44438e88c40":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"1800b996d8677670482a071dcb7a48b08c423ace":["c422e924212367b334b4938f1fd3e44438e88c40"],"ec996bf2daff09d61a876319e8fae4aebbea58e3":["cb4875e9db9b77346c36b7fe0d4b8759a1e095d3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"94ee361295fb38310ac4d53cb4773d1622423d68":["c422e924212367b334b4938f1fd3e44438e88c40","1800b996d8677670482a071dcb7a48b08c423ace"],"3be488b3c9121cfbcdc017c60ad93550b640fb02":["ec996bf2daff09d61a876319e8fae4aebbea58e3"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["3be488b3c9121cfbcdc017c60ad93550b640fb02"],"cb4875e9db9b77346c36b7fe0d4b8759a1e095d3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"04995b00da1e08edb88b14c5a9789d741de5c51d":["af2638813028b254a88b418ebeafb541afb49653","1e6acbaae7af722f17204ceccf0f7db5753eccf3","2331aada47d7da50e6835b59445dadc1bd456c39"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}