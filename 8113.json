{"path":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"33d0ed80b7b47e34ad3ff033a77544563aba3085","date":1341244632,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n\n    Integer numReplicas = req.getParams().getInt(\"numReplicas\", 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(\"numShards\");\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, \"numReplicas\", numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, \"numShards\", numShards);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["09b9c829f1aea668186008f85f674952a4c091ea","aa16b24e8441c80ef7c503119e979670698c7233"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8512200aed2724abd80dbeb686d3412d537b7d8a","date":1342139754,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(\"numReplicas\", 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(\"numShards\");\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, \"numReplicas\", numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, \"numShards\", numShards);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n\n    Integer numReplicas = req.getParams().getInt(\"numReplicas\", 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(\"numShards\");\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, \"numReplicas\", numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, \"numShards\", numShards);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(\"numReplicas\", 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(\"numShards\");\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, \"numReplicas\", numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, \"numShards\", numShards);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(\"numReplicas\", 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(\"numShards\");\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, \"numReplicas\", numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, \"numShards\", numShards);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n\n    Integer numReplicas = req.getParams().getInt(\"numReplicas\", 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(\"numShards\");\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, \"numReplicas\", numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, \"numShards\", numShards);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa16b24e8441c80ef7c503119e979670698c7233","date":1347735556,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(\"numShards\");\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, \"numShards\", numShards);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(\"numReplicas\", 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(\"numShards\");\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, \"numReplicas\", numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, \"numShards\", numShards);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","bugFix":["33d0ed80b7b47e34ad3ff033a77544563aba3085"],"bugIntro":["09b9c829f1aea668186008f85f674952a4c091ea","ccf4d8c4536f02247aec7edc26a89e19c5c05dd4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c215736a9e29403edd2132d9f0829a287b428df4","date":1354641965,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, OverseerCollectionProcessor.NUM_SLICES, numShards, OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(\"numShards\");\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, \"numShards\", numShards);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","bugFix":null,"bugIntro":["09b9c829f1aea668186008f85f674952a4c091ea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, OverseerCollectionProcessor.NUM_SLICES, numShards, OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(\"numShards\");\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, \"numShards\", numShards);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ccf4d8c4536f02247aec7edc26a89e19c5c05dd4","date":1355167764,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, OverseerCollectionProcessor.NUM_SLICES, numShards, OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, OverseerCollectionProcessor.NUM_SLICES, numShards, OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","bugFix":["aa16b24e8441c80ef7c503119e979670698c7233"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09b9c829f1aea668186008f85f674952a4c091ea","date":1355187286,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    \n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n    props.put(OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString());\n    props.put(\"name\", name);\n    if (configName != null) {\n      props.put(\"collection.configName\", configName);\n    }\n    props.put(OverseerCollectionProcessor.NUM_SLICES, numShards);\n    props.put(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n    \n    ZkNodeProps m = new ZkNodeProps(props);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, OverseerCollectionProcessor.NUM_SLICES, numShards, OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","bugFix":["33d0ed80b7b47e34ad3ff033a77544563aba3085","c215736a9e29403edd2132d9f0829a287b428df4","aa16b24e8441c80ef7c503119e979670698c7233"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a57adc9bfabbc207ed17740dd86e0a2401ea385","date":1355507623,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    String createNodeSetStr = req.getParams().get(OverseerCollectionProcessor.CREATE_NODE_SET);\n    \n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n    props.put(OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString());\n    props.put(\"name\", name);\n    if (configName != null) {\n      props.put(\"collection.configName\", configName);\n    }\n    props.put(OverseerCollectionProcessor.NUM_SLICES, numShards);\n    props.put(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n    props.put(OverseerCollectionProcessor.CREATE_NODE_SET, createNodeSetStr);\n    \n    ZkNodeProps m = new ZkNodeProps(props);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    \n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n    props.put(OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString());\n    props.put(\"name\", name);\n    if (configName != null) {\n      props.put(\"collection.configName\", configName);\n    }\n    props.put(OverseerCollectionProcessor.NUM_SLICES, numShards);\n    props.put(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n    \n    ZkNodeProps m = new ZkNodeProps(props);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    String createNodeSetStr = req.getParams().get(OverseerCollectionProcessor.CREATE_NODE_SET);\n    \n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n    props.put(OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString());\n    props.put(\"name\", name);\n    if (configName != null) {\n      props.put(\"collection.configName\", configName);\n    }\n    props.put(OverseerCollectionProcessor.NUM_SLICES, numShards);\n    props.put(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n    props.put(OverseerCollectionProcessor.CREATE_NODE_SET, createNodeSetStr);\n    \n    ZkNodeProps m = new ZkNodeProps(props);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 0);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    \n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION, OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString(), \"name\", name,\n        \"collection.configName\", configName, OverseerCollectionProcessor.NUM_SLICES, numShards, OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c986b1ea9768aff3c903f05a2c85b7b672b5c225","date":1359126891,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    String createNodeSetStr = req.getParams().get(OverseerCollectionProcessor.CREATE_NODE_SET);\n    \n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n    props.put(OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString());\n    props.put(\"name\", name);\n    if (configName != null) {\n      props.put(\"collection.configName\", configName);\n    }\n    props.put(OverseerCollectionProcessor.NUM_SLICES, numShards);\n    props.put(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n    props.put(OverseerCollectionProcessor.CREATE_NODE_SET, createNodeSetStr);\n    \n    ZkNodeProps m = new ZkNodeProps(props);\n\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    String createNodeSetStr = req.getParams().get(OverseerCollectionProcessor.CREATE_NODE_SET);\n    \n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n    props.put(OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString());\n    props.put(\"name\", name);\n    if (configName != null) {\n      props.put(\"collection.configName\", configName);\n    }\n    props.put(OverseerCollectionProcessor.NUM_SLICES, numShards);\n    props.put(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n    props.put(OverseerCollectionProcessor.CREATE_NODE_SET, createNodeSetStr);\n    \n    ZkNodeProps m = new ZkNodeProps(props);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd45d4a2ee01a1932d33eec42f5272c2402da679","date":1359316912,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    String createNodeSetStr = req.getParams().get(OverseerCollectionProcessor.CREATE_NODE_SET);\n    \n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n    props.put(OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString());\n    props.put(\"name\", name);\n    if (configName != null) {\n      props.put(\"collection.configName\", configName);\n    }\n    props.put(OverseerCollectionProcessor.NUM_SLICES, numShards);\n    props.put(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n    props.put(OverseerCollectionProcessor.CREATE_NODE_SET, createNodeSetStr);\n    \n    ZkNodeProps m = new ZkNodeProps(props);\n\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    String createNodeSetStr = req.getParams().get(OverseerCollectionProcessor.CREATE_NODE_SET);\n    \n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n    props.put(OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString());\n    props.put(\"name\", name);\n    if (configName != null) {\n      props.put(\"collection.configName\", configName);\n    }\n    props.put(OverseerCollectionProcessor.NUM_SLICES, numShards);\n    props.put(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n    props.put(OverseerCollectionProcessor.CREATE_NODE_SET, createNodeSetStr);\n    \n    ZkNodeProps m = new ZkNodeProps(props);\n\n    // TODO: what if you want to block until the collection is available?\n    coreContainer.getZkController().getOverseerCollectionQueue().offer(ZkStateReader.toJSON(m));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eeda7e62e149f90eee8895af874c74efa7d4852","date":1375293182,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        ROUTER,\n        SHARDS_PROP,\n        ROUTE_FIELD);\n\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    String createNodeSetStr = req.getParams().get(OverseerCollectionProcessor.CREATE_NODE_SET);\n    \n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n    props.put(OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString());\n    props.put(\"name\", name);\n    if (configName != null) {\n      props.put(\"collection.configName\", configName);\n    }\n    props.put(OverseerCollectionProcessor.NUM_SLICES, numShards);\n    props.put(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n    props.put(OverseerCollectionProcessor.CREATE_NODE_SET, createNodeSetStr);\n    \n    ZkNodeProps m = new ZkNodeProps(props);\n\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        ROUTER,\n        SHARDS_PROP,\n        ROUTE_FIELD);\n\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    Integer numReplicas = req.getParams().getInt(OverseerCollectionProcessor.REPLICATION_FACTOR, 1);\n    String name = req.getParams().required().get(\"name\");\n    String configName = req.getParams().get(\"collection.configName\");\n    String numShards = req.getParams().get(OverseerCollectionProcessor.NUM_SLICES);\n    String maxShardsPerNode = req.getParams().get(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE);\n    String createNodeSetStr = req.getParams().get(OverseerCollectionProcessor.CREATE_NODE_SET);\n    \n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n    props.put(OverseerCollectionProcessor.REPLICATION_FACTOR, numReplicas.toString());\n    props.put(\"name\", name);\n    if (configName != null) {\n      props.put(\"collection.configName\", configName);\n    }\n    props.put(OverseerCollectionProcessor.NUM_SLICES, numShards);\n    props.put(OverseerCollectionProcessor.MAX_SHARDS_PER_NODE, maxShardsPerNode);\n    props.put(OverseerCollectionProcessor.CREATE_NODE_SET, createNodeSetStr);\n    \n    ZkNodeProps m = new ZkNodeProps(props);\n\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e187a371a1d09379bb452c2c13a7b9221525dff8","date":1379517004,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        \"router.\");\n\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        ROUTER,\n        SHARDS_PROP,\n        ROUTE_FIELD);\n\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40dce2b6d4360eb09fa16fb6c40a18b25507ed73","date":1383035822,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        \"router.\");\n\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = new HashMap<String,Object>();\n    props.put(Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION);\n\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        \"router.\");\n\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b711ca2887ae3fda68611cbb78c1b389fa9833be","date":1384985717,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        \"router.\");\n\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        \"router.\");\n\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","date":1394784078,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        ASYNC,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        DocCollection.STATE_FORMAT,\n        ASYNC,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        ASYNC,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        ASYNC,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        DocCollection.STATE_FORMAT,\n        ASYNC,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        DocCollection.STATE_FORMAT,\n        ASYNC,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        ASYNC,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        ASYNC,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        DocCollection.STATE_FORMAT,\n        ASYNC,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad7bdba3e91cf3373cda2e52239cb761fc0b452","date":1408019547,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(), props,\n         \"name\",\n         ZkStateReader.REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET,\n         SHARDS_PROP,\n         ASYNC,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n        CREATE_NODE_SET ,\n        SHARDS_PROP,\n        ASYNC,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(), props,\n         \"name\",\n         ZkStateReader.REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET,\n         SHARDS_PROP,\n         ASYNC,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c688f7052130cef7bd419c85e3c5be214f7b9e","date":1411018984,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        OverseerCollectionProcessor.CREATECOLLECTION,\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(OverseerCollectionProcessor.CREATECOLLECTION, m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d196318cb8ce39ae32035f290cd1397833e472","date":1418140712,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n\n    if(SYSTEM_COLL.equals(name)){\n      //We must always create asystem collection with only a single shard\n      props.put(NUM_SLICES,1);\n      props.remove(SHARDS_PROP);\n      createSysConfigSet();\n\n    }\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n    \n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08b22329006608bd6b95aeba7a59f28092cd7a5e","date":1419362789,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET, CREATE_NODE_SET_SHUFFLE,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n\n    if(SYSTEM_COLL.equals(name)){\n      //We must always create asystem collection with only a single shard\n      props.put(NUM_SLICES,1);\n      props.remove(SHARDS_PROP);\n      createSysConfigSet();\n\n    }\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n\n    if(SYSTEM_COLL.equals(name)){\n      //We must always create asystem collection with only a single shard\n      props.put(NUM_SLICES,1);\n      props.remove(SHARDS_PROP);\n      createSysConfigSet();\n\n    }\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed5e858eb62a97f2c8f311bbc560d03fe017d119","date":1421935972,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET, CREATE_NODE_SET_SHUFFLE,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n    if(props.get(DocCollection.STATE_FORMAT) == null){\n      props.put(DocCollection.STATE_FORMAT,\"2\");\n    }\n\n    if(SYSTEM_COLL.equals(name)){\n      //We must always create asystem collection with only a single shard\n      props.put(NUM_SLICES,1);\n      props.remove(SHARDS_PROP);\n      createSysConfigSet();\n\n    }\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET, CREATE_NODE_SET_SHUFFLE,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n\n    if(SYSTEM_COLL.equals(name)){\n      //We must always create asystem collection with only a single shard\n      props.put(NUM_SLICES,1);\n      props.remove(SHARDS_PROP);\n      createSysConfigSet();\n\n    }\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(NAME);\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        NAME,\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET, CREATE_NODE_SET_SHUFFLE,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n    if(props.get(DocCollection.STATE_FORMAT) == null){\n      props.put(DocCollection.STATE_FORMAT,\"2\");\n    }\n\n    if(SYSTEM_COLL.equals(name)){\n      //We must always create asystem collection with only a single shard\n      props.put(NUM_SLICES,1);\n      props.remove(SHARDS_PROP);\n      createSysConfigSet();\n\n    }\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET, CREATE_NODE_SET_SHUFFLE,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n    if(props.get(DocCollection.STATE_FORMAT) == null){\n      props.put(DocCollection.STATE_FORMAT,\"2\");\n    }\n\n    if(SYSTEM_COLL.equals(name)){\n      //We must always create asystem collection with only a single shard\n      props.put(NUM_SLICES,1);\n      props.remove(SHARDS_PROP);\n      createSysConfigSet();\n\n    }\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(NAME);\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        NAME,\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET, CREATE_NODE_SET_SHUFFLE,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n    if(props.get(DocCollection.STATE_FORMAT) == null){\n      props.put(DocCollection.STATE_FORMAT,\"2\");\n    }\n\n    if(SYSTEM_COLL.equals(name)){\n      //We must always create asystem collection with only a single shard\n      props.put(NUM_SLICES,1);\n      props.remove(SHARDS_PROP);\n      createSysConfigSet();\n\n    }\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(\"name\");\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        \"name\",\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET, CREATE_NODE_SET_SHUFFLE,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n    if(props.get(DocCollection.STATE_FORMAT) == null){\n      props.put(DocCollection.STATE_FORMAT,\"2\");\n    }\n\n    if(SYSTEM_COLL.equals(name)){\n      //We must always create asystem collection with only a single shard\n      props.put(NUM_SLICES,1);\n      props.remove(SHARDS_PROP);\n      createSysConfigSet();\n\n    }\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe","date":1430750405,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(NAME);\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        NAME,\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET, CREATE_NODE_SET_SHUFFLE,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n    if(props.get(DocCollection.STATE_FORMAT) == null){\n      props.put(DocCollection.STATE_FORMAT,\"2\");\n    }\n    addRuleMap(req.getParams(), props, \"rule\");\n    addRuleMap(req.getParams(), props, \"snitch\");\n\n    if(SYSTEM_COLL.equals(name)){\n      //We must always create asystem collection with only a single shard\n      props.put(NUM_SLICES,1);\n      props.remove(SHARDS_PROP);\n      createSysConfigSet();\n\n    }\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(NAME);\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        NAME,\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET, CREATE_NODE_SET_SHUFFLE,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n    if(props.get(DocCollection.STATE_FORMAT) == null){\n      props.put(DocCollection.STATE_FORMAT,\"2\");\n    }\n\n    if(SYSTEM_COLL.equals(name)){\n      //We must always create asystem collection with only a single shard\n      props.put(NUM_SLICES,1);\n      props.remove(SHARDS_PROP);\n      createSysConfigSet();\n\n    }\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ebd3a557326ef3eab85b73a8cff781f7d801248","date":1431620752,"type":4,"author":"Noble Paul","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler#handleCreateAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":null,"sourceOld":"  // very simple currently, you can pass a template collection, and the new collection is created on\n  // every node the template collection is on\n  // there is a lot more to add - you should also be able to create with an explicit server list\n  // we might also want to think about error handling (add the request to a zk queue and involve overseer?)\n  // as well as specific replicas= options\n  private void handleCreateAction(SolrQueryRequest req,\n      SolrQueryResponse rsp) throws InterruptedException, KeeperException {\n    log.info(\"Creating Collection : \" + req.getParamString());\n    String name = req.getParams().required().get(NAME);\n    if (name == null) {\n      log.error(\"Collection name is required to create a new collection\");\n      throw new SolrException(ErrorCode.BAD_REQUEST,\n          \"Collection name is required to create a new collection\");\n    }\n\n    Map<String,Object> props = ZkNodeProps.makeMap(\n        Overseer.QUEUE_OPERATION,\n        CREATE.toLower(),\n        \"fromApi\",\"true\");\n    copyIfNotNull(req.getParams(),props,\n        NAME,\n        REPLICATION_FACTOR,\n         COLL_CONF,\n         NUM_SLICES,\n         MAX_SHARDS_PER_NODE,\n         CREATE_NODE_SET, CREATE_NODE_SET_SHUFFLE,\n         SHARDS_PROP,\n         ASYNC,\n         DocCollection.STATE_FORMAT,\n         AUTO_ADD_REPLICAS,\n        \"router.\");\n    if(props.get(DocCollection.STATE_FORMAT) == null){\n      props.put(DocCollection.STATE_FORMAT,\"2\");\n    }\n    addRuleMap(req.getParams(), props, \"rule\");\n    addRuleMap(req.getParams(), props, \"snitch\");\n\n    if(SYSTEM_COLL.equals(name)){\n      //We must always create asystem collection with only a single shard\n      props.put(NUM_SLICES,1);\n      props.remove(SHARDS_PROP);\n      createSysConfigSet();\n\n    }\n    copyPropertiesIfNotNull(req.getParams(), props);\n\n    ZkNodeProps m = new ZkNodeProps(props);\n    handleResponse(CREATE.toLower(), m, rsp);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","9a57adc9bfabbc207ed17740dd86e0a2401ea385"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["b711ca2887ae3fda68611cbb78c1b389fa9833be"],"9ebd3a557326ef3eab85b73a8cff781f7d801248":["8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c986b1ea9768aff3c903f05a2c85b7b672b5c225"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["9279b175e5e66258442d2123a50f052219a9cc1b"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["c986b1ea9768aff3c903f05a2c85b7b672b5c225"],"aa16b24e8441c80ef7c503119e979670698c7233":["8512200aed2724abd80dbeb686d3412d537b7d8a"],"aba371508186796cc6151d8223a5b4e16d02e26e":["33d0ed80b7b47e34ad3ff033a77544563aba3085","8512200aed2724abd80dbeb686d3412d537b7d8a"],"c215736a9e29403edd2132d9f0829a287b428df4":["aa16b24e8441c80ef7c503119e979670698c7233"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["ed5e858eb62a97f2c8f311bbc560d03fe017d119"],"c986b1ea9768aff3c903f05a2c85b7b672b5c225":["9a57adc9bfabbc207ed17740dd86e0a2401ea385"],"8512200aed2724abd80dbeb686d3412d537b7d8a":["33d0ed80b7b47e34ad3ff033a77544563aba3085"],"ed5e858eb62a97f2c8f311bbc560d03fe017d119":["08b22329006608bd6b95aeba7a59f28092cd7a5e"],"a0d196318cb8ce39ae32035f290cd1397833e472":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["ed5e858eb62a97f2c8f311bbc560d03fe017d119","1390137e395d2f07f9ba5b8c43d293befe84d563"],"08b22329006608bd6b95aeba7a59f28092cd7a5e":["a0d196318cb8ce39ae32035f290cd1397833e472"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["c986b1ea9768aff3c903f05a2c85b7b672b5c225","1eeda7e62e149f90eee8895af874c74efa7d4852"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"ccf4d8c4536f02247aec7edc26a89e19c5c05dd4":["c215736a9e29403edd2132d9f0829a287b428df4"],"407687e67faf6e1f02a211ca078d8e3eed631027":["aa16b24e8441c80ef7c503119e979670698c7233","c215736a9e29403edd2132d9f0829a287b428df4"],"b711ca2887ae3fda68611cbb78c1b389fa9833be":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73"],"9279b175e5e66258442d2123a50f052219a9cc1b":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"9a57adc9bfabbc207ed17740dd86e0a2401ea385":["09b9c829f1aea668186008f85f674952a4c091ea"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"09b9c829f1aea668186008f85f674952a4c091ea":["ccf4d8c4536f02247aec7edc26a89e19c5c05dd4"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8512200aed2724abd80dbeb686d3412d537b7d8a"],"e187a371a1d09379bb452c2c13a7b9221525dff8":["1eeda7e62e149f90eee8895af874c74efa7d4852"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73","b711ca2887ae3fda68611cbb78c1b389fa9833be"],"40dce2b6d4360eb09fa16fb6c40a18b25507ed73":["e187a371a1d09379bb452c2c13a7b9221525dff8"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ebd3a557326ef3eab85b73a8cff781f7d801248"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["dd45d4a2ee01a1932d33eec42f5272c2402da679"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"058f5a3debcfa0ea477da3eabb4cbe2ec0fac211":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"9ebd3a557326ef3eab85b73a8cff781f7d801248":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":[],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["a0d196318cb8ce39ae32035f290cd1397833e472"],"1eeda7e62e149f90eee8895af874c74efa7d4852":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","e187a371a1d09379bb452c2c13a7b9221525dff8"],"aa16b24e8441c80ef7c503119e979670698c7233":["c215736a9e29403edd2132d9f0829a287b428df4","407687e67faf6e1f02a211ca078d8e3eed631027"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"c215736a9e29403edd2132d9f0829a287b428df4":["ccf4d8c4536f02247aec7edc26a89e19c5c05dd4","407687e67faf6e1f02a211ca078d8e3eed631027"],"c986b1ea9768aff3c903f05a2c85b7b672b5c225":["dd45d4a2ee01a1932d33eec42f5272c2402da679","1eeda7e62e149f90eee8895af874c74efa7d4852","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"8512200aed2724abd80dbeb686d3412d537b7d8a":["aa16b24e8441c80ef7c503119e979670698c7233","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["d2638f781be724518ff6c2263d14a48cf6e68017","8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe"],"ed5e858eb62a97f2c8f311bbc560d03fe017d119":["1390137e395d2f07f9ba5b8c43d293befe84d563","d2638f781be724518ff6c2263d14a48cf6e68017"],"a0d196318cb8ce39ae32035f290cd1397833e472":["08b22329006608bd6b95aeba7a59f28092cd7a5e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["33d0ed80b7b47e34ad3ff033a77544563aba3085","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"08b22329006608bd6b95aeba7a59f28092cd7a5e":["ed5e858eb62a97f2c8f311bbc560d03fe017d119"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["aba371508186796cc6151d8223a5b4e16d02e26e","8512200aed2724abd80dbeb686d3412d537b7d8a"],"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"8c7a6584aa35e033d783e02c6f4eefa6ad21c7fe":["9ebd3a557326ef3eab85b73a8cff781f7d801248"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["0ad7bdba3e91cf3373cda2e52239cb761fc0b452"],"ccf4d8c4536f02247aec7edc26a89e19c5c05dd4":["09b9c829f1aea668186008f85f674952a4c091ea"],"b711ca2887ae3fda68611cbb78c1b389fa9833be":["058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"9279b175e5e66258442d2123a50f052219a9cc1b":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"9a57adc9bfabbc207ed17740dd86e0a2401ea385":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c986b1ea9768aff3c903f05a2c85b7b672b5c225"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"09b9c829f1aea668186008f85f674952a4c091ea":["9a57adc9bfabbc207ed17740dd86e0a2401ea385"],"0ad7bdba3e91cf3373cda2e52239cb761fc0b452":["9279b175e5e66258442d2123a50f052219a9cc1b"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"e187a371a1d09379bb452c2c13a7b9221525dff8":["40dce2b6d4360eb09fa16fb6c40a18b25507ed73"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"40dce2b6d4360eb09fa16fb6c40a18b25507ed73":["b711ca2887ae3fda68611cbb78c1b389fa9833be","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["dd45d4a2ee01a1932d33eec42f5272c2402da679","aba371508186796cc6151d8223a5b4e16d02e26e","d2638f781be724518ff6c2263d14a48cf6e68017","716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","fe33227f6805edab2036cbb80645cc4e2d1fa424","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}