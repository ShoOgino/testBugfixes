{"path":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","pathOld":"src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","sourceNew":"  public synchronized void sync() {\n    while(mergeThreadCount() > 0) {\n      if (verbose())\n        message(\"now wait for threads; currently \" + mergeThreads.size() + \" still running\");\n      final int count = mergeThreads.size();\n      if (verbose()) {\n        for(int i=0;i<count;i++)\n          message(\"    \" + i + \": \" + mergeThreads.get(i));\n      }\n      \n      try {\n        wait();\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void sync() {\n    while(mergeThreadCount() > 0) {\n      if (verbose())\n        message(\"now wait for threads; currently \" + mergeThreads.size() + \" still running\");\n      final int count = mergeThreads.size();\n      if (verbose()) {\n        for(int i=0;i<count;i++)\n          message(\"    \" + i + \": \" + mergeThreads.get(i));\n      }\n      \n      try {\n        wait();\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db603debe12d21cac9f37467b795dd3a8559496a","date":1292767070,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","sourceNew":"  /** Wait for any running merge threads to finish */\n  public void sync() {\n    while(true) {\n      MergeThread toSync = null;\n      synchronized(this) {\n        for(MergeThread t : mergeThreads) {\n          if (t.isAlive()) {\n            toSync = t;\n            break;\n          }\n        }\n      }\n      if (toSync != null) {\n        try {\n          toSync.join();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void sync() {\n    while(mergeThreadCount() > 0) {\n      if (verbose())\n        message(\"now wait for threads; currently \" + mergeThreads.size() + \" still running\");\n      final int count = mergeThreads.size();\n      if (verbose()) {\n        for(int i=0;i<count;i++)\n          message(\"    \" + i + \": \" + mergeThreads.get(i));\n      }\n      \n      try {\n        wait();\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eb1b144119d471f0d0af58fe8cf3af07b40f72be","date":1292778444,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","sourceNew":"  public synchronized void sync() {\n    while(mergeThreadCount() > 0) {\n      if (verbose())\n        message(\"now wait for threads; currently \" + mergeThreads.size() + \" still running\");\n      final int count = mergeThreads.size();\n      if (verbose()) {\n        for(int i=0;i<count;i++)\n          message(\"    \" + i + \": \" + mergeThreads.get(i));\n      }\n      \n      try {\n        wait();\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n  }\n\n","sourceOld":"  /** Wait for any running merge threads to finish */\n  public void sync() {\n    while(true) {\n      MergeThread toSync = null;\n      synchronized(this) {\n        for(MergeThread t : mergeThreads) {\n          if (t.isAlive()) {\n            toSync = t;\n            break;\n          }\n        }\n      }\n      if (toSync != null) {\n        try {\n          toSync.join();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["60679157c78fc286ee35471398529a1e5749621c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60679157c78fc286ee35471398529a1e5749621c","date":1292841330,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","sourceNew":"  /** Wait for any running merge threads to finish */\n  public void sync() {\n    while(true) {\n      MergeThread toSync = null;\n      synchronized(this) {\n        for(MergeThread t : mergeThreads) {\n          if (t.isAlive()) {\n            toSync = t;\n            break;\n          }\n        }\n      }\n      if (toSync != null) {\n        try {\n          toSync.join();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void sync() {\n    while(mergeThreadCount() > 0) {\n      if (verbose())\n        message(\"now wait for threads; currently \" + mergeThreads.size() + \" still running\");\n      final int count = mergeThreads.size();\n      if (verbose()) {\n        for(int i=0;i<count;i++)\n          message(\"    \" + i + \": \" + mergeThreads.get(i));\n      }\n      \n      try {\n        wait();\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n  }\n\n","bugFix":["eb1b144119d471f0d0af58fe8cf3af07b40f72be"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","sourceNew":"  /** Wait for any running merge threads to finish */\n  public void sync() {\n    while(true) {\n      MergeThread toSync = null;\n      synchronized(this) {\n        for(MergeThread t : mergeThreads) {\n          if (t.isAlive()) {\n            toSync = t;\n            break;\n          }\n        }\n      }\n      if (toSync != null) {\n        try {\n          toSync.join();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void sync() {\n    while(mergeThreadCount() > 0) {\n      if (verbose())\n        message(\"now wait for threads; currently \" + mergeThreads.size() + \" still running\");\n      final int count = mergeThreads.size();\n      if (verbose()) {\n        for(int i=0;i<count;i++)\n          message(\"    \" + i + \": \" + mergeThreads.get(i));\n      }\n      \n      try {\n        wait();\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","sourceNew":"  /** Wait for any running merge threads to finish */\n  public void sync() {\n    while(true) {\n      MergeThread toSync = null;\n      synchronized(this) {\n        for(MergeThread t : mergeThreads) {\n          if (t.isAlive()) {\n            toSync = t;\n            break;\n          }\n        }\n      }\n      if (toSync != null) {\n        try {\n          toSync.join();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void sync() {\n    while(mergeThreadCount() > 0) {\n      if (verbose())\n        message(\"now wait for threads; currently \" + mergeThreads.size() + \" still running\");\n      final int count = mergeThreads.size();\n      if (verbose()) {\n        for(int i=0;i<count;i++)\n          message(\"    \" + i + \": \" + mergeThreads.get(i));\n      }\n      \n      try {\n        wait();\n      } catch (InterruptedException ie) {\n        throw new ThreadInterruptedException(ie);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"abba363b04df5f50b5ec36177b5cd17c3fe73d6b","date":1295268568,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","sourceNew":"  /** Wait for any running merge threads to finish */\n  public void sync() {\n    while (true) {\n      MergeThread toSync = null;\n      synchronized (this) {\n        for (MergeThread t : mergeThreads) {\n          if (t.isAlive()) {\n            toSync = t;\n            break;\n          }\n        }\n      }\n      if (toSync != null) {\n        try {\n          toSync.join();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n","sourceOld":"  /** Wait for any running merge threads to finish */\n  public void sync() {\n    while(true) {\n      MergeThread toSync = null;\n      synchronized(this) {\n        for(MergeThread t : mergeThreads) {\n          if (t.isAlive()) {\n            toSync = t;\n            break;\n          }\n        }\n      }\n      if (toSync != null) {\n        try {\n          toSync.join();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","sourceNew":"  /** Wait for any running merge threads to finish */\n  public void sync() {\n    while (true) {\n      MergeThread toSync = null;\n      synchronized (this) {\n        for (MergeThread t : mergeThreads) {\n          if (t.isAlive()) {\n            toSync = t;\n            break;\n          }\n        }\n      }\n      if (toSync != null) {\n        try {\n          toSync.join();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n","sourceOld":"  /** Wait for any running merge threads to finish */\n  public void sync() {\n    while(true) {\n      MergeThread toSync = null;\n      synchronized(this) {\n        for(MergeThread t : mergeThreads) {\n          if (t.isAlive()) {\n            toSync = t;\n            break;\n          }\n        }\n      }\n      if (toSync != null) {\n        try {\n          toSync.join();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","sourceNew":"  /** Wait for any running merge threads to finish */\n  public void sync() {\n    while (true) {\n      MergeThread toSync = null;\n      synchronized (this) {\n        for (MergeThread t : mergeThreads) {\n          if (t.isAlive()) {\n            toSync = t;\n            break;\n          }\n        }\n      }\n      if (toSync != null) {\n        try {\n          toSync.join();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n","sourceOld":"  /** Wait for any running merge threads to finish */\n  public void sync() {\n    while(true) {\n      MergeThread toSync = null;\n      synchronized(this) {\n        for(MergeThread t : mergeThreads) {\n          if (t.isAlive()) {\n            toSync = t;\n            break;\n          }\n        }\n      }\n      if (toSync != null) {\n        try {\n          toSync.join();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#sync().mjava","sourceNew":"  /** Wait for any running merge threads to finish */\n  public void sync() {\n    while (true) {\n      MergeThread toSync = null;\n      synchronized (this) {\n        for (MergeThread t : mergeThreads) {\n          if (t.isAlive()) {\n            toSync = t;\n            break;\n          }\n        }\n      }\n      if (toSync != null) {\n        try {\n          toSync.join();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n","sourceOld":"  /** Wait for any running merge threads to finish */\n  public void sync() {\n    while (true) {\n      MergeThread toSync = null;\n      synchronized (this) {\n        for (MergeThread t : mergeThreads) {\n          if (t.isAlive()) {\n            toSync = t;\n            break;\n          }\n        }\n      }\n      if (toSync != null) {\n        try {\n          toSync.join();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["9454a6510e2db155fb01faa5c049b06ece95fab9","60679157c78fc286ee35471398529a1e5749621c"],"60679157c78fc286ee35471398529a1e5749621c":["eb1b144119d471f0d0af58fe8cf3af07b40f72be"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["abba363b04df5f50b5ec36177b5cd17c3fe73d6b"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["70ad682703b8585f5d0a637efec044d57ec05efb","abba363b04df5f50b5ec36177b5cd17c3fe73d6b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"abba363b04df5f50b5ec36177b5cd17c3fe73d6b":["60679157c78fc286ee35471398529a1e5749621c"],"db603debe12d21cac9f37467b795dd3a8559496a":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["9454a6510e2db155fb01faa5c049b06ece95fab9","60679157c78fc286ee35471398529a1e5749621c"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","abba363b04df5f50b5ec36177b5cd17c3fe73d6b"],"eb1b144119d471f0d0af58fe8cf3af07b40f72be":["db603debe12d21cac9f37467b795dd3a8559496a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"60679157c78fc286ee35471398529a1e5749621c":["70ad682703b8585f5d0a637efec044d57ec05efb","abba363b04df5f50b5ec36177b5cd17c3fe73d6b","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"abba363b04df5f50b5ec36177b5cd17c3fe73d6b":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","29ef99d61cda9641b6250bf9567329a6e65f901d","e79a6d080bdd5b2a8f56342cf571b5476de04180"],"db603debe12d21cac9f37467b795dd3a8559496a":["eb1b144119d471f0d0af58fe8cf3af07b40f72be"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["e79a6d080bdd5b2a8f56342cf571b5476de04180"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":[],"eb1b144119d471f0d0af58fe8cf3af07b40f72be":["60679157c78fc286ee35471398529a1e5749621c"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["70ad682703b8585f5d0a637efec044d57ec05efb","db603debe12d21cac9f37467b795dd3a8559496a","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","e79a6d080bdd5b2a8f56342cf571b5476de04180","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}