{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","commits":[{"id":"15ba547dfc0dd0b670e678cb3db8e5d27c694420","date":1511865512,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","pathOld":"/dev/null","sourceNew":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTime() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.ACTION_THROTTLE_PERIOD_SECONDS, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      lastActionExecutedAt.set(0);\n      throttlingDelayMs.set(TimeUnit.SECONDS.toMillis(6));\n      triggerFiredLatch = new CountDownLatch(2);\n      Map<String, Object> props = map(\"waitFor\", 0L, \"actions\", Collections.singletonList(map(\"name\",\"throttler\", \"class\", ThrottlingTesterAction.class.getName())));\n      scheduledTriggers.add(new NodeAddedTrigger(\"y1\", props, resourceLoader, solrCloudManager));\n      scheduledTriggers.add(new NodeAddedTrigger(\"y2\", props, resourceLoader, solrCloudManager));\n      JettySolrRunner newNode = cluster.startJettySolrRunner();\n      assertTrue(getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n        if (cluster.getJettySolrRunner(i) == newNode) {\n          cluster.stopJettySolrRunner(i);\n          break;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","pathOld":"/dev/null","sourceNew":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTime() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.ACTION_THROTTLE_PERIOD_SECONDS, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      lastActionExecutedAt.set(0);\n      throttlingDelayMs.set(TimeUnit.SECONDS.toMillis(6));\n      triggerFiredLatch = new CountDownLatch(2);\n      Map<String, Object> props = map(\"waitFor\", 0L, \"actions\", Collections.singletonList(map(\"name\",\"throttler\", \"class\", ThrottlingTesterAction.class.getName())));\n      scheduledTriggers.add(new NodeAddedTrigger(\"y1\", props, resourceLoader, solrCloudManager));\n      scheduledTriggers.add(new NodeAddedTrigger(\"y2\", props, resourceLoader, solrCloudManager));\n      JettySolrRunner newNode = cluster.startJettySolrRunner();\n      assertTrue(getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n        if (cluster.getJettySolrRunner(i) == newNode) {\n          cluster.stopJettySolrRunner(i);\n          break;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","sourceNew":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTime() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.ACTION_THROTTLE_PERIOD_SECONDS, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      lastActionExecutedAt.set(0);\n      throttlingDelayMs.set(TimeUnit.SECONDS.toMillis(6));\n      triggerFiredLatch = new CountDownLatch(2);\n      Map<String, Object> props = map(\"waitFor\", 0L, \"actions\", Collections.singletonList(map(\"name\",\"throttler\", \"class\", ThrottlingTesterAction.class.getName())));\n      scheduledTriggers.add(new NodeAddedTrigger(\"y1\", props, resourceLoader, solrCloudManager));\n      scheduledTriggers.add(new NodeAddedTrigger(\"y2\", props, resourceLoader, solrCloudManager));\n      scheduledTriggers.resetActionThrottle();\n      JettySolrRunner newNode = cluster.startJettySolrRunner();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n        if (cluster.getJettySolrRunner(i) == newNode) {\n          cluster.stopJettySolrRunner(i);\n          break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTime() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.ACTION_THROTTLE_PERIOD_SECONDS, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      lastActionExecutedAt.set(0);\n      throttlingDelayMs.set(TimeUnit.SECONDS.toMillis(6));\n      triggerFiredLatch = new CountDownLatch(2);\n      Map<String, Object> props = map(\"waitFor\", 0L, \"actions\", Collections.singletonList(map(\"name\",\"throttler\", \"class\", ThrottlingTesterAction.class.getName())));\n      scheduledTriggers.add(new NodeAddedTrigger(\"y1\", props, resourceLoader, solrCloudManager));\n      scheduledTriggers.add(new NodeAddedTrigger(\"y2\", props, resourceLoader, solrCloudManager));\n      JettySolrRunner newNode = cluster.startJettySolrRunner();\n      assertTrue(getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n        if (cluster.getJettySolrRunner(i) == newNode) {\n          cluster.stopJettySolrRunner(i);\n          break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0054ae381912e45884d3005a00486ed92a0f4925","date":1514900316,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","sourceNew":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTime() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","sourceOld":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTime() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.ACTION_THROTTLE_PERIOD_SECONDS, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      lastActionExecutedAt.set(0);\n      throttlingDelayMs.set(TimeUnit.SECONDS.toMillis(6));\n      triggerFiredLatch = new CountDownLatch(2);\n      Map<String, Object> props = map(\"waitFor\", 0L, \"actions\", Collections.singletonList(map(\"name\",\"throttler\", \"class\", ThrottlingTesterAction.class.getName())));\n      scheduledTriggers.add(new NodeAddedTrigger(\"y1\", props, resourceLoader, solrCloudManager));\n      scheduledTriggers.add(new NodeAddedTrigger(\"y2\", props, resourceLoader, solrCloudManager));\n      scheduledTriggers.resetActionThrottle();\n      JettySolrRunner newNode = cluster.startJettySolrRunner();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n        if (cluster.getJettySolrRunner(i) == newNode) {\n          cluster.stopJettySolrRunner(i);\n          break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","sourceNew":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTime() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","sourceOld":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTime() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.ACTION_THROTTLE_PERIOD_SECONDS, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      lastActionExecutedAt.set(0);\n      throttlingDelayMs.set(TimeUnit.SECONDS.toMillis(6));\n      triggerFiredLatch = new CountDownLatch(2);\n      Map<String, Object> props = map(\"waitFor\", 0L, \"actions\", Collections.singletonList(map(\"name\",\"throttler\", \"class\", ThrottlingTesterAction.class.getName())));\n      scheduledTriggers.add(new NodeAddedTrigger(\"y1\", props, resourceLoader, solrCloudManager));\n      scheduledTriggers.add(new NodeAddedTrigger(\"y2\", props, resourceLoader, solrCloudManager));\n      scheduledTriggers.resetActionThrottle();\n      JettySolrRunner newNode = cluster.startJettySolrRunner();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      for (int i = 0; i < cluster.getJettySolrRunners().size(); i++) {\n        if (cluster.getJettySolrRunner(i) == newNode) {\n          cluster.stopJettySolrRunner(i);\n          break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4412883c12067d8a4e2a354aa8adc58c32be1d6","date":1521129281,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","sourceNew":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTimeNs() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","sourceOld":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTime() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4","date":1522388336,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","sourceNew":"  public void testSetProperties() throws Exception {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\", \"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0) return;\n          long l = diff.get();\n          diff.set(timeSource.getTimeNs() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager) {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName())) {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n              + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames, 6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","sourceOld":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTimeNs() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acfe8d3b837b6b66eaddf114bb99cf9e2257764d","date":1522406637,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","sourceNew":"  public void testSetProperties() throws Exception {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\", \"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0) return;\n          long l = diff.get();\n          diff.set(timeSource.getTimeNs() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager) {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName())) {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n              + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames, 6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","sourceOld":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTimeNs() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1aad05eeff7818b0833c02ac6b743aa72054963b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","15ba547dfc0dd0b670e678cb3db8e5d27c694420"],"b94236357aaa22b76c10629851fe4e376e0cea82":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","0054ae381912e45884d3005a00486ed92a0f4925"],"15ba547dfc0dd0b670e678cb3db8e5d27c694420":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["b94236357aaa22b76c10629851fe4e376e0cea82"],"0054ae381912e45884d3005a00486ed92a0f4925":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"acfe8d3b837b6b66eaddf114bb99cf9e2257764d":["d4412883c12067d8a4e2a354aa8adc58c32be1d6","deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d"]},"commit2Childs":{"1aad05eeff7818b0833c02ac6b743aa72054963b":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"b94236357aaa22b76c10629851fe4e376e0cea82":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"15ba547dfc0dd0b670e678cb3db8e5d27c694420":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1aad05eeff7818b0833c02ac6b743aa72054963b","15ba547dfc0dd0b670e678cb3db8e5d27c694420"],"0054ae381912e45884d3005a00486ed92a0f4925":["b94236357aaa22b76c10629851fe4e376e0cea82"],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4","acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["b94236357aaa22b76c10629851fe4e376e0cea82","0054ae381912e45884d3005a00486ed92a0f4925"],"acfe8d3b837b6b66eaddf114bb99cf9e2257764d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}