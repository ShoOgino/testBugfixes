{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordLineBounds(PlanetModel,Bounds,double,double,double,double,double,double,Membership...).mjava","commits":[{"id":"b961ff1d2d65eab705046ed52539112d3a5f76e0","date":1463766553,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordLineBounds(PlanetModel,Bounds,double,double,double,double,double,double,Membership...).mjava","pathOld":"/dev/null","sourceNew":"  private static void recordLineBounds(final PlanetModel planetModel,\n    final Bounds boundsInfo,\n    final double lineVectorX, final double lineVectorY, final double lineVectorZ,\n    final double x0, final double y0, final double z0,\n    final Membership... bounds) {\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      //System.err.println(\" One point of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // One solution only\n      final double t = -B * inverse2A;\n      // Maybe we can save ourselves the cost of construction of a point?\n      final double pointX = lineVectorX * t + x0;\n      final double pointY = lineVectorY * t + y0;\n      final double pointZ = lineVectorZ * t + z0;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(pointX, pointY, pointZ)) {\n          return;\n        }\n      }\n      boundsInfo.addPoint(new GeoPoint(pointX, pointY, pointZ));\n    } else if (BsquaredMinus > 0.0) {\n      //System.err.println(\" Two points of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n\n      if (point1Valid) {\n        boundsInfo.addPoint(new GeoPoint(point1X, point1Y, point1Z));\n      }\n      if (point2Valid) {\n        boundsInfo.addPoint(new GeoPoint(point2X, point2Y, point2Z));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordLineBounds(PlanetModel,Bounds,double,double,double,double,double,double,Membership...).mjava","pathOld":"/dev/null","sourceNew":"  private static void recordLineBounds(final PlanetModel planetModel,\n    final Bounds boundsInfo,\n    final double lineVectorX, final double lineVectorY, final double lineVectorZ,\n    final double x0, final double y0, final double z0,\n    final Membership... bounds) {\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      //System.err.println(\" One point of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // One solution only\n      final double t = -B * inverse2A;\n      // Maybe we can save ourselves the cost of construction of a point?\n      final double pointX = lineVectorX * t + x0;\n      final double pointY = lineVectorY * t + y0;\n      final double pointZ = lineVectorZ * t + z0;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(pointX, pointY, pointZ)) {\n          return;\n        }\n      }\n      boundsInfo.addPoint(new GeoPoint(pointX, pointY, pointZ));\n    } else if (BsquaredMinus > 0.0) {\n      //System.err.println(\" Two points of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n\n      if (point1Valid) {\n        boundsInfo.addPoint(new GeoPoint(point1X, point1Y, point1Z));\n      }\n      if (point2Valid) {\n        boundsInfo.addPoint(new GeoPoint(point2X, point2Y, point2Z));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73684368e131f1201fcf3bfba05533e89f5829d0","date":1470312728,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordLineBounds(PlanetModel,Bounds,double,double,double,double,double,double,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordLineBounds(PlanetModel,Bounds,double,double,double,double,double,double,Membership...).mjava","sourceNew":"  private static void recordLineBounds(final PlanetModel planetModel,\n    final Bounds boundsInfo,\n    final double lineVectorX, final double lineVectorY, final double lineVectorZ,\n    final double x0, final double y0, final double z0,\n    final Membership... bounds) {\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      //System.err.println(\" One point of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // One solution only\n      final double t = -B * inverse2A;\n      // Maybe we can save ourselves the cost of construction of a point?\n      final double pointX = lineVectorX * t + x0;\n      final double pointY = lineVectorY * t + y0;\n      final double pointZ = lineVectorZ * t + z0;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(pointX, pointY, pointZ)) {\n          return;\n        }\n      }\n      boundsInfo.addPoint(new GeoPoint(pointX, pointY, pointZ));\n    } else if (BsquaredMinus > 0.0) {\n      //System.err.println(\" Two points of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n\n      if (point1Valid) {\n        boundsInfo.addPoint(new GeoPoint(point1X, point1Y, point1Z));\n      }\n      if (point2Valid) {\n        boundsInfo.addPoint(new GeoPoint(point2X, point2Y, point2Z));\n      }\n    } else {\n      // If we can't intersect line with world, then it's outside the world, so\n      // we have to assume everything is included.\n      boundsInfo.noBound(planetModel);\n    }\n  }\n\n","sourceOld":"  private static void recordLineBounds(final PlanetModel planetModel,\n    final Bounds boundsInfo,\n    final double lineVectorX, final double lineVectorY, final double lineVectorZ,\n    final double x0, final double y0, final double z0,\n    final Membership... bounds) {\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      //System.err.println(\" One point of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // One solution only\n      final double t = -B * inverse2A;\n      // Maybe we can save ourselves the cost of construction of a point?\n      final double pointX = lineVectorX * t + x0;\n      final double pointY = lineVectorY * t + y0;\n      final double pointZ = lineVectorZ * t + z0;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(pointX, pointY, pointZ)) {\n          return;\n        }\n      }\n      boundsInfo.addPoint(new GeoPoint(pointX, pointY, pointZ));\n    } else if (BsquaredMinus > 0.0) {\n      //System.err.println(\" Two points of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n\n      if (point1Valid) {\n        boundsInfo.addPoint(new GeoPoint(point1X, point1Y, point1Z));\n      }\n      if (point2Valid) {\n        boundsInfo.addPoint(new GeoPoint(point2X, point2Y, point2Z));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordLineBounds(PlanetModel,Bounds,double,double,double,double,double,double,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordLineBounds(PlanetModel,Bounds,double,double,double,double,double,double,Membership...).mjava","sourceNew":"  private static void recordLineBounds(final PlanetModel planetModel,\n    final Bounds boundsInfo,\n    final double lineVectorX, final double lineVectorY, final double lineVectorZ,\n    final double x0, final double y0, final double z0,\n    final Membership... bounds) {\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      //System.err.println(\" One point of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // One solution only\n      final double t = -B * inverse2A;\n      // Maybe we can save ourselves the cost of construction of a point?\n      final double pointX = lineVectorX * t + x0;\n      final double pointY = lineVectorY * t + y0;\n      final double pointZ = lineVectorZ * t + z0;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(pointX, pointY, pointZ)) {\n          return;\n        }\n      }\n      boundsInfo.addPoint(new GeoPoint(pointX, pointY, pointZ));\n    } else if (BsquaredMinus > 0.0) {\n      //System.err.println(\" Two points of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n\n      if (point1Valid) {\n        boundsInfo.addPoint(new GeoPoint(point1X, point1Y, point1Z));\n      }\n      if (point2Valid) {\n        boundsInfo.addPoint(new GeoPoint(point2X, point2Y, point2Z));\n      }\n    } else {\n      // If we can't intersect line with world, then it's outside the world, so\n      // we have to assume everything is included.\n      boundsInfo.noBound(planetModel);\n    }\n  }\n\n","sourceOld":"  private static void recordLineBounds(final PlanetModel planetModel,\n    final Bounds boundsInfo,\n    final double lineVectorX, final double lineVectorY, final double lineVectorZ,\n    final double x0, final double y0, final double z0,\n    final Membership... bounds) {\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      //System.err.println(\" One point of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // One solution only\n      final double t = -B * inverse2A;\n      // Maybe we can save ourselves the cost of construction of a point?\n      final double pointX = lineVectorX * t + x0;\n      final double pointY = lineVectorY * t + y0;\n      final double pointZ = lineVectorZ * t + z0;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(pointX, pointY, pointZ)) {\n          return;\n        }\n      }\n      boundsInfo.addPoint(new GeoPoint(pointX, pointY, pointZ));\n    } else if (BsquaredMinus > 0.0) {\n      //System.err.println(\" Two points of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n\n      if (point1Valid) {\n        boundsInfo.addPoint(new GeoPoint(point1X, point1Y, point1Z));\n      }\n      if (point2Valid) {\n        boundsInfo.addPoint(new GeoPoint(point2X, point2Y, point2Z));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordLineBounds(PlanetModel,Bounds,double,double,double,double,double,double,Membership...).mjava","pathOld":"/dev/null","sourceNew":"  private static void recordLineBounds(final PlanetModel planetModel,\n    final Bounds boundsInfo,\n    final double lineVectorX, final double lineVectorY, final double lineVectorZ,\n    final double x0, final double y0, final double z0,\n    final Membership... bounds) {\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      //System.err.println(\" One point of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // One solution only\n      final double t = -B * inverse2A;\n      // Maybe we can save ourselves the cost of construction of a point?\n      final double pointX = lineVectorX * t + x0;\n      final double pointY = lineVectorY * t + y0;\n      final double pointZ = lineVectorZ * t + z0;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(pointX, pointY, pointZ)) {\n          return;\n        }\n      }\n      boundsInfo.addPoint(new GeoPoint(pointX, pointY, pointZ));\n    } else if (BsquaredMinus > 0.0) {\n      //System.err.println(\" Two points of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n\n      if (point1Valid) {\n        boundsInfo.addPoint(new GeoPoint(point1X, point1Y, point1Z));\n      }\n      if (point2Valid) {\n        boundsInfo.addPoint(new GeoPoint(point2X, point2Y, point2Z));\n      }\n    } else {\n      // If we can't intersect line with world, then it's outside the world, so\n      // we have to assume everything is included.\n      boundsInfo.noBound(planetModel);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","date":1583186777,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordLineBounds(PlanetModel,Bounds,double,double,double,double,double,double,Membership...).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Plane#recordLineBounds(PlanetModel,Bounds,double,double,double,double,double,double,Membership...).mjava","sourceNew":"  private static void recordLineBounds(final PlanetModel planetModel,\n    final Bounds boundsInfo,\n    final double lineVectorX, final double lineVectorY, final double lineVectorZ,\n    final double x0, final double y0, final double z0,\n    final Membership... bounds) {\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/zScaling^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/zScaling^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / zScaling^2 + 2CC0t / zScaling^2 + C0^2 / zScaling^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / zScaling^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / zScaling^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / zScaling^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseXYScalingSquared +\n      lineVectorY * lineVectorY * planetModel.inverseXYScalingSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseZScalingSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseXYScalingSquared + lineVectorY * y0 * planetModel.inverseXYScalingSquared + lineVectorZ * z0 * planetModel.inverseZScalingSquared);\n    final double C = x0 * x0 * planetModel.inverseXYScalingSquared + y0 * y0 * planetModel.inverseXYScalingSquared + z0 * z0 * planetModel.inverseZScalingSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      //System.err.println(\" One point of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // One solution only\n      final double t = -B * inverse2A;\n      // Maybe we can save ourselves the cost of construction of a point?\n      final double pointX = lineVectorX * t + x0;\n      final double pointY = lineVectorY * t + y0;\n      final double pointZ = lineVectorZ * t + z0;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(pointX, pointY, pointZ)) {\n          return;\n        }\n      }\n      boundsInfo.addPoint(new GeoPoint(pointX, pointY, pointZ));\n    } else if (BsquaredMinus > 0.0) {\n      //System.err.println(\" Two points of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n\n      if (point1Valid) {\n        boundsInfo.addPoint(new GeoPoint(point1X, point1Y, point1Z));\n      }\n      if (point2Valid) {\n        boundsInfo.addPoint(new GeoPoint(point2X, point2Y, point2Z));\n      }\n    } else {\n      // If we can't intersect line with world, then it's outside the world, so\n      // we have to assume everything is included.\n      boundsInfo.noBound(planetModel);\n    }\n  }\n\n","sourceOld":"  private static void recordLineBounds(final PlanetModel planetModel,\n    final Bounds boundsInfo,\n    final double lineVectorX, final double lineVectorY, final double lineVectorZ,\n    final double x0, final double y0, final double z0,\n    final Membership... bounds) {\n    // Once an intersecting line is determined, the next step is to intersect that line with the ellipsoid, which\n    // will yield zero, one, or two points.\n    // The ellipsoid equation: 1,0 = x^2/a^2 + y^2/b^2 + z^2/c^2\n    // 1.0 = (At+A0)^2/a^2 + (Bt+B0)^2/b^2 + (Ct+C0)^2/c^2\n    // A^2 t^2 / a^2 + 2AA0t / a^2 + A0^2 / a^2 + B^2 t^2 / b^2 + 2BB0t / b^2 + B0^2 / b^2 + C^2 t^2 / c^2 + 2CC0t / c^2 + C0^2 / c^2  - 1,0 = 0.0\n    // [A^2 / a^2 + B^2 / b^2 + C^2 / c^2] t^2 + [2AA0 / a^2 + 2BB0 / b^2 + 2CC0 / c^2] t + [A0^2 / a^2 + B0^2 / b^2 + C0^2 / c^2 - 1,0] = 0.0\n    // Use the quadratic formula to determine t values and candidate point(s)\n    final double A = lineVectorX * lineVectorX * planetModel.inverseAbSquared +\n      lineVectorY * lineVectorY * planetModel.inverseAbSquared +\n      lineVectorZ * lineVectorZ * planetModel.inverseCSquared;\n    final double B = 2.0 * (lineVectorX * x0 * planetModel.inverseAbSquared + lineVectorY * y0 * planetModel.inverseAbSquared + lineVectorZ * z0 * planetModel.inverseCSquared);\n    final double C = x0 * x0 * planetModel.inverseAbSquared + y0 * y0 * planetModel.inverseAbSquared + z0 * z0 * planetModel.inverseCSquared - 1.0;\n\n    final double BsquaredMinus = B * B - 4.0 * A * C;\n    if (Math.abs(BsquaredMinus) < MINIMUM_RESOLUTION_SQUARED) {\n      //System.err.println(\" One point of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // One solution only\n      final double t = -B * inverse2A;\n      // Maybe we can save ourselves the cost of construction of a point?\n      final double pointX = lineVectorX * t + x0;\n      final double pointY = lineVectorY * t + y0;\n      final double pointZ = lineVectorZ * t + z0;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(pointX, pointY, pointZ)) {\n          return;\n        }\n      }\n      boundsInfo.addPoint(new GeoPoint(pointX, pointY, pointZ));\n    } else if (BsquaredMinus > 0.0) {\n      //System.err.println(\" Two points of intersection\");\n      final double inverse2A = 1.0 / (2.0 * A);\n      // Two solutions\n      final double sqrtTerm = Math.sqrt(BsquaredMinus);\n      final double t1 = (-B + sqrtTerm) * inverse2A;\n      final double t2 = (-B - sqrtTerm) * inverse2A;\n      // Up to two points being returned.  Do what we can to save on object creation though.\n      final double point1X = lineVectorX * t1 + x0;\n      final double point1Y = lineVectorY * t1 + y0;\n      final double point1Z = lineVectorZ * t1 + z0;\n      final double point2X = lineVectorX * t2 + x0;\n      final double point2Y = lineVectorY * t2 + y0;\n      final double point2Z = lineVectorZ * t2 + z0;\n      boolean point1Valid = true;\n      boolean point2Valid = true;\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point1X, point1Y, point1Z)) {\n          point1Valid = false;\n          break;\n        }\n      }\n      for (final Membership bound : bounds) {\n        if (!bound.isWithin(point2X, point2Y, point2Z)) {\n          point2Valid = false;\n          break;\n        }\n      }\n\n      if (point1Valid) {\n        boundsInfo.addPoint(new GeoPoint(point1X, point1Y, point1Z));\n      }\n      if (point2Valid) {\n        boundsInfo.addPoint(new GeoPoint(point2X, point2Y, point2Z));\n      }\n    } else {\n      // If we can't intersect line with world, then it's outside the world, so\n      // we have to assume everything is included.\n      boundsInfo.noBound(planetModel);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"73684368e131f1201fcf3bfba05533e89f5829d0":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["73684368e131f1201fcf3bfba05533e89f5829d0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","73684368e131f1201fcf3bfba05533e89f5829d0"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["d470c8182e92b264680e34081b75e70a9f2b3c89","73684368e131f1201fcf3bfba05533e89f5829d0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b961ff1d2d65eab705046ed52539112d3a5f76e0"],"b961ff1d2d65eab705046ed52539112d3a5f76e0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","b961ff1d2d65eab705046ed52539112d3a5f76e0"],"73684368e131f1201fcf3bfba05533e89f5829d0":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["73684368e131f1201fcf3bfba05533e89f5829d0","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b961ff1d2d65eab705046ed52539112d3a5f76e0":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}