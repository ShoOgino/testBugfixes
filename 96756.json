{"path":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random);\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random);\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random);\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","date":1338430031,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = IndexReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55eeb2534cd53d2a985669829df942468ebf5314","date":1354409119,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2)).\n        setMergeScheduler(new SerialMergeScheduler())  // nocommit\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"47b9e6cdfa7e1fc15944550d1007780d96b4dcb6","date":1358785685,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2)).\n        setMergeScheduler(new SerialMergeScheduler())  // nocommit\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":["902ba79f4590a41c663c447756d2e5041cbbdda9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173","date":1365631993,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      if (!(cause instanceof IllegalStateException)) {\n        throw new AssertionError(\"Expected an IAE\", e);\n      } // else OK because positions are not indexed\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = new IndexSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (IllegalStateException ise) {\n      // expected\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70e1c9c32f6e8c8b7c9af038f2795cdd98fb9068","date":1365636385,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      if (!(cause instanceof IllegalStateException)) {\n        throw new AssertionError(\"Expected an IAE\", e);\n      } // else OK because positions are not indexed\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.shutdown();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.shutdown();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).\n            setMaxBufferedDocs(2).\n            setSimilarity(new SimpleSimilarity()).\n            setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.shutdown();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.shutdown();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60596f28be69b10c37a56a303c2dbea07b2ca4ba","date":1425060541,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9e1499c5d26c936238506df90a3c02c76707722","date":1434449920,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery(a.field(), a.bytes(), c.bytes());\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery();\n    pq.add(a);\n    pq.add(c);\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery(a.field(), a.bytes(), c.bytes());\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq.build(),\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery(a.field(), a.bytes(), c.bytes());\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery bq = new BooleanQuery();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq,\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05fe562aa248790944d43cdd478f512572835ba0","date":1455901667,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery(a.field(), a.bytes(), c.bytes());\n    Exception expected = expectThrows(Exception.class, () -> {\n      searcher.search(pq, 10);\n    });\n    Throwable cause = expected;\n    // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n    while (cause.getCause() != null) {\n      cause = cause.getCause();\n    }\n    assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq.build(),\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery(a.field(), a.bytes(), c.bytes());\n    try {\n      searcher.search(pq, 10);\n      fail(\"did not hit expected exception\");\n    } catch (Exception e) {\n      Throwable cause = e;\n      // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n      while (cause.getCause() != null) {\n        cause = cause.getCause();\n      }\n      assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n    }\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq.build(),\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":["70e1c9c32f6e8c8b7c9af038f2795cdd98fb9068","955c32f886db6f6356c9fcdea6b1f1cb4effda24","3b0e8c39ca08b5a02de6edcd33d6f3b90b865173"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery(a.field(), a.bytes(), c.bytes());\n    Exception expected = expectThrows(Exception.class, () -> {\n      searcher.search(pq, 10);\n    });\n    Throwable cause = expected;\n    // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n    while (cause.getCause() != null) {\n      cause = cause.getCause();\n    }\n    assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq.build(),\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery(a.field(), a.bytes(), c.bytes());\n    Exception expected = expectThrows(Exception.class, () -> {\n      searcher.search(pq, 10);\n    });\n    Throwable cause = expected;\n    // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n    while (cause.getCause() != null) {\n      cause = cause.getCause();\n    }\n    assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq.build(),\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery(a.field(), a.bytes(), c.bytes());\n    Exception expected = expectThrows(Exception.class, () -> {\n      searcher.search(pq, 10);\n    });\n    Throwable cause = expected;\n    // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n    while (cause.getCause() != null) {\n      cause = cause.getCause();\n    }\n    assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq.build(),\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery(a.field(), a.bytes(), c.bytes());\n    Exception expected = expectThrows(Exception.class, () -> {\n      searcher.search(pq, 10);\n    });\n    Throwable cause = expected;\n    // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n    while (cause.getCause() != null) {\n      cause = cause.getCause();\n    }\n    assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public boolean needsScores() {\n                        return true;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq.build(),\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285244982ce6aa163d1e60a707f0e6e121736ce5","date":1536055304,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestOmitTf#testBasic().mjava","sourceNew":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery(a.field(), a.bytes(), c.bytes());\n    Exception expected = expectThrows(Exception.class, () -> {\n      searcher.search(pq, 10);\n    });\n    Throwable cause = expected;\n    // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n    while (cause.getCause() != null) {\n      cause = cause.getCause();\n    }\n    assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorable scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorable scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorable scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorable scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorable scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorable scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorable scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorable scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq.build(),\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test scores with one field with Term Freqs and one without, otherwise with equal content \n  public void testBasic() throws Exception {\n    Directory dir = newDirectory();  \n    Analyzer analyzer = new MockAnalyzer(random());\n    IndexWriter writer = new IndexWriter(\n        dir,\n        newIndexWriterConfig(analyzer)\n            .setMaxBufferedDocs(2)\n            .setSimilarity(new SimpleSimilarity())\n            .setMergePolicy(newLogMergePolicy(2))\n    );\n        \n    StringBuilder sb = new StringBuilder(265);\n    String term = \"term\";\n    for(int i = 0; i<30; i++){\n      Document d = new Document();\n      sb.append(term).append(\" \");\n      String content  = sb.toString();\n      Field noTf = newField(\"noTf\", content + (i%2==0 ? \"\" : \" notf\"), omitType);\n      d.add(noTf);\n          \n      Field tf = newField(\"tf\", content + (i%2==0 ? \" tf\" : \"\"), normalType);\n      d.add(tf);\n          \n      writer.addDocument(d);\n      //System.out.println(d);\n    }\n        \n    writer.forceMerge(1);\n    // flush\n    writer.close();\n\n    /*\n     * Verify the index\n     */         \n    IndexReader reader = DirectoryReader.open(dir);\n    IndexSearcher searcher = newSearcher(reader);\n    searcher.setSimilarity(new SimpleSimilarity());\n        \n    Term a = new Term(\"noTf\", term);\n    Term b = new Term(\"tf\", term);\n    Term c = new Term(\"noTf\", \"notf\");\n    Term d = new Term(\"tf\", \"tf\");\n    TermQuery q1 = new TermQuery(a);\n    TermQuery q2 = new TermQuery(b);\n    TermQuery q3 = new TermQuery(c);\n    TermQuery q4 = new TermQuery(d);\n\n    PhraseQuery pq = new PhraseQuery(a.field(), a.bytes(), c.bytes());\n    Exception expected = expectThrows(Exception.class, () -> {\n      searcher.search(pq, 10);\n    });\n    Throwable cause = expected;\n    // If the searcher uses an executor service, the IAE is wrapped into other exceptions\n    while (cause.getCause() != null) {\n      cause = cause.getCause();\n    }\n    assertTrue(\"Expected an IAE, got \" + cause, cause instanceof IllegalStateException);\n        \n    searcher.search(q1,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(\"got score=\" + score, score==1.0f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q2,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q2: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertEquals(1.0f+doc, score, 0.00001f);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n         \n        \n        \n        \n        \n    searcher.search(q3,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        float score = scorer.score();\n                        assertTrue(score==1.0f);\n                        assertFalse(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n    searcher.search(q4,\n                    new CountingHitCollector() {\n                      private Scorer scorer;\n                      @Override\n                      public ScoreMode scoreMode() {\n                        return ScoreMode.COMPLETE;\n                      }\n                      @Override\n                      public final void setScorer(Scorer scorer) {\n                        this.scorer = scorer;\n                      }\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        float score = scorer.score();\n                        //System.out.println(\"Q1: Doc=\" + doc + \" score=\" + score);\n                        assertTrue(score==1.0f);\n                        assertTrue(doc%2==0);\n                        super.collect(doc);\n                      }\n                    });\n    //System.out.println(CountingHitCollector.getCount());\n        \n        \n        \n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    bq.add(q1,Occur.MUST);\n    bq.add(q4,Occur.MUST);\n        \n    searcher.search(bq.build(),\n                    new CountingHitCollector() {\n                      @Override\n                      public final void collect(int doc) throws IOException {\n                        //System.out.println(\"BQ: Doc=\" + doc + \" score=\" + score);\n                        super.collect(doc);\n                      }\n                    });\n    assertEquals(15, CountingHitCollector.getCount());\n         \n    reader.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"05fe562aa248790944d43cdd478f512572835ba0":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"55eeb2534cd53d2a985669829df942468ebf5314":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"417142ff08fda9cf0b72d5133e63097a166c6458":["05fe562aa248790944d43cdd478f512572835ba0","9fc47cb7b4346802411bb432f501ed0673d7119e"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["e9e1499c5d26c936238506df90a3c02c76707722"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["d0ef034a4f10871667ae75181537775ddcf8ade4","60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"e9e1499c5d26c936238506df90a3c02c76707722":["60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","47b9e6cdfa7e1fc15944550d1007780d96b4dcb6"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["417142ff08fda9cf0b72d5133e63097a166c6458"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["70e1c9c32f6e8c8b7c9af038f2795cdd98fb9068"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["05fe562aa248790944d43cdd478f512572835ba0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"70e1c9c32f6e8c8b7c9af038f2795cdd98fb9068":["3b0e8c39ca08b5a02de6edcd33d6f3b90b865173"],"47b9e6cdfa7e1fc15944550d1007780d96b4dcb6":["55eeb2534cd53d2a985669829df942468ebf5314"]},"commit2Childs":{"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","e9e1499c5d26c936238506df90a3c02c76707722"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"05fe562aa248790944d43cdd478f512572835ba0":["417142ff08fda9cf0b72d5133e63097a166c6458","9fc47cb7b4346802411bb432f501ed0673d7119e"],"3b0e8c39ca08b5a02de6edcd33d6f3b90b865173":["70e1c9c32f6e8c8b7c9af038f2795cdd98fb9068"],"55eeb2534cd53d2a985669829df942468ebf5314":["47b9e6cdfa7e1fc15944550d1007780d96b4dcb6"],"417142ff08fda9cf0b72d5133e63097a166c6458":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["05fe562aa248790944d43cdd478f512572835ba0"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"d4d69c535930b5cce125cff868d40f6373dc27d4":["3b0e8c39ca08b5a02de6edcd33d6f3b90b865173"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["55eeb2534cd53d2a985669829df942468ebf5314","d4d69c535930b5cce125cff868d40f6373dc27d4"],"e9e1499c5d26c936238506df90a3c02c76707722":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["60596f28be69b10c37a56a303c2dbea07b2ca4ba","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"47b9e6cdfa7e1fc15944550d1007780d96b4dcb6":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"70e1c9c32f6e8c8b7c9af038f2795cdd98fb9068":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}