{"path":"solr/core/src/java/org/apache/solr/util/hll/NumberUtil#toHex(byte[],int,int).mjava","commits":[{"id":"6d8714f9ceaaff94f0968d1c2d037978c3fde569","date":1437042727,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/NumberUtil#toHex(byte[],int,int).mjava","pathOld":"/dev/null","sourceNew":"    // ------------------------------------------------------------------------\n    /**\n     * Converts the specified array of <code>byte</code>s into a string of\n     * hex characters (low <code>byte</code> first).\n     *\n     * @param  bytes the array of <code>byte</code>s that are to be converted.\n     *         This cannot be <code>null</code> though it may be empty.\n     * @param  offset the offset in <code>bytes</code> at which the bytes will\n     *         be taken.  This cannot be negative and must be less than\n     *         <code>bytes.length - 1</code>.\n     * @param  count the number of bytes to be retrieved from the specified array.\n     *         This cannot be negative.  If greater than <code>bytes.length - offset</code>\n     *         then that value is used.\n     * @return a string of at most <code>count</code> characters that represents\n     *         the specified byte array in hex.  This will never be <code>null</code>\n     *         though it may be empty if <code>bytes</code> is empty or <code>count</code>\n     *         is zero.\n     * @throws IllegalArgumentException if <code>offset</code> is greater than\n     *         or equal to <code>bytes.length</code>.\n     * @see #fromHex(String, int, int)\n     */\n    public static String toHex(final byte[] bytes, final int offset, final int count) {\n        if(offset >= bytes.length) throw new IllegalArgumentException(\"Offset is greater than the length (\" + offset + \" >= \" + bytes.length + \").\")/*by contract*/;\n        final int byteCount = Math.min( (bytes.length - offset), count);\n        final int upperBound = byteCount + offset;\n\n        final char[] chars = new char[byteCount * 2/*two chars per byte*/];\n        int charIndex = 0;\n        for(int i=offset; i<upperBound; i++) {\n            final byte value = bytes[i];\n            chars[charIndex++] = HEX[(value >>> 4) & 0x0F];\n            chars[charIndex++] = HEX[value & 0x0F];\n        }\n\n        return new String(chars);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b5ee4c66244bdfcc4796a114519d47701b2c026","date":1437132013,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/hll/NumberUtil#toHex(byte[],int,int).mjava","pathOld":"/dev/null","sourceNew":"    // ------------------------------------------------------------------------\n    /**\n     * Converts the specified array of <code>byte</code>s into a string of\n     * hex characters (low <code>byte</code> first).\n     *\n     * @param  bytes the array of <code>byte</code>s that are to be converted.\n     *         This cannot be <code>null</code> though it may be empty.\n     * @param  offset the offset in <code>bytes</code> at which the bytes will\n     *         be taken.  This cannot be negative and must be less than\n     *         <code>bytes.length - 1</code>.\n     * @param  count the number of bytes to be retrieved from the specified array.\n     *         This cannot be negative.  If greater than <code>bytes.length - offset</code>\n     *         then that value is used.\n     * @return a string of at most <code>count</code> characters that represents\n     *         the specified byte array in hex.  This will never be <code>null</code>\n     *         though it may be empty if <code>bytes</code> is empty or <code>count</code>\n     *         is zero.\n     * @throws IllegalArgumentException if <code>offset</code> is greater than\n     *         or equal to <code>bytes.length</code>.\n     * @see #fromHex(String, int, int)\n     */\n    public static String toHex(final byte[] bytes, final int offset, final int count) {\n        if(offset >= bytes.length) throw new IllegalArgumentException(\"Offset is greater than the length (\" + offset + \" >= \" + bytes.length + \").\")/*by contract*/;\n        final int byteCount = Math.min( (bytes.length - offset), count);\n        final int upperBound = byteCount + offset;\n\n        final char[] chars = new char[byteCount * 2/*two chars per byte*/];\n        int charIndex = 0;\n        for(int i=offset; i<upperBound; i++) {\n            final byte value = bytes[i];\n            chars[charIndex++] = HEX[(value >>> 4) & 0x0F];\n            chars[charIndex++] = HEX[value & 0x0F];\n        }\n\n        return new String(chars);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b5ee4c66244bdfcc4796a114519d47701b2c026"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b5ee4c66244bdfcc4796a114519d47701b2c026","6d8714f9ceaaff94f0968d1c2d037978c3fde569"],"3b5ee4c66244bdfcc4796a114519d47701b2c026":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6d8714f9ceaaff94f0968d1c2d037978c3fde569":["3b5ee4c66244bdfcc4796a114519d47701b2c026"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}