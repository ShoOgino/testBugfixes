{"path":"lucene/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+this.nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      char[] text;\n      String text2;\n      while(true) {\n        text = this.getRandomText();\n        text2 = new String(text, 0, text.length-1);\n        if (!termsSeen.contains(text2)) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+this.nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += this.nextInt(1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+this.nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += this.nextInt(1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && this.nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+this.nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) this.nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56da903869515527852ee21ea7ef7bfe414cd40d","date":1294224724,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","sourceNew":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+random.nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      String text2;\n      while(true) {\n        text2 = _TestUtil.randomUnicodeString(random);\n        if (!termsSeen.contains(text2) && !text2.endsWith(\".\")) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+random.nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += _TestUtil.nextInt(random, 1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+random.nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += _TestUtil.nextInt(random, 1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && random.nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+random.nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) random.nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","sourceOld":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+this.nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      char[] text;\n      String text2;\n      while(true) {\n        text = this.getRandomText();\n        text2 = new String(text, 0, text.length-1);\n        if (!termsSeen.contains(text2)) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+this.nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += this.nextInt(1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+this.nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += this.nextInt(1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && this.nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+this.nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) this.nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","sourceNew":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+random.nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      String text2;\n      while(true) {\n        text2 = _TestUtil.randomUnicodeString(random);\n        if (!termsSeen.contains(text2) && !text2.endsWith(\".\")) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+random.nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += _TestUtil.nextInt(random, 1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+random.nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += _TestUtil.nextInt(random, 1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && random.nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+random.nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) random.nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","sourceOld":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+this.nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      char[] text;\n      String text2;\n      while(true) {\n        text = this.getRandomText();\n        text2 = new String(text, 0, text.length-1);\n        if (!termsSeen.contains(text2)) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+this.nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += this.nextInt(1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+this.nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += this.nextInt(1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && this.nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+this.nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) this.nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","sourceNew":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+random.nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      String text2;\n      while(true) {\n        text2 = _TestUtil.randomUnicodeString(random);\n        if (!termsSeen.contains(text2) && !text2.endsWith(\".\")) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+random.nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += _TestUtil.nextInt(random, 1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+random.nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += _TestUtil.nextInt(random, 1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && random.nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+random.nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) random.nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","sourceOld":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+this.nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      char[] text;\n      String text2;\n      while(true) {\n        text = this.getRandomText();\n        text2 = new String(text, 0, text.length-1);\n        if (!termsSeen.contains(text2)) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+this.nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += this.nextInt(1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+this.nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += this.nextInt(1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && this.nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+this.nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) this.nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestCodecs#makeRandomTerms(boolean,boolean).mjava","sourceNew":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+random.nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      String text2;\n      while(true) {\n        text2 = _TestUtil.randomUnicodeString(random);\n        if (!termsSeen.contains(text2) && !text2.endsWith(\".\")) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+random.nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += _TestUtil.nextInt(random, 1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+random.nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += _TestUtil.nextInt(random, 1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && random.nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+random.nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) random.nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","sourceOld":"  TermData[] makeRandomTerms(final boolean omitTF, final boolean storePayloads) {\n    final int numTerms = 1+random.nextInt(NUM_TERMS_RAND);\n    //final int numTerms = 2;\n    final TermData[] terms = new TermData[numTerms];\n\n    final HashSet<String> termsSeen = new HashSet<String>();\n\n    for(int i=0;i<numTerms;i++) {\n\n      // Make term text\n      String text2;\n      while(true) {\n        text2 = _TestUtil.randomUnicodeString(random);\n        if (!termsSeen.contains(text2) && !text2.endsWith(\".\")) {\n          termsSeen.add(text2);\n          break;\n        }\n      }\n\n      final int docFreq = 1+random.nextInt(DOC_FREQ_RAND);\n      final int[] docs = new int[docFreq];\n      PositionData[][] positions;\n\n      if (!omitTF)\n        positions = new PositionData[docFreq][];\n      else\n        positions = null;\n\n      int docID = 0;\n      for(int j=0;j<docFreq;j++) {\n        docID += _TestUtil.nextInt(random, 1, 10);\n        docs[j] = docID;\n\n        if (!omitTF) {\n          final int termFreq = 1+random.nextInt(TERM_DOC_FREQ_RAND);\n          positions[j] = new PositionData[termFreq];\n          int position = 0;\n          for(int k=0;k<termFreq;k++) {\n            position += _TestUtil.nextInt(random, 1, 10);\n\n            final BytesRef payload;\n            if (storePayloads && random.nextInt(4) == 0) {\n              final byte[] bytes = new byte[1+random.nextInt(5)];\n              for(int l=0;l<bytes.length;l++) {\n                bytes[l] = (byte) random.nextInt(255);\n              }\n              payload = new BytesRef(bytes);\n            } else {\n              payload = null;\n            }\n\n            positions[j][k] = new PositionData(position, payload);\n          }\n        }\n      }\n\n      terms[i] = new TermData(text2, docs, positions);\n    }\n\n    return terms;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"70ad682703b8585f5d0a637efec044d57ec05efb":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","56da903869515527852ee21ea7ef7bfe414cd40d"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["56da903869515527852ee21ea7ef7bfe414cd40d"],"56da903869515527852ee21ea7ef7bfe414cd40d":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["955c32f886db6f6356c9fcdea6b1f1cb4effda24","56da903869515527852ee21ea7ef7bfe414cd40d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"70ad682703b8585f5d0a637efec044d57ec05efb":[],"56da903869515527852ee21ea7ef7bfe414cd40d":["70ad682703b8585f5d0a637efec044d57ec05efb","3a119bbc8703c10faa329ec201c654b3a35a1e3e","868da859b43505d9d2a023bfeae6dd0c795f5295"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["70ad682703b8585f5d0a637efec044d57ec05efb","56da903869515527852ee21ea7ef7bfe414cd40d","868da859b43505d9d2a023bfeae6dd0c795f5295"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["70ad682703b8585f5d0a637efec044d57ec05efb","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}