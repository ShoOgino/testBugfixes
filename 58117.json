{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#usePolicyFramework(Optional[DocCollection],SolrCloudManager).mjava","commits":[{"id":"01322d51122b6cbe6b5ba6059fffba67798dae72","date":1539067228,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#usePolicyFramework(Optional[DocCollection],SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/CloudUtil#usePolicyFramework(Optional[DocCollection],SolrCloudManager).mjava","sourceNew":"  private static boolean usePolicyFramework(Optional<DocCollection> collection, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    boolean useLegacyAssignment = false;\n    Map<String, Object> clusterProperties = cloudManager.getClusterStateProvider().getClusterProperties();\n    if (clusterProperties.containsKey(CollectionAdminParams.DEFAULTS))  {\n      Map<String, Object> defaults = (Map<String, Object>) clusterProperties.get(CollectionAdminParams.DEFAULTS);\n      Map<String, Object> collectionDefaults = (Map<String, Object>) defaults.getOrDefault(CollectionAdminParams.COLLECTION, Collections.emptyMap());\n      useLegacyAssignment = (boolean) collectionDefaults.getOrDefault(CollectionAdminParams.USE_LEGACY_REPLICA_ASSIGNMENT, false);\n    }\n\n    if (!useLegacyAssignment) {\n      // if legacy assignment is not selected then autoscaling is always available through the implicit policy/preferences\n      return true;\n    }\n\n    // legacy assignment is turned on, which means we must look at the actual autoscaling config\n    // to determine whether policy framework can be used or not for this collection\n\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    // if no autoscaling configuration exists then obviously we cannot use the policy framework\n    if (autoScalingConfig.getPolicy().isEmpty()) return false;\n    // do custom preferences exist\n    if (!autoScalingConfig.getPolicy().isEmptyPreferences()) return true;\n    // does a cluster policy exist\n    if (!autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) return true;\n    // finally we check if the current collection has a policy\n    return !collection.isPresent() || collection.get().getPolicyName() != null;\n  }\n\n","sourceOld":"  private static boolean usePolicyFramework(Optional<DocCollection> collection, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    // if no autoscaling configuration exists then obviously we cannot use the policy framework\n    if (autoScalingConfig.getPolicy().isEmpty()) return false;\n    // do custom preferences exist\n    if (!autoScalingConfig.getPolicy().isEmptyPreferences()) return true;\n    // does a cluster policy exist\n    if (!autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) return true;\n    // finally we check if the current collection has a policy\n    return !collection.isPresent() || collection.get().getPolicyName() != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9318235fae47cfc9aeb136234ff931ef095d0107","date":1539166132,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#usePolicyFramework(Optional[DocCollection],SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#usePolicyFramework(Optional[DocCollection],SolrCloudManager).mjava","sourceNew":"  private static boolean usePolicyFramework(Optional<DocCollection> collection, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    boolean useLegacyAssignment = false;\n    Map<String, Object> clusterProperties = cloudManager.getClusterStateProvider().getClusterProperties();\n    if (clusterProperties.containsKey(CollectionAdminParams.DEFAULTS))  {\n      Map<String, Object> defaults = (Map<String, Object>) clusterProperties.get(CollectionAdminParams.DEFAULTS);\n      Map<String, Object> collectionDefaults = (Map<String, Object>) defaults.getOrDefault(CollectionAdminParams.CLUSTER, Collections.emptyMap());\n      useLegacyAssignment = (boolean) collectionDefaults.getOrDefault(CollectionAdminParams.USE_LEGACY_REPLICA_ASSIGNMENT, false);\n    }\n\n    if (!useLegacyAssignment) {\n      // if legacy assignment is not selected then autoscaling is always available through the implicit policy/preferences\n      return true;\n    }\n\n    // legacy assignment is turned on, which means we must look at the actual autoscaling config\n    // to determine whether policy framework can be used or not for this collection\n\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    // if no autoscaling configuration exists then obviously we cannot use the policy framework\n    if (autoScalingConfig.getPolicy().isEmpty()) return false;\n    // do custom preferences exist\n    if (!autoScalingConfig.getPolicy().isEmptyPreferences()) return true;\n    // does a cluster policy exist\n    if (!autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) return true;\n    // finally we check if the current collection has a policy\n    return !collection.isPresent() || collection.get().getPolicyName() != null;\n  }\n\n","sourceOld":"  private static boolean usePolicyFramework(Optional<DocCollection> collection, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    boolean useLegacyAssignment = false;\n    Map<String, Object> clusterProperties = cloudManager.getClusterStateProvider().getClusterProperties();\n    if (clusterProperties.containsKey(CollectionAdminParams.DEFAULTS))  {\n      Map<String, Object> defaults = (Map<String, Object>) clusterProperties.get(CollectionAdminParams.DEFAULTS);\n      Map<String, Object> collectionDefaults = (Map<String, Object>) defaults.getOrDefault(CollectionAdminParams.COLLECTION, Collections.emptyMap());\n      useLegacyAssignment = (boolean) collectionDefaults.getOrDefault(CollectionAdminParams.USE_LEGACY_REPLICA_ASSIGNMENT, false);\n    }\n\n    if (!useLegacyAssignment) {\n      // if legacy assignment is not selected then autoscaling is always available through the implicit policy/preferences\n      return true;\n    }\n\n    // legacy assignment is turned on, which means we must look at the actual autoscaling config\n    // to determine whether policy framework can be used or not for this collection\n\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    // if no autoscaling configuration exists then obviously we cannot use the policy framework\n    if (autoScalingConfig.getPolicy().isEmpty()) return false;\n    // do custom preferences exist\n    if (!autoScalingConfig.getPolicy().isEmptyPreferences()) return true;\n    // does a cluster policy exist\n    if (!autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) return true;\n    // finally we check if the current collection has a policy\n    return !collection.isPresent() || collection.get().getPolicyName() != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"413f18c5620cf37b9bb2dfa7d3071bfa08b69a0d","date":1550526365,"type":3,"author":"shalinmangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#usePolicyFramework(Optional[DocCollection],SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#usePolicyFramework(Optional[DocCollection],SolrCloudManager).mjava","sourceNew":"  private static boolean usePolicyFramework(Optional<DocCollection> collection, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    boolean useLegacyAssignment = true;\n    Map<String, Object> clusterProperties = cloudManager.getClusterStateProvider().getClusterProperties();\n    if (clusterProperties.containsKey(CollectionAdminParams.DEFAULTS))  {\n      Map<String, Object> defaults = (Map<String, Object>) clusterProperties.get(CollectionAdminParams.DEFAULTS);\n      Map<String, Object> collectionDefaults = (Map<String, Object>) defaults.getOrDefault(CollectionAdminParams.CLUSTER, Collections.emptyMap());\n      useLegacyAssignment = Boolean.parseBoolean(collectionDefaults.getOrDefault(CollectionAdminParams.USE_LEGACY_REPLICA_ASSIGNMENT, \"true\").toString());\n    }\n\n    if (!useLegacyAssignment) {\n      // if legacy assignment is not selected then autoscaling is always available through the implicit policy/preferences\n      return true;\n    }\n\n    // legacy assignment is turned on, which means we must look at the actual autoscaling config\n    // to determine whether policy framework can be used or not for this collection\n\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    // if no autoscaling configuration exists then obviously we cannot use the policy framework\n    if (autoScalingConfig.getPolicy().isEmpty()) return false;\n    // do custom preferences exist\n    if (!autoScalingConfig.getPolicy().isEmptyPreferences()) return true;\n    // does a cluster policy exist\n    if (!autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) return true;\n    // finally we check if the current collection has a policy\n    return !collection.isPresent() || collection.get().getPolicyName() != null;\n  }\n\n","sourceOld":"  private static boolean usePolicyFramework(Optional<DocCollection> collection, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    boolean useLegacyAssignment = false;\n    Map<String, Object> clusterProperties = cloudManager.getClusterStateProvider().getClusterProperties();\n    if (clusterProperties.containsKey(CollectionAdminParams.DEFAULTS))  {\n      Map<String, Object> defaults = (Map<String, Object>) clusterProperties.get(CollectionAdminParams.DEFAULTS);\n      Map<String, Object> collectionDefaults = (Map<String, Object>) defaults.getOrDefault(CollectionAdminParams.CLUSTER, Collections.emptyMap());\n      useLegacyAssignment = (boolean) collectionDefaults.getOrDefault(CollectionAdminParams.USE_LEGACY_REPLICA_ASSIGNMENT, false);\n    }\n\n    if (!useLegacyAssignment) {\n      // if legacy assignment is not selected then autoscaling is always available through the implicit policy/preferences\n      return true;\n    }\n\n    // legacy assignment is turned on, which means we must look at the actual autoscaling config\n    // to determine whether policy framework can be used or not for this collection\n\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    // if no autoscaling configuration exists then obviously we cannot use the policy framework\n    if (autoScalingConfig.getPolicy().isEmpty()) return false;\n    // do custom preferences exist\n    if (!autoScalingConfig.getPolicy().isEmptyPreferences()) return true;\n    // does a cluster policy exist\n    if (!autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) return true;\n    // finally we check if the current collection has a policy\n    return !collection.isPresent() || collection.get().getPolicyName() != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"067ba8c807b0f23eae8bf41bc27046a87b548134","date":1587570399,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#usePolicyFramework(Optional[DocCollection],SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#usePolicyFramework(Optional[DocCollection],SolrCloudManager).mjava","sourceNew":"  private static boolean usePolicyFramework(Optional<DocCollection> collection, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    boolean useLegacyAssignment = true;\n    Map<String, Object> clusterProperties = cloudManager.getClusterStateProvider().getClusterProperties();\n    if (clusterProperties.containsKey(CollectionAdminParams.DEFAULTS))  {\n      Map<String, Object> defaults = (Map<String, Object>) clusterProperties.get(CollectionAdminParams.DEFAULTS);\n      Map<String, Object> collectionDefaults = (Map<String, Object>) defaults.getOrDefault(CollectionAdminParams.CLUSTER, Collections.emptyMap());\n      useLegacyAssignment = Boolean.parseBoolean(collectionDefaults.getOrDefault(CollectionAdminParams.USE_LEGACY_REPLICA_ASSIGNMENT, \"true\").toString());\n    }\n\n    if (!useLegacyAssignment) {\n      // if legacy assignment is not selected then autoscaling is always available through the implicit policy/preferences\n      return true;\n    }\n\n    // legacy assignment is turned on, which means we must look at the actual autoscaling config\n    // to determine whether policy framework can be used or not for this collection\n\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    // if no autoscaling configuration exists then obviously we cannot use the policy framework\n    if (autoScalingConfig.getPolicy().isEmpty()) return false;\n    // do custom preferences exist\n    if (!autoScalingConfig.getPolicy().hasEmptyPreferences()) return true;\n    // does a cluster policy exist\n    if (!autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) return true;\n    // finally we check if the current collection has a policy\n    return !collection.isPresent() || collection.get().getPolicyName() != null;\n  }\n\n","sourceOld":"  private static boolean usePolicyFramework(Optional<DocCollection> collection, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    boolean useLegacyAssignment = true;\n    Map<String, Object> clusterProperties = cloudManager.getClusterStateProvider().getClusterProperties();\n    if (clusterProperties.containsKey(CollectionAdminParams.DEFAULTS))  {\n      Map<String, Object> defaults = (Map<String, Object>) clusterProperties.get(CollectionAdminParams.DEFAULTS);\n      Map<String, Object> collectionDefaults = (Map<String, Object>) defaults.getOrDefault(CollectionAdminParams.CLUSTER, Collections.emptyMap());\n      useLegacyAssignment = Boolean.parseBoolean(collectionDefaults.getOrDefault(CollectionAdminParams.USE_LEGACY_REPLICA_ASSIGNMENT, \"true\").toString());\n    }\n\n    if (!useLegacyAssignment) {\n      // if legacy assignment is not selected then autoscaling is always available through the implicit policy/preferences\n      return true;\n    }\n\n    // legacy assignment is turned on, which means we must look at the actual autoscaling config\n    // to determine whether policy framework can be used or not for this collection\n\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    // if no autoscaling configuration exists then obviously we cannot use the policy framework\n    if (autoScalingConfig.getPolicy().isEmpty()) return false;\n    // do custom preferences exist\n    if (!autoScalingConfig.getPolicy().isEmptyPreferences()) return true;\n    // does a cluster policy exist\n    if (!autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) return true;\n    // finally we check if the current collection has a policy\n    return !collection.isPresent() || collection.get().getPolicyName() != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#usePolicyFramework(Optional[DocCollection],SolrCloudManager).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#usePolicyFramework(Optional[DocCollection],SolrCloudManager).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private static boolean usePolicyFramework(Optional<DocCollection> collection, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    boolean useLegacyAssignment = true;\n    Map<String, Object> clusterProperties = cloudManager.getClusterStateProvider().getClusterProperties();\n    if (clusterProperties.containsKey(CollectionAdminParams.DEFAULTS))  {\n      Map<String, Object> defaults = (Map<String, Object>) clusterProperties.get(CollectionAdminParams.DEFAULTS);\n      Map<String, Object> collectionDefaults = (Map<String, Object>) defaults.getOrDefault(CollectionAdminParams.CLUSTER, Collections.emptyMap());\n      useLegacyAssignment = Boolean.parseBoolean(collectionDefaults.getOrDefault(CollectionAdminParams.USE_LEGACY_REPLICA_ASSIGNMENT, \"true\").toString());\n    }\n\n    if (!useLegacyAssignment) {\n      // if legacy assignment is not selected then autoscaling is always available through the implicit policy/preferences\n      return true;\n    }\n\n    // legacy assignment is turned on, which means we must look at the actual autoscaling config\n    // to determine whether policy framework can be used or not for this collection\n\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    // if no autoscaling configuration exists then obviously we cannot use the policy framework\n    if (autoScalingConfig.getPolicy().isEmpty()) return false;\n    // do custom preferences exist\n    if (!autoScalingConfig.getPolicy().hasEmptyPreferences()) return true;\n    // does a cluster policy exist\n    if (!autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) return true;\n    // finally we check if the current collection has a policy\n    return !collection.isPresent() || collection.get().getPolicyName() != null;\n  }\n\n","sourceOld":"  private static boolean usePolicyFramework(Optional<DocCollection> collection, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    boolean useLegacyAssignment = true;\n    Map<String, Object> clusterProperties = cloudManager.getClusterStateProvider().getClusterProperties();\n    if (clusterProperties.containsKey(CollectionAdminParams.DEFAULTS))  {\n      Map<String, Object> defaults = (Map<String, Object>) clusterProperties.get(CollectionAdminParams.DEFAULTS);\n      Map<String, Object> collectionDefaults = (Map<String, Object>) defaults.getOrDefault(CollectionAdminParams.CLUSTER, Collections.emptyMap());\n      useLegacyAssignment = Boolean.parseBoolean(collectionDefaults.getOrDefault(CollectionAdminParams.USE_LEGACY_REPLICA_ASSIGNMENT, \"true\").toString());\n    }\n\n    if (!useLegacyAssignment) {\n      // if legacy assignment is not selected then autoscaling is always available through the implicit policy/preferences\n      return true;\n    }\n\n    // legacy assignment is turned on, which means we must look at the actual autoscaling config\n    // to determine whether policy framework can be used or not for this collection\n\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    // if no autoscaling configuration exists then obviously we cannot use the policy framework\n    if (autoScalingConfig.getPolicy().isEmpty()) return false;\n    // do custom preferences exist\n    if (!autoScalingConfig.getPolicy().hasEmptyPreferences()) return true;\n    // does a cluster policy exist\n    if (!autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) return true;\n    // finally we check if the current collection has a policy\n    return !collection.isPresent() || collection.get().getPolicyName() != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/Assign#usePolicyFramework(Optional[DocCollection],SolrCloudManager).mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  private static boolean usePolicyFramework(Optional<DocCollection> collection, SolrCloudManager cloudManager) throws IOException, InterruptedException {\n    boolean useLegacyAssignment = true;\n    Map<String, Object> clusterProperties = cloudManager.getClusterStateProvider().getClusterProperties();\n    if (clusterProperties.containsKey(CollectionAdminParams.DEFAULTS))  {\n      Map<String, Object> defaults = (Map<String, Object>) clusterProperties.get(CollectionAdminParams.DEFAULTS);\n      Map<String, Object> collectionDefaults = (Map<String, Object>) defaults.getOrDefault(CollectionAdminParams.CLUSTER, Collections.emptyMap());\n      useLegacyAssignment = Boolean.parseBoolean(collectionDefaults.getOrDefault(CollectionAdminParams.USE_LEGACY_REPLICA_ASSIGNMENT, \"true\").toString());\n    }\n\n    if (!useLegacyAssignment) {\n      // if legacy assignment is not selected then autoscaling is always available through the implicit policy/preferences\n      return true;\n    }\n\n    // legacy assignment is turned on, which means we must look at the actual autoscaling config\n    // to determine whether policy framework can be used or not for this collection\n\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    // if no autoscaling configuration exists then obviously we cannot use the policy framework\n    if (autoScalingConfig.getPolicy().isEmpty()) return false;\n    // do custom preferences exist\n    if (!autoScalingConfig.getPolicy().hasEmptyPreferences()) return true;\n    // does a cluster policy exist\n    if (!autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) return true;\n    // finally we check if the current collection has a policy\n    return !collection.isPresent() || collection.get().getPolicyName() != null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"01322d51122b6cbe6b5ba6059fffba67798dae72":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3f504512a03d978990cbff30db0522b354e846db":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["067ba8c807b0f23eae8bf41bc27046a87b548134"],"413f18c5620cf37b9bb2dfa7d3071bfa08b69a0d":["9318235fae47cfc9aeb136234ff931ef095d0107"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"067ba8c807b0f23eae8bf41bc27046a87b548134":["413f18c5620cf37b9bb2dfa7d3071bfa08b69a0d"],"9318235fae47cfc9aeb136234ff931ef095d0107":["01322d51122b6cbe6b5ba6059fffba67798dae72"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"01322d51122b6cbe6b5ba6059fffba67798dae72":["9318235fae47cfc9aeb136234ff931ef095d0107"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["3f504512a03d978990cbff30db0522b354e846db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["01322d51122b6cbe6b5ba6059fffba67798dae72"],"413f18c5620cf37b9bb2dfa7d3071bfa08b69a0d":["067ba8c807b0f23eae8bf41bc27046a87b548134"],"067ba8c807b0f23eae8bf41bc27046a87b548134":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"9318235fae47cfc9aeb136234ff931ef095d0107":["413f18c5620cf37b9bb2dfa7d3071bfa08b69a0d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}