{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","commits":[{"id":"a4422b331d00607258b0ed3e43934306e67764aa","date":1513943901,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private void simRunLeaderElection(String collection, Slice s, boolean saveClusterState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        AtomicReference<ReplicaInfo> riRef = new AtomicReference<>();\n        // find our ReplicaInfo for this replica\n        nodeReplicaMap.get(r.getNodeName()).forEach(info -> {\n          if (info.getName().equals(r.getName())) {\n            riRef.set(info);\n          }\n        });\n        ReplicaInfo ri = riRef.get();\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get()) {\n      collectionsStatesRef.set(null);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad60b6945c360ff89899d716d9cdec8dd674e2a0","date":1528114819,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","sourceNew":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        AtomicReference<ReplicaInfo> riRef = new AtomicReference<>();\n        // find our ReplicaInfo for this replica\n        nodeReplicaMap.get(r.getNodeName()).forEach(info -> {\n          if (info.getName().equals(r.getName())) {\n            riRef.set(info);\n          }\n        });\n        ReplicaInfo ri = riRef.get();\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(String collection, Slice s, boolean saveClusterState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        AtomicReference<ReplicaInfo> riRef = new AtomicReference<>();\n        // find our ReplicaInfo for this replica\n        nodeReplicaMap.get(r.getNodeName()).forEach(info -> {\n          if (info.getName().equals(r.getName())) {\n            riRef.set(info);\n          }\n        });\n        ReplicaInfo ri = riRef.get();\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get()) {\n      collectionsStatesRef.set(null);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","sourceNew":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        AtomicReference<ReplicaInfo> riRef = new AtomicReference<>();\n        // find our ReplicaInfo for this replica\n        nodeReplicaMap.get(r.getNodeName()).forEach(info -> {\n          if (info.getName().equals(r.getName())) {\n            riRef.set(info);\n          }\n        });\n        ReplicaInfo ri = riRef.get();\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(String collection, Slice s, boolean saveClusterState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        AtomicReference<ReplicaInfo> riRef = new AtomicReference<>();\n        // find our ReplicaInfo for this replica\n        nodeReplicaMap.get(r.getNodeName()).forEach(info -> {\n          if (info.getName().equals(r.getName())) {\n            riRef.set(info);\n          }\n        });\n        ReplicaInfo ri = riRef.get();\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get()) {\n      collectionsStatesRef.set(null);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","sourceNew":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        AtomicReference<ReplicaInfo> riRef = new AtomicReference<>();\n        // find our ReplicaInfo for this replica\n        nodeReplicaMap.get(r.getNodeName()).forEach(info -> {\n          if (info.getName().equals(r.getName())) {\n            riRef.set(info);\n          }\n        });\n        ReplicaInfo ri = riRef.get();\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(String collection, Slice s, boolean saveClusterState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        AtomicReference<ReplicaInfo> riRef = new AtomicReference<>();\n        // find our ReplicaInfo for this replica\n        nodeReplicaMap.get(r.getNodeName()).forEach(info -> {\n          if (info.getName().equals(r.getName())) {\n            riRef.set(info);\n          }\n        });\n        ReplicaInfo ri = riRef.get();\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get()) {\n      collectionsStatesRef.set(null);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b55cd711a129fb7fc4c3c4672d652149c9a4faa","date":1528813320,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","sourceNew":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        // find our ReplicaInfo for this replica\n        ReplicaInfo ri = getReplicaInfo(r);\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        AtomicReference<ReplicaInfo> riRef = new AtomicReference<>();\n        // find our ReplicaInfo for this replica\n        nodeReplicaMap.get(r.getNodeName()).forEach(info -> {\n          if (info.getName().equals(r.getName())) {\n            riRef.set(info);\n          }\n        });\n        ReplicaInfo ri = riRef.get();\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","sourceNew":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        // find our ReplicaInfo for this replica\n        ReplicaInfo ri = getReplicaInfo(r);\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        AtomicReference<ReplicaInfo> riRef = new AtomicReference<>();\n        // find our ReplicaInfo for this replica\n        nodeReplicaMap.get(r.getNodeName()).forEach(info -> {\n          if (info.getName().equals(r.getName())) {\n            riRef.set(info);\n          }\n        });\n        ReplicaInfo ri = riRef.get();\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","sourceNew":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        // find our ReplicaInfo for this replica\n        ReplicaInfo ri = getReplicaInfo(r);\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        AtomicReference<ReplicaInfo> riRef = new AtomicReference<>();\n        // find our ReplicaInfo for this replica\n        nodeReplicaMap.get(r.getNodeName()).forEach(info -> {\n          if (info.getName().equals(r.getName())) {\n            riRef.set(info);\n          }\n        });\n        ReplicaInfo ri = riRef.get();\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","sourceNew":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.debug(\"Running leader election for {} / {}\", collection, s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        LOG.debug(\"-- no replicas in {} / {}\", collection, s.getName());\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n          // find our ReplicaInfo for this replica\n          ReplicaInfo ri = getReplicaInfo(r);\n          if (ri == null) {\n            throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n          }\n          synchronized (ri) {\n            if (r.isActive(liveNodes.get())) {\n              if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                LOG.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                alreadyHasLeader.set(true);\n                return;\n              } else {\n                active.add(ri);\n              }\n            } else { // if it's on a node that is not live mark it down\n              LOG.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n              if (!liveNodes.contains(r.getNodeName())) {\n                ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                stateChanged.set(true);\n              }\n            }\n          }\n        });\n        if (alreadyHasLeader.get()) {\n          LOG.debug(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          LOG.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          LOG.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          LOG.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        stateChanged.set(true);\n        LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri.getName());\n      }\n    } else {\n      LOG.debug(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.trace(\"Running leader election for \" + collection + \" / \" + s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      lt.minimumWaitBetweenActions();\n      lt.markAttemptingAction();\n\n      // mark all replicas as non-leader (probably not necessary) and collect all active and live\n      List<ReplicaInfo> active = new ArrayList<>();\n      s.getReplicas().forEach(r -> {\n        // find our ReplicaInfo for this replica\n        ReplicaInfo ri = getReplicaInfo(r);\n        if (ri == null) {\n          throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n        }\n        synchronized (ri) {\n          if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {\n            stateChanged.set(true);\n          }\n          if (r.isActive(liveNodes.get())) {\n            active.add(ri);\n          } else { // if it's on a node that is not live mark it down\n            if (!liveNodes.contains(r.getNodeName())) {\n              ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n              stateChanged.set(true);\n            }\n          }\n        }\n      });\n      if (active.isEmpty()) {\n        LOG.warn(\"-- can't find any active replicas for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      // pick first active one\n      ReplicaInfo ri = null;\n      for (ReplicaInfo a : active) {\n        if (!a.getType().equals(Replica.Type.PULL)) {\n          ri = a;\n          break;\n        }\n      }\n      if (ri == null) {\n        LOG.warn(\"-- can't find any suitable replica type for \" + collection + \" / \" + s.getName());\n        return;\n      }\n      synchronized (ri) {\n        ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n      }\n      stateChanged.set(true);\n      LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri);\n    } else {\n      LOG.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","bugFix":["a4422b331d00607258b0ed3e43934306e67764aa","6b55cd711a129fb7fc4c3c4672d652149c9a4faa"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","sourceNew":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      log.debug(\"Running leader election for {} / {}\", collection, s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        log.debug(\"-- no replicas in {} / {}\", collection, s.getName());\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n          // find our ReplicaInfo for this replica\n          ReplicaInfo ri = getReplicaInfo(r);\n          if (ri == null) {\n            throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n          }\n          synchronized (ri) {\n            if (r.isActive(liveNodes.get())) {\n              if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                alreadyHasLeader.set(true);\n                return;\n              } else {\n                active.add(ri);\n              }\n            } else { // if it's on a node that is not live mark it down\n              log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n              if (!liveNodes.contains(r.getNodeName())) {\n                ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                stateChanged.set(true);\n              }\n            }\n          }\n        });\n        if (alreadyHasLeader.get()) {\n          log.debug(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        stateChanged.set(true);\n        log.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri.getName());\n      }\n    } else {\n      log.debug(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      LOG.debug(\"Running leader election for {} / {}\", collection, s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        LOG.debug(\"-- no replicas in {} / {}\", collection, s.getName());\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n          // find our ReplicaInfo for this replica\n          ReplicaInfo ri = getReplicaInfo(r);\n          if (ri == null) {\n            throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n          }\n          synchronized (ri) {\n            if (r.isActive(liveNodes.get())) {\n              if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                LOG.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                alreadyHasLeader.set(true);\n                return;\n              } else {\n                active.add(ri);\n              }\n            } else { // if it's on a node that is not live mark it down\n              LOG.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n              if (!liveNodes.contains(r.getNodeName())) {\n                ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                stateChanged.set(true);\n              }\n            }\n          }\n        });\n        if (alreadyHasLeader.get()) {\n          LOG.debug(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          LOG.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          LOG.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          LOG.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        stateChanged.set(true);\n        LOG.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri.getName());\n      }\n    } else {\n      LOG.debug(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc18bc8ea2e2c1e308757ff50671c774438e9f3e","date":1538052583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","sourceNew":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      log.trace(\"Running leader election for {} / {}\", collection, s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        log.trace(\"-- no replicas in {} / {}\", collection, s.getName());\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n          // find our ReplicaInfo for this replica\n          ReplicaInfo ri = getReplicaInfo(r);\n          if (ri == null) {\n            throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n          }\n          synchronized (ri) {\n            if (r.isActive(liveNodes.get())) {\n              if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                alreadyHasLeader.set(true);\n                return;\n              } else {\n                active.add(ri);\n              }\n            } else { // if it's on a node that is not live mark it down\n              log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n              if (!liveNodes.contains(r.getNodeName())) {\n                ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                stateChanged.set(true);\n              }\n            }\n          }\n        });\n        if (alreadyHasLeader.get()) {\n          log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        log.debug(\"-- elected new leader for {} / {}: {}\", collection, s.getName(), ri);\n        stateChanged.set(true);\n      }\n    } else {\n      log.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      log.debug(\"Running leader election for {} / {}\", collection, s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        log.debug(\"-- no replicas in {} / {}\", collection, s.getName());\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n          // find our ReplicaInfo for this replica\n          ReplicaInfo ri = getReplicaInfo(r);\n          if (ri == null) {\n            throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n          }\n          synchronized (ri) {\n            if (r.isActive(liveNodes.get())) {\n              if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                alreadyHasLeader.set(true);\n                return;\n              } else {\n                active.add(ri);\n              }\n            } else { // if it's on a node that is not live mark it down\n              log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n              if (!liveNodes.contains(r.getNodeName())) {\n                ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                stateChanged.set(true);\n              }\n            }\n          }\n        });\n        if (alreadyHasLeader.get()) {\n          log.debug(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        stateChanged.set(true);\n        log.debug(\"-- elected new leader for \" + collection + \" / \" + s.getName() + \": \" + ri.getName());\n      }\n    } else {\n      log.debug(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8254aa20264eb7a88d556bbe0346667937ed9c2a","date":1538494545,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","sourceNew":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      log.trace(\"Running leader election for {} / {}\", collection, s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        log.trace(\"-- no replicas in {} / {}\", collection, s.getName());\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n          // find our ReplicaInfo for this replica\n          ReplicaInfo ri = getReplicaInfo(r);\n          if (ri == null) {\n            throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n          }\n          synchronized (ri) {\n            if (r.isActive(liveNodes.get())) {\n              if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                alreadyHasLeader.set(true);\n                return;\n              } else {\n                active.add(ri);\n              }\n            } else { // if it's on a node that is not live mark it down\n              log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n              if (!liveNodes.contains(r.getNodeName())) {\n                ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                stateChanged.set(true);\n              }\n            }\n          }\n        });\n        if (alreadyHasLeader.get()) {\n          log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n            s.getName(), clusterStateVersion, ri);\n        stateChanged.set(true);\n      }\n    } else {\n      log.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      log.trace(\"Running leader election for {} / {}\", collection, s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        log.trace(\"-- no replicas in {} / {}\", collection, s.getName());\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n          // find our ReplicaInfo for this replica\n          ReplicaInfo ri = getReplicaInfo(r);\n          if (ri == null) {\n            throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n          }\n          synchronized (ri) {\n            if (r.isActive(liveNodes.get())) {\n              if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                alreadyHasLeader.set(true);\n                return;\n              } else {\n                active.add(ri);\n              }\n            } else { // if it's on a node that is not live mark it down\n              log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n              if (!liveNodes.contains(r.getNodeName())) {\n                ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                stateChanged.set(true);\n              }\n            }\n          }\n        });\n        if (alreadyHasLeader.get()) {\n          log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        log.debug(\"-- elected new leader for {} / {}: {}\", collection, s.getName(), ri);\n        stateChanged.set(true);\n      }\n    } else {\n      log.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n      saveClusterState.set(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aee7536c0dab5f97165523b2077d324095f5518","date":1544481552,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","sourceNew":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    lock.lockInterruptibly();\n    try {\n      Replica leader = s.getLeader();\n      if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"Running leader election for {} / {}\", collection, s.getName());\n        if (s.getReplicas().isEmpty()) { // no replicas - punt\n          log.trace(\"-- no replicas in {} / {}\", collection, s.getName());\n          return;\n        }\n        ActionThrottle lt = getThrottle(collection, s.getName());\n        synchronized (lt) {\n          // collect all active and live\n          List<ReplicaInfo> active = new ArrayList<>();\n          AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n          s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n          if (alreadyHasLeader.get()) {\n            log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n            return;\n          }\n          if (active.isEmpty()) {\n            log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n            log.debug(\"-- liveNodes: {}\", liveNodes.get());\n            return;\n          }\n          // pick first active one\n          ReplicaInfo ri = null;\n          for (ReplicaInfo a : active) {\n            if (!a.getType().equals(Replica.Type.PULL)) {\n              ri = a;\n              break;\n            }\n          }\n          if (ri == null) {\n            log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n            return;\n          }\n          // now mark the leader election throttle\n          lt.minimumWaitBetweenActions();\n          lt.markAttemptingAction();\n          synchronized (ri) {\n            ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n          }\n          log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n              s.getName(), clusterStateVersion, ri);\n          stateChanged.set(true);\n        }\n      } else {\n        log.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.set(null);\n      }\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    Replica leader = s.getLeader();\n    if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n      log.trace(\"Running leader election for {} / {}\", collection, s.getName());\n      if (s.getReplicas().isEmpty()) { // no replicas - punt\n        log.trace(\"-- no replicas in {} / {}\", collection, s.getName());\n        return;\n      }\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n          // find our ReplicaInfo for this replica\n          ReplicaInfo ri = getReplicaInfo(r);\n          if (ri == null) {\n            throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n          }\n          synchronized (ri) {\n            if (r.isActive(liveNodes.get())) {\n              if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                alreadyHasLeader.set(true);\n                return;\n              } else {\n                active.add(ri);\n              }\n            } else { // if it's on a node that is not live mark it down\n              log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n              if (!liveNodes.contains(r.getNodeName())) {\n                ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                stateChanged.set(true);\n              }\n            }\n          }\n        });\n        if (alreadyHasLeader.get()) {\n          log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n            s.getName(), clusterStateVersion, ri);\n        stateChanged.set(true);\n      }\n    } else {\n      log.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n    }\n    if (stateChanged.get() || saveState) {\n      collectionsStatesRef.set(null);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66b87d86427dfa19b2ef36b66de83aa9655cea33","date":1552627668,"type":5,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,String,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simRunLeaderElection(String,Slice,boolean).mjava","sourceNew":"  private void simRunLeaderElection(final String collection, final String slice,\n                                    final boolean saveState) throws Exception {\n    \n    log.trace(\"Attempting leader election ({} / {})\", collection, slice);\n    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    \n    lock.lockInterruptibly();\n    try {\n      final ClusterState state = getClusterState();\n      final DocCollection col = state.getCollectionOrNull(collection);\n      \n      if (null == col) {\n        log.trace(\"-- collection does not exist (anymore), skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }\n      final Slice s = col.getSlice(slice);\n      if (null == s) {\n        log.trace(\"-- slice does not exist, skipping leader election ({} / {})\",\n                  collection, slice);\n        return;\n      }        \n      if (s.getState() == Slice.State.INACTIVE) {\n        log.trace(\"-- slice state is {}, skipping leader election ({} / {})\",\n                  s.getState(), collection, slice);\n        return;\n      }\n      if (s.getReplicas().isEmpty()) {\n        log.trace(\"-- no replicas, skipping leader election ({} / {})\",  collection, slice);\n        return;\n      }\n      \n      final Replica leader = s.getLeader();\n      if (null != leader && liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"-- already has livenode leader, skipping leader election {} / {}\",\n                  collection, slice);\n        return;\n      }\n      \n      if (s.getState() != Slice.State.ACTIVE) {\n        log.trace(\"-- slice state is {}, but I will run leader election anyway ({} / {})\",\n                  s.getState(), collection, slice);\n      }\n      \n      log.debug(\"Running leader election ({} / {})\", collection, slice);\n      ActionThrottle lt = getThrottle(collection, s.getName());\n      synchronized (lt) {\n        // collect all active and live\n        List<ReplicaInfo> active = new ArrayList<>();\n        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n        s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n        if (alreadyHasLeader.get()) {\n          log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        if (active.isEmpty()) {\n          log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n          log.debug(\"-- liveNodes: {}\", liveNodes.get());\n          return;\n        }\n        // pick first active one\n        ReplicaInfo ri = null;\n        for (ReplicaInfo a : active) {\n          if (!a.getType().equals(Replica.Type.PULL)) {\n            ri = a;\n            break;\n          }\n        }\n        if (ri == null) {\n          log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n          return;\n        }\n        // now mark the leader election throttle\n        lt.minimumWaitBetweenActions();\n        lt.markAttemptingAction();\n        synchronized (ri) {\n          ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n        }\n        log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n                  s.getName(), clusterStateVersion, ri);\n        stateChanged.set(true);\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.set(null);\n      }\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  private void simRunLeaderElection(String collection, Slice s, boolean saveState) throws Exception {\n    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);\n    lock.lockInterruptibly();\n    try {\n      Replica leader = s.getLeader();\n      if (leader == null || !liveNodes.contains(leader.getNodeName())) {\n        log.trace(\"Running leader election for {} / {}\", collection, s.getName());\n        if (s.getReplicas().isEmpty()) { // no replicas - punt\n          log.trace(\"-- no replicas in {} / {}\", collection, s.getName());\n          return;\n        }\n        ActionThrottle lt = getThrottle(collection, s.getName());\n        synchronized (lt) {\n          // collect all active and live\n          List<ReplicaInfo> active = new ArrayList<>();\n          AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);\n          s.getReplicas().forEach(r -> {\n            // find our ReplicaInfo for this replica\n            ReplicaInfo ri = getReplicaInfo(r);\n            if (ri == null) {\n              throw new IllegalStateException(\"-- could not find ReplicaInfo for replica \" + r);\n            }\n            synchronized (ri) {\n              if (r.isActive(liveNodes.get())) {\n                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {\n                  log.trace(\"-- found existing leader {} / {}: {}, {}\", collection, s.getName(), ri, r);\n                  alreadyHasLeader.set(true);\n                  return;\n                } else {\n                  active.add(ri);\n                }\n              } else { // if it's on a node that is not live mark it down\n                log.trace(\"-- replica not active on live nodes: {}, {}\", liveNodes.get(), r);\n                if (!liveNodes.contains(r.getNodeName())) {\n                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);\n                  stateChanged.set(true);\n                }\n              }\n            }\n          });\n          if (alreadyHasLeader.get()) {\n            log.trace(\"-- already has leader {} / {}: {}\", collection, s.getName(), s);\n            return;\n          }\n          if (active.isEmpty()) {\n            log.warn(\"Can't find any active replicas for {} / {}: {}\", collection, s.getName(), s);\n            log.debug(\"-- liveNodes: {}\", liveNodes.get());\n            return;\n          }\n          // pick first active one\n          ReplicaInfo ri = null;\n          for (ReplicaInfo a : active) {\n            if (!a.getType().equals(Replica.Type.PULL)) {\n              ri = a;\n              break;\n            }\n          }\n          if (ri == null) {\n            log.warn(\"-- can't find any suitable replica type for {} / {}: {}\", collection, s.getName(), s);\n            return;\n          }\n          // now mark the leader election throttle\n          lt.minimumWaitBetweenActions();\n          lt.markAttemptingAction();\n          synchronized (ri) {\n            ri.getVariables().put(ZkStateReader.LEADER_PROP, \"true\");\n          }\n          log.debug(\"-- elected new leader for {} / {} (currentVersion={}): {}\", collection,\n              s.getName(), clusterStateVersion, ri);\n          stateChanged.set(true);\n        }\n      } else {\n        log.trace(\"-- already has leader for {} / {}\", collection, s.getName());\n      }\n    } finally {\n      if (stateChanged.get() || saveState) {\n        collectionsStatesRef.set(null);\n      }\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"1aee7536c0dab5f97165523b2077d324095f5518":["8254aa20264eb7a88d556bbe0346667937ed9c2a"],"8254aa20264eb7a88d556bbe0346667937ed9c2a":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["6b55cd711a129fb7fc4c3c4672d652149c9a4faa"],"6b55cd711a129fb7fc4c3c4672d652149c9a4faa":["ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["b70042a8a492f7054d480ccdd2be9796510d4327","6b55cd711a129fb7fc4c3c4672d652149c9a4faa"],"66b87d86427dfa19b2ef36b66de83aa9655cea33":["1aee7536c0dab5f97165523b2077d324095f5518"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["a4422b331d00607258b0ed3e43934306e67764aa","ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"a4422b331d00607258b0ed3e43934306e67764aa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ad60b6945c360ff89899d716d9cdec8dd674e2a0":["a4422b331d00607258b0ed3e43934306e67764aa"],"f592209545c71895260367152601e9200399776d":["a4422b331d00607258b0ed3e43934306e67764aa","ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["66b87d86427dfa19b2ef36b66de83aa9655cea33"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["f592209545c71895260367152601e9200399776d","6b55cd711a129fb7fc4c3c4672d652149c9a4faa"]},"commit2Childs":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["8254aa20264eb7a88d556bbe0346667937ed9c2a"],"1aee7536c0dab5f97165523b2077d324095f5518":["66b87d86427dfa19b2ef36b66de83aa9655cea33"],"8254aa20264eb7a88d556bbe0346667937ed9c2a":["1aee7536c0dab5f97165523b2077d324095f5518"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"6b55cd711a129fb7fc4c3c4672d652149c9a4faa":["042b92cf48996255bedb0c3c4bf772d7e06e4dea","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"66b87d86427dfa19b2ef36b66de83aa9655cea33":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b70042a8a492f7054d480ccdd2be9796510d4327":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a4422b331d00607258b0ed3e43934306e67764aa"],"a4422b331d00607258b0ed3e43934306e67764aa":["b70042a8a492f7054d480ccdd2be9796510d4327","ad60b6945c360ff89899d716d9cdec8dd674e2a0","f592209545c71895260367152601e9200399776d"],"ad60b6945c360ff89899d716d9cdec8dd674e2a0":["6b55cd711a129fb7fc4c3c4672d652149c9a4faa","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"f592209545c71895260367152601e9200399776d":["7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}