{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetValue#createFromNamedList(int,ResponseBuilder,PivotFacetField,NamedList[Object]).mjava","commits":[{"id":"92751ba9273251eab6a2e379ec42a1697a32ff96","date":1407954233,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetValue#createFromNamedList(int,ResponseBuilder,PivotFacetField,NamedList[Object]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * A recursive method to construct a new <code>PivotFacetValue</code> object from \n   * the contents of the {@link NamedList} provided by the specified shard, relative \n   * to the specified field.  \n   *\n   * If the <code>NamedList</code> contains data for a child {@link PivotFacetField} \n   * that will be recursively built as well.\n   *\n   * @see PivotFacetField#createFromListOfNamedLists\n   * @param shardNumber the id of the shard that provided this data\n   * @param rb The response builder of the current request\n   * @param parentField the parent field in the current pivot associated with this value\n   * @param pivotData the data from the specified shard for this pivot value\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static PivotFacetValue createFromNamedList(int shardNumber, ResponseBuilder rb, PivotFacetField parentField, NamedList<Object> pivotData) {\n    \n    Comparable pivotVal = null;\n    int pivotCount = 0;\n    List<NamedList<Object>> childPivotData = null;\n    \n    for (int i = 0; i < pivotData.size(); i++) {\n      String key = pivotData.getName(i);\n      Object value = pivotData.getVal(i);\n      PivotListEntry entry = PivotListEntry.get(key);\n      \n      switch (entry) {\n\n      case VALUE: \n        pivotVal = (Comparable)value;\n        break;\n      case FIELD:\n        assert parentField.field.equals(value) \n          : \"Parent Field mismatch: \" + parentField.field + \"!=\" + value;\n        break;\n      case COUNT:\n        pivotCount = (Integer)value;\n        break;\n      case PIVOT:\n        childPivotData = (List<NamedList<Object>>)value;\n        break;\n      default:\n        throw new RuntimeException(\"PivotListEntry contains unaccounted for item: \" + entry);\n      }\n    }    \n\n    PivotFacetValue newPivotFacet = new PivotFacetValue(parentField, pivotVal);\n    newPivotFacet.count = pivotCount;\n    newPivotFacet.sourceShards.set(shardNumber);\n    \n    newPivotFacet.childPivot = PivotFacetField.createFromListOfNamedLists(shardNumber, rb, newPivotFacet, childPivotData);\n    \n    return newPivotFacet;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c18a95e9168a30be855f5d5e7d61a863186fdc5","date":1415142581,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetValue#createFromNamedList(int,ResponseBuilder,PivotFacetField,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetValue#createFromNamedList(int,ResponseBuilder,PivotFacetField,NamedList[Object]).mjava","sourceNew":"  /**\n   * A recursive method to construct a new <code>PivotFacetValue</code> object from \n   * the contents of the {@link NamedList} provided by the specified shard, relative \n   * to the specified field.  \n   *\n   * If the <code>NamedList</code> contains data for a child {@link PivotFacetField} \n   * that will be recursively built as well.\n   *\n   * @see PivotFacetField#createFromListOfNamedLists\n   * @param shardNumber the id of the shard that provided this data\n   * @param rb The response builder of the current request\n   * @param parentField the parent field in the current pivot associated with this value\n   * @param pivotData the data from the specified shard for this pivot value\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static PivotFacetValue createFromNamedList(int shardNumber, ResponseBuilder rb, PivotFacetField parentField, NamedList<Object> pivotData) {\n    \n    Comparable pivotVal = null;\n    int pivotCount = 0;\n    List<NamedList<Object>> childPivotData = null;\n    NamedList<NamedList<NamedList<?>>> statsValues = null;\n    \n    for (int i = 0; i < pivotData.size(); i++) {\n      String key = pivotData.getName(i);\n      Object value = pivotData.getVal(i);\n      PivotListEntry entry = PivotListEntry.get(key);\n      \n      switch (entry) {\n\n      case VALUE: \n        pivotVal = (Comparable)value;\n        break;\n      case FIELD:\n        assert parentField.field.equals(value) \n          : \"Parent Field mismatch: \" + parentField.field + \"!=\" + value;\n        break;\n      case COUNT:\n        pivotCount = (Integer)value;\n        break;\n      case PIVOT:\n        childPivotData = (List<NamedList<Object>>)value;\n        break;\n      case STATS:\n        statsValues = (NamedList<NamedList<NamedList<?>>>) value;\n        break;\n      default:\n        throw new RuntimeException(\"PivotListEntry contains unaccounted for item: \" + entry);\n      }\n    }    \n\n    PivotFacetValue newPivotFacet = new PivotFacetValue(parentField, pivotVal);\n    newPivotFacet.count = pivotCount;\n    newPivotFacet.sourceShards.set(shardNumber);\n    if(statsValues != null) {\n      newPivotFacet.statsValues = PivotFacetHelper.mergeStats(null, statsValues, rb._statsInfo);\n    }\n    \n    newPivotFacet.childPivot = PivotFacetField.createFromListOfNamedLists(shardNumber, rb, newPivotFacet, childPivotData);\n    \n    return newPivotFacet;\n  }\n\n","sourceOld":"  /**\n   * A recursive method to construct a new <code>PivotFacetValue</code> object from \n   * the contents of the {@link NamedList} provided by the specified shard, relative \n   * to the specified field.  \n   *\n   * If the <code>NamedList</code> contains data for a child {@link PivotFacetField} \n   * that will be recursively built as well.\n   *\n   * @see PivotFacetField#createFromListOfNamedLists\n   * @param shardNumber the id of the shard that provided this data\n   * @param rb The response builder of the current request\n   * @param parentField the parent field in the current pivot associated with this value\n   * @param pivotData the data from the specified shard for this pivot value\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static PivotFacetValue createFromNamedList(int shardNumber, ResponseBuilder rb, PivotFacetField parentField, NamedList<Object> pivotData) {\n    \n    Comparable pivotVal = null;\n    int pivotCount = 0;\n    List<NamedList<Object>> childPivotData = null;\n    \n    for (int i = 0; i < pivotData.size(); i++) {\n      String key = pivotData.getName(i);\n      Object value = pivotData.getVal(i);\n      PivotListEntry entry = PivotListEntry.get(key);\n      \n      switch (entry) {\n\n      case VALUE: \n        pivotVal = (Comparable)value;\n        break;\n      case FIELD:\n        assert parentField.field.equals(value) \n          : \"Parent Field mismatch: \" + parentField.field + \"!=\" + value;\n        break;\n      case COUNT:\n        pivotCount = (Integer)value;\n        break;\n      case PIVOT:\n        childPivotData = (List<NamedList<Object>>)value;\n        break;\n      default:\n        throw new RuntimeException(\"PivotListEntry contains unaccounted for item: \" + entry);\n      }\n    }    \n\n    PivotFacetValue newPivotFacet = new PivotFacetValue(parentField, pivotVal);\n    newPivotFacet.count = pivotCount;\n    newPivotFacet.sourceShards.set(shardNumber);\n    \n    newPivotFacet.childPivot = PivotFacetField.createFromListOfNamedLists(shardNumber, rb, newPivotFacet, childPivotData);\n    \n    return newPivotFacet;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22d0a81a05eba47d5e18976f17d88306b218cc22","date":1436341569,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetValue#createFromNamedList(int,ResponseBuilder,PivotFacetField,NamedList[Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetValue#createFromNamedList(int,ResponseBuilder,PivotFacetField,NamedList[Object]).mjava","sourceNew":"  /**\n   * A recursive method to construct a new <code>PivotFacetValue</code> object from \n   * the contents of the {@link NamedList} provided by the specified shard, relative \n   * to the specified field.  \n   *\n   * If the <code>NamedList</code> contains data for a child {@link PivotFacetField} \n   * that will be recursively built as well.\n   *\n   * @see PivotFacetField#createFromListOfNamedLists\n   * @param shardNumber the id of the shard that provided this data\n   * @param rb The response builder of the current request\n   * @param parentField the parent field in the current pivot associated with this value\n   * @param pivotData the data from the specified shard for this pivot value\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static PivotFacetValue createFromNamedList(int shardNumber, ResponseBuilder rb, PivotFacetField parentField, NamedList<Object> pivotData) {\n    \n    Comparable pivotVal = null;\n    int pivotCount = 0;\n    List<NamedList<Object>> childPivotData = null;\n    NamedList<NamedList<NamedList<?>>> statsValues = null;\n    NamedList<Number> queryCounts = null;\n    SimpleOrderedMap<SimpleOrderedMap<Object>> ranges = null;\n    \n    for (int i = 0; i < pivotData.size(); i++) {\n      String key = pivotData.getName(i);\n      Object value = pivotData.getVal(i);\n      PivotListEntry entry = PivotListEntry.get(key);\n      \n      switch (entry) {\n\n      case VALUE: \n        pivotVal = (Comparable)value;\n        break;\n      case FIELD:\n        assert parentField.field.equals(value) \n          : \"Parent Field mismatch: \" + parentField.field + \"!=\" + value;\n        break;\n      case COUNT:\n        pivotCount = (Integer)value;\n        break;\n      case PIVOT:\n        childPivotData = (List<NamedList<Object>>)value;\n        break;\n      case STATS:\n        statsValues = (NamedList<NamedList<NamedList<?>>>) value;\n        break;\n      case QUERIES:\n        queryCounts = (NamedList<Number>) value;\n        break;\n      case RANGES:\n        ranges = (SimpleOrderedMap<SimpleOrderedMap<Object>>) value;\n        break;\n      default:\n        throw new RuntimeException(\"PivotListEntry contains unaccounted for item: \" + entry);\n      }\n    }    \n\n    PivotFacetValue newPivotFacet = new PivotFacetValue(parentField, pivotVal);\n    newPivotFacet.count = pivotCount;\n    newPivotFacet.sourceShards.set(shardNumber);\n    if(statsValues != null) {\n      newPivotFacet.statsValues = PivotFacetHelper.mergeStats(null, statsValues, rb._statsInfo);\n    }\n    if(queryCounts != null) {\n      newPivotFacet.queryCounts = PivotFacetHelper.mergeQueryCounts(null, queryCounts);\n    }\n    if(ranges != null) {\n      newPivotFacet.rangeCounts = new LinkedHashMap<>();\n      RangeFacetRequest.DistribRangeFacet.mergeFacetRangesFromShardResponse(newPivotFacet.rangeCounts, ranges);\n    }\n    \n    newPivotFacet.childPivot = PivotFacetField.createFromListOfNamedLists(shardNumber, rb, newPivotFacet, childPivotData);\n    \n    return newPivotFacet;\n  }\n\n","sourceOld":"  /**\n   * A recursive method to construct a new <code>PivotFacetValue</code> object from \n   * the contents of the {@link NamedList} provided by the specified shard, relative \n   * to the specified field.  \n   *\n   * If the <code>NamedList</code> contains data for a child {@link PivotFacetField} \n   * that will be recursively built as well.\n   *\n   * @see PivotFacetField#createFromListOfNamedLists\n   * @param shardNumber the id of the shard that provided this data\n   * @param rb The response builder of the current request\n   * @param parentField the parent field in the current pivot associated with this value\n   * @param pivotData the data from the specified shard for this pivot value\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static PivotFacetValue createFromNamedList(int shardNumber, ResponseBuilder rb, PivotFacetField parentField, NamedList<Object> pivotData) {\n    \n    Comparable pivotVal = null;\n    int pivotCount = 0;\n    List<NamedList<Object>> childPivotData = null;\n    NamedList<NamedList<NamedList<?>>> statsValues = null;\n    \n    for (int i = 0; i < pivotData.size(); i++) {\n      String key = pivotData.getName(i);\n      Object value = pivotData.getVal(i);\n      PivotListEntry entry = PivotListEntry.get(key);\n      \n      switch (entry) {\n\n      case VALUE: \n        pivotVal = (Comparable)value;\n        break;\n      case FIELD:\n        assert parentField.field.equals(value) \n          : \"Parent Field mismatch: \" + parentField.field + \"!=\" + value;\n        break;\n      case COUNT:\n        pivotCount = (Integer)value;\n        break;\n      case PIVOT:\n        childPivotData = (List<NamedList<Object>>)value;\n        break;\n      case STATS:\n        statsValues = (NamedList<NamedList<NamedList<?>>>) value;\n        break;\n      default:\n        throw new RuntimeException(\"PivotListEntry contains unaccounted for item: \" + entry);\n      }\n    }    \n\n    PivotFacetValue newPivotFacet = new PivotFacetValue(parentField, pivotVal);\n    newPivotFacet.count = pivotCount;\n    newPivotFacet.sourceShards.set(shardNumber);\n    if(statsValues != null) {\n      newPivotFacet.statsValues = PivotFacetHelper.mergeStats(null, statsValues, rb._statsInfo);\n    }\n    \n    newPivotFacet.childPivot = PivotFacetField.createFromListOfNamedLists(shardNumber, rb, newPivotFacet, childPivotData);\n    \n    return newPivotFacet;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22d0a81a05eba47d5e18976f17d88306b218cc22":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["22d0a81a05eba47d5e18976f17d88306b218cc22"]},"commit2Childs":{"92751ba9273251eab6a2e379ec42a1697a32ff96":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["92751ba9273251eab6a2e379ec42a1697a32ff96"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}