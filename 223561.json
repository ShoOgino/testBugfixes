{"path":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","commits":[{"id":"8be6e1e4fbbc94d90b78f175c03ff389b6949373","date":1306674752,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copy(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(new IntsRef(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term=\" + inputToString(inputMode, prefix) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copy(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      //System.out.println(\"TEST: after prune\");\n      /*\n        for(Map.Entry<BytesRef,CountMinOutput> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey()) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n        System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n        }\n      */\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next term=\" + inputToString(inputMode, current.input) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify term=\" + inputToString(inputMode, ent.getKey()) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copy(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(new IntsRef(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term=\" + inputToString(inputMode, prefix) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copy(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      //System.out.println(\"TEST: after prune\");\n      /*\n        for(Map.Entry<BytesRef,CountMinOutput> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey()) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n        System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n        }\n      */\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next term=\" + inputToString(inputMode, current.input) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify term=\" + inputToString(inputMode, ent.getKey()) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copy(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(new IntsRef(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term=\" + inputToString(inputMode, prefix) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copy(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      //System.out.println(\"TEST: after prune\");\n      /*\n        for(Map.Entry<BytesRef,CountMinOutput> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey()) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n        System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n        }\n      */\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next term=\" + inputToString(inputMode, current.input) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify term=\" + inputToString(inputMode, ent.getKey()) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copy(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(new IntsRef(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term=\" + inputToString(inputMode, prefix) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copy(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      //System.out.println(\"TEST: after prune\");\n      /*\n        for(Map.Entry<BytesRef,CountMinOutput> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey()) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n        System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n        }\n      */\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next term=\" + inputToString(inputMode, current.input) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify term=\" + inputToString(inputMode, ent.getKey()) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/automaton/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copy(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(new IntsRef(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term=\" + inputToString(inputMode, prefix) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copy(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      //System.out.println(\"TEST: after prune\");\n      /*\n        for(Map.Entry<BytesRef,CountMinOutput> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey()) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n        System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n        }\n      */\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next term=\" + inputToString(inputMode, current.input) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify term=\" + inputToString(inputMode, ent.getKey()) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copy(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(new IntsRef(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term=\" + inputToString(inputMode, prefix) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copy(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      //System.out.println(\"TEST: after prune\");\n      /*\n        for(Map.Entry<BytesRef,CountMinOutput> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey()) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n        System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n        }\n      */\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next term=\" + inputToString(inputMode, current.input) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify term=\" + inputToString(inputMode, ent.getKey()) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35cd51b37d4bf7e6086d959cda99ba9b67b204ac","date":1311203258,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copy(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(new IntsRef(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copy(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      //System.out.println(\"TEST: after prune\");\n      /*\n        for(Map.Entry<BytesRef,CountMinOutput> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey()) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n        System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n        }\n      */\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copy(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(new IntsRef(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term=\" + inputToString(inputMode, prefix) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copy(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      //System.out.println(\"TEST: after prune\");\n      /*\n        for(Map.Entry<BytesRef,CountMinOutput> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey()) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n        System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n        }\n      */\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next term=\" + inputToString(inputMode, current.input) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify term=\" + inputToString(inputMode, ent.getKey()) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":["56da903869515527852ee21ea7ef7bfe414cd40d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60ba444201d2570214b6fcf1d15600dc1a01f548","date":1313868045,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copy(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(new IntsRef(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copy(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey()) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copy(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(new IntsRef(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copy(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      //System.out.println(\"TEST: after prune\");\n      /*\n        for(Map.Entry<BytesRef,CountMinOutput> ent : prefixes.entrySet()) {\n        System.out.println(\"  \" + inputToString(inputMode, ent.getKey()) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n        if (ent.getValue().isFinal) {\n        System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n        }\n        }\n      */\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6e919043fa85ee891123768dd655a98edbbf63c","date":1322225413,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey()) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copy(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(new IntsRef(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copy(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey()) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4708e7bf7695781d702d204d178627b4faddc03f","date":1326982060,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey()) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3be20ca1091c0b7cdb2308b9023606a5e451cec","date":1327877325,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            T output1 = cmo.output;\n            if (output1.equals(outputs.getNoOutput())) {\n              output1 = outputs.getNoOutput();\n            }\n            T output2 = pair.output;\n            if (output2.equals(outputs.getNoOutput())) {\n              output2 = outputs.getNoOutput();\n            }\n            cmo.output = outputs.common(output1, output2);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            T output1 = cmo.output;\n            if (output1.equals(outputs.getNoOutput())) {\n              output1 = outputs.getNoOutput();\n            }\n            T output2 = pair.output;\n            if (output2.equals(outputs.getNoOutput())) {\n              output2 = outputs.getNoOutput();\n            }\n            cmo.output = outputs.common(output1, output2);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            T output1 = cmo.output;\n            if (output1.equals(outputs.getNoOutput())) {\n              output1 = outputs.getNoOutput();\n            }\n            T output2 = pair.output;\n            if (output2.equals(outputs.getNoOutput())) {\n              output2 = outputs.getNoOutput();\n            }\n            cmo.output = outputs.common(output1, output2);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            cmo.output = outputs.common(cmo.output, pair.output);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs.FSTTester#verifyPruned(int,FST[T],int,int).mjava","sourceNew":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            T output1 = cmo.output;\n            if (output1.equals(outputs.getNoOutput())) {\n              output1 = outputs.getNoOutput();\n            }\n            T output2 = pair.output;\n            if (output2.equals(outputs.getNoOutput())) {\n              output2 = outputs.getNoOutput();\n            }\n            cmo.output = outputs.common(output1, output2);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","sourceOld":"    // FST is pruned\n    private void verifyPruned(int inputMode, FST<T> fst, int prune1, int prune2) throws IOException {\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now verify pruned \" + pairs.size() + \" terms; outputs=\" + outputs);\n        for(InputOutput<T> pair : pairs) {\n          System.out.println(\"  \" + inputToString(inputMode, pair.input) + \": \" + outputs.outputToString(pair.output));\n        }\n      }\n\n      // To validate the FST, we brute-force compute all prefixes\n      // in the terms, matched to their \"common\" outputs, prune that\n      // set according to the prune thresholds, then assert the FST\n      // matches that same set.\n\n      // NOTE: Crazy RAM intensive!!\n\n      //System.out.println(\"TEST: tally prefixes\");\n\n      // build all prefixes\n      final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();\n      final IntsRef scratch = new IntsRef(10);\n      for(InputOutput<T> pair: pairs) {\n        scratch.copyInts(pair.input);\n        for(int idx=0;idx<=pair.input.length;idx++) {\n          scratch.length = idx;\n          CountMinOutput<T> cmo = prefixes.get(scratch);\n          if (cmo == null) {\n            cmo = new CountMinOutput<T>();\n            cmo.count = 1;\n            cmo.output = pair.output;\n            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);\n          } else {\n            cmo.count++;\n            T output1 = cmo.output;\n            if (output1.equals(outputs.getNoOutput())) {\n              output1 = outputs.getNoOutput();\n            }\n            T output2 = pair.output;\n            if (output2.equals(outputs.getNoOutput())) {\n              output2 = outputs.getNoOutput();\n            }\n            cmo.output = outputs.common(output1, output2);\n          }\n          if (idx == pair.input.length) {\n            cmo.isFinal = true;\n            cmo.finalOutput = cmo.output;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now prune\");\n      }\n\n      // prune 'em\n      final Iterator<Map.Entry<IntsRef,CountMinOutput<T>>> it = prefixes.entrySet().iterator();\n      while(it.hasNext()) {\n        Map.Entry<IntsRef,CountMinOutput<T>> ent = it.next();\n        final IntsRef prefix = ent.getKey();\n        final CountMinOutput<T> cmo = ent.getValue();\n        if (VERBOSE) {\n          System.out.println(\"  term prefix=\" + inputToString(inputMode, prefix, false) + \" count=\" + cmo.count + \" isLeaf=\" + cmo.isLeaf + \" output=\" + outputs.outputToString(cmo.output) + \" isFinal=\" + cmo.isFinal);\n        }\n        final boolean keep;\n        if (prune1 > 0) {\n          keep = cmo.count >= prune1;\n        } else {\n          assert prune2 > 0;\n          if (prune2 > 1 && cmo.count >= prune2) {\n            keep = true;\n          } else if (prefix.length > 0) {\n            // consult our parent\n            scratch.length = prefix.length-1;\n            System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            //System.out.println(\"    parent count = \" + (cmo2 == null ? -1 : cmo2.count));\n            keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));\n          } else if (cmo.count >= prune2) {\n            keep = true;\n          } else {\n            keep = false;\n          }\n        }\n\n        if (!keep) {\n          it.remove();\n          //System.out.println(\"    remove\");\n        } else {\n          // clear isLeaf for all ancestors\n          //System.out.println(\"    keep\");\n          scratch.copyInts(prefix);\n          scratch.length--;\n          while(scratch.length >= 0) {\n            final CountMinOutput<T> cmo2 = prefixes.get(scratch);\n            if (cmo2 != null) {\n              //System.out.println(\"    clear isLeaf \" + inputToString(inputMode, scratch));\n              cmo2.isLeaf = false;\n            }\n            scratch.length--;\n          }\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: after prune\");\n        for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n          System.out.println(\"  \" + inputToString(inputMode, ent.getKey(), false) + \": isLeaf=\" + ent.getValue().isLeaf + \" isFinal=\" + ent.getValue().isFinal);\n          if (ent.getValue().isFinal) {\n            System.out.println(\"    finalOutput=\" + outputs.outputToString(ent.getValue().finalOutput));\n          }\n        }\n      }\n\n      if (prefixes.size() <= 1) {\n        assertNull(fst);\n        return;\n      }\n\n      assertNotNull(fst);\n\n      // make sure FST only enums valid prefixes\n      if (VERBOSE) {\n        System.out.println(\"TEST: check pruned enum\");\n      }\n      IntsRefFSTEnum<T> fstEnum = new IntsRefFSTEnum<T>(fst);\n      IntsRefFSTEnum.InputOutput<T> current;\n      while((current = fstEnum.next()) != null) {\n        if (VERBOSE) {\n          System.out.println(\"  fstEnum.next prefix=\" + inputToString(inputMode, current.input, false) + \" output=\" + outputs.outputToString(current.output));\n        }\n        final CountMinOutput cmo = prefixes.get(current.input);\n        assertNotNull(cmo);\n        assertTrue(cmo.isLeaf || cmo.isFinal);\n        //if (cmo.isFinal && !cmo.isLeaf) {\n        if (cmo.isFinal) {\n          assertEquals(cmo.finalOutput, current.output);\n        } else {\n          assertEquals(cmo.output, current.output);\n        }\n      }\n\n      // make sure all non-pruned prefixes are present in the FST\n      if (VERBOSE) {\n        System.out.println(\"TEST: verify all prefixes\");\n      }\n      final int[] stopNode = new int[1];\n      for(Map.Entry<IntsRef,CountMinOutput<T>> ent : prefixes.entrySet()) {\n        if (ent.getKey().length > 0) {\n          final CountMinOutput<T> cmo = ent.getValue();\n          final T output = run(fst, ent.getKey(), stopNode);\n          if (VERBOSE) {\n            System.out.println(\"TEST: verify prefix=\" + inputToString(inputMode, ent.getKey(), false) + \" output=\" + outputs.outputToString(cmo.output));\n          }\n          // if (cmo.isFinal && !cmo.isLeaf) {\n          if (cmo.isFinal) {\n            assertEquals(cmo.finalOutput, output);\n          } else {\n            assertEquals(cmo.output, output);\n          }\n          assertEquals(ent.getKey().length, stopNode[0]);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"4708e7bf7695781d702d204d178627b4faddc03f":["e6e919043fa85ee891123768dd655a98edbbf63c"],"60ba444201d2570214b6fcf1d15600dc1a01f548":["35cd51b37d4bf7e6086d959cda99ba9b67b204ac"],"35cd51b37d4bf7e6086d959cda99ba9b67b204ac":["8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["4708e7bf7695781d702d204d178627b4faddc03f"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["4708e7bf7695781d702d204d178627b4faddc03f","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8be6e1e4fbbc94d90b78f175c03ff389b6949373"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5b6fdfce35d0adb18836cf8711abe487a934df33":["4708e7bf7695781d702d204d178627b4faddc03f","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"e6e919043fa85ee891123768dd655a98edbbf63c":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8be6e1e4fbbc94d90b78f175c03ff389b6949373"]},"commit2Childs":{"8be6e1e4fbbc94d90b78f175c03ff389b6949373":["35cd51b37d4bf7e6086d959cda99ba9b67b204ac","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4708e7bf7695781d702d204d178627b4faddc03f":["b3be20ca1091c0b7cdb2308b9023606a5e451cec","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33"],"60ba444201d2570214b6fcf1d15600dc1a01f548":["e6e919043fa85ee891123768dd655a98edbbf63c"],"35cd51b37d4bf7e6086d959cda99ba9b67b204ac":["60ba444201d2570214b6fcf1d15600dc1a01f548"],"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":[],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8be6e1e4fbbc94d90b78f175c03ff389b6949373","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"e6e919043fa85ee891123768dd655a98edbbf63c":["4708e7bf7695781d702d204d178627b4faddc03f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["817882884229bace7dc5d1b75f6b0e4aa1e47122","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","5b6fdfce35d0adb18836cf8711abe487a934df33","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}