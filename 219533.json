{"path":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000;iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000;iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2aafd88401639311b0404e67c94e829e123a0e45","date":1273477632,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000*_TestUtil.getRandomMultiplier();iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000;iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8dfd02cf03e7a1810924be21cddfdde6d265c14","date":1273590676,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator());\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000*_TestUtil.getRandomMultiplier();iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator(), false);\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000*_TestUtil.getRandomMultiplier();iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ffef5e24d3e6d9425ee37cd1abde0aaacbfcb946","date":1276772063,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator());\n\n    final int NUM_STREAM = 100*_TestUtil.getRandomMultiplier();\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000*_TestUtil.getRandomMultiplier();iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(r.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator());\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000*_TestUtil.getRandomMultiplier();iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator());\n\n    final int NUM_STREAM = 100*_TestUtil.getRandomMultiplier();\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000*_TestUtil.getRandomMultiplier();iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(r.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator());\n\n    final int NUM_STREAM = 25;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000*_TestUtil.getRandomMultiplier();iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          writer.writeVInt(counters[stream]+j);\n          //writer.writeVInt(ti);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) \n            assertEquals(j, reader.readVInt());\n            //assertEquals(ti, reader.readVInt());\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0e45742e10e8e3b98e854babe6dbb07a4197b71","date":1280230285,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator());\n\n    final int NUM_STREAM = 100 * RANDOM_MULTIPLIER;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = 10000 * RANDOM_MULTIPLIER;\n      for (int iter = 0; iter < num; iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(r.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator());\n\n    final int NUM_STREAM = 100*_TestUtil.getRandomMultiplier();\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000*_TestUtil.getRandomMultiplier();iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(r.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator());\n\n    final int NUM_STREAM = 100 * RANDOM_MULTIPLIER;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = 10000 * RANDOM_MULTIPLIER;\n      for (int iter = 0; iter < num; iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(r.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator());\n\n    final int NUM_STREAM = 100*_TestUtil.getRandomMultiplier();\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      for(int iter=0;iter<10000*_TestUtil.getRandomMultiplier();iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(r.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1f653cfcf159baeaafe5d01682a911e95bba4012","date":1284122058,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator());\n\n    final int NUM_STREAM = 100 * RANDOM_MULTIPLIER;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = 10000 * RANDOM_MULTIPLIER;\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator());\n\n    final int NUM_STREAM = 100 * RANDOM_MULTIPLIER;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = 10000 * RANDOM_MULTIPLIER;\n      for (int iter = 0; iter < num; iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(r.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5d6c52f55ea3ba9a5b1d5a6dd17f79bc7d308392","date":1286023472,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = 100 * RANDOM_MULTIPLIER;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = 10000 * RANDOM_MULTIPLIER;\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator());\n\n    final int NUM_STREAM = 100 * RANDOM_MULTIPLIER;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = 10000 * RANDOM_MULTIPLIER;\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = 100 * RANDOM_MULTIPLIER;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n\n      int num = 10000 * RANDOM_MULTIPLIER;\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt());\n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new ByteBlockAllocator());\n\n    final int NUM_STREAM = 100 * RANDOM_MULTIPLIER;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    Random r = newRandom();\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = 10000 * RANDOM_MULTIPLIER;\n      for (int iter = 0; iter < num; iter++) {\n        int stream = r.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = r.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(r.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0762b640e0d0d12b6edb96db68986e13145c3484","date":1307575932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(10000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = 100 * RANDOM_MULTIPLIER;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = 10000 * RANDOM_MULTIPLIER;\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":["7b90dce9d2510a4adffa447c4dbb85717693b5c3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(10000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = 100 * RANDOM_MULTIPLIER;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = 10000 * RANDOM_MULTIPLIER;\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(10000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = 100 * RANDOM_MULTIPLIER;\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = 10000 * RANDOM_MULTIPLIER;\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestByteSlices#testBasic().mjava","sourceNew":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(10000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","sourceOld":"  public void testBasic() throws Throwable {\n    ByteBlockPool pool = new ByteBlockPool(new RecyclingByteBlockAllocator(ByteBlockPool.BYTE_BLOCK_SIZE, Integer.MAX_VALUE));\n\n    final int NUM_STREAM = atLeast(100);\n\n    ByteSliceWriter writer = new ByteSliceWriter(pool);\n\n    int[] starts = new int[NUM_STREAM];\n    int[] uptos = new int[NUM_STREAM];\n    int[] counters = new int[NUM_STREAM];\n\n    ByteSliceReader reader = new ByteSliceReader();\n\n    for(int ti=0;ti<100;ti++) {\n\n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        starts[stream] = -1;\n        counters[stream] = 0;\n      }\n      \n      int num = atLeast(10000);\n      for (int iter = 0; iter < num; iter++) {\n        int stream = random.nextInt(NUM_STREAM);\n        if (VERBOSE)\n          System.out.println(\"write stream=\" + stream);\n\n        if (starts[stream] == -1) {\n          final int spot = pool.newSlice(ByteBlockPool.FIRST_LEVEL_SIZE);\n          starts[stream] = uptos[stream] = spot + pool.byteOffset;\n          if (VERBOSE)\n            System.out.println(\"  init to \" + starts[stream]);\n        }\n\n        writer.init(uptos[stream]);\n        int numValue = random.nextInt(20);\n        for(int j=0;j<numValue;j++) {\n          if (VERBOSE)\n            System.out.println(\"    write \" + (counters[stream]+j));\n          // write some large (incl. negative) ints:\n          writer.writeVInt(random.nextInt());\n          writer.writeVInt(counters[stream]+j);\n        }\n        counters[stream] += numValue;\n        uptos[stream] = writer.getAddress();\n        if (VERBOSE)\n          System.out.println(\"    addr now \" + uptos[stream]);\n      }\n    \n      for(int stream=0;stream<NUM_STREAM;stream++) {\n        if (VERBOSE)\n          System.out.println(\"  stream=\" + stream + \" count=\" + counters[stream]);\n\n        if (starts[stream] != -1 && starts[stream] != uptos[stream]) {\n          reader.init(pool, starts[stream], uptos[stream]);\n          for(int j=0;j<counters[stream];j++) {\n            reader.readVInt();\n            assertEquals(j, reader.readVInt()); \n          }\n        }\n      }\n\n      pool.reset();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e45742e10e8e3b98e854babe6dbb07a4197b71":["ffef5e24d3e6d9425ee37cd1abde0aaacbfcb946"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["5d6c52f55ea3ba9a5b1d5a6dd17f79bc7d308392","0762b640e0d0d12b6edb96db68986e13145c3484"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["5f4e87790277826a2aea119328600dfb07761f32","a0e45742e10e8e3b98e854babe6dbb07a4197b71"],"5d6c52f55ea3ba9a5b1d5a6dd17f79bc7d308392":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"0762b640e0d0d12b6edb96db68986e13145c3484":["5d6c52f55ea3ba9a5b1d5a6dd17f79bc7d308392"],"ffef5e24d3e6d9425ee37cd1abde0aaacbfcb946":["f8dfd02cf03e7a1810924be21cddfdde6d265c14"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["0762b640e0d0d12b6edb96db68986e13145c3484"],"2aafd88401639311b0404e67c94e829e123a0e45":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5f4e87790277826a2aea119328600dfb07761f32":["f8dfd02cf03e7a1810924be21cddfdde6d265c14","ffef5e24d3e6d9425ee37cd1abde0aaacbfcb946"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["3242a09f703274d3b9283f2064a1a33064b53a1b","5d6c52f55ea3ba9a5b1d5a6dd17f79bc7d308392"],"1f653cfcf159baeaafe5d01682a911e95bba4012":["a0e45742e10e8e3b98e854babe6dbb07a4197b71"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["5d6c52f55ea3ba9a5b1d5a6dd17f79bc7d308392","0762b640e0d0d12b6edb96db68986e13145c3484"],"f8dfd02cf03e7a1810924be21cddfdde6d265c14":["2aafd88401639311b0404e67c94e829e123a0e45"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a0e45742e10e8e3b98e854babe6dbb07a4197b71":["3242a09f703274d3b9283f2064a1a33064b53a1b","1f653cfcf159baeaafe5d01682a911e95bba4012"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":[],"3242a09f703274d3b9283f2064a1a33064b53a1b":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"5d6c52f55ea3ba9a5b1d5a6dd17f79bc7d308392":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","0762b640e0d0d12b6edb96db68986e13145c3484","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"0762b640e0d0d12b6edb96db68986e13145c3484":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","3a119bbc8703c10faa329ec201c654b3a35a1e3e","77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"ffef5e24d3e6d9425ee37cd1abde0aaacbfcb946":["a0e45742e10e8e3b98e854babe6dbb07a4197b71","5f4e87790277826a2aea119328600dfb07761f32"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5f4e87790277826a2aea119328600dfb07761f32":["3242a09f703274d3b9283f2064a1a33064b53a1b"],"2aafd88401639311b0404e67c94e829e123a0e45":["f8dfd02cf03e7a1810924be21cddfdde6d265c14"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"1f653cfcf159baeaafe5d01682a911e95bba4012":["5d6c52f55ea3ba9a5b1d5a6dd17f79bc7d308392"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"f8dfd02cf03e7a1810924be21cddfdde6d265c14":["ffef5e24d3e6d9425ee37cd1abde0aaacbfcb946","5f4e87790277826a2aea119328600dfb07761f32"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["2aafd88401639311b0404e67c94e829e123a0e45"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}