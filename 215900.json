{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","commits":[{"id":"e9eb6464bb91cd54f3151e5a0c18dde9311a60f1","date":1383143016,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"/dev/null","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    IndexInput in = state.directory.openInput(metaName, state.context);\n    boolean success = false;\n    final int version;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    success = false;\n    try {\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n      data = state.directory.openInput(dataName, state.context);\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9a70ce9bddc6f985feb8e5e182aebe20872328d4","37bbe660229a1c295260800f4ee03365b37fa15c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dac1db31006989ae24922811f00f909d30f1391d","date":1387560411,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    IndexInput in = state.directory.openInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    final int version;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    success = false;\n    try {\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n      data = state.directory.openInput(dataName, state.context);\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    IndexInput in = state.directory.openInput(metaName, state.context);\n    boolean success = false;\n    final int version;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    success = false;\n    try {\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n      data = state.directory.openInput(dataName, state.context);\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1f3b037cd083286b2af89f96e768f85dcd8072d6","date":1396337805,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      if (version >= VERSION_CHECKSUM) {\n        CodecUtil.checkFooter(in);\n      } else {\n        CodecUtil.checkEOF(in);\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    success = false;\n    try {\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n      data = state.directory.openInput(dataName, state.context);\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    IndexInput in = state.directory.openInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    final int version;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    success = false;\n    try {\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n      data = state.directory.openInput(dataName, state.context);\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      if (version >= VERSION_CHECKSUM) {\n        CodecUtil.checkFooter(in);\n      } else {\n        CodecUtil.checkEOF(in);\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    success = false;\n    try {\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n      data = state.directory.openInput(dataName, state.context);\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    IndexInput in = state.directory.openInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    final int version;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    success = false;\n    try {\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n      data = state.directory.openInput(dataName, state.context);\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37bbe660229a1c295260800f4ee03365b37fa15c","date":1400939801,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      if (version >= VERSION_CHECKSUM) {\n        CodecUtil.checkFooter(in);\n      } else {\n        CodecUtil.checkEOF(in);\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      if (version >= VERSION_CHECKSUM) {\n        CodecUtil.checkFooter(in);\n      } else {\n        CodecUtil.checkEOF(in);\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    success = false;\n    try {\n      String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n      data = state.directory.openInput(dataName, state.context);\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":["e9eb6464bb91cd54f3151e5a0c18dde9311a60f1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d14ffaac9c4a4a2c750bf0cd956506802561e062","date":1402602036,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      if (version >= VERSION_CHECKSUM) {\n        CodecUtil.checkFooter(in);\n      } else {\n        CodecUtil.checkEOF(in);\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      if (version >= VERSION_CHECKSUM) {\n        CodecUtil.checkFooter(in);\n      } else {\n        CodecUtil.checkEOF(in);\n      }\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b612f3f700a1ca999f12198b7a33c65b4a96fd0","date":1406127397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0936055c0eed56be3e4ae5c9db5b0e355390736a","date":1410874015,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      readFields(in);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9a70ce9bddc6f985feb8e5e182aebe20872328d4","date":1411172748,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch\");\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":["e9eb6464bb91cd54f3151e5a0c18dde9311a60f1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc8f80fee115148a0e4a0574560be06b494de821","date":1412069872,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29a93e7fb303505e4a719e87f378d9a45db981d0","date":1412167802,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkSegmentHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, \n                                                 state.segmentInfo.getId(), state.segmentSuffix);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkSegmentHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,\n                                                              state.segmentInfo.getId(), state.segmentSuffix);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkSegmentHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, \n                                                 state.segmentInfo.getId(), state.segmentSuffix);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkSegmentHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,\n                                                              state.segmentInfo.getId(), state.segmentSuffix);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkHeader(in, metaCodec, \n                                      VERSION_START,\n                                      VERSION_CURRENT);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkHeader(data, dataCodec, \n                                                 VERSION_START,\n                                                 VERSION_CURRENT);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkIndexHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, \n                                                 state.segmentInfo.getId(), state.segmentSuffix);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkIndexHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,\n                                                              state.segmentInfo.getId(), state.segmentSuffix);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkSegmentHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, \n                                                 state.segmentInfo.getId(), state.segmentSuffix);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkSegmentHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,\n                                                              state.segmentInfo.getId(), state.segmentSuffix);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkIndexHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, \n                                                 state.segmentInfo.getId(), state.segmentSuffix);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkIndexHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,\n                                                              state.segmentInfo.getId(), state.segmentSuffix);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkSegmentHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, \n                                                 state.segmentInfo.getId(), state.segmentSuffix);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkSegmentHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,\n                                                              state.segmentInfo.getId(), state.segmentSuffix);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.maxDoc();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkIndexHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, \n                                                 state.segmentInfo.getId(), state.segmentSuffix);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkIndexHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,\n                                                              state.segmentInfo.getId(), state.segmentSuffix);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkIndexHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, \n                                                 state.segmentInfo.getId(), state.segmentSuffix);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkIndexHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,\n                                                              state.segmentInfo.getId(), state.segmentSuffix);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.maxDoc();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkIndexHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, \n                                                 state.segmentInfo.getId(), state.segmentSuffix);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkIndexHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,\n                                                              state.segmentInfo.getId(), state.segmentSuffix);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkIndexHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, \n                                                 state.segmentInfo.getId(), state.segmentSuffix);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkIndexHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,\n                                                              state.segmentInfo.getId(), state.segmentSuffix);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.maxDoc();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkIndexHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, \n                                                 state.segmentInfo.getId(), state.segmentSuffix);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkIndexHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,\n                                                              state.segmentInfo.getId(), state.segmentSuffix);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.getDocCount();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkIndexHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, \n                                                 state.segmentInfo.getId(), state.segmentSuffix);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkIndexHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,\n                                                              state.segmentInfo.getId(), state.segmentSuffix);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f18fb78980c55a781fd9fdc505634171059b1d","date":1567674462,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer#DirectDocValuesProducer(SegmentReadState,String,String,String,String).mjava","sourceNew":null,"sourceOld":"  DirectDocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {\n    maxDoc = state.segmentInfo.maxDoc();\n    merging = false;\n    String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);\n    // read in the entries from the metadata file.\n    ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);\n    ramBytesUsed = new AtomicLong(RamUsageEstimator.shallowSizeOfInstance(getClass()));\n    boolean success = false;\n    try {\n      version = CodecUtil.checkIndexHeader(in, metaCodec, VERSION_START, VERSION_CURRENT, \n                                                 state.segmentInfo.getId(), state.segmentSuffix);\n      numEntries = readFields(in, state.fieldInfos);\n\n      CodecUtil.checkFooter(in);\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(in);\n      } else {\n        IOUtils.closeWhileHandlingException(in);\n      }\n    }\n\n    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dataExtension);\n    this.data = state.directory.openInput(dataName, state.context);\n    success = false;\n    try {\n      final int version2 = CodecUtil.checkIndexHeader(data, dataCodec, VERSION_START, VERSION_CURRENT,\n                                                              state.segmentInfo.getId(), state.segmentSuffix);\n      if (version != version2) {\n        throw new CorruptIndexException(\"Format versions mismatch: meta=\" + version + \", data=\" + version2, data);\n      }\n      \n      // NOTE: data file is too costly to verify checksum against all the bytes on open,\n      // but for now we at least verify proper structure of the checksum footer: which looks\n      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption\n      // such as file truncation.\n      CodecUtil.retrieveChecksum(data);\n\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(this.data);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["dac1db31006989ae24922811f00f909d30f1391d","1f3b037cd083286b2af89f96e768f85dcd8072d6"],"1f3b037cd083286b2af89f96e768f85dcd8072d6":["dac1db31006989ae24922811f00f909d30f1391d"],"b0267c69e2456a3477a1ad785723f2135da3117e":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["29a93e7fb303505e4a719e87f378d9a45db981d0"],"4b612f3f700a1ca999f12198b7a33c65b4a96fd0":["d14ffaac9c4a4a2c750bf0cd956506802561e062"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["37bbe660229a1c295260800f4ee03365b37fa15c","d14ffaac9c4a4a2c750bf0cd956506802561e062"],"37bbe660229a1c295260800f4ee03365b37fa15c":["1f3b037cd083286b2af89f96e768f85dcd8072d6"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238","b0267c69e2456a3477a1ad785723f2135da3117e"],"9a70ce9bddc6f985feb8e5e182aebe20872328d4":["0936055c0eed56be3e4ae5c9db5b0e355390736a"],"e9eb6464bb91cd54f3151e5a0c18dde9311a60f1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bc8f80fee115148a0e4a0574560be06b494de821":["9a70ce9bddc6f985feb8e5e182aebe20872328d4"],"b06445ae1731e049327712db0454e5643ca9b7fe":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238","b0267c69e2456a3477a1ad785723f2135da3117e"],"9bb9a29a5e71a90295f175df8919802993142c9a":["9a70ce9bddc6f985feb8e5e182aebe20872328d4","29a93e7fb303505e4a719e87f378d9a45db981d0"],"74f18fb78980c55a781fd9fdc505634171059b1d":["b0267c69e2456a3477a1ad785723f2135da3117e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"29a93e7fb303505e4a719e87f378d9a45db981d0":["bc8f80fee115148a0e4a0574560be06b494de821"],"dac1db31006989ae24922811f00f909d30f1391d":["e9eb6464bb91cd54f3151e5a0c18dde9311a60f1"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["9bb9a29a5e71a90295f175df8919802993142c9a","3384e6013a93e4d11b7d75388693f8d0388602bf"],"0936055c0eed56be3e4ae5c9db5b0e355390736a":["4b612f3f700a1ca999f12198b7a33c65b4a96fd0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["74f18fb78980c55a781fd9fdc505634171059b1d"],"d14ffaac9c4a4a2c750bf0cd956506802561e062":["37bbe660229a1c295260800f4ee03365b37fa15c"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"1f3b037cd083286b2af89f96e768f85dcd8072d6":["5eb2511ababf862ea11e10761c70ee560cd84510","37bbe660229a1c295260800f4ee03365b37fa15c"],"b0267c69e2456a3477a1ad785723f2135da3117e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","74f18fb78980c55a781fd9fdc505634171059b1d"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"4b612f3f700a1ca999f12198b7a33c65b4a96fd0":["0936055c0eed56be3e4ae5c9db5b0e355390736a"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"37bbe660229a1c295260800f4ee03365b37fa15c":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","d14ffaac9c4a4a2c750bf0cd956506802561e062"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"9a70ce9bddc6f985feb8e5e182aebe20872328d4":["bc8f80fee115148a0e4a0574560be06b494de821","9bb9a29a5e71a90295f175df8919802993142c9a"],"e9eb6464bb91cd54f3151e5a0c18dde9311a60f1":["dac1db31006989ae24922811f00f909d30f1391d"],"bc8f80fee115148a0e4a0574560be06b494de821":["29a93e7fb303505e4a719e87f378d9a45db981d0"],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"9bb9a29a5e71a90295f175df8919802993142c9a":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"29a93e7fb303505e4a719e87f378d9a45db981d0":["3384e6013a93e4d11b7d75388693f8d0388602bf","9bb9a29a5e71a90295f175df8919802993142c9a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e9eb6464bb91cd54f3151e5a0c18dde9311a60f1"],"74f18fb78980c55a781fd9fdc505634171059b1d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dac1db31006989ae24922811f00f909d30f1391d":["5eb2511ababf862ea11e10761c70ee560cd84510","1f3b037cd083286b2af89f96e768f85dcd8072d6"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["b0267c69e2456a3477a1ad785723f2135da3117e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe"],"0936055c0eed56be3e4ae5c9db5b0e355390736a":["9a70ce9bddc6f985feb8e5e182aebe20872328d4"],"d14ffaac9c4a4a2c750bf0cd956506802561e062":["4b612f3f700a1ca999f12198b7a33c65b4a96fd0","c6f080a2ab37c464dd98db173f6cbf10dc74f211"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","c6f080a2ab37c464dd98db173f6cbf10dc74f211","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}