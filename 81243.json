{"path":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","commits":[{"id":"7a71a0b2d4be2299a163f60626729852d81a8e02","date":1309442399,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["df4ed22dc7b048a2e9efa6ee55cb84b9457e9ee5","df4ed22dc7b048a2e9efa6ee55cb84b9457e9ee5","df4ed22dc7b048a2e9efa6ee55cb84b9457e9ee5","df4ed22dc7b048a2e9efa6ee55cb84b9457e9ee5","df4ed22dc7b048a2e9efa6ee55cb84b9457e9ee5","df4ed22dc7b048a2e9efa6ee55cb84b9457e9ee5","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","e22ffe8cc51a892ae103df018822d7873e901c2a","e22ffe8cc51a892ae103df018822d7873e901c2a","e22ffe8cc51a892ae103df018822d7873e901c2a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","pathOld":"solr/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,CoreDescriptor,UpdateHandler).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores.\n   * If a core with the same name already exists, it will be stopped and replaced by this one.\n   *@param dataDir the index directory\n   *@param config a solr config instance\n   *@param schema a solr schema instance\n   *@param updateHandler\n   *\n   *@since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema, CoreDescriptor cd, UpdateHandler updateHandler) {\n    coreDescriptor = cd;\n    this.setName( name );\n    resourceLoader = config.getResourceLoader();\n    if (dataDir == null){\n      if(cd.usingDefaultDataDir()) dataDir = config.getDataDir();\n      if(dataDir == null) dataDir = cd.getDataDir();\n    }\n\n    dataDir = SolrResourceLoader.normalizeDir(dataDir);\n\n    log.info(logid+\"Opening new SolrCore at \" + resourceLoader.getInstanceDir() + \", dataDir=\"+dataDir);\n\n    if (schema==null) {\n      schema = new IndexSchema(config, IndexSchema.DEFAULT_SCHEMA_FILE, null);\n    }\n\n    //Initialize JMX\n    if (config.jmxConfig.enabled) {\n      infoRegistry = new JmxMonitoredMap<String, SolrInfoMBean>(name, config.jmxConfig);\n    } else  {\n      log.info(\"JMX monitoring not detected for core: \" + name);\n      infoRegistry = new ConcurrentHashMap<String, SolrInfoMBean>();\n    }\n\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    this.schema = schema;\n    this.dataDir = dataDir;\n    this.solrConfig = config;\n    this.startTime = System.currentTimeMillis();\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n\n    booleanQueryMaxClauseCount();\n  \n    initListeners();\n\n    initDeletionPolicy();\n\n    this.codecProvider = initCodecProvider(solrConfig, schema);\n    initIndex();\n\n    initWriters();\n    initQParsers();\n    initValueSourceParsers();\n    initTransformerFactories();\n\n    this.searchComponents = Collections.unmodifiableMap(loadSearchComponents());\n\n    // Processors initialized before the handlers\n    updateProcessorChains = loadUpdateProcessorChains();\n    reqHandlers = new RequestHandlers(this);\n    reqHandlers.initHandlersFromConfig( solrConfig );\n\n\n    // Handle things that should eventually go away\n    initDeprecatedSupport();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(new Callable() {\n        public Object call() throws Exception {\n          latch.await();\n          return null;\n        }\n      });\n\n      // Open the searcher *before* the update handler so we don't end up opening\n      // one in the middle.\n      // With lockless commits in Lucene now, this probably shouldn't be an issue anymore\n      getSearcher(false,false,null);\n\n      String updateHandlerClass = solrConfig.getUpdateHandlerInfo().className;\n\n      if (updateHandler == null) {\n        this.updateHandler = createUpdateHandler(updateHandlerClass == null ? DirectUpdateHandler2.class\n            .getName() : updateHandlerClass);\n      } else {\n        \n        this.updateHandler = createUpdateHandler(\n            updateHandlerClass == null ? DirectUpdateHandler2.class.getName()\n                : updateHandlerClass, updateHandler);\n      }\n      infoRegistry.put(\"updateHandler\", this.updateHandler);\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform( resourceLoader );\n      resourceLoader.inform( this );  // last call before the latch is released.\n    } catch (IOException e) {\n      log.error(\"\", e);\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, null, e, false);\n    } finally {\n      // allow firstSearcher events to fire\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n    \n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"c26f00b574427b55127e869b935845554afde1fa":["7a71a0b2d4be2299a163f60626729852d81a8e02","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["7a71a0b2d4be2299a163f60626729852d81a8e02"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7a71a0b2d4be2299a163f60626729852d81a8e02"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7a71a0b2d4be2299a163f60626729852d81a8e02"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"],"7a71a0b2d4be2299a163f60626729852d81a8e02":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","7a71a0b2d4be2299a163f60626729852d81a8e02"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"817d8435e9135b756f08ce6710ab0baac51bdf88":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"7a71a0b2d4be2299a163f60626729852d81a8e02":["c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}