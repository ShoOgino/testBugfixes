{"path":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","commits":[{"id":"e3ce1ef883d26aa73919aa2d53991726e96caa13","date":1445421402,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"/dev/null","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 0.1 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          BKDUtil.bigIntToBytes(values[dim], scratch, dim, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new BKDReader.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public BKDReader.Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return BKDReader.Relation.QUERY_OUTSIDE_CELL;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return BKDReader.Relation.QUERY_CROSSES_CELL;\n              } else {\n                return BKDReader.Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca792c26af46bd6c4a08d81117c60440cf6a7e3d","date":1445938295,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 0.1 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          BKDUtil.bigIntToBytes(values[dim], scratch, dim, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.QUERY_OUTSIDE_CELL;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.QUERY_CROSSES_CELL;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 0.1 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          BKDUtil.bigIntToBytes(values[dim], scratch, dim, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new BKDReader.IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public BKDReader.Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return BKDReader.Relation.QUERY_OUTSIDE_CELL;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return BKDReader.Relation.QUERY_CROSSES_CELL;\n              } else {\n                return BKDReader.Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1904709ea0185dc04e3d77ea01c79e909caf2796","date":1447006699,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 0.1 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          BKDUtil.bigIntToBytes(values[dim], scratch, dim, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 0.1 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          BKDUtil.bigIntToBytes(values[dim], scratch, dim, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.QUERY_OUTSIDE_CELL;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.QUERY_CROSSES_CELL;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1786be6a11f9cf5e48ce84869d1bb71e9c02f966","date":1448381196,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          BKDUtil.bigIntToBytes(values[dim], scratch, dim, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 0.1 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          BKDUtil.bigIntToBytes(values[dim], scratch, dim, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToBytes(values[dim], scratch, dim, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          BKDUtil.bigIntToBytes(values[dim], scratch, dim, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = BKDUtil.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = BKDUtil.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = BKDUtil.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd4aa10c3623b9da92a555b8d04677af8fe86877","date":1456230278,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToBytes(values[dim], scratch, dim, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5296efc4b319f5647b606629c093a94b23692c6","date":1456267155,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToBytes(values[dim], scratch, dim, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ff4a3d0540c1b0f828f19adccd01d1b33c996a6","date":1456306182,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToBytes(values[dim], scratch, dim, numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"251c5b33f0a2c8988550b63c78ed22b0e84524e5","date":1456961997,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb","date":1457059932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":["dd4aa10c3623b9da92a555b8d04677af8fe86877"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.bytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.bytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.bytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca","date":1457777566,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount());\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"416f9e28900210be57b69bc12e2954fb98ed7ebe","date":1458479803,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount(true), true);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount());\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f3d902d9e126b838f492796a117a4d9e532d597a","date":1458810839,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, numDocs, true);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, randomPointCount(true), true);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, numDocs, true);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, numDocs, true);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78bdc7d6906146edb12a1a6c1f765ba680ed5124","date":1549523533,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, numDocs);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, numDocs, true);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cbc55bb1f9b4422860b0f903e6af8082280e7b72","date":1571986943,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, numDocs);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, randomBoolean());\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, numDocs);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"78e689a3b60e84c75dc6dd7b181a71fc19ef8482","date":1591689554,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, numDocs);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {        \n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in, randomBoolean());\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, numDocs);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {\n        indexFP = w.finish(out);\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, randomBoolean());\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6b1fd50f847900ca47783ea832846d60e81f990","date":1591769592,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, numDocs);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {        \n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, numDocs);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {        \n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in, randomBoolean());\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/bkd/TestBKD#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", new BKDConfig(numDims, numDims, numBytesPerDim, maxPointsInLeafNode), maxMB, numDocs);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {        \n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, 30);\n      int numDims = TestUtil.nextInt(random(), 1, 5);\n      int maxPointsInLeafNode = TestUtil.nextInt(random(), 50, 100);\n      float maxMB = (float) 3.0 + (3*random().nextFloat());\n      BKDWriter w = new BKDWriter(numDocs, dir, \"tmp\", numDims, numDims, numBytesPerDim, maxPointsInLeafNode, maxMB, numDocs);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      byte[] scratch = new byte[numBytesPerDim*numDims];\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, scratch, dim * numBytesPerDim);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        w.add(scratch, docID);\n      }\n\n      long indexFP;\n      try (IndexOutput out = dir.createOutput(\"bkd\", IOContext.DEFAULT)) {        \n        Runnable finalizer = w.finish(out, out, out);\n        indexFP = out.getFilePointer();\n        finalizer.run();\n      }\n\n      try (IndexInput in = dir.openInput(\"bkd\", IOContext.DEFAULT)) {\n        in.seek(indexFP);\n        BKDReader r = new BKDReader(in, in, in);\n\n        int iters = atLeast(100);\n        for(int iter=0;iter<iters;iter++) {\n          if (VERBOSE) {\n            System.out.println(\"\\nTEST: iter=\" + iter);\n          }\n\n          // Random N dims rect query:\n          BigInteger[] queryMin = new BigInteger[numDims];\n          BigInteger[] queryMax = new BigInteger[numDims];    \n          for(int dim=0;dim<numDims;dim++) {\n            queryMin[dim] = randomBigInt(numBytesPerDim);\n            queryMax[dim] = randomBigInt(numBytesPerDim);\n            if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n              BigInteger x = queryMin[dim];\n              queryMin[dim] = queryMax[dim];\n              queryMax[dim] = x;\n            }\n          }\n\n          final BitSet hits = new BitSet();\n          r.intersect(new IntersectVisitor() {\n            @Override\n            public void visit(int docID) {\n              hits.set(docID);\n              //System.out.println(\"visit docID=\" + docID);\n            }\n\n            @Override\n            public void visit(int docID, byte[] packedValue) {\n              //System.out.println(\"visit check docID=\" + docID);\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                  //System.out.println(\"  no\");\n                  return;\n                }\n              }\n\n              //System.out.println(\"  yes\");\n              hits.set(docID);\n            }\n\n            @Override\n            public Relation compare(byte[] minPacked, byte[] maxPacked) {\n              boolean crosses = false;\n              for(int dim=0;dim<numDims;dim++) {\n                BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                assert max.compareTo(min) >= 0;\n\n                if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                  return Relation.CELL_OUTSIDE_QUERY;\n                } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                  crosses = true;\n                }\n              }\n\n              if (crosses) {\n                return Relation.CELL_CROSSES_QUERY;\n              } else {\n                return Relation.CELL_INSIDE_QUERY;\n              }\n            }\n          });\n\n          for(int docID=0;docID<numDocs;docID++) {\n            BigInteger[] docValues = docs[docID];\n            boolean expected = true;\n            for(int dim=0;dim<numDims;dim++) {\n              BigInteger x = docValues[dim];\n              if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                expected = false;\n                break;\n              }\n            }\n            boolean actual = hits.get(docID);\n            assertEquals(\"docID=\" + docID, expected, actual);\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"1786be6a11f9cf5e48ce84869d1bb71e9c02f966":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["d6b1fd50f847900ca47783ea832846d60e81f990"],"f6652c943595e92c187ee904c382863013eae28f":["f3d902d9e126b838f492796a117a4d9e532d597a"],"dd4aa10c3623b9da92a555b8d04677af8fe86877":["770342641f7b505eaa8dccdc666158bff2419109"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["f6652c943595e92c187ee904c382863013eae28f"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1ff4a3d0540c1b0f828f19adccd01d1b33c996a6":["770342641f7b505eaa8dccdc666158bff2419109","a5296efc4b319f5647b606629c093a94b23692c6"],"770342641f7b505eaa8dccdc666158bff2419109":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["1ff4a3d0540c1b0f828f19adccd01d1b33c996a6"],"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"d6b1fd50f847900ca47783ea832846d60e81f990":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca"],"a5296efc4b319f5647b606629c093a94b23692c6":["770342641f7b505eaa8dccdc666158bff2419109","dd4aa10c3623b9da92a555b8d04677af8fe86877"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["1ff4a3d0540c1b0f828f19adccd01d1b33c996a6","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"f3d902d9e126b838f492796a117a4d9e532d597a":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["251c5b33f0a2c8988550b63c78ed22b0e84524e5"]},"commit2Childs":{"cbc55bb1f9b4422860b0f903e6af8082280e7b72":["78e689a3b60e84c75dc6dd7b181a71fc19ef8482"],"1786be6a11f9cf5e48ce84869d1bb71e9c02f966":["770342641f7b505eaa8dccdc666158bff2419109"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["78bdc7d6906146edb12a1a6c1f765ba680ed5124"],"dd4aa10c3623b9da92a555b8d04677af8fe86877":["a5296efc4b319f5647b606629c093a94b23692c6"],"78bdc7d6906146edb12a1a6c1f765ba680ed5124":["cbc55bb1f9b4422860b0f903e6af8082280e7b72"],"1904709ea0185dc04e3d77ea01c79e909caf2796":["1786be6a11f9cf5e48ce84869d1bb71e9c02f966"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"1ff4a3d0540c1b0f828f19adccd01d1b33c996a6":["251c5b33f0a2c8988550b63c78ed22b0e84524e5","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"770342641f7b505eaa8dccdc666158bff2419109":["dd4aa10c3623b9da92a555b8d04677af8fe86877","1ff4a3d0540c1b0f828f19adccd01d1b33c996a6","a5296efc4b319f5647b606629c093a94b23692c6"],"251c5b33f0a2c8988550b63c78ed22b0e84524e5":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"d6b1fd50f847900ca47783ea832846d60e81f990":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"ca792c26af46bd6c4a08d81117c60440cf6a7e3d":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"78e689a3b60e84c75dc6dd7b181a71fc19ef8482":["d6b1fd50f847900ca47783ea832846d60e81f990"],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["f3d902d9e126b838f492796a117a4d9e532d597a"],"a5296efc4b319f5647b606629c093a94b23692c6":["1ff4a3d0540c1b0f828f19adccd01d1b33c996a6"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca"],"f3d902d9e126b838f492796a117a4d9e532d597a":["f6652c943595e92c187ee904c382863013eae28f"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}