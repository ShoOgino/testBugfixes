{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","commits":[{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + waitForState(collectionName, 120, TimeUnit.SECONDS, clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.init(Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTime()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + waitForState(collectionName, 300, TimeUnit.SECONDS, clusterShape(1, 2)) + \"ms\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c6c0dad4932399aec99b4818086cb1772773916","date":1520515900,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.init(Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTime()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + waitForState(collectionName, 120, TimeUnit.SECONDS, clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.init(Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTime()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + waitForState(collectionName, 300, TimeUnit.SECONDS, clusterShape(1, 2)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4412883c12067d8a4e2a354aa8adc58c32be1d6","date":1521129281,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.init(Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.init(Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTime()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d","date":1522763990,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.init(Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11d6f92dfa9251d9da6d80ec5963a9cbecc90180","date":1530559969,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2)) + \"ms\");\n  }\n\n","bugFix":["9c6c0dad4932399aec99b4818086cb1772773916"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a6a5c1c40529f15b445e6720dfde1967e139bff1","date":1535375643,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestSimExecutePlanAction#testExecute().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/TestExecutePlanAction#testExecute().mjava","sourceNew":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","sourceOld":"  @Test\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 28-June-2018\n  public void testExecute() throws Exception {\n    SolrClient solrClient = cluster.simGetSolrClient();\n    String collectionName = \"testExecute\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 1, 2);\n    create.setMaxShardsPerNode(1);\n    create.process(solrClient);\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 120, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n\n    String sourceNodeName = cluster.getSimClusterStateProvider().simGetRandomNode(random());\n    ClusterState clusterState = cluster.getClusterStateProvider().getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collectionName);\n    List<Replica> replicas = docCollection.getReplicas(sourceNodeName);\n    assertNotNull(replicas);\n    assertFalse(replicas.isEmpty());\n\n    List<String> otherNodes = cluster.getClusterStateProvider().getLiveNodes().stream()\n        .filter(node -> !node.equals(sourceNodeName)).collect(Collectors.toList());\n    assertFalse(otherNodes.isEmpty());\n    String survivor = otherNodes.get(0);\n\n    try (ExecutePlanAction action = new ExecutePlanAction()) {\n      action.configure(cluster.getLoader(), cluster, Collections.singletonMap(\"name\", \"execute_plan\"));\n\n      // used to signal if we found that ExecutePlanAction did in fact create the right znode before executing the operation\n      AtomicBoolean znodeCreated = new AtomicBoolean(false);\n\n      CollectionAdminRequest.AsyncCollectionAdminRequest moveReplica = new CollectionAdminRequest.MoveReplica(collectionName, replicas.get(0).getName(), survivor);\n      CollectionAdminRequest.AsyncCollectionAdminRequest mockRequest = new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.OVERSEERSTATUS) {\n        @Override\n        public void setAsyncId(String asyncId) {\n          super.setAsyncId(asyncId);\n          String parentPath = ZkStateReader.SOLR_AUTOSCALING_TRIGGER_STATE_PATH + \"/xyz/execute_plan\";\n          try {\n            if (cluster.getDistribStateManager().hasData(parentPath)) {\n              java.util.List<String> children = cluster.getDistribStateManager().listData(parentPath);\n              if (!children.isEmpty()) {\n                String child = children.get(0);\n                VersionedData data = cluster.getDistribStateManager().getData(parentPath + \"/\" + child);\n                Map m = (Map) Utils.fromJSON(data.getData());\n                if (m.containsKey(\"requestid\")) {\n                  znodeCreated.set(m.get(\"requestid\").equals(asyncId));\n                }\n              }\n            }\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n\n        }\n      };\n      List<CollectionAdminRequest.AsyncCollectionAdminRequest> operations = Lists.asList(moveReplica, new CollectionAdminRequest.AsyncCollectionAdminRequest[]{mockRequest});\n      NodeLostTrigger.NodeLostEvent nodeLostEvent = new NodeLostTrigger.NodeLostEvent(TriggerEventType.NODELOST,\n          \"mock_trigger_name\", Collections.singletonList(TimeSource.CURRENT_TIME.getTimeNs()),\n          Collections.singletonList(sourceNodeName));\n      ActionContext actionContext = new ActionContext(cluster, null,\n          new HashMap<>(Collections.singletonMap(\"operations\", operations)));\n      action.process(nodeLostEvent, actionContext);\n\n//      assertTrue(\"ExecutePlanAction should have stored the requestid in ZK before executing the request\", znodeCreated.get());\n      List<NamedList<Object>> responses = (List<NamedList<Object>>) actionContext.getProperty(\"responses\");\n      assertNotNull(responses);\n      assertEquals(2, responses.size());\n      NamedList<Object> response = responses.get(0);\n      assertNull(response.get(\"failure\"));\n      assertNotNull(response.get(\"success\"));\n    }\n\n    log.info(\"Collection ready after \" + CloudTestUtils.waitForState(cluster, collectionName, 300, TimeUnit.SECONDS,\n        CloudTestUtils.clusterShape(1, 2, false, true)) + \"ms\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["11d6f92dfa9251d9da6d80ec5963a9cbecc90180"],"a6a5c1c40529f15b445e6720dfde1967e139bff1":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"9c6c0dad4932399aec99b4818086cb1772773916":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"11d6f92dfa9251d9da6d80ec5963a9cbecc90180":["cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d","11d6f92dfa9251d9da6d80ec5963a9cbecc90180"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["9c6c0dad4932399aec99b4818086cb1772773916"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a6a5c1c40529f15b445e6720dfde1967e139bff1"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d","11d6f92dfa9251d9da6d80ec5963a9cbecc90180"]},"commit2Childs":{"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["a6a5c1c40529f15b445e6720dfde1967e139bff1"],"a6a5c1c40529f15b445e6720dfde1967e139bff1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9c6c0dad4932399aec99b4818086cb1772773916":["d4412883c12067d8a4e2a354aa8adc58c32be1d6"],"11d6f92dfa9251d9da6d80ec5963a9cbecc90180":["042b92cf48996255bedb0c3c4bf772d7e06e4dea","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"d4412883c12067d8a4e2a354aa8adc58c32be1d6":["cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["9c6c0dad4932399aec99b4818086cb1772773916"],"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d":["11d6f92dfa9251d9da6d80ec5963a9cbecc90180","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}