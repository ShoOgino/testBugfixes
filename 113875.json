{"path":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","commits":[{"id":"027bee21e09164c9ee230395405076d1e0034b30","date":1401521821,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose()) {\n      message(\"findMerges: \" + numSegments + \" segments\");\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose()) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7277addaa5100a3b464703b0a0efb5a993ff5999","date":1447264320,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9614ff437b164d046388b749a04f5ef5b8f465b2","date":1472829210,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5399733c0eeb73827ff5b8aee51c110ec540e6f0","date":1511756706,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Set<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0e53d133180083c87dcb8114b087cfe6bfc7bce","date":1511856078,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Set<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d28f215464f76024caf026606f8ea51a5319c53","date":1527226629,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,MergeContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(MergeTrigger,SegmentInfos,IndexWriter).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, MergeContext mergeContext) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(mergeContext)) {\n      message(\"findMerges: \" + numSegments + \" segments\", mergeContext);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Set<SegmentCommitInfo> mergingSegments = mergeContext.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, mergeContext);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm);\n      levels.add(infoLevel);\n\n      if (verbose(mergeContext)) {\n        final long segBytes = sizeBytes(info, mergeContext);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + segString(mergeContext, Collections.singleton(info)) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, mergeContext);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(mergeContext)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", mergeContext);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, mergeContext) >= maxMergeSize || sizeDocs(info, mergeContext) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(mergeContext)) {\n            message(\"  add merge=\" + segString(mergeContext, mergeInfos) + \" start=\" + start + \" end=\" + end, mergeContext);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(mergeContext)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", mergeContext);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, IndexWriter writer) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose(writer)) {\n      message(\"findMerges: \" + numSegments + \" segments\", writer);\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<>(numSegments);\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Set<SegmentCommitInfo> mergingSegments = writer.getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentCommitInfo info = infos.info(i);\n      long size = size(info, writer);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm);\n      levels.add(infoLevel);\n\n      if (verbose(writer)) {\n        final long segBytes = sizeBytes(info, writer);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(Locale.ROOT, \"%.3f MB\", segBytes/1024/1024.) + extra, writer);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel) {\n          maxLevel = level;\n        }\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor) {\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      } else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor) {\n          levelBottom = levelFloor;\n        }\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose(writer)) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\", writer);\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentCommitInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info, writer) >= maxMergeSize || sizeDocs(info, writer) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentCommitInfo> mergeInfos = new ArrayList<>(end-start);\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose(writer)) {\n            message(\"  add merge=\" + writer.segString(mergeInfos) + \" start=\" + start + \" end=\" + end, writer);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose(writer)) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\", writer);\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7277addaa5100a3b464703b0a0efb5a993ff5999":["027bee21e09164c9ee230395405076d1e0034b30"],"5399733c0eeb73827ff5b8aee51c110ec540e6f0":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["7277addaa5100a3b464703b0a0efb5a993ff5999","89424def13674ea17829b41c5883c54ecc31a132"],"1d28f215464f76024caf026606f8ea51a5319c53":["f0e53d133180083c87dcb8114b087cfe6bfc7bce"],"f0e53d133180083c87dcb8114b087cfe6bfc7bce":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","5399733c0eeb73827ff5b8aee51c110ec540e6f0"],"bc8f206328a706450934717bec7ccc22ad166fc0":["7277addaa5100a3b464703b0a0efb5a993ff5999","9614ff437b164d046388b749a04f5ef5b8f465b2"],"027bee21e09164c9ee230395405076d1e0034b30":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9614ff437b164d046388b749a04f5ef5b8f465b2":["7277addaa5100a3b464703b0a0efb5a993ff5999"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7277addaa5100a3b464703b0a0efb5a993ff5999","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1d28f215464f76024caf026606f8ea51a5319c53"],"89424def13674ea17829b41c5883c54ecc31a132":["7277addaa5100a3b464703b0a0efb5a993ff5999","bc8f206328a706450934717bec7ccc22ad166fc0"]},"commit2Childs":{"7277addaa5100a3b464703b0a0efb5a993ff5999":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","bc8f206328a706450934717bec7ccc22ad166fc0","9614ff437b164d046388b749a04f5ef5b8f465b2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","89424def13674ea17829b41c5883c54ecc31a132"],"5399733c0eeb73827ff5b8aee51c110ec540e6f0":["f0e53d133180083c87dcb8114b087cfe6bfc7bce"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["5399733c0eeb73827ff5b8aee51c110ec540e6f0","f0e53d133180083c87dcb8114b087cfe6bfc7bce","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["027bee21e09164c9ee230395405076d1e0034b30"],"1d28f215464f76024caf026606f8ea51a5319c53":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f0e53d133180083c87dcb8114b087cfe6bfc7bce":["1d28f215464f76024caf026606f8ea51a5319c53"],"bc8f206328a706450934717bec7ccc22ad166fc0":["89424def13674ea17829b41c5883c54ecc31a132"],"027bee21e09164c9ee230395405076d1e0034b30":["7277addaa5100a3b464703b0a0efb5a993ff5999"],"9614ff437b164d046388b749a04f5ef5b8f465b2":["bc8f206328a706450934717bec7ccc22ad166fc0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}