{"path":"solr/core/src/java/org/apache/solr/cloud/ZkController#publishState().mjava","commits":[{"id":"c51a2dcb8b4e1820a44f35f11961110201e06cdb","date":1329994529,"type":0,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publishState().mjava","pathOld":"/dev/null","sourceNew":"  private void publishState() {\n    final String nodePath = \"/node_states/\" + getNodeName();\n\n    synchronized (coreStates) {\n      try {\n        zkClient.setData(nodePath, ZkStateReader.toJSON(coreStates.values()),\n            true);\n        \n      } catch (KeeperException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"could not publish node state\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"could not publish node state\", e);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed8b5134f21fa32f140bae646a12da6d5f807595","date":1330112118,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publishState().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publishState().mjava","sourceNew":"  private void publishState() {\n    final String nodePath = \"/node_states/\" + getNodeName();\n\n    long version;\n    byte[] coreStatesData;\n    synchronized (coreStates) {\n      version = ++coreStatesVersion;\n      coreStatesData = ZkStateReader.toJSON(coreStates.values());\n    }\n\n    // if multiple threads are trying to publish state, make sure that we never write\n    // an older version after a newer version.\n    synchronized (coreStatesPublishLock) {\n      try {\n        if (version < coreStatesPublishedVersion) {\n          log.info(\"Another thread already published a newer coreStates: ours=\"+version + \" lastPublished=\" + coreStatesPublishedVersion);\n        } else {\n          zkClient.setData(nodePath, coreStatesData, true);\n          coreStatesPublishedVersion = version;  // put it after so it won't be set if there's an exception\n        }\n      } catch (KeeperException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"could not publish node state\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"could not publish node state\", e);\n      }\n    }\n  }\n\n","sourceOld":"  private void publishState() {\n    final String nodePath = \"/node_states/\" + getNodeName();\n\n    synchronized (coreStates) {\n      try {\n        zkClient.setData(nodePath, ZkStateReader.toJSON(coreStates.values()),\n            true);\n        \n      } catch (KeeperException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"could not publish node state\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"could not publish node state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":0,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ZkController#publishState().mjava","pathOld":"/dev/null","sourceNew":"  private void publishState() {\n    final String nodePath = \"/node_states/\" + getNodeName();\n\n    long version;\n    byte[] coreStatesData;\n    synchronized (coreStates) {\n      version = ++coreStatesVersion;\n      coreStatesData = ZkStateReader.toJSON(coreStates.values());\n    }\n\n    // if multiple threads are trying to publish state, make sure that we never write\n    // an older version after a newer version.\n    synchronized (coreStatesPublishLock) {\n      try {\n        if (version < coreStatesPublishedVersion) {\n          log.info(\"Another thread already published a newer coreStates: ours=\"+version + \" lastPublished=\" + coreStatesPublishedVersion);\n        } else {\n          zkClient.setData(nodePath, coreStatesData, true);\n          coreStatesPublishedVersion = version;  // put it after so it won't be set if there's an exception\n        }\n      } catch (KeeperException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"could not publish node state\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"could not publish node state\", e);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5093a9e893633cc091cf2f729d7863671c2b715","date":1339132888,"type":4,"author":"Sami Siren","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/ZkController#publishState().mjava","sourceNew":null,"sourceOld":"  private void publishState() {\n    final String nodePath = \"/node_states/\" + getNodeName();\n\n    long version;\n    byte[] coreStatesData;\n    synchronized (coreStates) {\n      version = ++coreStatesVersion;\n      coreStatesData = ZkStateReader.toJSON(coreStates.values());\n    }\n\n    // if multiple threads are trying to publish state, make sure that we never write\n    // an older version after a newer version.\n    synchronized (coreStatesPublishLock) {\n      try {\n        if (version < coreStatesPublishedVersion) {\n          log.info(\"Another thread already published a newer coreStates: ours=\"+version + \" lastPublished=\" + coreStatesPublishedVersion);\n        } else {\n          zkClient.setData(nodePath, coreStatesData, true);\n          coreStatesPublishedVersion = version;  // put it after so it won't be set if there's an exception\n        }\n      } catch (KeeperException e) {\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"could not publish node state\", e);\n      } catch (InterruptedException e) {\n        // Restore the interrupted status\n        Thread.currentThread().interrupt();\n        throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n            \"could not publish node state\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ed8b5134f21fa32f140bae646a12da6d5f807595":["c51a2dcb8b4e1820a44f35f11961110201e06cdb"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ed8b5134f21fa32f140bae646a12da6d5f807595"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a5093a9e893633cc091cf2f729d7863671c2b715":["ed8b5134f21fa32f140bae646a12da6d5f807595"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a5093a9e893633cc091cf2f729d7863671c2b715"],"c51a2dcb8b4e1820a44f35f11961110201e06cdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"ed8b5134f21fa32f140bae646a12da6d5f807595":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a5093a9e893633cc091cf2f729d7863671c2b715"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","c51a2dcb8b4e1820a44f35f11961110201e06cdb"],"a5093a9e893633cc091cf2f729d7863671c2b715":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c51a2dcb8b4e1820a44f35f11961110201e06cdb":["ed8b5134f21fa32f140bae646a12da6d5f807595"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}