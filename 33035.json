{"path":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","commits":[{"id":"309bb934ccf1b9733206e54bd15a143b6a198889","date":1366132561,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","pathOld":"/dev/null","sourceNew":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n      clearIndex();\n      assertU(commit());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f29c962d2a19abc63339cd093c2c0f234fc763e8","date":1369157614,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","sourceNew":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      assertQ(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","sourceOld":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n      clearIndex();\n      assertU(commit());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e861f53430fcbc7afe2f446a7485e123055d073f","date":1369158274,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","sourceNew":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      assertQ(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","sourceOld":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      assertQ(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","sourceNew":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      assertQ(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","sourceOld":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      assertQ(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","sourceNew":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      assertQ(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","sourceOld":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      assertQ(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3802d95c3a31be21ea2971945049b711d95ef8d5","date":1455055616,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","sourceNew":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      for(String [] methodParam: new String[][]{ new String[]{}, new String []{\"facet.method\", \"uif\"}}) {\n        assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  , \"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQforUIF(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  ,\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQforUIF(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n        assertQforUIF(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n        );\n      }\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","sourceOld":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      assertQ(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c64189697927b548f74ba66dfa5051548662938","date":1455059336,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","sourceNew":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      for(String [] methodParam: new String[][]{ new String[]{}, new String []{\"facet.method\", \"uif\"}}) {\n        assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  , \"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQforUIF(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  ,\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQforUIF(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n        assertQforUIF(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n        );\n      }\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","sourceOld":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      assertQ(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0b21c0ef4cefc9a6c012a77388d894c9d2ceda12","date":1501539735,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","sourceNew":"  public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      for(String [] methodParam: new String[][]{ new String[]{}, new String []{\"facet.method\", \"uif\"}}) {\n        assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  , \"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQforUIF(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  ,\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQforUIF(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n        assertQforUIF(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n        );\n      }\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","sourceOld":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      for(String [] methodParam: new String[][]{ new String[]{}, new String []{\"facet.method\", \"uif\"}}) {\n        assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  , \"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQforUIF(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  ,\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQforUIF(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n        assertQforUIF(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n        );\n      }\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29100f1cf3406ddc394298904704d022872303d5","date":1501594929,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","sourceNew":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      for(String [] methodParam: new String[][]{ new String[]{}, new String []{\"facet.method\", \"uif\"}}) {\n        assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  , \"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQforUIF(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  ,\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQforUIF(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n        assertQforUIF(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n        );\n      }\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","sourceOld":"  public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      for(String [] methodParam: new String[][]{ new String[]{}, new String []{\"facet.method\", \"uif\"}}) {\n        assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  , \"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQforUIF(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  ,\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQforUIF(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n        assertQforUIF(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n        );\n      }\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ebff2e24a6d2f84582ff6315d8d377380941b23e","date":1501630388,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","sourceNew":"  public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      for(String [] methodParam: new String[][]{ new String[]{}, new String []{\"facet.method\", \"uif\"}}) {\n        assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  , \"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQforUIF(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  ,\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQforUIF(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n        assertQforUIF(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n        );\n      }\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","sourceOld":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      for(String [] methodParam: new String[][]{ new String[]{}, new String []{\"facet.method\", \"uif\"}}) {\n        assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  , \"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQforUIF(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  ,\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQforUIF(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n        assertQforUIF(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n        );\n      }\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestFaceting#testSimpleFacetCountsWithMultipleConfigurationsForSameField().mjava","sourceNew":"  public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      for(String [] methodParam: new String[][]{ new String[]{}, new String []{\"facet.method\", \"uif\"}}) {\n        assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  , \"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQforUIF(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  ,\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQforUIF(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n        assertQforUIF(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n        );\n      }\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","sourceOld":"    public void testSimpleFacetCountsWithMultipleConfigurationsForSameField() {\n      clearIndex();\n      String fname = \"trait_ss\";\n      assertU(adoc(\"id\", \"42\",\n          fname, \"Tool\",\n          fname, \"Obnoxious\",\n          \"name_s\", \"Zapp Brannigan\"));\n\n      assertU(adoc(\"id\", \"43\" ,\n                   \"title_s\", \"Democratic Order of Planets\"));\n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"44\",\n          fname, \"Tool\",\n          \"name_s\", \"The Zapper\"));\n  \n      assertU(adoc(\"id\", \"45\",\n          fname, \"Chauvinist\",\n          \"title_s\", \"25 star General\"));\n  \n      assertU(adoc(\"id\", \"46\",\n          fname, \"Obnoxious\",\n          \"subject_s\", \"Defeated the pacifists of the Gandhi nebula\"));\n  \n      assertU(commit());\n  \n      assertU(adoc(\"id\", \"47\",\n          fname, \"Pig\",\n          \"text_t\", \"line up and fly directly at the enemy death cannons, clogging them with wreckage!\"));\n      assertU(commit());\n  \n      for(String [] methodParam: new String[][]{ new String[]{}, new String []{\"facet.method\", \"uif\"}}) {\n        assertQ(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  , \"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                     \"facet.mincount=0 \"+\n                     \"facet.missing=false \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                     \"facet.mincount=2 \"+\n                     \"facet.missing=true \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=4]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='foo']/int[@name='Obnoxious'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='foo']/int[@name='Pig'][.='0']\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[not(@name)][.='1']\"\n              );\n  \n      assertQforUIF(\"checking facets when one has missing=true&mincount=2 and the other has missing=false&mincount=0\",\n              req(methodParam\n                  ,\"q\", \"id:[42 TO 47]\"\n                  ,\"facet\", \"true\"\n                  ,\"facet.zeros\", \"false\"\n                  ,\"fq\", \"id:[42 TO 45]\"\n                  ,\"facet.field\", \"{!key=foo \" +\n                      \"facet.prefix=Too \"+\n                  \"}\"+fname\n                  ,\"facet.field\", \"{!key=bar \" +\n                      \"facet.limit=2 \"+\n                      \"facet.sort=false \"+\n                  \"}\"+fname\n                  )\n              ,\"*[count(//doc)=4]\"\n              ,\"*[count(//lst[@name='foo']/int)=1]\"\n              ,\"*[count(//lst[@name='bar']/int)=2]\"\n              ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n              ,\"//lst[@name='bar']/int[@name='Chauvinist'][.='1']\"\n              ,\"//lst[@name='bar']/int[@name='Obnoxious'][.='1']\"\n              );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.sort vs facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.sort=index\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          )\n                      // foo is in index order w/o missing\n                      ,\"*[count(//lst[@name='foo']/int)=4]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Chauvinist'][.='1']\"\n                  ,\"//lst[@name='foo']/int[2][@name='Obnoxious'][.='1']\"\n                  ,\"//lst[@name='foo']/int[3][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[4][@name='Tool'][.='2']\"\n                  // bar is in count order by default and includes missing\n                  ,\"*[count(//lst[@name='bar']/int)=5]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='bar']/int[5][not(@name)][.='1']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.mincount\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.mincount=2\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // only Tool for foo\n                      ,\"*[count(//lst[@name='foo']/int)=1]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // all for bar\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQ(\"localparams in one facet variant should not affect defaults in another: facet.missing\",\n                  req(methodParam\n                      ,\"q\", \"id:[42 TO 47]\"\n                          ,\"rows\",\"0\"\n                          ,\"facet\", \"true\"\n                          ,\"fq\", \"id:[42 TO 45]\"\n                          ,\"facet.field\", \"{!key=foo \" +\n                              \"facet.missing=true\" +\n                          \"}\"+fname\n                          ,\"facet.field\", \"{!key=bar}\"+fname\n                          )\n                      // foo includes missing\n                      ,\"*[count(//lst[@name='foo']/int)=5]\"\n                  ,\"//lst[@name='foo']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='foo']/int[4][@name='Pig'][.='0']\"\n                  ,\"//lst[@name='foo']/int[5][not(@name)][.='1']\"\n                  // bar does not\n                  ,\"*[count(//lst[@name='bar']/int)=4]\"\n                  ,\"//lst[@name='bar']/int[1][@name='Tool'][.='2']\"\n                  // don't assume tie breaker for slots 3 & 4, behavior undefined?\n                  ,\"//lst[@name='bar']/int[4][@name='Pig'][.='0']\"\n                  );\n\n      assertQforUIF(\"checking facets when local facet.prefix param used after regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", fname\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n      );\n\n        assertQforUIF(\"checking facets when local facet.prefix param used before regular/raw field faceting\",\n          req(methodParam\n              ,\"q\", \"*:*\"\n              ,\"facet\", \"true\"\n              ,\"facet.field\", \"{!key=foo \" +\n              \"facet.prefix=T \"+\n              \"}\"+fname\n              ,\"facet.field\", fname\n          )\n          ,\"*[count(//doc)=6]\"\n          ,\"*[count(//lst[@name='\" + fname + \"']/int)=4]\"\n          ,\"*[count(//lst[@name='foo']/int)=1]\"\n          ,\"//lst[@name='foo']/int[@name='Tool'][.='2']\"\n        );\n      }\n\n      final String foo_range_facet = \"{!key=foo facet.range.gap=2}val_i\";\n      final String val_range_facet = \"val_i\";\n      for (boolean toggle : new boolean[] { true, false }) {\n          assertQ(\"local gap param mixed w/raw range faceting: \" + toggle,\n                      req(\"q\", \"*:*\"\n                              ,\"facet\", \"true\"\n                              ,\"rows\", \"0\"\n                              ,\"facet.range.start\", \"0\"\n                              ,\"facet.range.end\", \"10\"\n                              ,\"facet.range.gap\", \"1\"\n                              ,\"facet.range\", (toggle ? foo_range_facet : val_range_facet)\n                              ,\"facet.range\", (toggle ? val_range_facet : foo_range_facet)\n                              )\n                          ,\"*[count(//lst[@name='val_i']/lst[@name='counts']/int)=10]\"\n                      ,\"*[count(//lst[@name='foo']/lst[@name='counts']/int)=5]\"\n                      );\n        }\n\n      clearIndex();\n      assertU(commit());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["e861f53430fcbc7afe2f446a7485e123055d073f","19275ba31e621f6da1b83bf13af75233876fd3d4"],"f29c962d2a19abc63339cd093c2c0f234fc763e8":["309bb934ccf1b9733206e54bd15a143b6a198889"],"ebff2e24a6d2f84582ff6315d8d377380941b23e":["29100f1cf3406ddc394298904704d022872303d5"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["e861f53430fcbc7afe2f446a7485e123055d073f"],"309bb934ccf1b9733206e54bd15a143b6a198889":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3c64189697927b548f74ba66dfa5051548662938":["19275ba31e621f6da1b83bf13af75233876fd3d4","3802d95c3a31be21ea2971945049b711d95ef8d5"],"e861f53430fcbc7afe2f446a7485e123055d073f":["f29c962d2a19abc63339cd093c2c0f234fc763e8"],"29100f1cf3406ddc394298904704d022872303d5":["0b21c0ef4cefc9a6c012a77388d894c9d2ceda12"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["3c64189697927b548f74ba66dfa5051548662938","ebff2e24a6d2f84582ff6315d8d377380941b23e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0b21c0ef4cefc9a6c012a77388d894c9d2ceda12":["3c64189697927b548f74ba66dfa5051548662938"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ebff2e24a6d2f84582ff6315d8d377380941b23e"],"3802d95c3a31be21ea2971945049b711d95ef8d5":["19275ba31e621f6da1b83bf13af75233876fd3d4"]},"commit2Childs":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"f29c962d2a19abc63339cd093c2c0f234fc763e8":["e861f53430fcbc7afe2f446a7485e123055d073f"],"ebff2e24a6d2f84582ff6315d8d377380941b23e":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","3c64189697927b548f74ba66dfa5051548662938","3802d95c3a31be21ea2971945049b711d95ef8d5"],"309bb934ccf1b9733206e54bd15a143b6a198889":["f29c962d2a19abc63339cd093c2c0f234fc763e8"],"3c64189697927b548f74ba66dfa5051548662938":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","0b21c0ef4cefc9a6c012a77388d894c9d2ceda12"],"e861f53430fcbc7afe2f446a7485e123055d073f":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","19275ba31e621f6da1b83bf13af75233876fd3d4"],"29100f1cf3406ddc394298904704d022872303d5":["ebff2e24a6d2f84582ff6315d8d377380941b23e"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["309bb934ccf1b9733206e54bd15a143b6a198889"],"0b21c0ef4cefc9a6c012a77388d894c9d2ceda12":["29100f1cf3406ddc394298904704d022872303d5"],"3802d95c3a31be21ea2971945049b711d95ef8d5":["3c64189697927b548f74ba66dfa5051548662938"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}