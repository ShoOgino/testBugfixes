{"path":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","commits":[{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":0,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","pathOld":"/dev/null","sourceNew":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n//  if (core.getUpdateHandler().getUpdateLog() != null) {\n//    SolrException.log(LOG, \"'replicate-only' recovery strategy should only be used if no update logs are present, but this core has one: \"\n//        + core.getUpdateHandler().getUpdateLog());\n//    return;\n//  }\n  while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or it will close channels though\n    try {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n          cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n      final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n      String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n      boolean isLeader = leaderUrl.equals(ourUrl); //TODO: We can probably delete most of this code if we say this strategy can only be used for pull replicas\n      if (isLeader && !cloudDesc.isLeader()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n      }\n      if (cloudDesc.isLeader()) {\n        assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n        // we are now the leader - no one else must have been suitable\n        LOG.warn(\"We have not yet recovered - but we are now the leader!\");\n        LOG.info(\"Finished recovery process.\");\n        zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        return;\n      }\n      \n      \n      LOG.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n          ourUrl);\n      zkController.publish(core.getCoreDescriptor(), Replica.State.RECOVERING);\n      \n      if (isClosed()) {\n        LOG.info(\"Recovery for core {} has been closed\", core.getName());\n        break;\n      }\n      LOG.info(\"Starting Replication Recovery.\");\n\n      try {\n        LOG.info(\"Stopping background replicate from leader process\");\n        zkController.stopReplicationFromLeader(coreName);\n        replicate(zkController.getNodeName(), core, leaderprops);\n\n        if (isClosed()) {\n          LOG.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n\n        LOG.info(\"Replication Recovery was successful.\");\n        successfulRecovery = true;\n      } catch (Exception e) {\n        SolrException.log(LOG, \"Error while trying to recover\", e);\n      }\n\n    } catch (Exception e) {\n      SolrException.log(LOG, \"Error while trying to recover. core=\" + coreName, e);\n    } finally {\n      if (successfulRecovery) {\n        LOG.info(\"Restaring background replicate from leader process\");\n        zkController.startReplicationFromLeader(coreName, false);\n        LOG.info(\"Registering as Active after recovery.\");\n        try {\n          zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        } catch (Exception e) {\n          LOG.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n          successfulRecovery = false;\n        }\n        \n        if (successfulRecovery) {\n          close = true;\n          recoveryListener.recovered();\n        }\n      }\n    }\n\n    if (!successfulRecovery) {\n      // lets pause for a moment and we need to try again...\n      // TODO: we don't want to retry for some problems?\n      // Or do a fall off retry...\n      try {\n\n        if (isClosed()) {\n          LOG.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n        \n        LOG.error(\"Recovery failed - trying again... (\" + retries + \")\");\n        \n        retries++;\n        if (retries >= maxRetries) {\n          SolrException.log(LOG, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n          try {\n            recoveryFailed(core, zkController, baseUrl, coreZkNodeName, core.getCoreDescriptor());\n          } catch (Exception e) {\n            SolrException.log(LOG, \"Could not publish that recovery failed\", e);\n          }\n          break;\n        }\n      } catch (Exception e) {\n        SolrException.log(LOG, \"An error has occurred during recovery\", e);\n      }\n\n      try {\n        // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n        // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result \n        // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n        // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n        double loopCount = retries < 4 ? Math.min(Math.pow(2, retries), 12) : 12;\n        LOG.info(\"Wait [{}] seconds before trying to recover again (attempt={})\", loopCount, retries);\n        for (int i = 0; i < loopCount; i++) {\n          if (isClosed()) {\n            LOG.info(\"Recovery for core {} has been closed\", core.getName());\n            break; // check if someone closed us\n          }\n          Thread.sleep(startingRecoveryDelayMilliSeconds);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Recovery was interrupted.\", e);\n        close = true;\n      }\n    }\n\n  }\n  // We skip core.seedVersionBuckets(); We don't have a transaction log\n  LOG.info(\"Finished recovery process, successful=[{}]\", Boolean.toString(successfulRecovery));\n}\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","420b2cd54774495de0bb67f068f5231f3da5e494","ce75060aea8b539ea26382d0162679fba6151a9d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","pathOld":"/dev/null","sourceNew":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n//  if (core.getUpdateHandler().getUpdateLog() != null) {\n//    SolrException.log(LOG, \"'replicate-only' recovery strategy should only be used if no update logs are present, but this core has one: \"\n//        + core.getUpdateHandler().getUpdateLog());\n//    return;\n//  }\n  while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or it will close channels though\n    try {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n          cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n      final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n      String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n      boolean isLeader = leaderUrl.equals(ourUrl); //TODO: We can probably delete most of this code if we say this strategy can only be used for pull replicas\n      if (isLeader && !cloudDesc.isLeader()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n      }\n      if (cloudDesc.isLeader()) {\n        assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n        // we are now the leader - no one else must have been suitable\n        LOG.warn(\"We have not yet recovered - but we are now the leader!\");\n        LOG.info(\"Finished recovery process.\");\n        zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        return;\n      }\n      \n      \n      LOG.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n          ourUrl);\n      zkController.publish(core.getCoreDescriptor(), Replica.State.RECOVERING);\n      \n      if (isClosed()) {\n        LOG.info(\"Recovery for core {} has been closed\", core.getName());\n        break;\n      }\n      LOG.info(\"Starting Replication Recovery.\");\n\n      try {\n        LOG.info(\"Stopping background replicate from leader process\");\n        zkController.stopReplicationFromLeader(coreName);\n        replicate(zkController.getNodeName(), core, leaderprops);\n\n        if (isClosed()) {\n          LOG.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n\n        LOG.info(\"Replication Recovery was successful.\");\n        successfulRecovery = true;\n      } catch (Exception e) {\n        SolrException.log(LOG, \"Error while trying to recover\", e);\n      }\n\n    } catch (Exception e) {\n      SolrException.log(LOG, \"Error while trying to recover. core=\" + coreName, e);\n    } finally {\n      if (successfulRecovery) {\n        LOG.info(\"Restaring background replicate from leader process\");\n        zkController.startReplicationFromLeader(coreName, false);\n        LOG.info(\"Registering as Active after recovery.\");\n        try {\n          zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        } catch (Exception e) {\n          LOG.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n          successfulRecovery = false;\n        }\n        \n        if (successfulRecovery) {\n          close = true;\n          recoveryListener.recovered();\n        }\n      }\n    }\n\n    if (!successfulRecovery) {\n      // lets pause for a moment and we need to try again...\n      // TODO: we don't want to retry for some problems?\n      // Or do a fall off retry...\n      try {\n\n        if (isClosed()) {\n          LOG.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n        \n        LOG.error(\"Recovery failed - trying again... (\" + retries + \")\");\n        \n        retries++;\n        if (retries >= maxRetries) {\n          SolrException.log(LOG, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n          try {\n            recoveryFailed(core, zkController, baseUrl, coreZkNodeName, core.getCoreDescriptor());\n          } catch (Exception e) {\n            SolrException.log(LOG, \"Could not publish that recovery failed\", e);\n          }\n          break;\n        }\n      } catch (Exception e) {\n        SolrException.log(LOG, \"An error has occurred during recovery\", e);\n      }\n\n      try {\n        // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n        // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result \n        // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n        // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n        double loopCount = retries < 4 ? Math.min(Math.pow(2, retries), 12) : 12;\n        LOG.info(\"Wait [{}] seconds before trying to recover again (attempt={})\", loopCount, retries);\n        for (int i = 0; i < loopCount; i++) {\n          if (isClosed()) {\n            LOG.info(\"Recovery for core {} has been closed\", core.getName());\n            break; // check if someone closed us\n          }\n          Thread.sleep(startingRecoveryDelayMilliSeconds);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Recovery was interrupted.\", e);\n        close = true;\n      }\n    }\n\n  }\n  // We skip core.seedVersionBuckets(); We don't have a transaction log\n  LOG.info(\"Finished recovery process, successful=[{}]\", Boolean.toString(successfulRecovery));\n}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce75060aea8b539ea26382d0162679fba6151a9d","date":1534411849,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","sourceNew":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n//  if (core.getUpdateHandler().getUpdateLog() != null) {\n//    SolrException.log(LOG, \"'replicate-only' recovery strategy should only be used if no update logs are present, but this core has one: \"\n//        + core.getUpdateHandler().getUpdateLog());\n//    return;\n//  }\n  while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or it will close channels though\n    try {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n          cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n      final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n      String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n      boolean isLeader = leaderUrl.equals(ourUrl); //TODO: We can probably delete most of this code if we say this strategy can only be used for pull replicas\n      if (isLeader && !cloudDesc.isLeader()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n      }\n      if (cloudDesc.isLeader()) {\n        assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n        // we are now the leader - no one else must have been suitable\n        LOG.warn(\"We have not yet recovered - but we are now the leader!\");\n        LOG.info(\"Finished recovery process.\");\n        zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        return;\n      }\n      \n      \n      LOG.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n          ourUrl);\n      zkController.publish(core.getCoreDescriptor(), Replica.State.RECOVERING);\n      \n      if (isClosed()) {\n        LOG.info(\"Recovery for core {} has been closed\", core.getName());\n        break;\n      }\n      LOG.info(\"Starting Replication Recovery.\");\n\n      try {\n        LOG.info(\"Stopping background replicate from leader process\");\n        zkController.stopReplicationFromLeader(coreName);\n        replicate(zkController.getNodeName(), core, leaderprops);\n\n        if (isClosed()) {\n          LOG.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n\n        LOG.info(\"Replication Recovery was successful.\");\n        successfulRecovery = true;\n      } catch (Exception e) {\n        SolrException.log(LOG, \"Error while trying to recover\", e);\n      }\n\n    } catch (Exception e) {\n      SolrException.log(LOG, \"Error while trying to recover. core=\" + coreName, e);\n    } finally {\n      if (successfulRecovery) {\n        LOG.info(\"Restaring background replicate from leader process\");\n        zkController.startReplicationFromLeader(coreName, false);\n        LOG.info(\"Registering as Active after recovery.\");\n        try {\n          zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        } catch (Exception e) {\n          LOG.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n          successfulRecovery = false;\n        }\n        \n        if (successfulRecovery) {\n          close = true;\n          recoveryListener.recovered();\n        }\n      }\n    }\n\n    if (!successfulRecovery) {\n      // lets pause for a moment and we need to try again...\n      // TODO: we don't want to retry for some problems?\n      // Or do a fall off retry...\n      try {\n\n        if (isClosed()) {\n          LOG.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n        \n        LOG.error(\"Recovery failed - trying again... (\" + retries + \")\");\n        \n        retries++;\n        if (retries >= maxRetries) {\n          SolrException.log(LOG, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n          try {\n            recoveryFailed(core, zkController, baseUrl, coreZkNodeName, core.getCoreDescriptor());\n          } catch (Exception e) {\n            SolrException.log(LOG, \"Could not publish that recovery failed\", e);\n          }\n          break;\n        }\n      } catch (Exception e) {\n        SolrException.log(LOG, \"An error has occurred during recovery\", e);\n      }\n\n      try {\n        // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n        // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result\n        // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n        // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n        int loopCount = retries < 4 ? (int) Math.min(Math.pow(2, retries), 12) : 12;\n        LOG.info(\"Wait [{}] seconds before trying to recover again (attempt={})\",\n            TimeUnit.MILLISECONDS.toSeconds(loopCount * startingRecoveryDelayMilliSeconds), retries);\n        for (int i = 0; i < loopCount; i++) {\n          if (isClosed()) {\n            LOG.info(\"Recovery for core {} has been closed\", core.getName());\n            break; // check if someone closed us\n          }\n          Thread.sleep(startingRecoveryDelayMilliSeconds);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Recovery was interrupted.\", e);\n        close = true;\n      }\n    }\n\n  }\n  // We skip core.seedVersionBuckets(); We don't have a transaction log\n  LOG.info(\"Finished recovery process, successful=[{}]\", Boolean.toString(successfulRecovery));\n}\n\n","sourceOld":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n//  if (core.getUpdateHandler().getUpdateLog() != null) {\n//    SolrException.log(LOG, \"'replicate-only' recovery strategy should only be used if no update logs are present, but this core has one: \"\n//        + core.getUpdateHandler().getUpdateLog());\n//    return;\n//  }\n  while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or it will close channels though\n    try {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n          cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n      final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n      String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n      boolean isLeader = leaderUrl.equals(ourUrl); //TODO: We can probably delete most of this code if we say this strategy can only be used for pull replicas\n      if (isLeader && !cloudDesc.isLeader()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n      }\n      if (cloudDesc.isLeader()) {\n        assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n        // we are now the leader - no one else must have been suitable\n        LOG.warn(\"We have not yet recovered - but we are now the leader!\");\n        LOG.info(\"Finished recovery process.\");\n        zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        return;\n      }\n      \n      \n      LOG.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n          ourUrl);\n      zkController.publish(core.getCoreDescriptor(), Replica.State.RECOVERING);\n      \n      if (isClosed()) {\n        LOG.info(\"Recovery for core {} has been closed\", core.getName());\n        break;\n      }\n      LOG.info(\"Starting Replication Recovery.\");\n\n      try {\n        LOG.info(\"Stopping background replicate from leader process\");\n        zkController.stopReplicationFromLeader(coreName);\n        replicate(zkController.getNodeName(), core, leaderprops);\n\n        if (isClosed()) {\n          LOG.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n\n        LOG.info(\"Replication Recovery was successful.\");\n        successfulRecovery = true;\n      } catch (Exception e) {\n        SolrException.log(LOG, \"Error while trying to recover\", e);\n      }\n\n    } catch (Exception e) {\n      SolrException.log(LOG, \"Error while trying to recover. core=\" + coreName, e);\n    } finally {\n      if (successfulRecovery) {\n        LOG.info(\"Restaring background replicate from leader process\");\n        zkController.startReplicationFromLeader(coreName, false);\n        LOG.info(\"Registering as Active after recovery.\");\n        try {\n          zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        } catch (Exception e) {\n          LOG.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n          successfulRecovery = false;\n        }\n        \n        if (successfulRecovery) {\n          close = true;\n          recoveryListener.recovered();\n        }\n      }\n    }\n\n    if (!successfulRecovery) {\n      // lets pause for a moment and we need to try again...\n      // TODO: we don't want to retry for some problems?\n      // Or do a fall off retry...\n      try {\n\n        if (isClosed()) {\n          LOG.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n        \n        LOG.error(\"Recovery failed - trying again... (\" + retries + \")\");\n        \n        retries++;\n        if (retries >= maxRetries) {\n          SolrException.log(LOG, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n          try {\n            recoveryFailed(core, zkController, baseUrl, coreZkNodeName, core.getCoreDescriptor());\n          } catch (Exception e) {\n            SolrException.log(LOG, \"Could not publish that recovery failed\", e);\n          }\n          break;\n        }\n      } catch (Exception e) {\n        SolrException.log(LOG, \"An error has occurred during recovery\", e);\n      }\n\n      try {\n        // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n        // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result \n        // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n        // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n        double loopCount = retries < 4 ? Math.min(Math.pow(2, retries), 12) : 12;\n        LOG.info(\"Wait [{}] seconds before trying to recover again (attempt={})\", loopCount, retries);\n        for (int i = 0; i < loopCount; i++) {\n          if (isClosed()) {\n            LOG.info(\"Recovery for core {} has been closed\", core.getName());\n            break; // check if someone closed us\n          }\n          Thread.sleep(startingRecoveryDelayMilliSeconds);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Recovery was interrupted.\", e);\n        close = true;\n      }\n    }\n\n  }\n  // We skip core.seedVersionBuckets(); We don't have a transaction log\n  LOG.info(\"Finished recovery process, successful=[{}]\", Boolean.toString(successfulRecovery));\n}\n\n","bugFix":["61c45e99cf6676da48f19d7511c73712ad39402b"],"bugIntro":["420b2cd54774495de0bb67f068f5231f3da5e494"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","sourceNew":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n//  if (core.getUpdateHandler().getUpdateLog() != null) {\n//    SolrException.log(log, \"'replicate-only' recovery strategy should only be used if no update logs are present, but this core has one: \"\n//        + core.getUpdateHandler().getUpdateLog());\n//    return;\n//  }\n  while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or it will close channels though\n    try {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n          cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n      final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n      String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n      boolean isLeader = leaderUrl.equals(ourUrl); //TODO: We can probably delete most of this code if we say this strategy can only be used for pull replicas\n      if (isLeader && !cloudDesc.isLeader()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n      }\n      if (cloudDesc.isLeader()) {\n        assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n        // we are now the leader - no one else must have been suitable\n        log.warn(\"We have not yet recovered - but we are now the leader!\");\n        log.info(\"Finished recovery process.\");\n        zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        return;\n      }\n      \n      \n      log.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n          ourUrl);\n      zkController.publish(core.getCoreDescriptor(), Replica.State.RECOVERING);\n      \n      if (isClosed()) {\n        log.info(\"Recovery for core {} has been closed\", core.getName());\n        break;\n      }\n      log.info(\"Starting Replication Recovery.\");\n\n      try {\n        log.info(\"Stopping background replicate from leader process\");\n        zkController.stopReplicationFromLeader(coreName);\n        replicate(zkController.getNodeName(), core, leaderprops);\n\n        if (isClosed()) {\n          log.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n\n        log.info(\"Replication Recovery was successful.\");\n        successfulRecovery = true;\n      } catch (Exception e) {\n        SolrException.log(log, \"Error while trying to recover\", e);\n      }\n\n    } catch (Exception e) {\n      SolrException.log(log, \"Error while trying to recover. core=\" + coreName, e);\n    } finally {\n      if (successfulRecovery) {\n        log.info(\"Restaring background replicate from leader process\");\n        zkController.startReplicationFromLeader(coreName, false);\n        log.info(\"Registering as Active after recovery.\");\n        try {\n          zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        } catch (Exception e) {\n          log.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n          successfulRecovery = false;\n        }\n        \n        if (successfulRecovery) {\n          close = true;\n          recoveryListener.recovered();\n        }\n      }\n    }\n\n    if (!successfulRecovery) {\n      // lets pause for a moment and we need to try again...\n      // TODO: we don't want to retry for some problems?\n      // Or do a fall off retry...\n      try {\n\n        if (isClosed()) {\n          log.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n        \n        log.error(\"Recovery failed - trying again... (\" + retries + \")\");\n        \n        retries++;\n        if (retries >= maxRetries) {\n          SolrException.log(log, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n          try {\n            recoveryFailed(core, zkController, baseUrl, coreZkNodeName, core.getCoreDescriptor());\n          } catch (Exception e) {\n            SolrException.log(log, \"Could not publish that recovery failed\", e);\n          }\n          break;\n        }\n      } catch (Exception e) {\n        SolrException.log(log, \"An error has occurred during recovery\", e);\n      }\n\n      try {\n        // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n        // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result\n        // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n        // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n        int loopCount = retries < 4 ? (int) Math.min(Math.pow(2, retries), 12) : 12;\n        log.info(\"Wait [{}] seconds before trying to recover again (attempt={})\",\n            TimeUnit.MILLISECONDS.toSeconds(loopCount * startingRecoveryDelayMilliSeconds), retries);\n        for (int i = 0; i < loopCount; i++) {\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break; // check if someone closed us\n          }\n          Thread.sleep(startingRecoveryDelayMilliSeconds);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"Recovery was interrupted.\", e);\n        close = true;\n      }\n    }\n\n  }\n  // We skip core.seedVersionBuckets(); We don't have a transaction log\n  log.info(\"Finished recovery process, successful=[{}]\", Boolean.toString(successfulRecovery));\n}\n\n","sourceOld":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n//  if (core.getUpdateHandler().getUpdateLog() != null) {\n//    SolrException.log(LOG, \"'replicate-only' recovery strategy should only be used if no update logs are present, but this core has one: \"\n//        + core.getUpdateHandler().getUpdateLog());\n//    return;\n//  }\n  while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or it will close channels though\n    try {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n          cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n      final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n      String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n      boolean isLeader = leaderUrl.equals(ourUrl); //TODO: We can probably delete most of this code if we say this strategy can only be used for pull replicas\n      if (isLeader && !cloudDesc.isLeader()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n      }\n      if (cloudDesc.isLeader()) {\n        assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n        // we are now the leader - no one else must have been suitable\n        LOG.warn(\"We have not yet recovered - but we are now the leader!\");\n        LOG.info(\"Finished recovery process.\");\n        zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        return;\n      }\n      \n      \n      LOG.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n          ourUrl);\n      zkController.publish(core.getCoreDescriptor(), Replica.State.RECOVERING);\n      \n      if (isClosed()) {\n        LOG.info(\"Recovery for core {} has been closed\", core.getName());\n        break;\n      }\n      LOG.info(\"Starting Replication Recovery.\");\n\n      try {\n        LOG.info(\"Stopping background replicate from leader process\");\n        zkController.stopReplicationFromLeader(coreName);\n        replicate(zkController.getNodeName(), core, leaderprops);\n\n        if (isClosed()) {\n          LOG.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n\n        LOG.info(\"Replication Recovery was successful.\");\n        successfulRecovery = true;\n      } catch (Exception e) {\n        SolrException.log(LOG, \"Error while trying to recover\", e);\n      }\n\n    } catch (Exception e) {\n      SolrException.log(LOG, \"Error while trying to recover. core=\" + coreName, e);\n    } finally {\n      if (successfulRecovery) {\n        LOG.info(\"Restaring background replicate from leader process\");\n        zkController.startReplicationFromLeader(coreName, false);\n        LOG.info(\"Registering as Active after recovery.\");\n        try {\n          zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        } catch (Exception e) {\n          LOG.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n          successfulRecovery = false;\n        }\n        \n        if (successfulRecovery) {\n          close = true;\n          recoveryListener.recovered();\n        }\n      }\n    }\n\n    if (!successfulRecovery) {\n      // lets pause for a moment and we need to try again...\n      // TODO: we don't want to retry for some problems?\n      // Or do a fall off retry...\n      try {\n\n        if (isClosed()) {\n          LOG.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n        \n        LOG.error(\"Recovery failed - trying again... (\" + retries + \")\");\n        \n        retries++;\n        if (retries >= maxRetries) {\n          SolrException.log(LOG, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n          try {\n            recoveryFailed(core, zkController, baseUrl, coreZkNodeName, core.getCoreDescriptor());\n          } catch (Exception e) {\n            SolrException.log(LOG, \"Could not publish that recovery failed\", e);\n          }\n          break;\n        }\n      } catch (Exception e) {\n        SolrException.log(LOG, \"An error has occurred during recovery\", e);\n      }\n\n      try {\n        // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n        // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result\n        // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n        // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n        int loopCount = retries < 4 ? (int) Math.min(Math.pow(2, retries), 12) : 12;\n        LOG.info(\"Wait [{}] seconds before trying to recover again (attempt={})\",\n            TimeUnit.MILLISECONDS.toSeconds(loopCount * startingRecoveryDelayMilliSeconds), retries);\n        for (int i = 0; i < loopCount; i++) {\n          if (isClosed()) {\n            LOG.info(\"Recovery for core {} has been closed\", core.getName());\n            break; // check if someone closed us\n          }\n          Thread.sleep(startingRecoveryDelayMilliSeconds);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Recovery was interrupted.\", e);\n        close = true;\n      }\n    }\n\n  }\n  // We skip core.seedVersionBuckets(); We don't have a transaction log\n  LOG.info(\"Finished recovery process, successful=[{}]\", Boolean.toString(successfulRecovery));\n}\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","420b2cd54774495de0bb67f068f5231f3da5e494"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"420b2cd54774495de0bb67f068f5231f3da5e494","date":1538382330,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","sourceNew":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n//  if (core.getUpdateHandler().getUpdateLog() != null) {\n//    SolrException.log(log, \"'replicate-only' recovery strategy should only be used if no update logs are present, but this core has one: \"\n//        + core.getUpdateHandler().getUpdateLog());\n//    return;\n//  }\n    while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or it will close channels though\n      try {\n        CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n        final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n        String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n        boolean isLeader = leaderUrl.equals(ourUrl); //TODO: We can probably delete most of this code if we say this strategy can only be used for pull replicas\n        if (isLeader && !cloudDesc.isLeader()) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n        }\n        if (cloudDesc.isLeader()) {\n          assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n          // we are now the leader - no one else must have been suitable\n          log.warn(\"We have not yet recovered - but we are now the leader!\");\n          log.info(\"Finished recovery process.\");\n          zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n          return;\n        }\n\n\n        log.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n            ourUrl);\n        zkController.publish(core.getCoreDescriptor(), Replica.State.RECOVERING);\n\n        if (isClosed()) {\n          log.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n        log.info(\"Starting Replication Recovery.\");\n\n        try {\n          log.info(\"Stopping background replicate from leader process\");\n          zkController.stopReplicationFromLeader(coreName);\n          replicate(zkController.getNodeName(), core, leaderprops);\n\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break;\n          }\n\n          log.info(\"Replication Recovery was successful.\");\n          successfulRecovery = true;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error while trying to recover\", e);\n        }\n\n      } catch (Exception e) {\n        SolrException.log(log, \"Error while trying to recover. core=\" + coreName, e);\n      } finally {\n        if (successfulRecovery) {\n          log.info(\"Restaring background replicate from leader process\");\n          zkController.startReplicationFromLeader(coreName, false);\n          log.info(\"Registering as Active after recovery.\");\n          try {\n            zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n          } catch (Exception e) {\n            log.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n            successfulRecovery = false;\n          }\n\n          if (successfulRecovery) {\n            close = true;\n            recoveryListener.recovered();\n          }\n        }\n      }\n\n      if (!successfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break;\n          }\n\n          log.error(\"Recovery failed - trying again... (\" + retries + \")\");\n\n          retries++;\n          if (retries >= maxRetries) {\n            SolrException.log(log, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n            try {\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName, core.getCoreDescriptor());\n            } catch (Exception e) {\n              SolrException.log(log, \"Could not publish that recovery failed\", e);\n            }\n            break;\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"An error has occurred during recovery\", e);\n        }\n\n        try {\n          // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n          // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result\n          // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n          // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n          int loopCount = retries < 4 ? (int) Math.min(Math.pow(2, retries), 12) : 12;\n          log.info(\"Wait [{}] seconds before trying to recover again (attempt={})\",\n              TimeUnit.MILLISECONDS.toSeconds(loopCount * startingRecoveryDelayMilliSeconds), retries);\n          for (int i = 0; i < loopCount; i++) {\n            if (isClosed()) {\n              log.info(\"Recovery for core {} has been closed\", core.getName());\n              break; // check if someone closed us\n            }\n            Thread.sleep(startingRecoveryDelayMilliSeconds);\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted.\", e);\n          close = true;\n        }\n      }\n\n    }\n    // We skip core.seedVersionBuckets(); We don't have a transaction log\n    log.info(\"Finished recovery process, successful=[{}]\", Boolean.toString(successfulRecovery));\n  }\n\n","sourceOld":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n//  if (core.getUpdateHandler().getUpdateLog() != null) {\n//    SolrException.log(log, \"'replicate-only' recovery strategy should only be used if no update logs are present, but this core has one: \"\n//        + core.getUpdateHandler().getUpdateLog());\n//    return;\n//  }\n  while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or it will close channels though\n    try {\n      CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n      ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n          cloudDesc.getCollectionName(), cloudDesc.getShardId());\n      final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n      final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n      String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n      String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n      boolean isLeader = leaderUrl.equals(ourUrl); //TODO: We can probably delete most of this code if we say this strategy can only be used for pull replicas\n      if (isLeader && !cloudDesc.isLeader()) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n      }\n      if (cloudDesc.isLeader()) {\n        assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n        // we are now the leader - no one else must have been suitable\n        log.warn(\"We have not yet recovered - but we are now the leader!\");\n        log.info(\"Finished recovery process.\");\n        zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        return;\n      }\n      \n      \n      log.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n          ourUrl);\n      zkController.publish(core.getCoreDescriptor(), Replica.State.RECOVERING);\n      \n      if (isClosed()) {\n        log.info(\"Recovery for core {} has been closed\", core.getName());\n        break;\n      }\n      log.info(\"Starting Replication Recovery.\");\n\n      try {\n        log.info(\"Stopping background replicate from leader process\");\n        zkController.stopReplicationFromLeader(coreName);\n        replicate(zkController.getNodeName(), core, leaderprops);\n\n        if (isClosed()) {\n          log.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n\n        log.info(\"Replication Recovery was successful.\");\n        successfulRecovery = true;\n      } catch (Exception e) {\n        SolrException.log(log, \"Error while trying to recover\", e);\n      }\n\n    } catch (Exception e) {\n      SolrException.log(log, \"Error while trying to recover. core=\" + coreName, e);\n    } finally {\n      if (successfulRecovery) {\n        log.info(\"Restaring background replicate from leader process\");\n        zkController.startReplicationFromLeader(coreName, false);\n        log.info(\"Registering as Active after recovery.\");\n        try {\n          zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n        } catch (Exception e) {\n          log.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n          successfulRecovery = false;\n        }\n        \n        if (successfulRecovery) {\n          close = true;\n          recoveryListener.recovered();\n        }\n      }\n    }\n\n    if (!successfulRecovery) {\n      // lets pause for a moment and we need to try again...\n      // TODO: we don't want to retry for some problems?\n      // Or do a fall off retry...\n      try {\n\n        if (isClosed()) {\n          log.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n        \n        log.error(\"Recovery failed - trying again... (\" + retries + \")\");\n        \n        retries++;\n        if (retries >= maxRetries) {\n          SolrException.log(log, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n          try {\n            recoveryFailed(core, zkController, baseUrl, coreZkNodeName, core.getCoreDescriptor());\n          } catch (Exception e) {\n            SolrException.log(log, \"Could not publish that recovery failed\", e);\n          }\n          break;\n        }\n      } catch (Exception e) {\n        SolrException.log(log, \"An error has occurred during recovery\", e);\n      }\n\n      try {\n        // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n        // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result\n        // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n        // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n        int loopCount = retries < 4 ? (int) Math.min(Math.pow(2, retries), 12) : 12;\n        log.info(\"Wait [{}] seconds before trying to recover again (attempt={})\",\n            TimeUnit.MILLISECONDS.toSeconds(loopCount * startingRecoveryDelayMilliSeconds), retries);\n        for (int i = 0; i < loopCount; i++) {\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break; // check if someone closed us\n          }\n          Thread.sleep(startingRecoveryDelayMilliSeconds);\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        log.warn(\"Recovery was interrupted.\", e);\n        close = true;\n      }\n    }\n\n  }\n  // We skip core.seedVersionBuckets(); We don't have a transaction log\n  log.info(\"Finished recovery process, successful=[{}]\", Boolean.toString(successfulRecovery));\n}\n\n","bugFix":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","ce75060aea8b539ea26382d0162679fba6151a9d","61c45e99cf6676da48f19d7511c73712ad39402b"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","sourceNew":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n    // if (core.getUpdateHandler().getUpdateLog() != null) {\n    // SolrException.log(log, \"'replicate-only' recovery strategy should only be used if no update logs are present, but\n    // this core has one: \"\n    // + core.getUpdateHandler().getUpdateLog());\n    // return;\n    // }\n    while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or\n                                                                                            // it will close channels\n                                                                                            // though\n      try {\n        CloudDescriptor cloudDesc = this.coreDescriptor.getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n        final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n        String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n        boolean isLeader = leaderUrl.equals(ourUrl); // TODO: We can probably delete most of this code if we say this\n                                                     // strategy can only be used for pull replicas\n        if (isLeader && !cloudDesc.isLeader()) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n        }\n        if (cloudDesc.isLeader()) {\n          assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n          // we are now the leader - no one else must have been suitable\n          log.warn(\"We have not yet recovered - but we are now the leader!\");\n          log.info(\"Finished recovery process.\");\n          zkController.publish(this.coreDescriptor, Replica.State.ACTIVE);\n          return;\n        }\n\n        log.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n            ourUrl);\n        zkController.publish(this.coreDescriptor, Replica.State.RECOVERING);\n\n        if (isClosed()) {\n          log.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n        log.info(\"Starting Replication Recovery.\");\n\n        try {\n          log.info(\"Stopping background replicate from leader process\");\n          zkController.stopReplicationFromLeader(coreName);\n          replicate(zkController.getNodeName(), core, leaderprops);\n\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break;\n          }\n\n          log.info(\"Replication Recovery was successful.\");\n          successfulRecovery = true;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error while trying to recover\", e);\n        }\n\n      } catch (Exception e) {\n        SolrException.log(log, \"Error while trying to recover. core=\" + coreName, e);\n      } finally {\n        if (successfulRecovery) {\n          log.info(\"Restaring background replicate from leader process\");\n          zkController.startReplicationFromLeader(coreName, false);\n          log.info(\"Registering as Active after recovery.\");\n          try {\n            zkController.publish(this.coreDescriptor, Replica.State.ACTIVE);\n          } catch (Exception e) {\n            log.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n            successfulRecovery = false;\n          }\n\n          if (successfulRecovery) {\n            close = true;\n            recoveryListener.recovered();\n          }\n        }\n      }\n\n      if (!successfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break;\n          }\n\n          log.error(\"Recovery failed - trying again... (\" + retries + \")\");\n\n          retries++;\n          if (retries >= maxRetries) {\n            SolrException.log(log, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n            try {\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName, this.coreDescriptor);\n            } catch (Exception e) {\n              SolrException.log(log, \"Could not publish that recovery failed\", e);\n            }\n            break;\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"An error has occurred during recovery\", e);\n        }\n\n        try {\n          // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n          // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result\n          // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n          // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n          int loopCount = retries < 4 ? (int) Math.min(Math.pow(2, retries), 12) : 12;\n          log.info(\"Wait [{}] seconds before trying to recover again (attempt={})\",\n              TimeUnit.MILLISECONDS.toSeconds(loopCount * startingRecoveryDelayMilliSeconds), retries);\n          for (int i = 0; i < loopCount; i++) {\n            if (isClosed()) {\n              log.info(\"Recovery for core {} has been closed\", core.getName());\n              break; // check if someone closed us\n            }\n            Thread.sleep(startingRecoveryDelayMilliSeconds);\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted.\", e);\n          close = true;\n        }\n      }\n\n    }\n    // We skip core.seedVersionBuckets(); We don't have a transaction log\n    log.info(\"Finished recovery process, successful=[{}]\", Boolean.toString(successfulRecovery));\n  }\n\n","sourceOld":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n//  if (core.getUpdateHandler().getUpdateLog() != null) {\n//    SolrException.log(log, \"'replicate-only' recovery strategy should only be used if no update logs are present, but this core has one: \"\n//        + core.getUpdateHandler().getUpdateLog());\n//    return;\n//  }\n    while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or it will close channels though\n      try {\n        CloudDescriptor cloudDesc = core.getCoreDescriptor().getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n        final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n        String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n        boolean isLeader = leaderUrl.equals(ourUrl); //TODO: We can probably delete most of this code if we say this strategy can only be used for pull replicas\n        if (isLeader && !cloudDesc.isLeader()) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n        }\n        if (cloudDesc.isLeader()) {\n          assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n          // we are now the leader - no one else must have been suitable\n          log.warn(\"We have not yet recovered - but we are now the leader!\");\n          log.info(\"Finished recovery process.\");\n          zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n          return;\n        }\n\n\n        log.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n            ourUrl);\n        zkController.publish(core.getCoreDescriptor(), Replica.State.RECOVERING);\n\n        if (isClosed()) {\n          log.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n        log.info(\"Starting Replication Recovery.\");\n\n        try {\n          log.info(\"Stopping background replicate from leader process\");\n          zkController.stopReplicationFromLeader(coreName);\n          replicate(zkController.getNodeName(), core, leaderprops);\n\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break;\n          }\n\n          log.info(\"Replication Recovery was successful.\");\n          successfulRecovery = true;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error while trying to recover\", e);\n        }\n\n      } catch (Exception e) {\n        SolrException.log(log, \"Error while trying to recover. core=\" + coreName, e);\n      } finally {\n        if (successfulRecovery) {\n          log.info(\"Restaring background replicate from leader process\");\n          zkController.startReplicationFromLeader(coreName, false);\n          log.info(\"Registering as Active after recovery.\");\n          try {\n            zkController.publish(core.getCoreDescriptor(), Replica.State.ACTIVE);\n          } catch (Exception e) {\n            log.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n            successfulRecovery = false;\n          }\n\n          if (successfulRecovery) {\n            close = true;\n            recoveryListener.recovered();\n          }\n        }\n      }\n\n      if (!successfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break;\n          }\n\n          log.error(\"Recovery failed - trying again... (\" + retries + \")\");\n\n          retries++;\n          if (retries >= maxRetries) {\n            SolrException.log(log, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n            try {\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName, core.getCoreDescriptor());\n            } catch (Exception e) {\n              SolrException.log(log, \"Could not publish that recovery failed\", e);\n            }\n            break;\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"An error has occurred during recovery\", e);\n        }\n\n        try {\n          // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n          // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result\n          // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n          // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n          int loopCount = retries < 4 ? (int) Math.min(Math.pow(2, retries), 12) : 12;\n          log.info(\"Wait [{}] seconds before trying to recover again (attempt={})\",\n              TimeUnit.MILLISECONDS.toSeconds(loopCount * startingRecoveryDelayMilliSeconds), retries);\n          for (int i = 0; i < loopCount; i++) {\n            if (isClosed()) {\n              log.info(\"Recovery for core {} has been closed\", core.getName());\n              break; // check if someone closed us\n            }\n            Thread.sleep(startingRecoveryDelayMilliSeconds);\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted.\", e);\n          close = true;\n        }\n      }\n\n    }\n    // We skip core.seedVersionBuckets(); We don't have a transaction log\n    log.info(\"Finished recovery process, successful=[{}]\", Boolean.toString(successfulRecovery));\n  }\n\n","bugFix":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","420b2cd54774495de0bb67f068f5231f3da5e494","61c45e99cf6676da48f19d7511c73712ad39402b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f094c7572a69662d1c30498ccea3852e3d8705b","date":1579198427,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","sourceNew":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n    // if (core.getUpdateHandler().getUpdateLog() != null) {\n    // SolrException.log(log, \"'replicate-only' recovery strategy should only be used if no update logs are present, but\n    // this core has one: \"\n    // + core.getUpdateHandler().getUpdateLog());\n    // return;\n    // }\n    while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or\n                                                                                            // it will close channels\n                                                                                            // though\n      try {\n        CloudDescriptor cloudDesc = this.coreDescriptor.getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n        final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n        String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n        boolean isLeader = leaderUrl.equals(ourUrl); // TODO: We can probably delete most of this code if we say this\n                                                     // strategy can only be used for pull replicas\n        if (isLeader && !cloudDesc.isLeader()) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n        }\n        if (cloudDesc.isLeader()) {\n          assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n          // we are now the leader - no one else must have been suitable\n          log.warn(\"We have not yet recovered - but we are now the leader!\");\n          log.info(\"Finished recovery process.\");\n          zkController.publish(this.coreDescriptor, Replica.State.ACTIVE);\n          return;\n        }\n\n        log.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n            ourUrl);\n        zkController.publish(this.coreDescriptor, Replica.State.RECOVERING);\n\n        if (isClosed()) {\n          log.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n        log.info(\"Starting Replication Recovery.\");\n\n        try {\n          log.info(\"Stopping background replicate from leader process\");\n          zkController.stopReplicationFromLeader(coreName);\n          replicate(zkController.getNodeName(), core, leaderprops);\n\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break;\n          }\n\n          log.info(\"Replication Recovery was successful.\");\n          successfulRecovery = true;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error while trying to recover\", e);\n        }\n\n      } catch (Exception e) {\n        SolrException.log(log, \"Error while trying to recover. core=\" + coreName, e);\n      } finally {\n        if (successfulRecovery) {\n          log.info(\"Restarting background replicate from leader process\");\n          zkController.startReplicationFromLeader(coreName, false);\n          log.info(\"Registering as Active after recovery.\");\n          try {\n            zkController.publish(this.coreDescriptor, Replica.State.ACTIVE);\n          } catch (Exception e) {\n            log.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n            successfulRecovery = false;\n          }\n\n          if (successfulRecovery) {\n            close = true;\n            recoveryListener.recovered();\n          }\n        }\n      }\n\n      if (!successfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break;\n          }\n\n          log.error(\"Recovery failed - trying again... (\" + retries + \")\");\n\n          retries++;\n          if (retries >= maxRetries) {\n            SolrException.log(log, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n            try {\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName, this.coreDescriptor);\n            } catch (Exception e) {\n              SolrException.log(log, \"Could not publish that recovery failed\", e);\n            }\n            break;\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"An error has occurred during recovery\", e);\n        }\n\n        try {\n          // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n          // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result\n          // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n          // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n          int loopCount = retries < 4 ? (int) Math.min(Math.pow(2, retries), 12) : 12;\n          log.info(\"Wait [{}] seconds before trying to recover again (attempt={})\",\n              TimeUnit.MILLISECONDS.toSeconds(loopCount * startingRecoveryDelayMilliSeconds), retries);\n          for (int i = 0; i < loopCount; i++) {\n            if (isClosed()) {\n              log.info(\"Recovery for core {} has been closed\", core.getName());\n              break; // check if someone closed us\n            }\n            Thread.sleep(startingRecoveryDelayMilliSeconds);\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted.\", e);\n          close = true;\n        }\n      }\n\n    }\n    // We skip core.seedVersionBuckets(); We don't have a transaction log\n    log.info(\"Finished recovery process, successful=[{}]\", Boolean.toString(successfulRecovery));\n  }\n\n","sourceOld":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n    // if (core.getUpdateHandler().getUpdateLog() != null) {\n    // SolrException.log(log, \"'replicate-only' recovery strategy should only be used if no update logs are present, but\n    // this core has one: \"\n    // + core.getUpdateHandler().getUpdateLog());\n    // return;\n    // }\n    while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or\n                                                                                            // it will close channels\n                                                                                            // though\n      try {\n        CloudDescriptor cloudDesc = this.coreDescriptor.getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n        final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n        String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n        boolean isLeader = leaderUrl.equals(ourUrl); // TODO: We can probably delete most of this code if we say this\n                                                     // strategy can only be used for pull replicas\n        if (isLeader && !cloudDesc.isLeader()) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n        }\n        if (cloudDesc.isLeader()) {\n          assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n          // we are now the leader - no one else must have been suitable\n          log.warn(\"We have not yet recovered - but we are now the leader!\");\n          log.info(\"Finished recovery process.\");\n          zkController.publish(this.coreDescriptor, Replica.State.ACTIVE);\n          return;\n        }\n\n        log.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n            ourUrl);\n        zkController.publish(this.coreDescriptor, Replica.State.RECOVERING);\n\n        if (isClosed()) {\n          log.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n        log.info(\"Starting Replication Recovery.\");\n\n        try {\n          log.info(\"Stopping background replicate from leader process\");\n          zkController.stopReplicationFromLeader(coreName);\n          replicate(zkController.getNodeName(), core, leaderprops);\n\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break;\n          }\n\n          log.info(\"Replication Recovery was successful.\");\n          successfulRecovery = true;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error while trying to recover\", e);\n        }\n\n      } catch (Exception e) {\n        SolrException.log(log, \"Error while trying to recover. core=\" + coreName, e);\n      } finally {\n        if (successfulRecovery) {\n          log.info(\"Restaring background replicate from leader process\");\n          zkController.startReplicationFromLeader(coreName, false);\n          log.info(\"Registering as Active after recovery.\");\n          try {\n            zkController.publish(this.coreDescriptor, Replica.State.ACTIVE);\n          } catch (Exception e) {\n            log.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n            successfulRecovery = false;\n          }\n\n          if (successfulRecovery) {\n            close = true;\n            recoveryListener.recovered();\n          }\n        }\n      }\n\n      if (!successfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break;\n          }\n\n          log.error(\"Recovery failed - trying again... (\" + retries + \")\");\n\n          retries++;\n          if (retries >= maxRetries) {\n            SolrException.log(log, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n            try {\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName, this.coreDescriptor);\n            } catch (Exception e) {\n              SolrException.log(log, \"Could not publish that recovery failed\", e);\n            }\n            break;\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"An error has occurred during recovery\", e);\n        }\n\n        try {\n          // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n          // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result\n          // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n          // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n          int loopCount = retries < 4 ? (int) Math.min(Math.pow(2, retries), 12) : 12;\n          log.info(\"Wait [{}] seconds before trying to recover again (attempt={})\",\n              TimeUnit.MILLISECONDS.toSeconds(loopCount * startingRecoveryDelayMilliSeconds), retries);\n          for (int i = 0; i < loopCount; i++) {\n            if (isClosed()) {\n              log.info(\"Recovery for core {} has been closed\", core.getName());\n              break; // check if someone closed us\n            }\n            Thread.sleep(startingRecoveryDelayMilliSeconds);\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted.\", e);\n          close = true;\n        }\n      }\n\n    }\n    // We skip core.seedVersionBuckets(); We don't have a transaction log\n    log.info(\"Finished recovery process, successful=[{}]\", Boolean.toString(successfulRecovery));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4957cde742defe6db19689abdc267c5d948066","date":1587990850,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy#doReplicateOnlyRecovery(SolrCore).mjava","sourceNew":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n    // if (core.getUpdateHandler().getUpdateLog() != null) {\n    // SolrException.log(log, \"'replicate-only' recovery strategy should only be used if no update logs are present, but\n    // this core has one: \"\n    // + core.getUpdateHandler().getUpdateLog());\n    // return;\n    // }\n    while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or\n                                                                                            // it will close channels\n                                                                                            // though\n      try {\n        CloudDescriptor cloudDesc = this.coreDescriptor.getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n        final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n        String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n        boolean isLeader = leaderUrl.equals(ourUrl); // TODO: We can probably delete most of this code if we say this\n                                                     // strategy can only be used for pull replicas\n        if (isLeader && !cloudDesc.isLeader()) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n        }\n        if (cloudDesc.isLeader()) {\n          assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n          // we are now the leader - no one else must have been suitable\n          log.warn(\"We have not yet recovered - but we are now the leader!\");\n          log.info(\"Finished recovery process.\");\n          zkController.publish(this.coreDescriptor, Replica.State.ACTIVE);\n          return;\n        }\n\n        if (log.isInfoEnabled()) {\n          log.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n              ourUrl);\n        }\n        zkController.publish(this.coreDescriptor, Replica.State.RECOVERING);\n\n        if (isClosed()) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n          }\n          break;\n        }\n        log.info(\"Starting Replication Recovery.\");\n\n        try {\n          log.info(\"Stopping background replicate from leader process\");\n          zkController.stopReplicationFromLeader(coreName);\n          replicate(zkController.getNodeName(), core, leaderprops);\n\n          if (isClosed()) {\n            if (log.isInfoEnabled()) {\n              log.info(\"Recovery for core {} has been closed\", core.getName());\n            }\n            break;\n          }\n\n          log.info(\"Replication Recovery was successful.\");\n          successfulRecovery = true;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error while trying to recover\", e);\n        }\n\n      } catch (Exception e) {\n        SolrException.log(log, \"Error while trying to recover. core=\" + coreName, e);\n      } finally {\n        if (successfulRecovery) {\n          log.info(\"Restarting background replicate from leader process\");\n          zkController.startReplicationFromLeader(coreName, false);\n          log.info(\"Registering as Active after recovery.\");\n          try {\n            zkController.publish(this.coreDescriptor, Replica.State.ACTIVE);\n          } catch (Exception e) {\n            log.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n            successfulRecovery = false;\n          }\n\n          if (successfulRecovery) {\n            close = true;\n            recoveryListener.recovered();\n          }\n        }\n      }\n\n      if (!successfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n\n          if (isClosed()) {\n            if (log.isInfoEnabled()) {\n              log.info(\"Recovery for core {} has been closed\", core.getName());\n            }\n            break;\n          }\n\n          log.error(\"Recovery failed - trying again... ({})\", retries);\n\n          retries++;\n          if (retries >= maxRetries) {\n            SolrException.log(log, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n            try {\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName, this.coreDescriptor);\n            } catch (Exception e) {\n              SolrException.log(log, \"Could not publish that recovery failed\", e);\n            }\n            break;\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"An error has occurred during recovery\", e);\n        }\n\n        try {\n          // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n          // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result\n          // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n          // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n          int loopCount = retries < 4 ? (int) Math.min(Math.pow(2, retries), 12) : 12;\n          if (log.isInfoEnabled()) {\n            log.info(\"Wait [{}] seconds before trying to recover again (attempt={})\",\n                TimeUnit.MILLISECONDS.toSeconds(loopCount * startingRecoveryDelayMilliSeconds), retries);\n          }\n          for (int i = 0; i < loopCount; i++) {\n            if (isClosed()) {\n              if (log.isInfoEnabled()) {\n                log.info(\"Recovery for core {} has been closed\", core.getName());\n              }\n              break; // check if someone closed us\n            }\n            Thread.sleep(startingRecoveryDelayMilliSeconds);\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted.\", e);\n          close = true;\n        }\n      }\n\n    }\n    // We skip core.seedVersionBuckets(); We don't have a transaction log\n    log.info(\"Finished recovery process, successful=[{}]\", successfulRecovery);\n  }\n\n","sourceOld":"  final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedException {\n    boolean successfulRecovery = false;\n\n    // if (core.getUpdateHandler().getUpdateLog() != null) {\n    // SolrException.log(log, \"'replicate-only' recovery strategy should only be used if no update logs are present, but\n    // this core has one: \"\n    // + core.getUpdateHandler().getUpdateLog());\n    // return;\n    // }\n    while (!successfulRecovery && !Thread.currentThread().isInterrupted() && !isClosed()) { // don't use interruption or\n                                                                                            // it will close channels\n                                                                                            // though\n      try {\n        CloudDescriptor cloudDesc = this.coreDescriptor.getCloudDescriptor();\n        ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n        final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n        final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n\n        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n\n        String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n\n        boolean isLeader = leaderUrl.equals(ourUrl); // TODO: We can probably delete most of this code if we say this\n                                                     // strategy can only be used for pull replicas\n        if (isLeader && !cloudDesc.isLeader()) {\n          throw new SolrException(ErrorCode.SERVER_ERROR, \"Cloud state still says we are leader.\");\n        }\n        if (cloudDesc.isLeader()) {\n          assert cloudDesc.getReplicaType() != Replica.Type.PULL;\n          // we are now the leader - no one else must have been suitable\n          log.warn(\"We have not yet recovered - but we are now the leader!\");\n          log.info(\"Finished recovery process.\");\n          zkController.publish(this.coreDescriptor, Replica.State.ACTIVE);\n          return;\n        }\n\n        log.info(\"Publishing state of core [{}] as recovering, leader is [{}] and I am [{}]\", core.getName(), leaderUrl,\n            ourUrl);\n        zkController.publish(this.coreDescriptor, Replica.State.RECOVERING);\n\n        if (isClosed()) {\n          log.info(\"Recovery for core {} has been closed\", core.getName());\n          break;\n        }\n        log.info(\"Starting Replication Recovery.\");\n\n        try {\n          log.info(\"Stopping background replicate from leader process\");\n          zkController.stopReplicationFromLeader(coreName);\n          replicate(zkController.getNodeName(), core, leaderprops);\n\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break;\n          }\n\n          log.info(\"Replication Recovery was successful.\");\n          successfulRecovery = true;\n        } catch (Exception e) {\n          SolrException.log(log, \"Error while trying to recover\", e);\n        }\n\n      } catch (Exception e) {\n        SolrException.log(log, \"Error while trying to recover. core=\" + coreName, e);\n      } finally {\n        if (successfulRecovery) {\n          log.info(\"Restarting background replicate from leader process\");\n          zkController.startReplicationFromLeader(coreName, false);\n          log.info(\"Registering as Active after recovery.\");\n          try {\n            zkController.publish(this.coreDescriptor, Replica.State.ACTIVE);\n          } catch (Exception e) {\n            log.error(\"Could not publish as ACTIVE after succesful recovery\", e);\n            successfulRecovery = false;\n          }\n\n          if (successfulRecovery) {\n            close = true;\n            recoveryListener.recovered();\n          }\n        }\n      }\n\n      if (!successfulRecovery) {\n        // lets pause for a moment and we need to try again...\n        // TODO: we don't want to retry for some problems?\n        // Or do a fall off retry...\n        try {\n\n          if (isClosed()) {\n            log.info(\"Recovery for core {} has been closed\", core.getName());\n            break;\n          }\n\n          log.error(\"Recovery failed - trying again... (\" + retries + \")\");\n\n          retries++;\n          if (retries >= maxRetries) {\n            SolrException.log(log, \"Recovery failed - max retries exceeded (\" + retries + \").\");\n            try {\n              recoveryFailed(core, zkController, baseUrl, coreZkNodeName, this.coreDescriptor);\n            } catch (Exception e) {\n              SolrException.log(log, \"Could not publish that recovery failed\", e);\n            }\n            break;\n          }\n        } catch (Exception e) {\n          SolrException.log(log, \"An error has occurred during recovery\", e);\n        }\n\n        try {\n          // Wait an exponential interval between retries, start at 5 seconds and work up to a minute.\n          // If we're at attempt >= 4, there's no point computing pow(2, retries) because the result\n          // will always be the minimum of the two (12). Since we sleep at 5 seconds sub-intervals in\n          // order to check if we were closed, 12 is chosen as the maximum loopCount (5s * 12 = 1m).\n          int loopCount = retries < 4 ? (int) Math.min(Math.pow(2, retries), 12) : 12;\n          log.info(\"Wait [{}] seconds before trying to recover again (attempt={})\",\n              TimeUnit.MILLISECONDS.toSeconds(loopCount * startingRecoveryDelayMilliSeconds), retries);\n          for (int i = 0; i < loopCount; i++) {\n            if (isClosed()) {\n              log.info(\"Recovery for core {} has been closed\", core.getName());\n              break; // check if someone closed us\n            }\n            Thread.sleep(startingRecoveryDelayMilliSeconds);\n          }\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          log.warn(\"Recovery was interrupted.\", e);\n          close = true;\n        }\n      }\n\n    }\n    // We skip core.seedVersionBuckets(); We don't have a transaction log\n    log.info(\"Finished recovery process, successful=[{}]\", Boolean.toString(successfulRecovery));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","61c45e99cf6676da48f19d7511c73712ad39402b"],"61c45e99cf6676da48f19d7511c73712ad39402b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["420b2cd54774495de0bb67f068f5231f3da5e494"],"420b2cd54774495de0bb67f068f5231f3da5e494":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"4f094c7572a69662d1c30498ccea3852e3d8705b":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"ce75060aea8b539ea26382d0162679fba6151a9d":["61c45e99cf6676da48f19d7511c73712ad39402b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad4957cde742defe6db19689abdc267c5d948066":["4f094c7572a69662d1c30498ccea3852e3d8705b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ad4957cde742defe6db19689abdc267c5d948066"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["ce75060aea8b539ea26382d0162679fba6151a9d"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","ce75060aea8b539ea26382d0162679fba6151a9d"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["4f094c7572a69662d1c30498ccea3852e3d8705b"],"420b2cd54774495de0bb67f068f5231f3da5e494":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e9017cf144952056066919f1ebc7897ff9bd71b1","61c45e99cf6676da48f19d7511c73712ad39402b"],"4f094c7572a69662d1c30498ccea3852e3d8705b":["ad4957cde742defe6db19689abdc267c5d948066"],"ce75060aea8b539ea26382d0162679fba6151a9d":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"ad4957cde742defe6db19689abdc267c5d948066":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["420b2cd54774495de0bb67f068f5231f3da5e494"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}