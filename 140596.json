{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/PolyFitEvaluator#doWork(Object...).mjava","commits":[{"id":"88db5ca967adae8f7da7df4fd8480da635bbf01a","date":1507140133,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/PolyFitEvaluator#doWork(Object...).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfit function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      //Only the y values passed\n\n      y = ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      // x, y and degree passed\n\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        // x and y passed\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n      } else {\n        // y and degree passed\n        y = ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d7859b8e6a469429413db808a609e8468be14c03","date":1507222263,"type":0,"author":"tballison","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/PolyFitEvaluator#doWork(Object...).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfit function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      //Only the y values passed\n\n      y = ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      // x, y and degree passed\n\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        // x and y passed\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n      } else {\n        // y and degree passed\n        y = ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54","date":1512439781,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/PolyFitEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/PolyFitEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfit function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      //Only the y values passed\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      // x, y and degree passed\n\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        // x and y passed\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      } else {\n        // y and degree passed\n        y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfit function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      //Only the y values passed\n\n      y = ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      // x, y and degree passed\n\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        // x and y passed\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n      } else {\n        // y and degree passed\n        y = ((List) first).stream().mapToDouble(value -> ((BigDecimal) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"abdd6d7eec99bf2099b46b3389307036ed6d1a0d","date":1533652313,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/PolyFitEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/PolyFitEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfit function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      //Only the y values passed\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      // x, y and degree passed\n\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        // x and y passed\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      } else {\n        // y and degree passed\n        y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n\n    VectorFunction vec = new VectorFunction(pf, list);\n    vec.addToContext(\"x\", x);\n    vec.addToContext(\"y\", y);\n\n    return vec;\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfit function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      //Only the y values passed\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      // x, y and degree passed\n\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        // x and y passed\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      } else {\n        // y and degree passed\n        y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n    return list;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885","date":1591579911,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/PolyFitEvaluator#doWork(Object...).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/eval/PolyFitEvaluator#doWork(Object...).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfit function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      //Only the y values passed\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      // x, y and degree passed\n\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        // x and y passed\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      } else {\n        // y and degree passed\n        y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n\n    VectorFunction vec = new VectorFunction(pf, list);\n    vec.addToContext(\"x\", x);\n    vec.addToContext(\"y\", y);\n\n    return vec;\n  }\n\n","sourceOld":"  @Override\n  public Object doWork(Object... objects) throws IOException{\n\n    if(objects.length > 3) {\n      throw new IOException(\"polyfit function takes a maximum of 3 arguments.\");\n    }\n\n    Object first = objects[0];\n\n    double[] x = null;\n    double[] y = null;\n    int degree = 3;\n\n    if(objects.length == 1) {\n      //Only the y values passed\n\n      y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      x = new double[y.length];\n      for(int i=0; i<y.length; i++) {\n        x[i] = i;\n      }\n\n    } else if(objects.length == 3) {\n      // x, y and degree passed\n\n      Object second = objects[1];\n      x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      degree = ((Number)objects[2]).intValue();\n    } else if(objects.length == 2) {\n      if(objects[1] instanceof List) {\n        // x and y passed\n        Object second = objects[1];\n        x = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        y = ((List) second).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n      } else {\n        // y and degree passed\n        y = ((List) first).stream().mapToDouble(value -> ((Number) value).doubleValue()).toArray();\n        x = new double[y.length];\n        for(int i=0; i<y.length; i++) {\n          x[i] = i;\n        }\n\n        degree = ((Number)objects[1]).intValue();\n      }\n    }\n\n    PolynomialCurveFitter curveFitter = PolynomialCurveFitter.create(degree);\n    WeightedObservedPoints points = new WeightedObservedPoints();\n    for(int i=0; i<x.length; i++) {\n      points.add(x[i], y[i]);\n    }\n\n    double[] coef = curveFitter.fit(points.toList());\n    PolynomialFunction pf = new PolynomialFunction(coef);\n\n    List list = new ArrayList();\n    for(double xvalue : x) {\n      double yvalue= pf.value(xvalue);\n      list.add(yvalue);\n    }\n\n\n    VectorFunction vec = new VectorFunction(pf, list);\n    vec.addToContext(\"x\", x);\n    vec.addToContext(\"y\", y);\n\n    return vec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885":["abdd6d7eec99bf2099b46b3389307036ed6d1a0d"],"d7859b8e6a469429413db808a609e8468be14c03":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","88db5ca967adae8f7da7df4fd8480da635bbf01a"],"bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54":["88db5ca967adae8f7da7df4fd8480da635bbf01a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"88db5ca967adae8f7da7df4fd8480da635bbf01a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"abdd6d7eec99bf2099b46b3389307036ed6d1a0d":["bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885"]},"commit2Childs":{"df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d7859b8e6a469429413db808a609e8468be14c03":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d7859b8e6a469429413db808a609e8468be14c03","88db5ca967adae8f7da7df4fd8480da635bbf01a"],"bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54":["abdd6d7eec99bf2099b46b3389307036ed6d1a0d"],"88db5ca967adae8f7da7df4fd8480da635bbf01a":["d7859b8e6a469429413db808a609e8468be14c03","bbe7f5e9d90420c7fc8cd235dd8fb33fa9befe54"],"abdd6d7eec99bf2099b46b3389307036ed6d1a0d":["df1b3ced2f2a6c2031f5a5b0cfff01f7ae017885"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d7859b8e6a469429413db808a609e8468be14c03","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}