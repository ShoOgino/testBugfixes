{"path":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","commits":[{"id":"c72f6f0907682b825869d7878ba72d8259dabc91","date":1480192617,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"/dev/null","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"2\", \"3\", \"1\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"1\", \"2\", \"3\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"2\", \"3\", \"1\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"1\", \"2\", \"3\", \"4\"});\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0e7ddedf744427dad36befd57a11188002f735f9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"949bde462bfd00409852e22bedf12f7b18868909","date":1480227090,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"2\", \"3\", \"1\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"1\", \"2\", \"3\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"2\", \"3\", \"1\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"1\", \"2\", \"3\", \"4\"});\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"/dev/null","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"931cb705e783c7f07cdb110a0cb03bad79fe1b2b","date":1480386986,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"/dev/null","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e7ddedf744427dad36befd57a11188002f735f9","date":1481407395,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":["c72f6f0907682b825869d7878ba72d8259dabc91"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab2f54aa3920f7b4a9b92e45334237f6427b20d3","date":1522384863,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 26-Mar-2018\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acfe8d3b837b6b66eaddf114bb99cf9e2257764d","date":1522406637,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 26-Mar-2018\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1c374690db69470f6aa4bffc43dcacf1f4e3e49","date":1529007399,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  // 12-Jun-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 26-Mar-2018\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 26-Mar-2018\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  // 12-Jun-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 26-Mar-2018\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 26-Mar-2018\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  // 12-Jun-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 26-Mar-2018\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 26-Mar-2018\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"268f5a06c7ea42fbf9c9a25b7e9d33cf083d83e2","date":1544401888,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  // 12-Jun-2018 @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 26-Mar-2018\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab3edb4bdcf1695b3c43f8584d7473f9516a34e4","date":1550862271,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  //@AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4","date":1551083645,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  //@AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1bf90b7e397312bd3e0bdc880c43b1f32ca30cf","date":1555648681,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  //@AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    Solr11035BandAid(client, COLLECTION, \"id\", 4, \"*:*\");\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  //@AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    \n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c344401c324a00bc10cacfb90598738235a4decb","date":1556461561,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    Solr11035BandAid(client, COLLECTION, \"id\", 4, \"*:*\");\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  //@AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    Solr11035BandAid(client, COLLECTION, \"id\", 4, \"*:*\");\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d1b2d0c6ded13ab96ad6447c1a48eb58f8a377c","date":1557431147,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    Solr11035BandAid(client, COLLECTION, \"id\", 4, \"*:*\", \"DocValuesNotINdexedTest.testGroupSorting\");\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    Solr11035BandAid(client, COLLECTION, \"id\", 4, \"*:*\");\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":null,"bugIntro":["3821108e77348b1cdb6baf5422727f926ba7af61"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3821108e77348b1cdb6baf5422727f926ba7af61","date":1582300636,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/DocValuesNotIndexedTest#testGroupingSorting().mjava","sourceNew":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","sourceOld":"  // We should be able to sort thing with missing first/last and that are _NOT_ present at all on one server.\n  @Test\n  public void testGroupingSorting() throws IOException, SolrServerException {\n    CloudSolrClient client = cluster.getSolrClient();\n\n    // The point of these is to have at least one shard w/o the value. \n    // While getting values for each of these fields starts _out_ random, each successive\n    // _value_ increases.\n    List<SolrInputDocument> docs = new ArrayList<>(3);\n    docs.add(makeGSDoc(2, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(1, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    docs.add(makeGSDoc(3, fieldsToTestGroupSortFirst, fieldsToTestGroupSortLast));\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", 4);\n    docs.add(doc);\n\n    new UpdateRequest()\n        .add(docs)\n        .commit(client, COLLECTION);\n    Solr11035BandAid(client, COLLECTION, \"id\", 4, \"*:*\", \"DocValuesNotINdexedTest.testGroupSorting\");\n\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortFirst, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"asc\", new String[]{\"4\", \"2\", \"1\", \"3\"}, new String[]{\"4\", \"1\", \"2\", \"3\"});\n    checkSortOrder(client, fieldsToTestGroupSortLast, \"desc\", new String[]{\"3\", \"1\", \"2\", \"4\"}, new String[]{\"2\", \"3\", \"1\", \"4\"});\n\n  }\n\n","bugFix":["9d1b2d0c6ded13ab96ad6447c1a48eb58f8a377c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3821108e77348b1cdb6baf5422727f926ba7af61":["9d1b2d0c6ded13ab96ad6447c1a48eb58f8a377c"],"9d1b2d0c6ded13ab96ad6447c1a48eb58f8a377c":["c344401c324a00bc10cacfb90598738235a4decb"],"949bde462bfd00409852e22bedf12f7b18868909":["c72f6f0907682b825869d7878ba72d8259dabc91"],"ab2f54aa3920f7b4a9b92e45334237f6427b20d3":["0e7ddedf744427dad36befd57a11188002f735f9"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d","a1c374690db69470f6aa4bffc43dcacf1f4e3e49"],"ab3edb4bdcf1695b3c43f8584d7473f9516a34e4":["268f5a06c7ea42fbf9c9a25b7e9d33cf083d83e2"],"727bb765ff2542275f6d31f67be18d7104bae148":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","949bde462bfd00409852e22bedf12f7b18868909"],"c72f6f0907682b825869d7878ba72d8259dabc91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b1bf90b7e397312bd3e0bdc880c43b1f32ca30cf":["0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"0e7ddedf744427dad36befd57a11188002f735f9":["931cb705e783c7f07cdb110a0cb03bad79fe1b2b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9856095f7afb5a607bf5e65077615ed91273508c":["727bb765ff2542275f6d31f67be18d7104bae148","0e7ddedf744427dad36befd57a11188002f735f9"],"931cb705e783c7f07cdb110a0cb03bad79fe1b2b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","949bde462bfd00409852e22bedf12f7b18868909"],"c344401c324a00bc10cacfb90598738235a4decb":["b1bf90b7e397312bd3e0bdc880c43b1f32ca30cf"],"268f5a06c7ea42fbf9c9a25b7e9d33cf083d83e2":["a1c374690db69470f6aa4bffc43dcacf1f4e3e49"],"acfe8d3b837b6b66eaddf114bb99cf9e2257764d":["0e7ddedf744427dad36befd57a11188002f735f9","ab2f54aa3920f7b4a9b92e45334237f6427b20d3"],"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4":["268f5a06c7ea42fbf9c9a25b7e9d33cf083d83e2","ab3edb4bdcf1695b3c43f8584d7473f9516a34e4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3821108e77348b1cdb6baf5422727f926ba7af61"],"a1c374690db69470f6aa4bffc43dcacf1f4e3e49":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d","a1c374690db69470f6aa4bffc43dcacf1f4e3e49"]},"commit2Childs":{"3821108e77348b1cdb6baf5422727f926ba7af61":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9d1b2d0c6ded13ab96ad6447c1a48eb58f8a377c":["3821108e77348b1cdb6baf5422727f926ba7af61"],"949bde462bfd00409852e22bedf12f7b18868909":["727bb765ff2542275f6d31f67be18d7104bae148","931cb705e783c7f07cdb110a0cb03bad79fe1b2b"],"ab2f54aa3920f7b4a9b92e45334237f6427b20d3":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"ab3edb4bdcf1695b3c43f8584d7473f9516a34e4":["0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"727bb765ff2542275f6d31f67be18d7104bae148":["9856095f7afb5a607bf5e65077615ed91273508c"],"c72f6f0907682b825869d7878ba72d8259dabc91":["949bde462bfd00409852e22bedf12f7b18868909"],"0e7ddedf744427dad36befd57a11188002f735f9":["ab2f54aa3920f7b4a9b92e45334237f6427b20d3","9856095f7afb5a607bf5e65077615ed91273508c","acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"b1bf90b7e397312bd3e0bdc880c43b1f32ca30cf":["c344401c324a00bc10cacfb90598738235a4decb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["727bb765ff2542275f6d31f67be18d7104bae148","c72f6f0907682b825869d7878ba72d8259dabc91","931cb705e783c7f07cdb110a0cb03bad79fe1b2b"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"931cb705e783c7f07cdb110a0cb03bad79fe1b2b":["0e7ddedf744427dad36befd57a11188002f735f9"],"c344401c324a00bc10cacfb90598738235a4decb":["9d1b2d0c6ded13ab96ad6447c1a48eb58f8a377c"],"acfe8d3b837b6b66eaddf114bb99cf9e2257764d":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","a1c374690db69470f6aa4bffc43dcacf1f4e3e49","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"268f5a06c7ea42fbf9c9a25b7e9d33cf083d83e2":["ab3edb4bdcf1695b3c43f8584d7473f9516a34e4","0d2d6c361b65277d72b2f3dd0f83b9721875e6b4"],"0d2d6c361b65277d72b2f3dd0f83b9721875e6b4":["b1bf90b7e397312bd3e0bdc880c43b1f32ca30cf"],"a1c374690db69470f6aa4bffc43dcacf1f4e3e49":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","268f5a06c7ea42fbf9c9a25b7e9d33cf083d83e2","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}