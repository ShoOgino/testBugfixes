{"path":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings(\"unchecked\") final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd9c9f83215f32164e7ac9a57342ffc418a5fcb0","date":1335879139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ebe14aae60589c9bb6423f3cce02d5f599e1540","date":1348361556,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    lastNode.isFinal = true;\n    lastNode.output = NO_OUTPUT;\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<T>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length == 0 || input.compareTo(lastInput) >= 0: \"inputs are added out of order lastInput=\" + lastInput + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length, input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.ints[pos1] != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":["ea8136d8c9f128223389b731b2affdeccdbf1af3","d4769bdea5a853f1841c485bc1fd9d79cb7022fc","5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e4563f34ffeedc07a91ffbd4bd829bdc4199dde2","date":1436467768,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** It's OK to add the same input twice in a row with\n   *  different outputs, as long as outputs impls the merge\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcb85e0b9bc3b04eccb9b0f54a53706c8ac0659f","date":1464187721,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final UnCompiledNode<T>[] next =\n        new UnCompiledNode[ArrayUtil.oversize(input.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(frontier, 0, next, 0, frontier.length);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":5,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FSTCompiler#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":5,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FSTCompiler#add(IntsRef,T).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Builder#add(IntsRef,T).mjava","sourceNew":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","sourceOld":"  /** Add the next input/output pair.  The provided input\n   *  must be sorted after the previous one according to\n   *  {@link IntsRef#compareTo}.  It's also OK to add the same\n   *  input twice in a row with different outputs, as long\n   *  as {@link Outputs} implements the {@link Outputs#merge}\n   *  method. Note that input is fully consumed after this\n   *  method is returned (so caller is free to reuse), but\n   *  output is not.  So if your outputs are changeable (eg\n   *  {@link ByteSequenceOutputs} or {@link\n   *  IntSequenceOutputs}) then you cannot reuse across\n   *  calls. */\n  public void add(IntsRef input, T output) throws IOException {\n    /*\n    if (DEBUG) {\n      BytesRef b = new BytesRef(input.length);\n      for(int x=0;x<input.length;x++) {\n        b.bytes[x] = (byte) input.ints[x];\n      }\n      b.length = input.length;\n      if (output == NO_OUTPUT) {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b);\n      } else {\n        System.out.println(\"\\nFST ADD: input=\" + toString(b) + \" \" + b + \" output=\" + fst.outputs.outputToString(output));\n      }\n    }\n    */\n\n    // De-dup NO_OUTPUT since it must be a singleton:\n    if (output.equals(NO_OUTPUT)) {\n      output = NO_OUTPUT;\n    }\n\n    assert lastInput.length() == 0 || input.compareTo(lastInput.get()) >= 0: \"inputs are added out of order lastInput=\" + lastInput.get() + \" vs input=\" + input;\n    assert validOutput(output);\n\n    //System.out.println(\"\\nadd: \" + input);\n    if (input.length == 0) {\n      // empty input: only allowed as first input.  we have\n      // to special case this because the packed FST\n      // format cannot represent the empty input since\n      // 'finalness' is stored on the incoming arc, not on\n      // the node\n      frontier[0].inputCount++;\n      frontier[0].isFinal = true;\n      fst.setEmptyOutput(output);\n      return;\n    }\n\n    // compare shared prefix length\n    int pos1 = 0;\n    int pos2 = input.offset;\n    final int pos1Stop = Math.min(lastInput.length(), input.length);\n    while(true) {\n      frontier[pos1].inputCount++;\n      //System.out.println(\"  incr \" + pos1 + \" ct=\" + frontier[pos1].inputCount + \" n=\" + frontier[pos1]);\n      if (pos1 >= pos1Stop || lastInput.intAt(pos1) != input.ints[pos2]) {\n        break;\n      }\n      pos1++;\n      pos2++;\n    }\n    final int prefixLenPlus1 = pos1+1;\n      \n    if (frontier.length < input.length+1) {\n      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);\n      for(int idx=frontier.length;idx<next.length;idx++) {\n        next[idx] = new UnCompiledNode<>(this, idx);\n      }\n      frontier = next;\n    }\n\n    // minimize/compile states from previous input's\n    // orphan'd suffix\n    freezeTail(prefixLenPlus1);\n\n    // init tail states for current input\n    for(int idx=prefixLenPlus1;idx<=input.length;idx++) {\n      frontier[idx-1].addArc(input.ints[input.offset + idx - 1],\n                             frontier[idx]);\n      frontier[idx].inputCount++;\n    }\n\n    final UnCompiledNode<T> lastNode = frontier[input.length];\n    if (lastInput.length() != input.length || prefixLenPlus1 != input.length + 1) {\n      lastNode.isFinal = true;\n      lastNode.output = NO_OUTPUT;\n    }\n\n    // push conflicting outputs forward, only as far as\n    // needed\n    for(int idx=1;idx<prefixLenPlus1;idx++) {\n      final UnCompiledNode<T> node = frontier[idx];\n      final UnCompiledNode<T> parentNode = frontier[idx-1];\n\n      final T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - 1]);\n      assert validOutput(lastOutput);\n\n      final T commonOutputPrefix;\n      final T wordSuffix;\n\n      if (lastOutput != NO_OUTPUT) {\n        commonOutputPrefix = fst.outputs.common(output, lastOutput);\n        assert validOutput(commonOutputPrefix);\n        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);\n        assert validOutput(wordSuffix);\n        parentNode.setLastOutput(input.ints[input.offset + idx - 1], commonOutputPrefix);\n        node.prependOutput(wordSuffix);\n      } else {\n        commonOutputPrefix = wordSuffix = NO_OUTPUT;\n      }\n\n      output = fst.outputs.subtract(output, commonOutputPrefix);\n      assert validOutput(output);\n    }\n\n    if (lastInput.length() == input.length && prefixLenPlus1 == 1+input.length) {\n      // same input more than 1 time in a row, mapping to\n      // multiple outputs\n      lastNode.output = fst.outputs.merge(lastNode.output, output);\n    } else {\n      // this new arc is private to this new input; set its\n      // arc output to the leftover output:\n      frontier[prefixLenPlus1-1].setLastOutput(input.ints[input.offset + prefixLenPlus1-1], output);\n    }\n\n    // save last input\n    lastInput.copyInts(input);\n\n    //System.out.println(\"  count[0]=\" + frontier[0].inputCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bcb85e0b9bc3b04eccb9b0f54a53706c8ac0659f":["e4563f34ffeedc07a91ffbd4bd829bdc4199dde2"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["e4563f34ffeedc07a91ffbd4bd829bdc4199dde2","bcb85e0b9bc3b04eccb9b0f54a53706c8ac0659f"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd9c9f83215f32164e7ac9a57342ffc418a5fcb0":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"83870855d82aba6819217abeff5a40779dbb28b4":["e4563f34ffeedc07a91ffbd4bd829bdc4199dde2","0e121d43b5a10f2df530f406f935102656e9c4e8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["e4563f34ffeedc07a91ffbd4bd829bdc4199dde2","0e121d43b5a10f2df530f406f935102656e9c4e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e4563f34ffeedc07a91ffbd4bd829bdc4199dde2":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["cd9c9f83215f32164e7ac9a57342ffc418a5fcb0"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["0e121d43b5a10f2df530f406f935102656e9c4e8","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"]},"commit2Childs":{"bcb85e0b9bc3b04eccb9b0f54a53706c8ac0659f":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd9c9f83215f32164e7ac9a57342ffc418a5fcb0"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["e4563f34ffeedc07a91ffbd4bd829bdc4199dde2"],"cd9c9f83215f32164e7ac9a57342ffc418a5fcb0":["5ebe14aae60589c9bb6423f3cce02d5f599e1540"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"e4563f34ffeedc07a91ffbd4bd829bdc4199dde2":["bcb85e0b9bc3b04eccb9b0f54a53706c8ac0659f","0e121d43b5a10f2df530f406f935102656e9c4e8","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"5ebe14aae60589c9bb6423f3cce02d5f599e1540":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","83870855d82aba6819217abeff5a40779dbb28b4","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}