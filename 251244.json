{"path":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","commits":[{"id":"1275856c84e2d39350c6d0f98681e2c6ba1e18aa","date":1459923987,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(OverseerCollectionMessageHandler.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, Collections.emptySet(), 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6284684320a9808c41a5e43de958b2da22f89bd","date":1459977490,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(OverseerCollectionMessageHandler.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, Collections.emptySet(), 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e4014209b24e71d602e579a316f994355596012","date":1465717267,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","sourceNew":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(OverseerCollectionMessageHandler.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","sourceOld":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(OverseerCollectionMessageHandler.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, Collections.emptySet(), 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","sourceNew":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(OverseerCollectionMessageHandler.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","sourceOld":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(OverseerCollectionMessageHandler.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, Collections.emptySet(), 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"82b686ab2904b3e81184ecea0d238b4ab0885376","date":1529576124,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","sourceNew":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(CollectionAdminParams.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","sourceOld":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(OverseerCollectionMessageHandler.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","sourceNew":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(CollectionAdminParams.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","sourceOld":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(OverseerCollectionMessageHandler.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","sourceNew":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(CollectionAdminParams.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","sourceOld":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(OverseerCollectionMessageHandler.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dfb8001b6712216ccbf7ccc85f830f08ce3b544","date":1576882501,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","sourceNew":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(CollectionAdminParams.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(\"foo bar\".getBytes(StandardCharsets.UTF_8));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","sourceOld":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(CollectionAdminParams.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a","date":1577276097,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","sourceNew":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(CollectionAdminParams.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(\"foo bar\".getBytes(StandardCharsets.UTF_8));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","sourceOld":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(CollectionAdminParams.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(SolrResponse.serializable(new SolrResponseBase()));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/OverseerTaskQueueTest#testContainsTaskWithRequestId().mjava","sourceNew":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(CollectionAdminParams.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      @SuppressWarnings({\"unchecked\"})\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(\"foo bar\".getBytes(StandardCharsets.UTF_8));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","sourceOld":"  @Test\n  public void testContainsTaskWithRequestId() throws Exception {\n    String tqZNode = \"/taskqueue/test\";\n    String requestId = \"foo\";\n    String nonExistentRequestId = \"bar\";\n\n    OverseerTaskQueue tq = makeDistributedQueue(tqZNode);\n\n    // Basic ops\n    // Put an expected Overseer task onto the queue\n    final Map<String, Object> props = new HashMap<>();\n    props.put(CommonParams.NAME, \"coll1\");\n    props.put(CollectionAdminParams.COLL_CONF, \"myconf\");\n    props.put(OverseerCollectionMessageHandler.NUM_SLICES, 1);\n    props.put(ZkStateReader.REPLICATION_FACTOR, 3);\n    props.put(CommonAdminParams.ASYNC, requestId);\n    tq.offer(Utils.toJSON(props));\n\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n\n    assertFalse(\"Task queue should not contain task with requestid \" + nonExistentRequestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, nonExistentRequestId));\n\n    // Create a response node as if someone is waiting for a response from the Overseer; then,\n    // create the request node.\n    // Here we're reaching a bit into the internals of OverseerTaskQueue in order to create the same\n    // response node structure but without setting a watch on it and removing it immediately when\n    // a response is set, in order to artificially create the race condition that\n    // containsTaskWithRequestId runs while the response is still in the queue.\n    String watchID = tq.createResponseNode();\n    String requestId2 = \"baz\";\n    props.put(CommonAdminParams.ASYNC, requestId2);\n    tq.createRequestNode(Utils.toJSON(props), watchID);\n\n    // Set a SolrResponse as the response node by removing the QueueEvent, as done in OverseerTaskProcessor\n    List<OverseerTaskQueue.QueueEvent> queueEvents = tq.peekTopN(2, s -> false, 1000);\n    OverseerTaskQueue.QueueEvent requestId2Event = null;\n    for (OverseerTaskQueue.QueueEvent queueEvent : queueEvents) {\n      Map<String, Object> eventProps = (Map<String, Object>) Utils.fromJSON(queueEvent.getBytes());\n      if (requestId2.equals(eventProps.get(CommonAdminParams.ASYNC))) {\n        requestId2Event = queueEvent;\n        break;\n      }\n    }\n    assertNotNull(\"Didn't find event with requestid \" + requestId2, requestId2Event);\n    requestId2Event.setBytes(\"foo bar\".getBytes(StandardCharsets.UTF_8));\n    tq.remove(requestId2Event);\n\n    // Make sure this call to check if requestId exists doesn't barf with Json parse exception\n    assertTrue(\"Task queue should contain task with requestid \" + requestId,\n        tq.containsTaskWithRequestId(CommonAdminParams.ASYNC, requestId));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a":["82b686ab2904b3e81184ecea0d238b4ab0885376","2dfb8001b6712216ccbf7ccc85f830f08ce3b544"],"2dfb8001b6712216ccbf7ccc85f830f08ce3b544":["82b686ab2904b3e81184ecea0d238b4ab0885376"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["1e4014209b24e71d602e579a316f994355596012","82b686ab2904b3e81184ecea0d238b4ab0885376"],"1275856c84e2d39350c6d0f98681e2c6ba1e18aa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b6284684320a9808c41a5e43de958b2da22f89bd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1275856c84e2d39350c6d0f98681e2c6ba1e18aa"],"1e4014209b24e71d602e579a316f994355596012":["b6284684320a9808c41a5e43de958b2da22f89bd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"82b686ab2904b3e81184ecea0d238b4ab0885376":["1e4014209b24e71d602e579a316f994355596012"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b6284684320a9808c41a5e43de958b2da22f89bd","1e4014209b24e71d602e579a316f994355596012"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["2dfb8001b6712216ccbf7ccc85f830f08ce3b544"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["1e4014209b24e71d602e579a316f994355596012","82b686ab2904b3e81184ecea0d238b4ab0885376"]},"commit2Childs":{"96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a":[],"2dfb8001b6712216ccbf7ccc85f830f08ce3b544":["96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a","e98520789adb1d5ad05afb4956eca0944a929688"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"1275856c84e2d39350c6d0f98681e2c6ba1e18aa":["b6284684320a9808c41a5e43de958b2da22f89bd"],"b6284684320a9808c41a5e43de958b2da22f89bd":["1e4014209b24e71d602e579a316f994355596012","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"1e4014209b24e71d602e579a316f994355596012":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","82b686ab2904b3e81184ecea0d238b4ab0885376","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1275856c84e2d39350c6d0f98681e2c6ba1e18aa","b6284684320a9808c41a5e43de958b2da22f89bd"],"82b686ab2904b3e81184ecea0d238b4ab0885376":["96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a","2dfb8001b6712216ccbf7ccc85f830f08ce3b544","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["96b4a3cd1f2463ebc4ffc0f61acdb3359637fe2a","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}