{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(PlanetModel,List[GeoPoint],int,int,SidedPlane,boolean,List[GeoPolygon],GeoPoint).mjava","commits":[{"id":"40aa98241c87d86a0077beb8023713d93a0becfe","date":1459784560,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(PlanetModel,List[GeoPoint],int,int,SidedPlane,boolean,List[GeoPolygon],GeoPoint).mjava","pathOld":"/dev/null","sourceNew":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param pointsList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param isInternalEdge is true if the specified edge is an internal one.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return a GeoMembershipShape corresponding to what was specified, or null if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return null, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  public static GeoPolygon buildPolygonShape(\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final boolean isInternalEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, startPointIndex, endPointIndex, startingEdge, isInternalEdge);\n\n    // Current composite.  This is what we'll actually be returning.  This will have a number of convex polygons, and\n    // maybe a single concave one too.\n    final GeoCompositePolygon rval = new GeoCompositePolygon();\n\n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return null;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    if (makeConcavePolygon(planetModel, rval, edgeBuffer, holes, testPoint) == false) {\n      return null;\n    }\n    \n    return rval;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09af2c9610ce53a4b25fd99344299b40318a4a1a","date":1459876565,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(PlanetModel,List[GeoPoint],int,int,SidedPlane,boolean,List[GeoPolygon],GeoPoint).mjava","pathOld":"/dev/null","sourceNew":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param pointsList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param isInternalEdge is true if the specified edge is an internal one.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return a GeoMembershipShape corresponding to what was specified, or null if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return null, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  public static GeoPolygon buildPolygonShape(\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final boolean isInternalEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, startPointIndex, endPointIndex, startingEdge, isInternalEdge);\n\n    // Current composite.  This is what we'll actually be returning.  This will have a number of convex polygons, and\n    // maybe a single concave one too.\n    final GeoCompositePolygon rval = new GeoCompositePolygon();\n\n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return null;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    if (makeConcavePolygon(planetModel, rval, edgeBuffer, holes, testPoint) == false) {\n      return null;\n    }\n    \n    return rval;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a75c862521bb895a29958e7bc5cb188597205a08","date":1459977470,"type":5,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(GeoCompositePolygon,PlanetModel,List[GeoPoint],BitSet,int,int,SidedPlane,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(PlanetModel,List[GeoPoint],int,int,SidedPlane,boolean,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param rval is the composite polygon to add to.\n   * @param planetModel is the planet model.\n   * @param pointsList is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param internalEdges specifies which edges are internal.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return the GeoPolygon passed in in the rval parameter, or null if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return null, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  public static GeoPolygon buildPolygonShape(\n    final GeoCompositePolygon rval,\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final BitSet internalEdges,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, internalEdges, startPointIndex, endPointIndex, startingEdge);\n\n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return null;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // Look for any reason that the concave polygon cannot be created.\n    // This test is really the converse of the one for a convex polygon.\n    // Points on the edge of a convex polygon MUST be inside all the other\n    // edges.  For a concave polygon, this check is still the same, except we have\n    // to look at the reverse sided planes, not the forward ones.\n    \n    // If we find a point that is outside of the complementary edges, it means that\n    // the point is in fact able to form a convex polygon with the edge it is\n    // offending. \n    \n    // If what is left has any plane/point pair that is on the wrong side, we have to split using one of the plane endpoints and the \n    // point in question.  This is best structured as a recursion, if detected.\n    final Iterator<Edge> checkIterator = edgeBuffer.iterator();\n    while (checkIterator.hasNext()) {\n      final Edge checkEdge = checkIterator.next();\n      final SidedPlane flippedPlane = new SidedPlane(checkEdge.plane);\n      // Now walk around again looking for points that fail\n      final Iterator<Edge> confirmIterator = edgeBuffer.iterator();\n      while (confirmIterator.hasNext()) {\n        final Edge confirmEdge = confirmIterator.next();\n        if (confirmEdge == checkEdge) {\n          continue;\n        }\n        final GeoPoint thePoint;\n        if (checkEdge.startPoint != confirmEdge.startPoint && checkEdge.endPoint != confirmEdge.startPoint && !flippedPlane.isWithin(confirmEdge.startPoint)) {\n          thePoint = confirmEdge.startPoint;\n        } else if (checkEdge.startPoint != confirmEdge.endPoint && checkEdge.endPoint != confirmEdge.endPoint && !flippedPlane.isWithin(confirmEdge.endPoint)) {\n          thePoint = confirmEdge.endPoint;\n        } else {\n          thePoint = null;\n        }\n        if (thePoint != null) {\n          // Found a split!!\n          \n          // This should be the only problematic part of the polygon.\n          // We know that thePoint is on the \"wrong\" side of the edge -- that is, it's on the side that the\n          // edge is pointing at.\n          final List<GeoPoint> thirdPartPoints = new ArrayList<>();\n          final BitSet thirdPartInternal = new BitSet();\n          thirdPartPoints.add(checkEdge.startPoint);\n          thirdPartInternal.set(0, checkEdge.isInternal);\n          thirdPartPoints.add(checkEdge.endPoint);\n          thirdPartInternal.set(1, true);\n          thirdPartPoints.add(thePoint);\n          thirdPartInternal.set(2, true);\n          //System.out.println(\"Doing convex part...\");\n          final GeoPolygon thirdPoly = buildPolygonShape(rval,\n            planetModel,\n            thirdPartPoints,\n            thirdPartInternal, \n            0,\n            1,\n            checkEdge.plane,\n            holes,\n            testPoint);\n          //System.out.println(\"...done convex part.\");\n          if (thirdPoly == null) {\n            return null;\n          }\n\n          // The part preceding the bad edge, back to thePoint, needs to be recursively\n          // processed.  So, assemble what we need, which is basically a list of edges.\n          Edge loopEdge = edgeBuffer.getPrevious(checkEdge);\n          final List<GeoPoint> firstPartPoints = new ArrayList<>();\n          final BitSet firstPartInternal = new BitSet();\n          int i = 0;\n          while (true) {\n            firstPartPoints.add(loopEdge.endPoint);\n            if (loopEdge.endPoint == thePoint) {\n              break;\n            }\n            firstPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getPrevious(loopEdge);\n          }\n          firstPartInternal.set(i, true);\n          //System.out.println(\"Doing first part...\");\n          final GeoPolygon firstPoly = buildPolygonShape(rval,\n            planetModel,\n            firstPartPoints,\n            firstPartInternal, \n            firstPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.endPoint, false, checkEdge.startPoint, thePoint),\n            holes,\n            testPoint);\n          //System.out.println(\"...done first part.\");\n          if (firstPoly == null) {\n            return null;\n          }\n          final List<GeoPoint> secondPartPoints = new ArrayList<>();\n          final BitSet secondPartInternal = new BitSet();\n          loopEdge = edgeBuffer.getNext(checkEdge);\n          i = 0;\n          while (true) {\n            secondPartPoints.add(loopEdge.startPoint);\n            if (loopEdge.startPoint == thePoint) {\n              break;\n            }\n            secondPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getNext(loopEdge);\n          }\n          secondPartInternal.set(i, true);\n          //System.out.println(\"Doing second part...\");\n          final GeoPolygon secondPoly = buildPolygonShape(rval,\n            planetModel,\n            secondPartPoints,\n            secondPartInternal, \n            secondPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.endPoint, true, checkEdge.startPoint, thePoint),\n            holes,\n            testPoint);\n          //System.out.println(\"... done second part\");\n          if (secondPoly == null) {\n            return null;\n          }\n          \n          return rval;\n        }\n      }\n    }\n    \n    // No violations found: we know it's a legal concave polygon.\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    if (makeConcavePolygon(planetModel, rval, edgeBuffer, holes, testPoint) == false) {\n      return null;\n    }\n    \n    return rval;\n  }\n\n","sourceOld":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param pointsList        is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param isInternalEdge is true if the specified edge is an internal one.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return a GeoMembershipShape corresponding to what was specified, or null if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return null, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  public static GeoPolygon buildPolygonShape(\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final boolean isInternalEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, startPointIndex, endPointIndex, startingEdge, isInternalEdge);\n\n    // Current composite.  This is what we'll actually be returning.  This will have a number of convex polygons, and\n    // maybe a single concave one too.\n    final GeoCompositePolygon rval = new GeoCompositePolygon();\n\n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return null;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    if (makeConcavePolygon(planetModel, rval, edgeBuffer, holes, testPoint) == false) {\n      return null;\n    }\n    \n    return rval;\n  }\n\n","bugFix":null,"bugIntro":["dc584fa95053c03d95035277a2d2aaddd537c0fa"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"09af2c9610ce53a4b25fd99344299b40318a4a1a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","40aa98241c87d86a0077beb8023713d93a0becfe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"40aa98241c87d86a0077beb8023713d93a0becfe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a75c862521bb895a29958e7bc5cb188597205a08"],"a75c862521bb895a29958e7bc5cb188597205a08":["40aa98241c87d86a0077beb8023713d93a0becfe"]},"commit2Childs":{"09af2c9610ce53a4b25fd99344299b40318a4a1a":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09af2c9610ce53a4b25fd99344299b40318a4a1a","40aa98241c87d86a0077beb8023713d93a0becfe"],"40aa98241c87d86a0077beb8023713d93a0becfe":["09af2c9610ce53a4b25fd99344299b40318a4a1a","a75c862521bb895a29958e7bc5cb188597205a08"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"a75c862521bb895a29958e7bc5cb188597205a08":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["09af2c9610ce53a4b25fd99344299b40318a4a1a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}