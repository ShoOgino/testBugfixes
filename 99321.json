{"path":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","commits":[{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","sourceNew":"  /**\n   * The Xpath is split into segments using the '/' as a seperator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a seperator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * seperator or if a sequence of multiple seperator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<String>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip seperator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * The Xpath is split into segments using the '/' as a seperator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a seperator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * seperator or if a sequence of multiple seperator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<String>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip seperator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","sourceNew":"  /**\n   * The Xpath is split into segments using the '/' as a seperator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a seperator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * seperator or if a sequence of multiple seperator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<String>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip seperator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * The Xpath is split into segments using the '/' as a seperator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a seperator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * seperator or if a sequence of multiple seperator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<String>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip seperator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","sourceNew":"  /**\n   * The Xpath is split into segments using the '/' as a seperator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a seperator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * seperator or if a sequence of multiple seperator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip seperator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * The Xpath is split into segments using the '/' as a seperator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a seperator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * seperator or if a sequence of multiple seperator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<String>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip seperator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"18e7cf5eab4be20c96aa36554daa39b53f43cf6e","date":1490632275,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","sourceNew":"  /**\n   * The Xpath is split into segments using the '/' as a separator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a separator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * separator or if a sequence of multiple separator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip separator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * The Xpath is split into segments using the '/' as a seperator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a seperator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * seperator or if a sequence of multiple seperator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip seperator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"febf4fa8feff6bbc932c1b388cbd758a3e6697f7","date":1490873944,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","sourceNew":"  /**\n   * The Xpath is split into segments using the '/' as a separator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a separator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * separator or if a sequence of multiple separator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip separator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * The Xpath is split into segments using the '/' as a seperator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a seperator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * seperator or if a sequence of multiple seperator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip seperator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b","date":1598712724,"type":4,"author":"Alexandre Rafalovitch","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/XPathRecordReader#splitEscapeQuote(String).mjava","sourceNew":null,"sourceOld":"  /**\n   * The Xpath is split into segments using the '/' as a separator. However\n   * this method deals with special cases where there is a slash '/' character\n   * inside the attribute value e.g. x/@html='text/html'. We split by '/' but \n   * then reassemble things were the '/' appears within a quoted sub-string.\n   *\n   * We have already enforced that the string must begin with a separator. This\n   * method depends heavily on how split behaves if the string starts with the\n   * separator or if a sequence of multiple separator's appear. \n   */\n  private static List<String> splitEscapeQuote(String str) {\n    List<String> result = new LinkedList<>();\n    String[] ss = str.split(\"/\");\n    for (int i=0; i<ss.length; i++) { // i=1: skip separator at start of string\n      StringBuilder sb = new StringBuilder();\n      int quoteCount = 0;\n      while (true) {\n        sb.append(ss[i]);\n        for (int j=0; j<ss[i].length(); j++)\n            if (ss[i].charAt(j) == '\\'') quoteCount++;\n        // have we got a split inside quoted sub-string?\n        if ((quoteCount % 2) == 0) break;\n        // yes!; replace the '/' and loop to concat next token\n        i++;\n        sb.append(\"/\");\n      }\n      result.add(sb.toString());\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"febf4fa8feff6bbc932c1b388cbd758a3e6697f7":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["c26f00b574427b55127e869b935845554afde1fa"],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["18e7cf5eab4be20c96aa36554daa39b53f43cf6e"],"18e7cf5eab4be20c96aa36554daa39b53f43cf6e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"]},"commit2Childs":{"febf4fa8feff6bbc932c1b388cbd758a3e6697f7":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["febf4fa8feff6bbc932c1b388cbd758a3e6697f7","18e7cf5eab4be20c96aa36554daa39b53f43cf6e"],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"18e7cf5eab4be20c96aa36554daa39b53f43cf6e":["d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","c26f00b574427b55127e869b935845554afde1fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["febf4fa8feff6bbc932c1b388cbd758a3e6697f7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}