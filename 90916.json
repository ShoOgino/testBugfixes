{"path":"src/java/org/apache/lucene/document/DateTools#stringToDate(String).mjava","commits":[{"id":"f0c7cf7c5321e0d685b7ac1fce06922d12b16203","date":1094419649,"type":0,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/document/DateTools#stringToDate(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Converts a string produced by <code>timeToString</code> or\n   * <code>dateToString</code> back to a time, represented as a\n   * Date object.\n   * \n   * @param dateString the date string to be converted\n   * @return the parsed time as a Date object \n   * @throws ParseException if <code>dateString</code> is not in the \n   *  expected format \n   */\n  public static Date stringToDate(String dateString) throws ParseException {\n    String pattern = null;\n    if (dateString.length() == 4 )\n      pattern = \"yyyy\";\n    else if (dateString.length() == 6 )\n      pattern = \"yyyyMM\";\n    else if (dateString.length() == 8 )\n      pattern = \"yyyyMMdd\";\n    else if (dateString.length() == 10 )\n      pattern = \"yyyyMMddHH\";\n    else if (dateString.length() == 12 )\n      pattern = \"yyyyMMddHHmm\";\n    else if (dateString.length() == 14 )\n      pattern = \"yyyyMMddHHmmss\";\n    else if (dateString.length() == 17 )\n      pattern = \"yyyyMMddHHmmssSSS\";\n    else\n      throw new ParseException(\"Input is not valid date string: \" + dateString, 0);\n    SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n    Date date = sdf.parse(dateString);\n    return date;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87236df7b0a6d20724a5a1e1a4d8f4d0f0615cf0","date":1139163422,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/document/DateTools#stringToDate(String).mjava","pathOld":"src/java/org/apache/lucene/document/DateTools#stringToDate(String).mjava","sourceNew":"  /**\n   * Converts a string produced by <code>timeToString</code> or\n   * <code>dateToString</code> back to a time, represented as a\n   * Date object.\n   * \n   * @param dateString the date string to be converted\n   * @return the parsed time as a Date object \n   * @throws ParseException if <code>dateString</code> is not in the \n   *  expected format \n   */\n  public static Date stringToDate(String dateString) throws ParseException {\n    String pattern = null;\n    if (dateString.length() == 4 )\n      pattern = \"yyyy\";\n    else if (dateString.length() == 6 )\n      pattern = \"yyyyMM\";\n    else if (dateString.length() == 8 )\n      pattern = \"yyyyMMdd\";\n    else if (dateString.length() == 10 )\n      pattern = \"yyyyMMddHH\";\n    else if (dateString.length() == 12 )\n      pattern = \"yyyyMMddHHmm\";\n    else if (dateString.length() == 14 )\n      pattern = \"yyyyMMddHHmmss\";\n    else if (dateString.length() == 17 )\n      pattern = \"yyyyMMddHHmmssSSS\";\n    else\n      throw new ParseException(\"Input is not valid date string: \" + dateString, 0);\n    SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n    sdf.setTimeZone(GMT);\n    Date date = sdf.parse(dateString);\n    return date;\n  }\n\n","sourceOld":"  /**\n   * Converts a string produced by <code>timeToString</code> or\n   * <code>dateToString</code> back to a time, represented as a\n   * Date object.\n   * \n   * @param dateString the date string to be converted\n   * @return the parsed time as a Date object \n   * @throws ParseException if <code>dateString</code> is not in the \n   *  expected format \n   */\n  public static Date stringToDate(String dateString) throws ParseException {\n    String pattern = null;\n    if (dateString.length() == 4 )\n      pattern = \"yyyy\";\n    else if (dateString.length() == 6 )\n      pattern = \"yyyyMM\";\n    else if (dateString.length() == 8 )\n      pattern = \"yyyyMMdd\";\n    else if (dateString.length() == 10 )\n      pattern = \"yyyyMMddHH\";\n    else if (dateString.length() == 12 )\n      pattern = \"yyyyMMddHHmm\";\n    else if (dateString.length() == 14 )\n      pattern = \"yyyyMMddHHmmss\";\n    else if (dateString.length() == 17 )\n      pattern = \"yyyyMMddHHmmssSSS\";\n    else\n      throw new ParseException(\"Input is not valid date string: \" + dateString, 0);\n    SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n    Date date = sdf.parse(dateString);\n    return date;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28017b5a799539c88697d8570c796d841accb25f","date":1153514303,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/document/DateTools#stringToDate(String).mjava","pathOld":"src/java/org/apache/lucene/document/DateTools#stringToDate(String).mjava","sourceNew":"  /**\n   * Converts a string produced by <code>timeToString</code> or\n   * <code>dateToString</code> back to a time, represented as a\n   * Date object.\n   * \n   * @param dateString the date string to be converted\n   * @return the parsed time as a Date object \n   * @throws ParseException if <code>dateString</code> is not in the \n   *  expected format \n   */\n  public static Date stringToDate(String dateString) throws ParseException {\n    Date date;\n    if (dateString.length() == 4) {\n      synchronized (YEAR_FORMAT) {\n        date = YEAR_FORMAT.parse(dateString);\n      }\n    } else if (dateString.length() == 6) {\n      synchronized (MONTH_FORMAT) {\n        date = MONTH_FORMAT.parse(dateString);\n      }\n    } else if (dateString.length() == 8) {\n      synchronized (DAY_FORMAT) {\n        date = DAY_FORMAT.parse(dateString);\n      }\n    } else if (dateString.length() == 10) {\n      synchronized (HOUR_FORMAT) {\n        date = HOUR_FORMAT.parse(dateString);\n      }\n    } else if (dateString.length() == 12) {\n      synchronized (MINUTE_FORMAT) {\n        date = MINUTE_FORMAT.parse(dateString);\n      }\n    } else if (dateString.length() == 14) {\n      synchronized (SECOND_FORMAT) {\n        date = SECOND_FORMAT.parse(dateString);\n      }\n    } else if (dateString.length() == 17) {\n      synchronized (MILLISECOND_FORMAT) {\n        date = MILLISECOND_FORMAT.parse(dateString);\n      }\n    } else {\n      throw new ParseException(\"Input is not valid date string: \" + dateString, 0);\n    }\n    return date;\n  }\n\n","sourceOld":"  /**\n   * Converts a string produced by <code>timeToString</code> or\n   * <code>dateToString</code> back to a time, represented as a\n   * Date object.\n   * \n   * @param dateString the date string to be converted\n   * @return the parsed time as a Date object \n   * @throws ParseException if <code>dateString</code> is not in the \n   *  expected format \n   */\n  public static Date stringToDate(String dateString) throws ParseException {\n    String pattern = null;\n    if (dateString.length() == 4 )\n      pattern = \"yyyy\";\n    else if (dateString.length() == 6 )\n      pattern = \"yyyyMM\";\n    else if (dateString.length() == 8 )\n      pattern = \"yyyyMMdd\";\n    else if (dateString.length() == 10 )\n      pattern = \"yyyyMMddHH\";\n    else if (dateString.length() == 12 )\n      pattern = \"yyyyMMddHHmm\";\n    else if (dateString.length() == 14 )\n      pattern = \"yyyyMMddHHmmss\";\n    else if (dateString.length() == 17 )\n      pattern = \"yyyyMMddHHmmssSSS\";\n    else\n      throw new ParseException(\"Input is not valid date string: \" + dateString, 0);\n    SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n    sdf.setTimeZone(GMT);\n    Date date = sdf.parse(dateString);\n    return date;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea5e8d049564c69ae93ebb291c320fb586c02733","date":1243512095,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/document/DateTools#stringToDate(String).mjava","pathOld":"src/java/org/apache/lucene/document/DateTools#stringToDate(String).mjava","sourceNew":"  /**\n   * Converts a string produced by <code>timeToString</code> or\n   * <code>dateToString</code> back to a time, represented as a\n   * Date object.\n   * \n   * @param dateString the date string to be converted\n   * @return the parsed time as a Date object \n   * @throws ParseException if <code>dateString</code> is not in the \n   *  expected format \n   */\n  public static synchronized Date stringToDate(String dateString) throws ParseException {\n    if (dateString.length() == 4) {\n      return YEAR_FORMAT.parse(dateString);\n    } else if (dateString.length() == 6) {\n      return MONTH_FORMAT.parse(dateString);\n    } else if (dateString.length() == 8) {\n      return DAY_FORMAT.parse(dateString);\n    } else if (dateString.length() == 10) {\n      return HOUR_FORMAT.parse(dateString);\n    } else if (dateString.length() == 12) {\n      return MINUTE_FORMAT.parse(dateString);\n    } else if (dateString.length() == 14) {\n      return SECOND_FORMAT.parse(dateString);\n    } else if (dateString.length() == 17) {\n      return MILLISECOND_FORMAT.parse(dateString);\n    }\n    throw new ParseException(\"Input is not valid date string: \" + dateString, 0);\n  }\n\n","sourceOld":"  /**\n   * Converts a string produced by <code>timeToString</code> or\n   * <code>dateToString</code> back to a time, represented as a\n   * Date object.\n   * \n   * @param dateString the date string to be converted\n   * @return the parsed time as a Date object \n   * @throws ParseException if <code>dateString</code> is not in the \n   *  expected format \n   */\n  public static Date stringToDate(String dateString) throws ParseException {\n    Date date;\n    if (dateString.length() == 4) {\n      synchronized (YEAR_FORMAT) {\n        date = YEAR_FORMAT.parse(dateString);\n      }\n    } else if (dateString.length() == 6) {\n      synchronized (MONTH_FORMAT) {\n        date = MONTH_FORMAT.parse(dateString);\n      }\n    } else if (dateString.length() == 8) {\n      synchronized (DAY_FORMAT) {\n        date = DAY_FORMAT.parse(dateString);\n      }\n    } else if (dateString.length() == 10) {\n      synchronized (HOUR_FORMAT) {\n        date = HOUR_FORMAT.parse(dateString);\n      }\n    } else if (dateString.length() == 12) {\n      synchronized (MINUTE_FORMAT) {\n        date = MINUTE_FORMAT.parse(dateString);\n      }\n    } else if (dateString.length() == 14) {\n      synchronized (SECOND_FORMAT) {\n        date = SECOND_FORMAT.parse(dateString);\n      }\n    } else if (dateString.length() == 17) {\n      synchronized (MILLISECOND_FORMAT) {\n        date = MILLISECOND_FORMAT.parse(dateString);\n      }\n    } else {\n      throw new ParseException(\"Input is not valid date string: \" + dateString, 0);\n    }\n    return date;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":4,"author":"Dawid Weiss","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/document/DateTools#stringToDate(String).mjava","sourceNew":null,"sourceOld":"  /**\n   * Converts a string produced by <code>timeToString</code> or\n   * <code>dateToString</code> back to a time, represented as a\n   * Date object.\n   * \n   * @param dateString the date string to be converted\n   * @return the parsed time as a Date object \n   * @throws ParseException if <code>dateString</code> is not in the \n   *  expected format \n   */\n  public static synchronized Date stringToDate(String dateString) throws ParseException {\n    if (dateString.length() == 4) {\n      return YEAR_FORMAT.parse(dateString);\n    } else if (dateString.length() == 6) {\n      return MONTH_FORMAT.parse(dateString);\n    } else if (dateString.length() == 8) {\n      return DAY_FORMAT.parse(dateString);\n    } else if (dateString.length() == 10) {\n      return HOUR_FORMAT.parse(dateString);\n    } else if (dateString.length() == 12) {\n      return MINUTE_FORMAT.parse(dateString);\n    } else if (dateString.length() == 14) {\n      return SECOND_FORMAT.parse(dateString);\n    } else if (dateString.length() == 17) {\n      return MILLISECOND_FORMAT.parse(dateString);\n    }\n    throw new ParseException(\"Input is not valid date string: \" + dateString, 0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"28017b5a799539c88697d8570c796d841accb25f":["87236df7b0a6d20724a5a1e1a4d8f4d0f0615cf0"],"f0c7cf7c5321e0d685b7ac1fce06922d12b16203":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ea5e8d049564c69ae93ebb291c320fb586c02733":["28017b5a799539c88697d8570c796d841accb25f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["ea5e8d049564c69ae93ebb291c320fb586c02733"],"87236df7b0a6d20724a5a1e1a4d8f4d0f0615cf0":["f0c7cf7c5321e0d685b7ac1fce06922d12b16203"]},"commit2Childs":{"28017b5a799539c88697d8570c796d841accb25f":["ea5e8d049564c69ae93ebb291c320fb586c02733"],"f0c7cf7c5321e0d685b7ac1fce06922d12b16203":["87236df7b0a6d20724a5a1e1a4d8f4d0f0615cf0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f0c7cf7c5321e0d685b7ac1fce06922d12b16203"],"ea5e8d049564c69ae93ebb291c320fb586c02733":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"87236df7b0a6d20724a5a1e1a4d8f4d0f0615cf0":["28017b5a799539c88697d8570c796d841accb25f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}