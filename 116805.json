{"path":"lucene/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","commits":[{"id":"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4","date":1291128345,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/PagedBytes.Reader#fillUsingLengthPrefix4(BytesRef,long).mjava","sourceNew":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        byte[] buffer = threadBuffers.get();\n        if (buffer == null) {\n          buffer = new byte[length];\n          threadBuffers.set(buffer);\n        } else if (buffer.length < length) {\n          buffer = ArrayUtil.grow(buffer, length);\n          threadBuffers.set(buffer);\n        }\n        b.bytes = buffer;\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, buffer, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, buffer, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","sourceOld":"    /**\n     * Reads length as 1 or 2 byte vInt prefix, starting @ start and fill the\n     * given {@link BytesRef} with the byte slice starting after the length\n     * prefix.\n     * @lucene.internal\n     **/\n    public BytesRef fillUsingLengthPrefix4(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        byte[] buffer = threadBuffers.get();\n        if (buffer == null) {\n          buffer = new byte[length];\n          threadBuffers.set(buffer);\n        } else if (buffer.length < length) {\n          buffer = ArrayUtil.grow(buffer, length);\n          threadBuffers.set(buffer);\n        }\n        b.bytes = buffer;\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, buffer, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, buffer, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e8d7ba2175f47e280231533f7d3016249cea88b","date":1307711934,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        byte[] buffer = threadBuffers.get();\n        if (buffer == null) {\n          buffer = new byte[length];\n          threadBuffers.set(buffer);\n        } else if (buffer.length < length) {\n          buffer = ArrayUtil.grow(buffer, length);\n          threadBuffers.set(buffer);\n        }\n        b.bytes = buffer;\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, buffer, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, buffer, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        byte[] buffer = threadBuffers.get();\n        if (buffer == null) {\n          buffer = new byte[length];\n          threadBuffers.set(buffer);\n        } else if (buffer.length < length) {\n          buffer = ArrayUtil.grow(buffer, length);\n          threadBuffers.set(buffer);\n        }\n        b.bytes = buffer;\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, buffer, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, buffer, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/PagedBytes.Reader#fillSliceWithPrefix(BytesRef,long).mjava","sourceNew":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        byte[] buffer = threadBuffers.get();\n        if (buffer == null) {\n          buffer = new byte[length];\n          threadBuffers.set(buffer);\n        } else if (buffer.length < length) {\n          buffer = ArrayUtil.grow(buffer, length);\n          threadBuffers.set(buffer);\n        }\n        b.bytes = buffer;\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, buffer, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, buffer, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","sourceOld":"    /**\n     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the\n     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a\n     * block border this method will allocate sufficient resources and copy the\n     * paged data.\n     * <p>\n     * Slices spanning more than one block are not supported.\n     * </p>\n     * \n     * @lucene.internal\n     **/\n    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {\n      final int index = (int) (start >> blockBits);\n      int offset = (int) (start & blockMask);\n      final byte[] block = blocks[index];\n      final int length;\n      if ((block[offset] & 128) == 0) {\n        length = block[offset];\n        offset = offset+1;\n      } else {\n        length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);\n        offset = offset+2;\n        assert length > 0;\n      }\n      assert length >= 0: \"length=\" + length;\n      b.length = length;\n      if (blockSize - offset >= length) {\n        // Within block\n        b.offset = offset;\n        b.bytes = blocks[index];\n      } else {\n        // Split\n        byte[] buffer = threadBuffers.get();\n        if (buffer == null) {\n          buffer = new byte[length];\n          threadBuffers.set(buffer);\n        } else if (buffer.length < length) {\n          buffer = ArrayUtil.grow(buffer, length);\n          threadBuffers.set(buffer);\n        }\n        b.bytes = buffer;\n        b.offset = 0;\n        System.arraycopy(blocks[index], offset, buffer, 0, blockSize-offset);\n        System.arraycopy(blocks[1+index], 0, buffer, blockSize-offset, length-(blockSize-offset));\n      }\n      return b;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2e8d7ba2175f47e280231533f7d3016249cea88b"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":[],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5a98a65bdb67cd0b27d18a5564d63bd3e944d3f4","a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","2e8d7ba2175f47e280231533f7d3016249cea88b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}