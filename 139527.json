{"path":"src/test/org/apache/lucene/search/TestConstantScoreRangeQuery#testBooleanOrderUnAffected().mjava","commits":[{"id":"c5f8e44d5e9627993851287f67e8360a36cb302a","date":1132032532,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/TestConstantScoreRangeQuery#testBooleanOrderUnAffected().mjava","pathOld":"/dev/null","sourceNew":"    public void testBooleanOrderUnAffected() throws IOException {\n        // NOTE: uses index build in *this* setUp\n        \n        IndexReader reader = IndexReader.open(small);\n\tIndexSearcher search = new IndexSearcher(reader);\n\n        // first do a regular RangeQuery which uses term expansion so\n        // docs with more terms in range get higher scores\n        \n        Query rq = new RangeQuery(new Term(\"data\",\"1\"),new Term(\"data\",\"4\"),T);\n\n        Hits expected = search.search(rq);\n        int numHits = expected.length();\n\n        // now do a boolean where which also contains a\n        // ConstantScoreRangeQuery and make sure hte order is the same\n        \n        BooleanQuery q = new BooleanQuery();\n        q.add(rq, T, F);\n        q.add(csrq(\"data\",\"1\",\"6\", T, T), T, F);\n\n        Hits actual = search.search(q);\n\n        assertEquals(\"wrong numebr of hits\", numHits, actual.length());\n        for (int i = 0; i < numHits; i++) {\n            assertEquals(\"mismatch in docid for hit#\"+i,\n                         expected.id(i), actual.id(i));\n        }\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c69e98ffd83f56083b99e5443ca713cd5783a2ae","date":1142955392,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/TestConstantScoreRangeQuery#testBooleanOrderUnAffected().mjava","pathOld":"src/test/org/apache/lucene/search/TestConstantScoreRangeQuery#testBooleanOrderUnAffected().mjava","sourceNew":"    public void testBooleanOrderUnAffected() throws IOException {\n        // NOTE: uses index build in *this* setUp\n        \n        IndexReader reader = IndexReader.open(small);\n\tIndexSearcher search = new IndexSearcher(reader);\n\n        // first do a regular RangeQuery which uses term expansion so\n        // docs with more terms in range get higher scores\n        \n        Query rq = new RangeQuery(new Term(\"data\",\"1\"),new Term(\"data\",\"4\"),T);\n\n        Hits expected = search.search(rq);\n        int numHits = expected.length();\n\n        // now do a boolean where which also contains a\n        // ConstantScoreRangeQuery and make sure hte order is the same\n        \n        BooleanQuery q = new BooleanQuery();\n        q.add(rq, BooleanClause.Occur.MUST);//T, F);\n        q.add(csrq(\"data\",\"1\",\"6\", T, T), BooleanClause.Occur.MUST);//T, F);\n\n        Hits actual = search.search(q);\n\n        assertEquals(\"wrong numebr of hits\", numHits, actual.length());\n        for (int i = 0; i < numHits; i++) {\n            assertEquals(\"mismatch in docid for hit#\"+i,\n                         expected.id(i), actual.id(i));\n        }\n\n    }\n\n","sourceOld":"    public void testBooleanOrderUnAffected() throws IOException {\n        // NOTE: uses index build in *this* setUp\n        \n        IndexReader reader = IndexReader.open(small);\n\tIndexSearcher search = new IndexSearcher(reader);\n\n        // first do a regular RangeQuery which uses term expansion so\n        // docs with more terms in range get higher scores\n        \n        Query rq = new RangeQuery(new Term(\"data\",\"1\"),new Term(\"data\",\"4\"),T);\n\n        Hits expected = search.search(rq);\n        int numHits = expected.length();\n\n        // now do a boolean where which also contains a\n        // ConstantScoreRangeQuery and make sure hte order is the same\n        \n        BooleanQuery q = new BooleanQuery();\n        q.add(rq, T, F);\n        q.add(csrq(\"data\",\"1\",\"6\", T, T), T, F);\n\n        Hits actual = search.search(q);\n\n        assertEquals(\"wrong numebr of hits\", numHits, actual.length());\n        for (int i = 0; i < numHits; i++) {\n            assertEquals(\"mismatch in docid for hit#\"+i,\n                         expected.id(i), actual.id(i));\n        }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5af07783dbc171e26a694c4f7d735e30c2769faa","date":1211569075,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/test/org/apache/lucene/search/TestConstantScoreRangeQuery#testBooleanOrderUnAffected().mjava","pathOld":"src/test/org/apache/lucene/search/TestConstantScoreRangeQuery#testBooleanOrderUnAffected().mjava","sourceNew":"    public void testBooleanOrderUnAffected() throws IOException {\n        // NOTE: uses index build in *this* setUp\n        \n        IndexReader reader = IndexReader.open(small);\n\tIndexSearcher search = new IndexSearcher(reader);\n\n        // first do a regular RangeQuery which uses term expansion so\n        // docs with more terms in range get higher scores\n        \n        Query rq = new RangeQuery(new Term(\"data\",\"1\"),new Term(\"data\",\"4\"),T);\n\n        ScoreDoc[] expected = search.search(rq, null, 1000).scoreDocs;\n        int numHits = expected.length;\n\n        // now do a boolean where which also contains a\n        // ConstantScoreRangeQuery and make sure hte order is the same\n        \n        BooleanQuery q = new BooleanQuery();\n        q.add(rq, BooleanClause.Occur.MUST);//T, F);\n        q.add(csrq(\"data\",\"1\",\"6\", T, T), BooleanClause.Occur.MUST);//T, F);\n\n        ScoreDoc[] actual = search.search(q, null, 1000).scoreDocs;\n\n        assertEquals(\"wrong numebr of hits\", numHits, actual.length);\n        for (int i = 0; i < numHits; i++) {\n            assertEquals(\"mismatch in docid for hit#\"+i,\n                         expected[i].doc, actual[i].doc);\n        }\n\n    }\n\n","sourceOld":"    public void testBooleanOrderUnAffected() throws IOException {\n        // NOTE: uses index build in *this* setUp\n        \n        IndexReader reader = IndexReader.open(small);\n\tIndexSearcher search = new IndexSearcher(reader);\n\n        // first do a regular RangeQuery which uses term expansion so\n        // docs with more terms in range get higher scores\n        \n        Query rq = new RangeQuery(new Term(\"data\",\"1\"),new Term(\"data\",\"4\"),T);\n\n        Hits expected = search.search(rq);\n        int numHits = expected.length();\n\n        // now do a boolean where which also contains a\n        // ConstantScoreRangeQuery and make sure hte order is the same\n        \n        BooleanQuery q = new BooleanQuery();\n        q.add(rq, BooleanClause.Occur.MUST);//T, F);\n        q.add(csrq(\"data\",\"1\",\"6\", T, T), BooleanClause.Occur.MUST);//T, F);\n\n        Hits actual = search.search(q);\n\n        assertEquals(\"wrong numebr of hits\", numHits, actual.length());\n        for (int i = 0; i < numHits; i++) {\n            assertEquals(\"mismatch in docid for hit#\"+i,\n                         expected.id(i), actual.id(i));\n        }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f7a11eba51d213f09b96054111cf56a1e5796a3","date":1226364000,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/test/org/apache/lucene/search/TestConstantScoreRangeQuery#testBooleanOrderUnAffected().mjava","sourceNew":null,"sourceOld":"    public void testBooleanOrderUnAffected() throws IOException {\n        // NOTE: uses index build in *this* setUp\n        \n        IndexReader reader = IndexReader.open(small);\n\tIndexSearcher search = new IndexSearcher(reader);\n\n        // first do a regular RangeQuery which uses term expansion so\n        // docs with more terms in range get higher scores\n        \n        Query rq = new RangeQuery(new Term(\"data\",\"1\"),new Term(\"data\",\"4\"),T);\n\n        ScoreDoc[] expected = search.search(rq, null, 1000).scoreDocs;\n        int numHits = expected.length;\n\n        // now do a boolean where which also contains a\n        // ConstantScoreRangeQuery and make sure hte order is the same\n        \n        BooleanQuery q = new BooleanQuery();\n        q.add(rq, BooleanClause.Occur.MUST);//T, F);\n        q.add(csrq(\"data\",\"1\",\"6\", T, T), BooleanClause.Occur.MUST);//T, F);\n\n        ScoreDoc[] actual = search.search(q, null, 1000).scoreDocs;\n\n        assertEquals(\"wrong numebr of hits\", numHits, actual.length);\n        for (int i = 0; i < numHits; i++) {\n            assertEquals(\"mismatch in docid for hit#\"+i,\n                         expected[i].doc, actual[i].doc);\n        }\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c5f8e44d5e9627993851287f67e8360a36cb302a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c69e98ffd83f56083b99e5443ca713cd5783a2ae":["c5f8e44d5e9627993851287f67e8360a36cb302a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5af07783dbc171e26a694c4f7d735e30c2769faa":["c69e98ffd83f56083b99e5443ca713cd5783a2ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6f7a11eba51d213f09b96054111cf56a1e5796a3"],"6f7a11eba51d213f09b96054111cf56a1e5796a3":["5af07783dbc171e26a694c4f7d735e30c2769faa"]},"commit2Childs":{"c5f8e44d5e9627993851287f67e8360a36cb302a":["c69e98ffd83f56083b99e5443ca713cd5783a2ae"],"c69e98ffd83f56083b99e5443ca713cd5783a2ae":["5af07783dbc171e26a694c4f7d735e30c2769faa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c5f8e44d5e9627993851287f67e8360a36cb302a"],"5af07783dbc171e26a694c4f7d735e30c2769faa":["6f7a11eba51d213f09b96054111cf56a1e5796a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"6f7a11eba51d213f09b96054111cf56a1e5796a3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}