{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testSplitConfig().mjava","commits":[{"id":"a97a72dc16d01fda8ca5c9e0264b3604e30ab539","date":1565639985,"type":1,"author":"Megan Carey","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testSplitConfig().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testSplitMethodConfig().mjava","sourceNew":"  //test that split parameters can be overridden\n  @Test\n  public void testSplitConfig() throws Exception {\n    String collectionName = \"testSplitConfig_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudUtil.clusterShape(2, 2, false, true));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    props.put(CommonAdminParams.SPLIT_METHOD, SolrIndexSplitter.SplitMethod.REWRITE.toLower());\n    props.put(IndexSizeTrigger.SPLIT_BY_PREFIX, true);\n    \n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger6\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        \n        // verify overrides for split config\n        assertEquals(\"splitMethod: \" + op, SolrIndexSplitter.SplitMethod.REWRITE.toLower(),\n            params.get(CommonAdminParams.SPLIT_METHOD));\n        assertEquals(\"splitByPrefix: \" + op, true, params.get(CommonAdminParams.SPLIT_BY_PREFIX));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n\n  }\n\n","sourceOld":"  @Test\n  public void testSplitMethodConfig() throws Exception {\n    String collectionName = \"testSplitMethod_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudUtil.clusterShape(2, 2, false, true));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    props.put(CommonAdminParams.SPLIT_METHOD, \"link\");\n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger6\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        assertEquals(\"splitMethod: \" + op, \"link\", params.get(CommonAdminParams.SPLIT_METHOD));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testSplitConfig().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testSplitConfig().mjava","sourceNew":"  //test that split parameters can be overridden\n  @Test\n  public void testSplitConfig() throws Exception {\n    String collectionName = \"testSplitConfig_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudUtil.clusterShape(2, 2, false, true));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    props.put(CommonAdminParams.SPLIT_METHOD, SolrIndexSplitter.SplitMethod.REWRITE.toLower());\n    props.put(IndexSizeTrigger.SPLIT_BY_PREFIX, true);\n    \n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger6\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      @SuppressWarnings({\"unchecked\"})\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        @SuppressWarnings({\"unchecked\"})\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        @SuppressWarnings({\"unchecked\"})\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        \n        // verify overrides for split config\n        assertEquals(\"splitMethod: \" + op, SolrIndexSplitter.SplitMethod.REWRITE.toLower(),\n            params.get(CommonAdminParams.SPLIT_METHOD));\n        assertEquals(\"splitByPrefix: \" + op, true, params.get(CommonAdminParams.SPLIT_BY_PREFIX));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n\n  }\n\n","sourceOld":"  //test that split parameters can be overridden\n  @Test\n  public void testSplitConfig() throws Exception {\n    String collectionName = \"testSplitConfig_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudUtil.clusterShape(2, 2, false, true));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    props.put(CommonAdminParams.SPLIT_METHOD, SolrIndexSplitter.SplitMethod.REWRITE.toLower());\n    props.put(IndexSizeTrigger.SPLIT_BY_PREFIX, true);\n    \n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger6\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        \n        // verify overrides for split config\n        assertEquals(\"splitMethod: \" + op, SolrIndexSplitter.SplitMethod.REWRITE.toLower(),\n            params.get(CommonAdminParams.SPLIT_METHOD));\n        assertEquals(\"splitByPrefix: \" + op, true, params.get(CommonAdminParams.SPLIT_BY_PREFIX));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testSplitConfig().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testSplitConfig().mjava","sourceNew":"  //test that split parameters can be overridden\n  @Test\n  public void testSplitConfig() throws Exception {\n    String collectionName = \"testSplitConfig_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudUtil.clusterShape(2, 2, false, true));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    props.put(CommonAdminParams.SPLIT_METHOD, SolrIndexSplitter.SplitMethod.REWRITE.toLower());\n    props.put(IndexSizeTrigger.SPLIT_BY_PREFIX, true);\n    \n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger6\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      @SuppressWarnings({\"unchecked\"})\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        @SuppressWarnings({\"unchecked\"})\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        @SuppressWarnings({\"unchecked\"})\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        \n        // verify overrides for split config\n        assertEquals(\"splitMethod: \" + op, SolrIndexSplitter.SplitMethod.REWRITE.toLower(),\n            params.get(CommonAdminParams.SPLIT_METHOD));\n        assertEquals(\"splitByPrefix: \" + op, true, params.get(CommonAdminParams.SPLIT_BY_PREFIX));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n\n  }\n\n","sourceOld":"  //test that split parameters can be overridden\n  @Test\n  public void testSplitConfig() throws Exception {\n    String collectionName = \"testSplitConfig_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2).setMaxShardsPerNode(2);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudUtil.clusterShape(2, 2, false, true));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    props.put(CommonAdminParams.SPLIT_METHOD, SolrIndexSplitter.SplitMethod.REWRITE.toLower());\n    props.put(IndexSizeTrigger.SPLIT_BY_PREFIX, true);\n    \n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger6\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      @SuppressWarnings({\"unchecked\"})\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        @SuppressWarnings({\"unchecked\"})\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        @SuppressWarnings({\"unchecked\"})\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        \n        // verify overrides for split config\n        assertEquals(\"splitMethod: \" + op, SolrIndexSplitter.SplitMethod.REWRITE.toLower(),\n            params.get(CommonAdminParams.SPLIT_METHOD));\n        assertEquals(\"splitByPrefix: \" + op, true, params.get(CommonAdminParams.SPLIT_BY_PREFIX));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/IndexSizeTriggerTest#testSplitConfig().mjava","sourceNew":null,"sourceOld":"  //test that split parameters can be overridden\n  @Test\n  public void testSplitConfig() throws Exception {\n    String collectionName = \"testSplitConfig_collection\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,\n        \"conf\", 2, 2);\n    create.process(solrClient);\n    CloudUtil.waitForState(cloudManager, \"failed to create \" + collectionName, collectionName,\n        CloudUtil.clusterShape(2, 2, false, true));\n\n    long waitForSeconds = 3 + random().nextInt(5);\n    Map<String, Object> props = createTriggerProps(waitForSeconds);\n    props.put(CommonAdminParams.SPLIT_METHOD, SolrIndexSplitter.SplitMethod.REWRITE.toLower());\n    props.put(IndexSizeTrigger.SPLIT_BY_PREFIX, true);\n    \n    try (IndexSizeTrigger trigger = new IndexSizeTrigger(\"index_size_trigger6\")) {\n      trigger.configure(loader, cloudManager, props);\n      trigger.init();\n      trigger.setProcessor(noFirstRunProcessor);\n      trigger.run();\n\n      for (int i = 0; i < 25; i++) {\n        SolrInputDocument doc = new SolrInputDocument(\"id\", \"id-\" + i);\n        solrClient.add(collectionName, doc);\n      }\n      solrClient.commit(collectionName);\n\n      AtomicBoolean fired = new AtomicBoolean(false);\n      AtomicReference<TriggerEvent> eventRef = new AtomicReference<>();\n      trigger.setProcessor(event -> {\n        if (fired.compareAndSet(false, true)) {\n          eventRef.set(event);\n          long currentTimeNanos = timeSource.getTimeNs();\n          long eventTimeNanos = event.getEventTime();\n          long waitForNanos = TimeUnit.NANOSECONDS.convert(waitForSeconds, TimeUnit.SECONDS) - WAIT_FOR_DELTA_NANOS;\n          if (currentTimeNanos - eventTimeNanos <= waitForNanos) {\n            fail(\"processor was fired before the configured waitFor period: currentTimeNanos=\" + currentTimeNanos + \", eventTimeNanos=\" +  eventTimeNanos + \",waitForNanos=\" + waitForNanos);\n          }\n        } else {\n          fail(\"IndexSizeTrigger was fired more than once!\");\n        }\n        return true;\n      });\n      trigger.run();\n      TriggerEvent ev = eventRef.get();\n      // waitFor delay - should not produce any event yet\n      assertNull(\"waitFor not elapsed but produced an event\", ev);\n      timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));\n      trigger.run();\n      ev = eventRef.get();\n      assertNotNull(\"should have fired an event\", ev);\n      @SuppressWarnings({\"unchecked\"})\n      List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>) ev.getProperty(TriggerEvent.REQUESTED_OPS);\n      assertNotNull(\"should contain requestedOps\", ops);\n      assertEquals(\"number of ops: \" + ops, 2, ops.size());\n      boolean shard1 = false;\n      boolean shard2 = false;\n      for (TriggerEvent.Op op : ops) {\n        assertEquals(CollectionParams.CollectionAction.SPLITSHARD, op.getAction());\n        @SuppressWarnings({\"unchecked\"})\n        Set<Pair<String, String>> hints = (Set<Pair<String, String>>)op.getHints().get(Suggester.Hint.COLL_SHARD);\n        assertNotNull(\"hints\", hints);\n        assertEquals(\"hints\", 1, hints.size());\n        Pair<String, String> p = hints.iterator().next();\n        assertEquals(collectionName, p.first());\n        if (p.second().equals(\"shard1\")) {\n          shard1 = true;\n        } else if (p.second().equals(\"shard2\")) {\n          shard2 = true;\n        } else {\n          fail(\"unexpected shard name \" + p.second());\n        }\n        @SuppressWarnings({\"unchecked\"})\n        Map<String, Object> params = (Map<String, Object>)op.getHints().get(Suggester.Hint.PARAMS);\n        assertNotNull(\"params are null: \" + op, params);\n        \n        // verify overrides for split config\n        assertEquals(\"splitMethod: \" + op, SolrIndexSplitter.SplitMethod.REWRITE.toLower(),\n            params.get(CommonAdminParams.SPLIT_METHOD));\n        assertEquals(\"splitByPrefix: \" + op, true, params.get(CommonAdminParams.SPLIT_BY_PREFIX));\n      }\n      assertTrue(\"shard1 should be split\", shard1);\n      assertTrue(\"shard2 should be split\", shard2);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["a97a72dc16d01fda8ca5c9e0264b3604e30ab539"],"3f504512a03d978990cbff30db0522b354e846db":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"a97a72dc16d01fda8ca5c9e0264b3604e30ab539":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a97a72dc16d01fda8ca5c9e0264b3604e30ab539"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["3f504512a03d978990cbff30db0522b354e846db"],"a97a72dc16d01fda8ca5c9e0264b3604e30ab539":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}