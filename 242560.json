{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws CorruptIndexException, IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory, codec);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getCurrentSegmentFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos(true);\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws CorruptIndexException, IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory, codec);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getCurrentSegmentFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos(true);\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"438e995b4e32916f631722aab36254146830fefb","date":1328903827,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws CorruptIndexException, IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory, codec);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos(true);\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws CorruptIndexException, IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory, codec);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getCurrentSegmentFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos(true);\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws CorruptIndexException, IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos(true);\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws CorruptIndexException, IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory, codec);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos(true);\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws CorruptIndexException, IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws CorruptIndexException, IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos(true);\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws CorruptIndexException, IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws CorruptIndexException, IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory, codec);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos(true);\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws CorruptIndexException, IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":["455aeff4fef915340c5b19d71d5e147034e83093"],"bugIntro":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws CorruptIndexException, IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b47e1512544568a22b82c96169d466fae8a4b79e","date":1354519309,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        segmentInfos.setUserData(pendingCommit.getUserData());\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d793cb4fa803a8c1df6052bc96094cfaae7d86bb","date":1372272532,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        segmentInfos.updateGeneration(pendingCommit);\n        lastCommitChangeCount = pendingCommitChangeCount;\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        segmentInfos.updateGeneration(pendingCommit);\n        lastCommitChangeCount = pendingCommitChangeCount;\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        lastCommitChangeCount = pendingCommitChangeCount;\n        segmentInfos.updateGeneration(pendingCommit);\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666","date":1381263930,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        segmentInfos.updateGeneration(pendingCommit);\n        lastCommitChangeCount = pendingCommitChangeCount;\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        // NOTE: don't use this.checkpoint() here, because\n        // we do not want to increment changeCount:\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        segmentInfos.updateGeneration(pendingCommit);\n        lastCommitChangeCount = pendingCommitChangeCount;\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"203d65f24251ea8106efd122cca89a2a91205ae4","date":1398262565,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        segmentInfos.updateGeneration(pendingCommit);\n        lastCommitChangeCount = pendingCommitChangeCount;\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        // NOTE: don't use this.checkpoint() here, because\n        // we do not want to increment changeCount:\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      }\n      \n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        segmentInfos.updateGeneration(pendingCommit);\n        lastCommitChangeCount = pendingCommitChangeCount;\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        // NOTE: don't use this.checkpoint() here, because\n        // we do not want to increment changeCount:\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        segmentInfos.updateGeneration(pendingCommit);\n        lastCommitChangeCount = pendingCommitChangeCount;\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        // NOTE: don't use this.checkpoint() here, because\n        // we do not want to increment changeCount:\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      }\n      \n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        segmentInfos.updateGeneration(pendingCommit);\n        lastCommitChangeCount = pendingCommitChangeCount;\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        // NOTE: don't use this.checkpoint() here, because\n        // we do not want to increment changeCount:\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cefe924a3b76c22b7df9a075329750871699af6b","date":1409757963,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        segmentInfos.updateGeneration(pendingCommit);\n        lastCommitChangeCount = pendingCommitChangeCount;\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        // NOTE: don't use this.checkpoint() here, because\n        // we do not want to increment changeCount:\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        try {\n          deleter.decRef(filesToCommit);\n        } finally {\n          filesToCommit = null;\n          pendingCommit = null;\n          notifyAll();\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      }\n      \n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        segmentInfos.updateGeneration(pendingCommit);\n        lastCommitChangeCount = pendingCommitChangeCount;\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        // NOTE: don't use this.checkpoint() here, because\n        // we do not want to increment changeCount:\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        deleter.decRef(filesToCommit);\n        filesToCommit = null;\n        pendingCommit = null;\n        notifyAll();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      }\n      \n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":["455aeff4fef915340c5b19d71d5e147034e83093","47d5b6b2c183bf4deaffb52b7cb8dec16c8dcf0f"],"bugIntro":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"949847c0040cd70a68222d526cb0da7bf6cbb3c2","date":1410997182,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private synchronized final void finishCommit() throws IOException {\n\n    boolean success = false;\n    \n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        success = true;\n        // we committed, if anything goes wrong after this: we are screwed\n        try {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n          }\n          segmentInfos.updateGeneration(pendingCommit);\n          lastCommitChangeCount = pendingCommitChangeCount;\n          rollbackSegments = pendingCommit.createBackupSegmentInfos();\n          // NOTE: don't use this.checkpoint() here, because\n          // we do not want to increment changeCount:\n          deleter.checkpoint(pendingCommit, true);\n        } catch (Throwable tragedy) {\n          tragicEvent(tragedy, \"finishCommit\");\n        }\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        try {\n          if (success == false || tragedy == null) {\n            try {\n              deleter.decRef(filesToCommit);\n            } catch (Throwable t) {\n              // if the commit succeeded, we are in screwed state\n              // otherwise, throw our original exception\n              if (success) {\n                tragicEvent(tragedy, \"finishCommit\");\n              }\n            } \n          }\n        } finally {\n          filesToCommit = null;\n          pendingCommit = null;\n          notifyAll();\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      }\n      \n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws IOException {\n\n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n        }\n        segmentInfos.updateGeneration(pendingCommit);\n        lastCommitChangeCount = pendingCommitChangeCount;\n        rollbackSegments = pendingCommit.createBackupSegmentInfos();\n        // NOTE: don't use this.checkpoint() here, because\n        // we do not want to increment changeCount:\n        deleter.checkpoint(pendingCommit, true);\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        try {\n          deleter.decRef(filesToCommit);\n        } finally {\n          filesToCommit = null;\n          pendingCommit = null;\n          notifyAll();\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      }\n      \n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"25e07bf0d9fa18cd8f0185e309d09a873c45017c","date":1411478085,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    boolean finished = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        if (pendingCommit != null) {\n          try {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n            finished = true;\n          } finally {\n            notifyAll();\n            try {\n              if (finished) {\n                // all is good\n                deleter.decRef(filesToCommit);\n              } else if (commitCompleted == false) {\n                // exc happened in finishCommit: not a tragedy\n                deleter.decRefWhileHandlingException(filesToCommit);\n              }\n            } finally {\n              pendingCommit = null;\n              filesToCommit = null;\n            }\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      } else {\n        IOUtils.reThrow(t);\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private synchronized final void finishCommit() throws IOException {\n\n    boolean success = false;\n    \n    if (pendingCommit != null) {\n      try {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n        }\n        pendingCommit.finishCommit(directory);\n        success = true;\n        // we committed, if anything goes wrong after this: we are screwed\n        try {\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + pendingCommit.getSegmentsFileName() + \"\\\"\");\n          }\n          segmentInfos.updateGeneration(pendingCommit);\n          lastCommitChangeCount = pendingCommitChangeCount;\n          rollbackSegments = pendingCommit.createBackupSegmentInfos();\n          // NOTE: don't use this.checkpoint() here, because\n          // we do not want to increment changeCount:\n          deleter.checkpoint(pendingCommit, true);\n        } catch (Throwable tragedy) {\n          tragicEvent(tragedy, \"finishCommit\");\n        }\n      } finally {\n        // Matches the incRef done in prepareCommit:\n        try {\n          if (success == false || tragedy == null) {\n            try {\n              deleter.decRef(filesToCommit);\n            } catch (Throwable t) {\n              // if the commit succeeded, we are in screwed state\n              // otherwise, throw our original exception\n              if (success) {\n                tragicEvent(tragedy, \"finishCommit\");\n              }\n            } \n          }\n        } finally {\n          filesToCommit = null;\n          pendingCommit = null;\n          notifyAll();\n        }\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      }\n      \n    } else {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":["203d65f24251ea8106efd122cca89a2a91205ae4","949847c0040cd70a68222d526cb0da7bf6cbb3c2","4356000e349e38c9fb48034695b7c309abd54557","4d3e8520fd031bab31fd0e4d480e55958bc45efe","c5df35ab57c223ea11aec64b53bf611904f3dced","58c6bbc222f074c844e736e6fb23647e3db9cfe3","455aeff4fef915340c5b19d71d5e147034e83093","cefe924a3b76c22b7df9a075329750871699af6b","47d5b6b2c183bf4deaffb52b7cb8dec16c8dcf0f"],"bugIntro":["e453ee95e5ed4cd001de2d5d3269e25f977980f1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e453ee95e5ed4cd001de2d5d3269e25f977980f1","date":1432836708,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    boolean finished = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        if (pendingCommit != null) {\n          try {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n            finished = true;\n          } finally {\n            notifyAll();\n            try {\n              if (finished) {\n                // all is good\n                deleter.decRef(filesToCommit);\n              } else if (commitCompleted == false) {\n                // exc happened in finishCommit: not a tragedy\n                deleter.decRefWhileHandlingException(filesToCommit);\n              }\n            } finally {\n              pendingCommit = null;\n              filesToCommit = null;\n            }\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      } else {\n        IOUtils.reThrow(t);\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    boolean finished = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        if (pendingCommit != null) {\n          try {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n            finished = true;\n          } finally {\n            notifyAll();\n            try {\n              if (finished) {\n                // all is good\n                deleter.decRef(filesToCommit);\n              } else if (commitCompleted == false) {\n                // exc happened in finishCommit: not a tragedy\n                deleter.decRefWhileHandlingException(filesToCommit);\n              }\n            } finally {\n              pendingCommit = null;\n              filesToCommit = null;\n            }\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      } else {\n        IOUtils.reThrow(t);\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commit: wrote segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9e22bdf0692bfa61e342b04a6ac7078670c1e16","date":1436866730,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    boolean finished = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy);\n        }\n\n        if (pendingCommit != null) {\n          try {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n            finished = true;\n          } finally {\n            notifyAll();\n            try {\n              if (finished) {\n                // all is good\n                deleter.decRef(filesToCommit);\n              } else if (commitCompleted == false) {\n                // exc happened in finishCommit: not a tragedy\n                deleter.decRefWhileHandlingException(filesToCommit);\n              }\n            } finally {\n              pendingCommit = null;\n              filesToCommit = null;\n            }\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      } else {\n        IOUtils.reThrow(t);\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    boolean finished = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        if (pendingCommit != null) {\n          try {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n            finished = true;\n          } finally {\n            notifyAll();\n            try {\n              if (finished) {\n                // all is good\n                deleter.decRef(filesToCommit);\n              } else if (commitCompleted == false) {\n                // exc happened in finishCommit: not a tragedy\n                deleter.decRefWhileHandlingException(filesToCommit);\n              }\n            } finally {\n              pendingCommit = null;\n              filesToCommit = null;\n            }\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      } else {\n        IOUtils.reThrow(t);\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","date":1493374641,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    boolean finished = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy);\n        }\n\n        if (pendingCommit != null) {\n          try {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n            finished = true;\n          } finally {\n            notifyAll();\n            try {\n              if (finished) {\n                // all is good\n                deleter.decRef(filesToCommit);\n              } else if (commitCompleted == false) {\n                // exc happened in finishCommit: not a tragedy\n                deleter.decRefWhileHandlingException(filesToCommit);\n              }\n            } finally {\n              pendingCommit = null;\n              filesToCommit = null;\n            }\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      } else {\n        throw IOUtils.rethrowAlways(t);\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    boolean finished = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy);\n        }\n\n        if (pendingCommit != null) {\n          try {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n            finished = true;\n          } finally {\n            notifyAll();\n            try {\n              if (finished) {\n                // all is good\n                deleter.decRef(filesToCommit);\n              } else if (commitCompleted == false) {\n                // exc happened in finishCommit: not a tragedy\n                deleter.decRefWhileHandlingException(filesToCommit);\n              }\n            } finally {\n              pendingCommit = null;\n              filesToCommit = null;\n            }\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      } else {\n        IOUtils.reThrow(t);\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    boolean finished = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy);\n        }\n\n        if (pendingCommit != null) {\n          try {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n            finished = true;\n          } finally {\n            notifyAll();\n            try {\n              if (finished) {\n                // all is good\n                deleter.decRef(filesToCommit);\n              } else if (commitCompleted == false) {\n                // exc happened in finishCommit: not a tragedy\n                deleter.decRefWhileHandlingException(filesToCommit);\n              }\n            } finally {\n              pendingCommit = null;\n              filesToCommit = null;\n            }\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      } else {\n        throw IOUtils.rethrowAlways(t);\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    boolean finished = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy);\n        }\n\n        if (pendingCommit != null) {\n          try {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n            finished = true;\n          } finally {\n            notifyAll();\n            try {\n              if (finished) {\n                // all is good\n                deleter.decRef(filesToCommit);\n              } else if (commitCompleted == false) {\n                // exc happened in finishCommit: not a tragedy\n                deleter.decRefWhileHandlingException(filesToCommit);\n              }\n            } finally {\n              pendingCommit = null;\n              filesToCommit = null;\n            }\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      } else {\n        IOUtils.reThrow(t);\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    boolean finished = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy.get() != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy.get());\n        }\n\n        if (pendingCommit != null) {\n          try {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n            finished = true;\n          } finally {\n            notifyAll();\n            try {\n              if (finished) {\n                // all is good\n                deleter.decRef(filesToCommit);\n              } else if (commitCompleted == false) {\n                // exc happened in finishCommit: not a tragedy\n                deleter.decRefWhileHandlingException(filesToCommit);\n              }\n            } finally {\n              pendingCommit = null;\n              filesToCommit = null;\n            }\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      }\n      throw t;\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    boolean finished = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy);\n        }\n\n        if (pendingCommit != null) {\n          try {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n            finished = true;\n          } finally {\n            notifyAll();\n            try {\n              if (finished) {\n                // all is good\n                deleter.decRef(filesToCommit);\n              } else if (commitCompleted == false) {\n                // exc happened in finishCommit: not a tragedy\n                deleter.decRefWhileHandlingException(filesToCommit);\n              }\n            } finally {\n              pendingCommit = null;\n              filesToCommit = null;\n            }\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      } else {\n        throw IOUtils.rethrowAlways(t);\n      }\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb04d6a79e860154f2a1c519790fc42f5a792915","date":1521621668,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy.get() != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy.get());\n        }\n\n        if (pendingCommit != null) {\n          final Collection<String> commitFiles = this.filesToCommit;\n          try (Closeable finalizer = () -> deleter.decRef(commitFiles)) {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n          } finally {\n            notifyAll();\n            pendingCommit = null;\n            this.filesToCommit = null;\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      }\n      throw t;\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    boolean finished = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy.get() != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy.get());\n        }\n\n        if (pendingCommit != null) {\n          try {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n            finished = true;\n          } finally {\n            notifyAll();\n            try {\n              if (finished) {\n                // all is good\n                deleter.decRef(filesToCommit);\n              } else if (commitCompleted == false) {\n                // exc happened in finishCommit: not a tragedy\n                deleter.decRefWhileHandlingException(filesToCommit);\n              }\n            } finally {\n              pendingCommit = null;\n              filesToCommit = null;\n            }\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      }\n      throw t;\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","date":1521731438,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy.get() != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy.get());\n        }\n\n        if (pendingCommit != null) {\n          final Collection<String> commitFiles = this.filesToCommit;\n          try (Closeable finalizer = () -> deleter.decRef(commitFiles)) {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n          } finally {\n            notifyAll();\n            pendingCommit = null;\n            this.filesToCommit = null;\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      }\n      throw t;\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    boolean finished = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy.get() != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy.get());\n        }\n\n        if (pendingCommit != null) {\n          try {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n            finished = true;\n          } finally {\n            notifyAll();\n            try {\n              if (finished) {\n                // all is good\n                deleter.decRef(filesToCommit);\n              } else if (commitCompleted == false) {\n                // exc happened in finishCommit: not a tragedy\n                deleter.decRefWhileHandlingException(filesToCommit);\n              }\n            } finally {\n              pendingCommit = null;\n              filesToCommit = null;\n            }\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      }\n      throw t;\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e165dc2e339428ed06c118109d99acf35e8240de","date":1523200521,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  @SuppressWarnings(\"try\")\n  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy.get() != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy.get());\n        }\n\n        if (pendingCommit != null) {\n          final Collection<String> commitFiles = this.filesToCommit;\n          try (Closeable finalizer = () -> deleter.decRef(commitFiles)) {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n          } finally {\n            notifyAll();\n            pendingCommit = null;\n            this.filesToCommit = null;\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      }\n      throw t;\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy.get() != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy.get());\n        }\n\n        if (pendingCommit != null) {\n          final Collection<String> commitFiles = this.filesToCommit;\n          try (Closeable finalizer = () -> deleter.decRef(commitFiles)) {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n          } finally {\n            notifyAll();\n            pendingCommit = null;\n            this.filesToCommit = null;\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      }\n      throw t;\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58e44159788900f4a2113b84463dc3fbbf80f20","date":1523319203,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  @SuppressWarnings(\"try\")\n  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy.get() != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy.get());\n        }\n\n        if (pendingCommit != null) {\n          final Collection<String> commitFiles = this.filesToCommit;\n          try (Closeable finalizer = () -> deleter.decRef(commitFiles)) {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n          } finally {\n            notifyAll();\n            pendingCommit = null;\n            this.filesToCommit = null;\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      }\n      throw t;\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy.get() != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy.get());\n        }\n\n        if (pendingCommit != null) {\n          final Collection<String> commitFiles = this.filesToCommit;\n          try (Closeable finalizer = () -> deleter.decRef(commitFiles)) {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n          } finally {\n            notifyAll();\n            pendingCommit = null;\n            this.filesToCommit = null;\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      }\n      throw t;\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2178aefcd4690bd53785e9673e2c918cdb64165","date":1587583605,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#finishCommit().mjava","sourceNew":"  @SuppressWarnings(\"try\")\n  private void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy.get() != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy.get());\n        }\n\n        if (pendingCommit != null) {\n          final Collection<String> commitFiles = this.filesToCommit;\n          try (Closeable finalizer = () -> deleter.decRef(commitFiles)) {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n          } finally {\n            notifyAll();\n            pendingCommit = null;\n            this.filesToCommit = null;\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      }\n      throw t;\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"try\")\n  private final void finishCommit() throws IOException {\n\n    boolean commitCompleted = false;\n    String committedSegmentsFileName = null;\n\n    try {\n      synchronized(this) {\n        ensureOpen(false);\n\n        if (tragedy.get() != null) {\n          throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete commit\", tragedy.get());\n        }\n\n        if (pendingCommit != null) {\n          final Collection<String> commitFiles = this.filesToCommit;\n          try (Closeable finalizer = () -> deleter.decRef(commitFiles)) {\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: pendingCommit != null\");\n            }\n\n            committedSegmentsFileName = pendingCommit.finishCommit(directory);\n\n            // we committed, if anything goes wrong after this, we are screwed and it's a tragedy:\n            commitCompleted = true;\n\n            if (infoStream.isEnabled(\"IW\")) {\n              infoStream.message(\"IW\", \"commit: done writing segments file \\\"\" + committedSegmentsFileName + \"\\\"\");\n            }\n\n            // NOTE: don't use this.checkpoint() here, because\n            // we do not want to increment changeCount:\n            deleter.checkpoint(pendingCommit, true);\n\n            // Carry over generation to our master SegmentInfos:\n            segmentInfos.updateGeneration(pendingCommit);\n\n            lastCommitChangeCount = pendingCommitChangeCount;\n            rollbackSegments = pendingCommit.createBackupSegmentInfos();\n\n          } finally {\n            notifyAll();\n            pendingCommit = null;\n            this.filesToCommit = null;\n          }\n        } else {\n          assert filesToCommit == null;\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"commit: pendingCommit == null; skip\");\n          }\n        }\n      }\n    } catch (Throwable t) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"hit exception during finishCommit: \" + t.getMessage());\n      }\n      if (commitCompleted) {\n        tragicEvent(t, \"finishCommit\");\n      }\n      throw t;\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", String.format(Locale.ROOT, \"commit: took %.1f msec\", (System.nanoTime()-startCommitTime)/1000000.0));\n      infoStream.message(\"IW\", \"commit: done\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d793cb4fa803a8c1df6052bc96094cfaae7d86bb":["b47e1512544568a22b82c96169d466fae8a4b79e"],"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["845b760a99e5f369fcd0a5d723a87b8def6a3f56","bb04d6a79e860154f2a1c519790fc42f5a792915"],"e165dc2e339428ed06c118109d99acf35e8240de":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["b47e1512544568a22b82c96169d466fae8a4b79e","d793cb4fa803a8c1df6052bc96094cfaae7d86bb"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e453ee95e5ed4cd001de2d5d3269e25f977980f1":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","e165dc2e339428ed06c118109d99acf35e8240de"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16","97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"4356000e349e38c9fb48034695b7c309abd54557":["438e995b4e32916f631722aab36254146830fefb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"25e07bf0d9fa18cd8f0185e309d09a873c45017c":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"bb04d6a79e860154f2a1c519790fc42f5a792915":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["cefe924a3b76c22b7df9a075329750871699af6b"],"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666":["d793cb4fa803a8c1df6052bc96094cfaae7d86bb"],"203d65f24251ea8106efd122cca89a2a91205ae4":["8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666","203d65f24251ea8106efd122cca89a2a91205ae4"],"cefe924a3b76c22b7df9a075329750871699af6b":["203d65f24251ea8106efd122cca89a2a91205ae4"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["4356000e349e38c9fb48034695b7c309abd54557"],"407687e67faf6e1f02a211ca078d8e3eed631027":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","b47e1512544568a22b82c96169d466fae8a4b79e"],"d2178aefcd4690bd53785e9673e2c918cdb64165":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["e453ee95e5ed4cd001de2d5d3269e25f977980f1"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["438e995b4e32916f631722aab36254146830fefb","9d153abcf92dc5329d98571a8c3035df9bd80648"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"b47e1512544568a22b82c96169d466fae8a4b79e":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"438e995b4e32916f631722aab36254146830fefb":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d2178aefcd4690bd53785e9673e2c918cdb64165"]},"commit2Childs":{"d793cb4fa803a8c1df6052bc96094cfaae7d86bb":["37a0f60745e53927c4c876cfe5b5a58170f0646c","8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666"],"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["e165dc2e339428ed06c118109d99acf35e8240de","d58e44159788900f4a2113b84463dc3fbbf80f20"],"e165dc2e339428ed06c118109d99acf35e8240de":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","bb04d6a79e860154f2a1c519790fc42f5a792915"],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["845b760a99e5f369fcd0a5d723a87b8def6a3f56","e9017cf144952056066919f1ebc7897ff9bd71b1"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["438e995b4e32916f631722aab36254146830fefb"],"e453ee95e5ed4cd001de2d5d3269e25f977980f1":["d9e22bdf0692bfa61e342b04a6ac7078670c1e16"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["d2178aefcd4690bd53785e9673e2c918cdb64165"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"4356000e349e38c9fb48034695b7c309abd54557":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"bb04d6a79e860154f2a1c519790fc42f5a792915":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"25e07bf0d9fa18cd8f0185e309d09a873c45017c":["e453ee95e5ed4cd001de2d5d3269e25f977980f1"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["407687e67faf6e1f02a211ca078d8e3eed631027","fe33227f6805edab2036cbb80645cc4e2d1fa424","b47e1512544568a22b82c96169d466fae8a4b79e"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["25e07bf0d9fa18cd8f0185e309d09a873c45017c"],"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666":["203d65f24251ea8106efd122cca89a2a91205ae4","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe"],"203d65f24251ea8106efd122cca89a2a91205ae4":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","cefe924a3b76c22b7df9a075329750871699af6b"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"cefe924a3b76c22b7df9a075329750871699af6b":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"d2178aefcd4690bd53785e9673e2c918cdb64165":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d9e22bdf0692bfa61e342b04a6ac7078670c1e16":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","e9017cf144952056066919f1ebc7897ff9bd71b1"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"b47e1512544568a22b82c96169d466fae8a4b79e":["d793cb4fa803a8c1df6052bc96094cfaae7d86bb","37a0f60745e53927c4c876cfe5b5a58170f0646c","407687e67faf6e1f02a211ca078d8e3eed631027"],"438e995b4e32916f631722aab36254146830fefb":["4356000e349e38c9fb48034695b7c309abd54557","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","e9017cf144952056066919f1ebc7897ff9bd71b1","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","407687e67faf6e1f02a211ca078d8e3eed631027","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}