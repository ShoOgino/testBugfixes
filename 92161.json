{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","commits":[{"id":"58b93c361b4f6fe193e84bfd27ea523366eada52","date":1490100167,"type":1,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (fcontext.facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)fcontext.facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8908009aaa8e9318b455c1c22b83e0e87738228a","date":1490280013,"type":1,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (fcontext.facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)fcontext.facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ab027bdfe663227636ccbeda13ae82add302939","date":1529980633,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n      }\n\n      Object result = subRequest.process(subContext);\n\n      response.add( sub.getKey(), result);\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n      }\n\n      Object result = subRequest.process(subContext);\n\n      response.add( sub.getKey(), result);\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n      }\n\n      Object result = subRequest.process(subContext);\n\n      response.add( sub.getKey(), result);\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n      FacetProcessor subProcessor = subRequest.createFacetProcessor(subContext);\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n\n        fdebug.setReqDescription(subRequest.getFacetDescription());\n        fdebug.setProcessor(subProcessor.getClass().getSimpleName());\n        if (subContext.filter != null) fdebug.setFilter(subContext.filter.toString());\n\n        final RTimer timer = new RTimer();\n        subProcessor.process();\n        long timeElapsed = (long) timer.getTime();\n        fdebug.setElapse(timeElapsed);\n        fdebug.putInfoItem(\"domainSize\", (long)subContext.base.size());\n      } else {\n        subProcessor.process();\n      }\n\n      response.add( sub.getKey(), subProcessor.getResponse() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"248f6ecc900c3a5633fd5ca6f564ea8b717720da","date":1588863846,"type":3,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","sourceNew":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetRequest.FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetRequest.FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n      }\n\n      Object result = subRequest.process(subContext);\n\n      response.add( sub.getKey(), result);\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n      }\n\n      Object result = subRequest.process(subContext);\n\n      response.add( sub.getKey(), result);\n    }\n  }\n\n","bugFix":["faf1236ae092482293a7e0659e347d172185ef6f","8ec805ca8fedc0166461148c7182f1bcbbd18ee1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56a9893014b284af4d1af451e6c02e7ffdf5b6e","date":1590065972,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#processSubs(SimpleOrderedMap[Object],Query,DocSet,boolean,Map[String,Object]).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n      }\n\n      Object result = subRequest.process(subContext);\n\n      response.add( sub.getKey(), result);\n    }\n  }\n\n","sourceOld":"  void processSubs(SimpleOrderedMap<Object> response, Query filter, DocSet domain, boolean skip, Map<String,Object> facetInfo) throws IOException {\n\n    boolean emptyDomain = domain == null || domain.size() == 0;\n\n    for (Map.Entry<String,FacetRequest> sub : freq.getSubFacets().entrySet()) {\n      FacetRequest subRequest = sub.getValue();\n\n      // This includes a static check if a sub-facet can possibly produce something from\n      // an empty domain.  Should this be changed to a dynamic check as well?  That would\n      // probably require actually executing the facet anyway, and dropping it at the\n      // end if it was unproductive.\n      if (emptyDomain && !freq.processEmpty && !subRequest.canProduceFromEmpty()) {\n        continue;\n      }\n\n      Map<String,Object>facetInfoSub = null;\n      if (facetInfo != null) {\n        facetInfoSub = (Map<String,Object>)facetInfo.get(sub.getKey());\n      }\n\n      // If we're skipping this node, then we only need to process sub-facets that have facet info specified.\n      if (skip && facetInfoSub == null) continue;\n\n      // make a new context for each sub-facet since they can change the domain\n      FacetRequest.FacetContext subContext = fcontext.sub(filter, domain);\n      subContext.facetInfo = facetInfoSub;\n      if (!skip) subContext.flags &= ~FacetRequest.FacetContext.SKIP_FACET;  // turn off the skip flag if we're not skipping this bucket\n\n      if (fcontext.getDebugInfo() != null) {   // if fcontext.debugInfo != null, it means rb.debug() == true\n        FacetDebugInfo fdebug = new FacetDebugInfo();\n        subContext.setDebugInfo(fdebug);\n        fcontext.getDebugInfo().addChild(fdebug);\n      }\n\n      Object result = subRequest.process(subContext);\n\n      response.add( sub.getKey(), result);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2ab027bdfe663227636ccbeda13ae82add302939":["58b93c361b4f6fe193e84bfd27ea523366eada52"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"58b93c361b4f6fe193e84bfd27ea523366eada52":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["58b93c361b4f6fe193e84bfd27ea523366eada52","2ab027bdfe663227636ccbeda13ae82add302939"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["2ab027bdfe663227636ccbeda13ae82add302939"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8908009aaa8e9318b455c1c22b83e0e87738228a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["58b93c361b4f6fe193e84bfd27ea523366eada52","2ab027bdfe663227636ccbeda13ae82add302939"]},"commit2Childs":{"2ab027bdfe663227636ccbeda13ae82add302939":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","248f6ecc900c3a5633fd5ca6f564ea8b717720da","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"58b93c361b4f6fe193e84bfd27ea523366eada52":["2ab027bdfe663227636ccbeda13ae82add302939","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["58b93c361b4f6fe193e84bfd27ea523366eada52","8908009aaa8e9318b455c1c22b83e0e87738228a"],"8908009aaa8e9318b455c1c22b83e0e87738228a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","8908009aaa8e9318b455c1c22b83e0e87738228a","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}