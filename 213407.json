{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock(Thread,DocumentsWriter).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock(Thread,DocumentsWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock(Thread,DocumentsWriter).mjava","sourceNew":"  public abstract ThreadState getAndLock(Thread requestingThread, DocumentsWriter documentsWriter);\n\n","sourceOld":"  public abstract ThreadState getAndLock(Thread requestingThread, DocumentsWriter documentsWriter);\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94b3b94bf2ad869ca54992ccbf5ca4f6c525c46f","date":1335146295,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock(Thread,DocumentsWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock(Thread,DocumentsWriter).mjava","sourceNew":"  // you cannot subclass this without being in o.a.l.index package anyway, so\n  // the class is already pkg-private... fix me: see LUCENE-4013\n  abstract ThreadState getAndLock(Thread requestingThread, DocumentsWriter documentsWriter);\n\n","sourceOld":"  public abstract ThreadState getAndLock(Thread requestingThread, DocumentsWriter documentsWriter);\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"839ca1793cd9a8eb5bd7c7c62918192d47972f73","date":1399544004,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock(Thread,DocumentsWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock(Thread,DocumentsWriter).mjava","sourceNew":"  /** This method is used by DocumentsWriter/FlushControl to obtain a ThreadState to do an indexing operation (add/updateDocument). */\n  ThreadState getAndLock(Thread requestingThread, DocumentsWriter documentsWriter) {\n    ThreadState threadState = null;\n    synchronized (this) {\n      while (true) {\n        if (freeCount > 0) {\n          // Important that we are LIFO here! This way if number of concurrent indexing threads was once high, but has now reduced, we only use a\n          // limited number of thread states:\n          threadState = freeList[freeCount-1];\n          freeCount--;\n          break;\n        } else if (numThreadStatesActive < threadStates.length) {\n          // ThreadState is already locked before return by this method:\n          return newThreadState();\n        } else {\n          // Wait until a thread state frees up:\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n      }\n    }\n\n    // This could take time, e.g. if the threadState is [briefly] checked for flushing:\n    threadState.lock();\n\n    return threadState;\n  }\n\n","sourceOld":"  // you cannot subclass this without being in o.a.l.index package anyway, so\n  // the class is already pkg-private... fix me: see LUCENE-4013\n  abstract ThreadState getAndLock(Thread requestingThread, DocumentsWriter documentsWriter);\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"925e350e1b939d6381c12c2d73ce20aa438d482c","date":1399678506,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock(Thread,DocumentsWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock(Thread,DocumentsWriter).mjava","sourceNew":"  /** This method is used by DocumentsWriter/FlushControl to obtain a ThreadState to do an indexing operation (add/updateDocument). */\n  ThreadState getAndLock(Thread requestingThread, DocumentsWriter documentsWriter) {\n    ThreadState threadState = null;\n    synchronized (this) {\n      while (true) {\n        if (freeCount > 0) {\n          // Important that we are LIFO here! This way if number of concurrent indexing threads was once high, but has now reduced, we only use a\n          // limited number of thread states:\n          threadState = freeList[freeCount-1];\n\n          if (threadState.dwpt == null) {\n            // This thread-state is not initialized, e.g. it\n            // was just flushed. See if we can instead find\n            // another free thread state that already has docs\n            // indexed. This way if incoming thread concurrency\n            // has decreased, we don't leave docs\n            // indefinitely buffered, tying up RAM.  This\n            // will instead get those thread states flushed,\n            // freeing up RAM for larger segment flushes:\n            for(int i=0;i<freeCount;i++) {\n              if (freeList[i].dwpt != null) {\n                // Use this one instead, and swap it with\n                // the un-initialized one:\n                ThreadState ts = freeList[i];\n                freeList[i] = threadState;\n                threadState = ts;\n                break;\n              }\n            }\n          }\n          freeCount--;\n          break;\n        } else if (numThreadStatesActive < threadStates.length) {\n          // ThreadState is already locked before return by this method:\n          return newThreadState();\n        } else {\n          // Wait until a thread state frees up:\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n      }\n    }\n\n    // This could take time, e.g. if the threadState is [briefly] checked for flushing:\n    threadState.lock();\n\n    return threadState;\n  }\n\n","sourceOld":"  /** This method is used by DocumentsWriter/FlushControl to obtain a ThreadState to do an indexing operation (add/updateDocument). */\n  ThreadState getAndLock(Thread requestingThread, DocumentsWriter documentsWriter) {\n    ThreadState threadState = null;\n    synchronized (this) {\n      while (true) {\n        if (freeCount > 0) {\n          // Important that we are LIFO here! This way if number of concurrent indexing threads was once high, but has now reduced, we only use a\n          // limited number of thread states:\n          threadState = freeList[freeCount-1];\n          freeCount--;\n          break;\n        } else if (numThreadStatesActive < threadStates.length) {\n          // ThreadState is already locked before return by this method:\n          return newThreadState();\n        } else {\n          // Wait until a thread state frees up:\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n      }\n    }\n\n    // This could take time, e.g. if the threadState is [briefly] checked for flushing:\n    threadState.lock();\n\n    return threadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c02b804ab16489b95429791a2d8fb0e0728354d4","date":1436551798,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock(Thread,DocumentsWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock(Thread,DocumentsWriter).mjava","sourceNew":"  /** This method is used by DocumentsWriter/FlushControl to obtain a ThreadState to do an indexing operation (add/updateDocument). */\n  ThreadState getAndLock(Thread requestingThread, DocumentsWriter documentsWriter) {\n    ThreadState threadState = null;\n    synchronized (this) {\n      if (freeList.isEmpty()) {\n        // ThreadState is already locked before return by this method:\n        return newThreadState();\n      } else {\n        // Important that we are LIFO here! This way if number of concurrent indexing threads was once high, but has now reduced, we only use a\n        // limited number of thread states:\n        threadState = freeList.remove(freeList.size()-1);\n\n        if (threadState.dwpt == null) {\n          // This thread-state is not initialized, e.g. it\n          // was just flushed. See if we can instead find\n          // another free thread state that already has docs\n          // indexed. This way if incoming thread concurrency\n          // has decreased, we don't leave docs\n          // indefinitely buffered, tying up RAM.  This\n          // will instead get those thread states flushed,\n          // freeing up RAM for larger segment flushes:\n          for(int i=0;i<freeList.size();i++) {\n            ThreadState ts = freeList.get(i);\n            if (ts.dwpt != null) {\n              // Use this one instead, and swap it with\n              // the un-initialized one:\n              freeList.set(i, threadState);\n              threadState = ts;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // This could take time, e.g. if the threadState is [briefly] checked for flushing:\n    threadState.lock();\n\n    return threadState;\n  }\n\n","sourceOld":"  /** This method is used by DocumentsWriter/FlushControl to obtain a ThreadState to do an indexing operation (add/updateDocument). */\n  ThreadState getAndLock(Thread requestingThread, DocumentsWriter documentsWriter) {\n    ThreadState threadState = null;\n    synchronized (this) {\n      while (true) {\n        if (freeCount > 0) {\n          // Important that we are LIFO here! This way if number of concurrent indexing threads was once high, but has now reduced, we only use a\n          // limited number of thread states:\n          threadState = freeList[freeCount-1];\n\n          if (threadState.dwpt == null) {\n            // This thread-state is not initialized, e.g. it\n            // was just flushed. See if we can instead find\n            // another free thread state that already has docs\n            // indexed. This way if incoming thread concurrency\n            // has decreased, we don't leave docs\n            // indefinitely buffered, tying up RAM.  This\n            // will instead get those thread states flushed,\n            // freeing up RAM for larger segment flushes:\n            for(int i=0;i<freeCount;i++) {\n              if (freeList[i].dwpt != null) {\n                // Use this one instead, and swap it with\n                // the un-initialized one:\n                ThreadState ts = freeList[i];\n                freeList[i] = threadState;\n                threadState = ts;\n                break;\n              }\n            }\n          }\n          freeCount--;\n          break;\n        } else if (numThreadStatesActive < threadStates.length) {\n          // ThreadState is already locked before return by this method:\n          return newThreadState();\n        } else {\n          // Wait until a thread state frees up:\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n      }\n    }\n\n    // This could take time, e.g. if the threadState is [briefly] checked for flushing:\n    threadState.lock();\n\n    return threadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee67a99e7e36da49a4b68758a01d1ac09ff5472c","date":1547653069,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool#getAndLock(Thread,DocumentsWriter).mjava","sourceNew":"  /** This method is used by DocumentsWriter/FlushControl to obtain a ThreadState to do an indexing operation (add/updateDocument). */\n  ThreadState getAndLock() {\n    ThreadState threadState = null;\n    synchronized (this) {\n      if (freeList.isEmpty()) {\n        // ThreadState is already locked before return by this method:\n        return newThreadState();\n      } else {\n        // Important that we are LIFO here! This way if number of concurrent indexing threads was once high, but has now reduced, we only use a\n        // limited number of thread states:\n        threadState = freeList.remove(freeList.size()-1);\n\n        if (threadState.dwpt == null) {\n          // This thread-state is not initialized, e.g. it\n          // was just flushed. See if we can instead find\n          // another free thread state that already has docs\n          // indexed. This way if incoming thread concurrency\n          // has decreased, we don't leave docs\n          // indefinitely buffered, tying up RAM.  This\n          // will instead get those thread states flushed,\n          // freeing up RAM for larger segment flushes:\n          for(int i=0;i<freeList.size();i++) {\n            ThreadState ts = freeList.get(i);\n            if (ts.dwpt != null) {\n              // Use this one instead, and swap it with\n              // the un-initialized one:\n              freeList.set(i, threadState);\n              threadState = ts;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // This could take time, e.g. if the threadState is [briefly] checked for flushing:\n    threadState.lock();\n\n    return threadState;\n  }\n\n","sourceOld":"  /** This method is used by DocumentsWriter/FlushControl to obtain a ThreadState to do an indexing operation (add/updateDocument). */\n  ThreadState getAndLock(Thread requestingThread, DocumentsWriter documentsWriter) {\n    ThreadState threadState = null;\n    synchronized (this) {\n      if (freeList.isEmpty()) {\n        // ThreadState is already locked before return by this method:\n        return newThreadState();\n      } else {\n        // Important that we are LIFO here! This way if number of concurrent indexing threads was once high, but has now reduced, we only use a\n        // limited number of thread states:\n        threadState = freeList.remove(freeList.size()-1);\n\n        if (threadState.dwpt == null) {\n          // This thread-state is not initialized, e.g. it\n          // was just flushed. See if we can instead find\n          // another free thread state that already has docs\n          // indexed. This way if incoming thread concurrency\n          // has decreased, we don't leave docs\n          // indefinitely buffered, tying up RAM.  This\n          // will instead get those thread states flushed,\n          // freeing up RAM for larger segment flushes:\n          for(int i=0;i<freeList.size();i++) {\n            ThreadState ts = freeList.get(i);\n            if (ts.dwpt != null) {\n              // Use this one instead, and swap it with\n              // the un-initialized one:\n              freeList.set(i, threadState);\n              threadState = ts;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // This could take time, e.g. if the threadState is [briefly] checked for flushing:\n    threadState.lock();\n\n    return threadState;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"839ca1793cd9a8eb5bd7c7c62918192d47972f73":["94b3b94bf2ad869ca54992ccbf5ca4f6c525c46f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"925e350e1b939d6381c12c2d73ce20aa438d482c":["839ca1793cd9a8eb5bd7c7c62918192d47972f73"],"94b3b94bf2ad869ca54992ccbf5ca4f6c525c46f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ee67a99e7e36da49a4b68758a01d1ac09ff5472c":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ee67a99e7e36da49a4b68758a01d1ac09ff5472c"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["925e350e1b939d6381c12c2d73ce20aa438d482c"]},"commit2Childs":{"839ca1793cd9a8eb5bd7c7c62918192d47972f73":["925e350e1b939d6381c12c2d73ce20aa438d482c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["94b3b94bf2ad869ca54992ccbf5ca4f6c525c46f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"94b3b94bf2ad869ca54992ccbf5ca4f6c525c46f":["839ca1793cd9a8eb5bd7c7c62918192d47972f73"],"925e350e1b939d6381c12c2d73ce20aa438d482c":["c02b804ab16489b95429791a2d8fb0e0728354d4"],"ee67a99e7e36da49a4b68758a01d1ac09ff5472c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c02b804ab16489b95429791a2d8fb0e0728354d4":["ee67a99e7e36da49a4b68758a01d1ac09ff5472c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}