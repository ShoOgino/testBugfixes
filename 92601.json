{"path":"src/java/org/apache/solr/search/QueryParsing#parseLocalParams(String,int,Map[String,String],SolrParams).mjava","commits":[{"id":"66ab3886c1d845c59c9e5b23b2fb247b927db498","date":1193060587,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseLocalParams(String,int,Map[String,String],SolrParams).mjava","pathOld":"/dev/null","sourceNew":"  // note to self: something needs to detect infinite recursion when parsing queries\n  static int parseLocalParams(String txt, int start, Map<String,String> target, SolrParams params) throws ParseException {\n    int off=start;\n    if (!txt.startsWith(\"<!\",off)) return start;\n    StrParser p = new StrParser(txt,start,txt.length());\n    p.pos+=2; // skip over \"<!\"\n\n    for(;;) {\n      /*\n      if (p.pos>=txt.length()) {\n        throw new ParseException(\"Missing '>' parsing local params '\" + txt + '\"');\n      }\n      */\n      char ch = p.peek();\n      if (ch=='>') {\n        return p.pos+1;\n      }\n\n      String id = p.getId();\n      if (id.length()==0) {\n        throw new ParseException(\"Expected identifier '>' parsing local params '\" + txt + '\"');\n\n      }\n      String val=null;\n\n      ch = p.peek();\n      if (ch!='=') {\n        // single word... treat <!func> as \"\"=func for easy lookup\n        val = id;\n        id = TYPE;\n      } else {\n        // saw equals, so read value\n        p.pos++;\n        ch = p.peek();\n        if (ch=='\\\"' || ch=='\\'') {\n          val = p.getQuotedString();\n        } else if (ch=='$') {\n          p.pos++;\n          // dereference parameter\n          String pname = p.getId();\n          if (params!=null) {\n            val = params.get(pname);\n          }\n        } else {\n          // read unquoted literal ended by whitespace or '>'\n          // there is no escaping.\n          int valStart = p.pos;\n          for (;;) {\n            if (p.pos >= p.end) {\n              throw new ParseException(\"Missing end to unquoted value starting at \" + valStart + \" str='\" + txt +\"'\");\n            }\n            char c = p.val.charAt(p.pos);\n            if (c=='>' || Character.isWhitespace(c)) {\n              val = p.val.substring(valStart, p.pos);\n              break;\n            }\n            p.pos++;\n          }\n        }\n      }\n      if (target != null) target.put(id,val);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ed9977f1cdec244969bc4f5054a6041028238bf","date":1209503245,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseLocalParams(String,int,Map[String,String],SolrParams).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseLocalParams(String,int,Map[String,String],SolrParams).mjava","sourceNew":"  // note to self: something needs to detect infinite recursion when parsing queries\n  static int parseLocalParams(String txt, int start, Map<String,String> target, SolrParams params) throws ParseException {\n    int off=start;\n    if (!txt.startsWith(LOCALPARAM_START,off)) return start;\n    StrParser p = new StrParser(txt,start,txt.length());\n    p.pos+=2; // skip over \"{!\"\n\n    for(;;) {\n      /*\n      if (p.pos>=txt.length()) {\n        throw new ParseException(\"Missing '}' parsing local params '\" + txt + '\"');\n      }\n      */\n      char ch = p.peek();\n      if (ch==LOCALPARAM_END) {\n        return p.pos+1;\n      }\n\n      String id = p.getId();\n      if (id.length()==0) {\n        throw new ParseException(\"Expected identifier '}' parsing local params '\" + txt + '\"');\n\n      }\n      String val=null;\n\n      ch = p.peek();\n      if (ch!='=') {\n        // single word... treat {!func} as type=func for easy lookup\n        val = id;\n        id = TYPE;\n      } else {\n        // saw equals, so read value\n        p.pos++;\n        ch = p.peek();\n        if (ch=='\\\"' || ch=='\\'') {\n          val = p.getQuotedString();\n        } else if (ch=='$') {\n          p.pos++;\n          // dereference parameter\n          String pname = p.getId();\n          if (params!=null) {\n            val = params.get(pname);\n          }\n        } else {\n          // read unquoted literal ended by whitespace or '}'\n          // there is no escaping.\n          int valStart = p.pos;\n          for (;;) {\n            if (p.pos >= p.end) {\n              throw new ParseException(\"Missing end to unquoted value starting at \" + valStart + \" str='\" + txt +\"'\");\n            }\n            char c = p.val.charAt(p.pos);\n            if (c==LOCALPARAM_END || Character.isWhitespace(c)) {\n              val = p.val.substring(valStart, p.pos);\n              break;\n            }\n            p.pos++;\n          }\n        }\n      }\n      if (target != null) target.put(id,val);\n    }\n  }\n\n","sourceOld":"  // note to self: something needs to detect infinite recursion when parsing queries\n  static int parseLocalParams(String txt, int start, Map<String,String> target, SolrParams params) throws ParseException {\n    int off=start;\n    if (!txt.startsWith(\"<!\",off)) return start;\n    StrParser p = new StrParser(txt,start,txt.length());\n    p.pos+=2; // skip over \"<!\"\n\n    for(;;) {\n      /*\n      if (p.pos>=txt.length()) {\n        throw new ParseException(\"Missing '>' parsing local params '\" + txt + '\"');\n      }\n      */\n      char ch = p.peek();\n      if (ch=='>') {\n        return p.pos+1;\n      }\n\n      String id = p.getId();\n      if (id.length()==0) {\n        throw new ParseException(\"Expected identifier '>' parsing local params '\" + txt + '\"');\n\n      }\n      String val=null;\n\n      ch = p.peek();\n      if (ch!='=') {\n        // single word... treat <!func> as \"\"=func for easy lookup\n        val = id;\n        id = TYPE;\n      } else {\n        // saw equals, so read value\n        p.pos++;\n        ch = p.peek();\n        if (ch=='\\\"' || ch=='\\'') {\n          val = p.getQuotedString();\n        } else if (ch=='$') {\n          p.pos++;\n          // dereference parameter\n          String pname = p.getId();\n          if (params!=null) {\n            val = params.get(pname);\n          }\n        } else {\n          // read unquoted literal ended by whitespace or '>'\n          // there is no escaping.\n          int valStart = p.pos;\n          for (;;) {\n            if (p.pos >= p.end) {\n              throw new ParseException(\"Missing end to unquoted value starting at \" + valStart + \" str='\" + txt +\"'\");\n            }\n            char c = p.val.charAt(p.pos);\n            if (c=='>' || Character.isWhitespace(c)) {\n              val = p.val.substring(valStart, p.pos);\n              break;\n            }\n            p.pos++;\n          }\n        }\n      }\n      if (target != null) target.put(id,val);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"32ef722831135736529762b4b97a13dd58b06f66","date":1260567610,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/search/QueryParsing#parseLocalParams(String,int,Map[String,String],SolrParams).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseLocalParams(String,int,Map[String,String],SolrParams).mjava","sourceNew":"  // note to self: something needs to detect infinite recursion when parsing queries\n  static int parseLocalParams(String txt, int start, Map<String, String> target, SolrParams params) throws ParseException {\n    int off = start;\n    if (!txt.startsWith(LOCALPARAM_START, off)) return start;\n    StrParser p = new StrParser(txt, start, txt.length());\n    p.pos += 2; // skip over \"{!\"\n\n    for (; ;) {\n      /*\n      if (p.pos>=txt.length()) {\n        throw new ParseException(\"Missing '}' parsing local params '\" + txt + '\"');\n      }\n      */\n      char ch = p.peek();\n      if (ch == LOCALPARAM_END) {\n        return p.pos + 1;\n      }\n\n      String id = p.getId();\n      if (id.length() == 0) {\n        throw new ParseException(\"Expected identifier '}' parsing local params '\" + txt + '\"');\n\n      }\n      String val = null;\n\n      ch = p.peek();\n      if (ch != '=') {\n        // single word... treat {!func} as type=func for easy lookup\n        val = id;\n        id = TYPE;\n      } else {\n        // saw equals, so read value\n        p.pos++;\n        ch = p.peek();\n        if (ch == '\\\"' || ch == '\\'') {\n          val = p.getQuotedString();\n        } else if (ch == '$') {\n          p.pos++;\n          // dereference parameter\n          String pname = p.getId();\n          if (params != null) {\n            val = params.get(pname);\n          }\n        } else {\n          // read unquoted literal ended by whitespace or '}'\n          // there is no escaping.\n          int valStart = p.pos;\n          for (; ;) {\n            if (p.pos >= p.end) {\n              throw new ParseException(\"Missing end to unquoted value starting at \" + valStart + \" str='\" + txt + \"'\");\n            }\n            char c = p.val.charAt(p.pos);\n            if (c == LOCALPARAM_END || Character.isWhitespace(c)) {\n              val = p.val.substring(valStart, p.pos);\n              break;\n            }\n            p.pos++;\n          }\n        }\n      }\n      if (target != null) target.put(id, val);\n    }\n  }\n\n","sourceOld":"  // note to self: something needs to detect infinite recursion when parsing queries\n  static int parseLocalParams(String txt, int start, Map<String,String> target, SolrParams params) throws ParseException {\n    int off=start;\n    if (!txt.startsWith(LOCALPARAM_START,off)) return start;\n    StrParser p = new StrParser(txt,start,txt.length());\n    p.pos+=2; // skip over \"{!\"\n\n    for(;;) {\n      /*\n      if (p.pos>=txt.length()) {\n        throw new ParseException(\"Missing '}' parsing local params '\" + txt + '\"');\n      }\n      */\n      char ch = p.peek();\n      if (ch==LOCALPARAM_END) {\n        return p.pos+1;\n      }\n\n      String id = p.getId();\n      if (id.length()==0) {\n        throw new ParseException(\"Expected identifier '}' parsing local params '\" + txt + '\"');\n\n      }\n      String val=null;\n\n      ch = p.peek();\n      if (ch!='=') {\n        // single word... treat {!func} as type=func for easy lookup\n        val = id;\n        id = TYPE;\n      } else {\n        // saw equals, so read value\n        p.pos++;\n        ch = p.peek();\n        if (ch=='\\\"' || ch=='\\'') {\n          val = p.getQuotedString();\n        } else if (ch=='$') {\n          p.pos++;\n          // dereference parameter\n          String pname = p.getId();\n          if (params!=null) {\n            val = params.get(pname);\n          }\n        } else {\n          // read unquoted literal ended by whitespace or '}'\n          // there is no escaping.\n          int valStart = p.pos;\n          for (;;) {\n            if (p.pos >= p.end) {\n              throw new ParseException(\"Missing end to unquoted value starting at \" + valStart + \" str='\" + txt +\"'\");\n            }\n            char c = p.val.charAt(p.pos);\n            if (c==LOCALPARAM_END || Character.isWhitespace(c)) {\n              val = p.val.substring(valStart, p.pos);\n              break;\n            }\n            p.pos++;\n          }\n        }\n      }\n      if (target != null) target.put(id,val);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/QueryParsing#parseLocalParams(String,int,Map[String,String],SolrParams).mjava","pathOld":"src/java/org/apache/solr/search/QueryParsing#parseLocalParams(String,int,Map[String,String],SolrParams).mjava","sourceNew":"  // note to self: something needs to detect infinite recursion when parsing queries\n  static int parseLocalParams(String txt, int start, Map<String, String> target, SolrParams params) throws ParseException {\n    int off = start;\n    if (!txt.startsWith(LOCALPARAM_START, off)) return start;\n    StrParser p = new StrParser(txt, start, txt.length());\n    p.pos += 2; // skip over \"{!\"\n\n    for (; ;) {\n      /*\n      if (p.pos>=txt.length()) {\n        throw new ParseException(\"Missing '}' parsing local params '\" + txt + '\"');\n      }\n      */\n      char ch = p.peek();\n      if (ch == LOCALPARAM_END) {\n        return p.pos + 1;\n      }\n\n      String id = p.getId();\n      if (id.length() == 0) {\n        throw new ParseException(\"Expected identifier '}' parsing local params '\" + txt + '\"');\n\n      }\n      String val = null;\n\n      ch = p.peek();\n      if (ch != '=') {\n        // single word... treat {!func} as type=func for easy lookup\n        val = id;\n        id = TYPE;\n      } else {\n        // saw equals, so read value\n        p.pos++;\n        ch = p.peek();\n        if (ch == '\\\"' || ch == '\\'') {\n          val = p.getQuotedString();\n        } else if (ch == '$') {\n          p.pos++;\n          // dereference parameter\n          String pname = p.getId();\n          if (params != null) {\n            val = params.get(pname);\n          }\n        } else {\n          // read unquoted literal ended by whitespace or '}'\n          // there is no escaping.\n          int valStart = p.pos;\n          for (; ;) {\n            if (p.pos >= p.end) {\n              throw new ParseException(\"Missing end to unquoted value starting at \" + valStart + \" str='\" + txt + \"'\");\n            }\n            char c = p.val.charAt(p.pos);\n            if (c == LOCALPARAM_END || Character.isWhitespace(c)) {\n              val = p.val.substring(valStart, p.pos);\n              break;\n            }\n            p.pos++;\n          }\n        }\n      }\n      if (target != null) target.put(id, val);\n    }\n  }\n\n","sourceOld":"  // note to self: something needs to detect infinite recursion when parsing queries\n  static int parseLocalParams(String txt, int start, Map<String, String> target, SolrParams params) throws ParseException {\n    int off = start;\n    if (!txt.startsWith(LOCALPARAM_START, off)) return start;\n    StrParser p = new StrParser(txt, start, txt.length());\n    p.pos += 2; // skip over \"{!\"\n\n    for (; ;) {\n      /*\n      if (p.pos>=txt.length()) {\n        throw new ParseException(\"Missing '}' parsing local params '\" + txt + '\"');\n      }\n      */\n      char ch = p.peek();\n      if (ch == LOCALPARAM_END) {\n        return p.pos + 1;\n      }\n\n      String id = p.getId();\n      if (id.length() == 0) {\n        throw new ParseException(\"Expected identifier '}' parsing local params '\" + txt + '\"');\n\n      }\n      String val = null;\n\n      ch = p.peek();\n      if (ch != '=') {\n        // single word... treat {!func} as type=func for easy lookup\n        val = id;\n        id = TYPE;\n      } else {\n        // saw equals, so read value\n        p.pos++;\n        ch = p.peek();\n        if (ch == '\\\"' || ch == '\\'') {\n          val = p.getQuotedString();\n        } else if (ch == '$') {\n          p.pos++;\n          // dereference parameter\n          String pname = p.getId();\n          if (params != null) {\n            val = params.get(pname);\n          }\n        } else {\n          // read unquoted literal ended by whitespace or '}'\n          // there is no escaping.\n          int valStart = p.pos;\n          for (; ;) {\n            if (p.pos >= p.end) {\n              throw new ParseException(\"Missing end to unquoted value starting at \" + valStart + \" str='\" + txt + \"'\");\n            }\n            char c = p.val.charAt(p.pos);\n            if (c == LOCALPARAM_END || Character.isWhitespace(c)) {\n              val = p.val.substring(valStart, p.pos);\n              break;\n            }\n            p.pos++;\n          }\n        }\n      }\n      if (target != null) target.put(id, val);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0ed9977f1cdec244969bc4f5054a6041028238bf":["66ab3886c1d845c59c9e5b23b2fb247b927db498"],"66ab3886c1d845c59c9e5b23b2fb247b927db498":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"32ef722831135736529762b4b97a13dd58b06f66":["0ed9977f1cdec244969bc4f5054a6041028238bf"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["32ef722831135736529762b4b97a13dd58b06f66"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0ed9977f1cdec244969bc4f5054a6041028238bf":["32ef722831135736529762b4b97a13dd58b06f66"],"66ab3886c1d845c59c9e5b23b2fb247b927db498":["0ed9977f1cdec244969bc4f5054a6041028238bf"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["66ab3886c1d845c59c9e5b23b2fb247b927db498"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"32ef722831135736529762b4b97a13dd58b06f66":["ad94625fb8d088209f46650c8097196fec67f00c"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}