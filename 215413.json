{"path":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"e147cce225492338f15a94a427f51f867da574ee","date":1346365916,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<HashPartitioner.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    try {\n\n      String[] pathsArr = params.getParams(\"path\");\n      List<String> paths = null;\n\n      String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n\n\n      // dirFactory = core.getDirectoryFactory();\n\n\n      if (pathsArr != null) {\n\n        paths = Arrays.asList(pathsArr);\n\n        if (rangesStr == null) {\n          HashPartitioner hp = new HashPartitioner();\n          // should this be static?\n          // TODO: use real range if we know it.  If we don't know it, we should prob\n          // split on every other doc rather than on a hash?\n          ranges = hp.partitionRange(pathsArr.length, Integer.MIN_VALUE, Integer.MAX_VALUE);\n        }\n\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, ranges);\n      core.getUpdateHandler().split(cmd);\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n    }\n\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<HashPartitioner.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    try {\n\n      String[] pathsArr = params.getParams(\"path\");\n      List<String> paths = null;\n\n      String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n\n\n      // dirFactory = core.getDirectoryFactory();\n\n\n      if (pathsArr != null) {\n\n        paths = Arrays.asList(pathsArr);\n\n        if (rangesStr == null) {\n          HashPartitioner hp = new HashPartitioner();\n          // should this be static?\n          // TODO: use real range if we know it.  If we don't know it, we should prob\n          // split on every other doc rather than on a hash?\n          ranges = hp.partitionRange(pathsArr.length, Integer.MIN_VALUE, Integer.MAX_VALUE);\n        }\n\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, ranges);\n      core.getUpdateHandler().split(cmd);\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n    }\n\n    return false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2d1ec821a2d311389d0085f20e2b2698e4b3442","date":1346690180,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<HashPartitioner.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : params.getInt(\"partitions\", 2);\n\n\n      // TODO: if we don't know the real range of the current core, we should just\n      //  split on every other doc rather than hash.\n\n      // TODO (cloud): get from the current core\n      HashPartitioner.Range currentRange = new HashPartitioner.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n\n      HashPartitioner hp = new HashPartitioner();\n      ranges = hp.partitionRange(partitions, currentRange);\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (int i=0; i<partitions; i++) {\n          SolrCore newCore = createCore(core, i, ranges.get(i));\n          newCores.add(newCore);\n        }\n\n        // TODO (cloud): cores should be registered, should be in recovery / buffering-updates mode, and the shard\n        // leader should be forwarding updates to the new shards *before* we split the current shard\n        // into the new shards.\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<HashPartitioner.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    try {\n\n      String[] pathsArr = params.getParams(\"path\");\n      List<String> paths = null;\n\n      String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n\n\n      // dirFactory = core.getDirectoryFactory();\n\n\n      if (pathsArr != null) {\n\n        paths = Arrays.asList(pathsArr);\n\n        if (rangesStr == null) {\n          HashPartitioner hp = new HashPartitioner();\n          // should this be static?\n          // TODO: use real range if we know it.  If we don't know it, we should prob\n          // split on every other doc rather than on a hash?\n          ranges = hp.partitionRange(pathsArr.length, Integer.MIN_VALUE, Integer.MAX_VALUE);\n        }\n\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, ranges);\n      core.getUpdateHandler().split(cmd);\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":["a5cd9341c578f132de886964218bbefe52bdcd83"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<DocRouter.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : params.getInt(\"partitions\", 2);\n\n\n      // TODO: if we don't know the real range of the current core, we should just\n      //  split on every other doc rather than hash.\n\n      // TODO (cloud): get from the current core\n      DocRouter.Range currentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n\n      DocRouter hp = new DocRouter();\n      ranges = hp.partitionRange(partitions, currentRange);\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (int i=0; i<partitions; i++) {\n          SolrCore newCore = createCore(core, i, ranges.get(i));\n          newCores.add(newCore);\n        }\n\n        // TODO (cloud): cores should be registered, should be in recovery / buffering-updates mode, and the shard\n        // leader should be forwarding updates to the new shards *before* we split the current shard\n        // into the new shards.\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<HashPartitioner.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : params.getInt(\"partitions\", 2);\n\n\n      // TODO: if we don't know the real range of the current core, we should just\n      //  split on every other doc rather than hash.\n\n      // TODO (cloud): get from the current core\n      HashPartitioner.Range currentRange = new HashPartitioner.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n\n      HashPartitioner hp = new HashPartitioner();\n      ranges = hp.partitionRange(partitions, currentRange);\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (int i=0; i<partitions; i++) {\n          SolrCore newCore = createCore(core, i, ranges.get(i));\n          newCores.add(newCore);\n        }\n\n        // TODO (cloud): cores should be registered, should be in recovery / buffering-updates mode, and the shard\n        // leader should be forwarding updates to the new shards *before* we split the current shard\n        // into the new shards.\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89f828d954597b98a28942874636f35c719b8a5d","date":1354471211,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<DocRouter.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : params.getInt(\"partitions\", 2);\n\n\n      // TODO: if we don't know the real range of the current core, we should just\n      //  split on every other doc rather than hash.\n\n      // TODO (cloud): get from the current core\n      DocRouter.Range currentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n\n      DocRouter hp = DocRouter.DEFAULT;  // TODO: get actual doc router for collection if available\n      ranges = hp.partitionRange(partitions, currentRange);\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (int i=0; i<partitions; i++) {\n          SolrCore newCore = createCore(core, i, ranges.get(i));\n          newCores.add(newCore);\n        }\n\n        // TODO (cloud): cores should be registered, should be in recovery / buffering-updates mode, and the shard\n        // leader should be forwarding updates to the new shards *before* we split the current shard\n        // into the new shards.\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<DocRouter.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : params.getInt(\"partitions\", 2);\n\n\n      // TODO: if we don't know the real range of the current core, we should just\n      //  split on every other doc rather than hash.\n\n      // TODO (cloud): get from the current core\n      DocRouter.Range currentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n\n      DocRouter hp = new DocRouter();\n      ranges = hp.partitionRange(partitions, currentRange);\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (int i=0; i<partitions; i++) {\n          SolrCore newCore = createCore(core, i, ranges.get(i));\n          newCores.add(newCore);\n        }\n\n        // TODO (cloud): cores should be registered, should be in recovery / buffering-updates mode, and the shard\n        // leader should be forwarding updates to the new shards *before* we split the current shard\n        // into the new shards.\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<DocRouter.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : params.getInt(\"partitions\", 2);\n\n\n      // TODO: if we don't know the real range of the current core, we should just\n      //  split on every other doc rather than hash.\n\n      // TODO (cloud): get from the current core\n      DocRouter.Range currentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n\n      DocRouter hp = DocRouter.DEFAULT;  // TODO: get actual doc router for collection if available\n      ranges = hp.partitionRange(partitions, currentRange);\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (int i=0; i<partitions; i++) {\n          SolrCore newCore = createCore(core, i, ranges.get(i));\n          newCores.add(newCore);\n        }\n\n        // TODO (cloud): cores should be registered, should be in recovery / buffering-updates mode, and the shard\n        // leader should be forwarding updates to the new shards *before* we split the current shard\n        // into the new shards.\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<HashPartitioner.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : params.getInt(\"partitions\", 2);\n\n\n      // TODO: if we don't know the real range of the current core, we should just\n      //  split on every other doc rather than hash.\n\n      // TODO (cloud): get from the current core\n      HashPartitioner.Range currentRange = new HashPartitioner.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n\n      HashPartitioner hp = new HashPartitioner();\n      ranges = hp.partitionRange(partitions, currentRange);\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (int i=0; i<partitions; i++) {\n          SolrCore newCore = createCore(core, i, ranges.get(i));\n          newCores.add(newCore);\n        }\n\n        // TODO (cloud): cores should be registered, should be in recovery / buffering-updates mode, and the shard\n        // leader should be forwarding updates to the new shards *before* we split the current shard\n        // into the new shards.\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7076f869d198bd177040d04939016611b2e07d34","date":1361224899,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<DocRouter.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : params.getInt(\"partitions\", 2);\n\n\n      // TODO: if we don't know the real range of the current core, we should just\n      //  split on every other doc rather than hash.\n\n      // TODO (cloud): get from the current core\n      DocRouter.Range currentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n\n      DocRouter hp = DocRouter.DEFAULT;  // TODO: get actual doc router for collection if available\n      ranges = hp.partitionRange(partitions, currentRange);\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n        // TODO (cloud): cores should be registered, should be in recovery / buffering-updates mode, and the shard\n        // leader should be forwarding updates to the new shards *before* we split the current shard\n        // into the new shards.\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<DocRouter.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : params.getInt(\"partitions\", 2);\n\n\n      // TODO: if we don't know the real range of the current core, we should just\n      //  split on every other doc rather than hash.\n\n      // TODO (cloud): get from the current core\n      DocRouter.Range currentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n\n      DocRouter hp = DocRouter.DEFAULT;  // TODO: get actual doc router for collection if available\n      ranges = hp.partitionRange(partitions, currentRange);\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (int i=0; i<partitions; i++) {\n          SolrCore newCore = createCore(core, i, ranges.get(i));\n          newCores.add(newCore);\n        }\n\n        // TODO (cloud): cores should be registered, should be in recovery / buffering-updates mode, and the shard\n        // leader should be forwarding updates to the new shards *before* we split the current shard\n        // into the new shards.\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0beaed456aa3358e5e4a99ea2aea994ef6c81de3","date":1365434191,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  /**\n   * Handle the core admin SPLIT action.\n   * @return true if a modification has resulted that requires persistence \n   *         of the CoreContainer configuration.\n   */\n  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<DocRouter.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : params.getInt(\"partitions\", 2);\n\n      // TODO: if we don't know the real range of the current core, we should just\n      //  split on every other doc rather than hash.\n      ClusterState clusterState = coreContainer.getZkController().getClusterState();\n      String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n      DocCollection collection = clusterState.getCollection(collectionName);\n      String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = clusterState.getSlice(collectionName, sliceName);\n      DocRouter.Range currentRange = slice.getRange() == null ?\n          new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE) : slice.getRange();\n\n      DocRouter hp = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n      ranges = hp.partitionRange(partitions, currentRange);\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<DocRouter.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : params.getInt(\"partitions\", 2);\n\n\n      // TODO: if we don't know the real range of the current core, we should just\n      //  split on every other doc rather than hash.\n\n      // TODO (cloud): get from the current core\n      DocRouter.Range currentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n\n      DocRouter hp = DocRouter.DEFAULT;  // TODO: get actual doc router for collection if available\n      ranges = hp.partitionRange(partitions, currentRange);\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n        // TODO (cloud): cores should be registered, should be in recovery / buffering-updates mode, and the shard\n        // leader should be forwarding updates to the new shards *before* we split the current shard\n        // into the new shards.\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7ba13b1e8eb54daafdac40183a898b820ac9f73b","date":1365684595,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  /**\n   * Handle the core admin SPLIT action.\n   * @return true if a modification has resulted that requires persistence \n   *         of the CoreContainer configuration.\n   */\n  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        DocRouter.Range currentRange = slice.getRange();\n        DocRouter hp = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        ranges = currentRange != null ? hp.partitionRange(partitions, currentRange) : null;\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Handle the core admin SPLIT action.\n   * @return true if a modification has resulted that requires persistence \n   *         of the CoreContainer configuration.\n   */\n  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n     // partitions=N    (split into N partitions, leaving it up to solr what the ranges are and where to put them)\n    // path - multiValued param, or comma separated param?  Only creates indexes, not cores\n\n    List<DocRouter.Range> ranges = null;\n    // boolean closeDirectories = true;\n    // DirectoryFactory dirFactory = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : params.getInt(\"partitions\", 2);\n\n      // TODO: if we don't know the real range of the current core, we should just\n      //  split on every other doc rather than hash.\n      ClusterState clusterState = coreContainer.getZkController().getClusterState();\n      String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n      DocCollection collection = clusterState.getCollection(collectionName);\n      String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n      Slice slice = clusterState.getSlice(collectionName, sliceName);\n      DocRouter.Range currentRange = slice.getRange() == null ?\n          new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE) : slice.getRange();\n\n      DocRouter hp = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n      ranges = hp.partitionRange(partitions, currentRange);\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":["a5cd9341c578f132de886964218bbefe52bdcd83"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5cd9341c578f132de886964218bbefe52bdcd83","date":1368036656,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  /**\n   * Handle the core admin SPLIT action.\n   * @return true if a modification has resulted that requires persistence \n   *         of the CoreContainer configuration.\n   */\n  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        DocRouter.Range currentRange = slice.getRange();\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Handle the core admin SPLIT action.\n   * @return true if a modification has resulted that requires persistence \n   *         of the CoreContainer configuration.\n   */\n  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        DocRouter.Range currentRange = slice.getRange();\n        DocRouter hp = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        ranges = currentRange != null ? hp.partitionRange(partitions, currentRange) : null;\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":["c2d1ec821a2d311389d0085f20e2b2698e4b3442","7ba13b1e8eb54daafdac40183a898b820ac9f73b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e764e9a107f93be9fa3c922bc6a197b3eec387e","date":1373560501,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        DocRouter.Range currentRange = slice.getRange();\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Handle the core admin SPLIT action.\n   * @return true if a modification has resulted that requires persistence \n   *         of the CoreContainer configuration.\n   */\n  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        DocRouter.Range currentRange = slice.getRange();\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        DocRouter.Range currentRange = slice.getRange();\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Handle the core admin SPLIT action.\n   * @return true if a modification has resulted that requires persistence \n   *         of the CoreContainer configuration.\n   */\n  protected boolean handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        DocRouter.Range currentRange = slice.getRange();\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1816753738ff1f27f11b38030e83c0ded050b7a4","date":1380106089,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        DocRouter.Range currentRange = slice.getRange();\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        Map m = (Map) collection.get(DOC_ROUTER);\n        if (m != null)  {\n          routeFieldName = (String) m.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        DocRouter.Range currentRange = slice.getRange();\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["4115dda4435028a1f5e27c4236a1f4c1dae1dfb1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2e73db80cda3387e197641256d964f8c1c3992c7","date":1380978036,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0 || rangesArr.length == 1) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least two ranges specified to split an index\");\n      } else  {\n        ranges = new ArrayList<DocRouter.Range>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Map m = (Map) collection.get(DOC_ROUTER);\n        if (m != null)  {\n          routeFieldName = (String) m.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(\"ranges\");    // ranges=a-b,c-d,e-f\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        DocRouter.Range currentRange = slice.getRange();\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        Map m = (Map) collection.get(DOC_ROUTER);\n        if (m != null)  {\n          routeFieldName = (String) m.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fbe8b2974b783dfe1b0160f39e4de0315fa51adb","date":1382029739,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0 || rangesArr.length == 1) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least two ranges specified to split an index\");\n      } else  {\n        ranges = new ArrayList<DocRouter.Range>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Map m = (Map) collection.get(DOC_ROUTER);\n        if (m != null)  {\n          routeFieldName = (String) m.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0 || rangesArr.length == 1) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least two ranges specified to split an index\");\n      } else  {\n        ranges = new ArrayList<DocRouter.Range>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Map m = (Map) collection.get(DOC_ROUTER);\n        if (m != null)  {\n          routeFieldName = (String) m.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e66dec19143fe0dbc2d4a567ebef0b2669bc4158","date":1382112661,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else  {\n        ranges = new ArrayList<DocRouter.Range>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Map m = (Map) collection.get(DOC_ROUTER);\n        if (m != null)  {\n          routeFieldName = (String) m.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0 || rangesArr.length == 1) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least two ranges specified to split an index\");\n      } else  {\n        ranges = new ArrayList<DocRouter.Range>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Map m = (Map) collection.get(DOC_ROUTER);\n        if (m != null)  {\n          routeFieldName = (String) m.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4115dda4435028a1f5e27c4236a1f4c1dae1dfb1","date":1391098010,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else  {\n        ranges = new ArrayList<DocRouter.Range>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else  {\n        ranges = new ArrayList<DocRouter.Range>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Map m = (Map) collection.get(DOC_ROUTER);\n        if (m != null)  {\n          routeFieldName = (String) m.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","bugFix":["1816753738ff1f27f11b38030e83c0ded050b7a4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else  {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else  {\n        ranges = new ArrayList<DocRouter.Range>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<SolrCore>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1390137e395d2f07f9ba5b8c43d293befe84d563","date":1427947685,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else  {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else  {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else  {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(\"path\");\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else  {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa0876236f0bd8be403747120d248bdd42b75a96","date":1451844229,"type":4,"author":"Noble Paul","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CoreAdminHandler#handleSplitAction(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":null,"sourceOld":"  /**\n   * Handle the core admin SPLIT action.\n   */\n  protected void handleSplitAction(SolrQueryRequest adminReq, SolrQueryResponse rsp) throws IOException {\n    SolrParams params = adminReq.getParams();\n    List<DocRouter.Range> ranges = null;\n\n    String[] pathsArr = params.getParams(PATH);\n    String rangesStr = params.get(CoreAdminParams.RANGES);    // ranges=a-b,c-d,e-f\n    if (rangesStr != null)  {\n      String[] rangesArr = rangesStr.split(\",\");\n      if (rangesArr.length == 0) {\n        throw new SolrException(ErrorCode.BAD_REQUEST, \"There must be at least one range specified to split an index\");\n      } else  {\n        ranges = new ArrayList<>(rangesArr.length);\n        for (String r : rangesArr) {\n          try {\n            ranges.add(DocRouter.DEFAULT.fromString(r));\n          } catch (Exception e) {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Exception parsing hexadecimal hash range: \" + r, e);\n          }\n        }\n      }\n    }\n    String splitKey = params.get(\"split.key\");\n    String[] newCoreNames = params.getParams(\"targetCore\");\n    String cname = params.get(CoreAdminParams.CORE, \"\");\n\n    if ((pathsArr == null || pathsArr.length == 0) && (newCoreNames == null || newCoreNames.length == 0)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Either path or targetCore param must be specified\");\n    }\n\n    log.info(\"Invoked split action for core: \" + cname);\n    SolrCore core = coreContainer.getCore(cname);\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    List<SolrCore> newCores = null;\n\n    try {\n      // TODO: allow use of rangesStr in the future\n      List<String> paths = null;\n      int partitions = pathsArr != null ? pathsArr.length : newCoreNames.length;\n\n      DocRouter router = null;\n      String routeFieldName = null;\n      if (coreContainer.isZooKeeperAware()) {\n        ClusterState clusterState = coreContainer.getZkController().getClusterState();\n        String collectionName = req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName();\n        DocCollection collection = clusterState.getCollection(collectionName);\n        String sliceName = req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId();\n        Slice slice = clusterState.getSlice(collectionName, sliceName);\n        router = collection.getRouter() != null ? collection.getRouter() : DocRouter.DEFAULT;\n        if (ranges == null) {\n          DocRouter.Range currentRange = slice.getRange();\n          ranges = currentRange != null ? router.partitionRange(partitions, currentRange) : null;\n        }\n        Object routerObj = collection.get(DOC_ROUTER); // for back-compat with Solr 4.4\n        if (routerObj != null && routerObj instanceof Map) {\n          Map routerProps = (Map) routerObj;\n          routeFieldName = (String) routerProps.get(\"field\");\n        }\n      }\n\n      if (pathsArr == null) {\n        newCores = new ArrayList<>(partitions);\n        for (String newCoreName : newCoreNames) {\n          SolrCore newcore = coreContainer.getCore(newCoreName);\n          if (newcore != null) {\n            newCores.add(newcore);\n          } else {\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Core with core name \" + newCoreName + \" expected but doesn't exist.\");\n          }\n        }\n      } else {\n        paths = Arrays.asList(pathsArr);\n      }\n\n\n      SplitIndexCommand cmd = new SplitIndexCommand(req, paths, newCores, ranges, router, routeFieldName, splitKey);\n      core.getUpdateHandler().split(cmd);\n\n      // After the split has completed, someone (here?) should start the process of replaying the buffered updates.\n\n    } catch (Exception e) {\n      log.error(\"ERROR executing split:\", e);\n      throw new RuntimeException(e);\n\n    } finally {\n      if (req != null) req.close();\n      if (core != null) core.close();\n      if (newCores != null) {\n        for (SolrCore newCore : newCores) {\n          newCore.close();\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4115dda4435028a1f5e27c4236a1f4c1dae1dfb1"],"fbe8b2974b783dfe1b0160f39e4de0315fa51adb":["2e73db80cda3387e197641256d964f8c1c3992c7"],"1816753738ff1f27f11b38030e83c0ded050b7a4":["6e764e9a107f93be9fa3c922bc6a197b3eec387e"],"89f828d954597b98a28942874636f35c719b8a5d":["c5a558d54519c651068ddb202f03befefb1514a7"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a5cd9341c578f132de886964218bbefe52bdcd83","6e764e9a107f93be9fa3c922bc6a197b3eec387e"],"4115dda4435028a1f5e27c4236a1f4c1dae1dfb1":["e66dec19143fe0dbc2d4a567ebef0b2669bc4158"],"407687e67faf6e1f02a211ca078d8e3eed631027":["c2d1ec821a2d311389d0085f20e2b2698e4b3442","89f828d954597b98a28942874636f35c719b8a5d"],"fa0876236f0bd8be403747120d248bdd42b75a96":["1390137e395d2f07f9ba5b8c43d293befe84d563"],"c2d1ec821a2d311389d0085f20e2b2698e4b3442":["e147cce225492338f15a94a427f51f867da574ee"],"e147cce225492338f15a94a427f51f867da574ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["7076f869d198bd177040d04939016611b2e07d34"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e147cce225492338f15a94a427f51f867da574ee"],"7076f869d198bd177040d04939016611b2e07d34":["89f828d954597b98a28942874636f35c719b8a5d"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a5cd9341c578f132de886964218bbefe52bdcd83":["7ba13b1e8eb54daafdac40183a898b820ac9f73b"],"2e73db80cda3387e197641256d964f8c1c3992c7":["1816753738ff1f27f11b38030e83c0ded050b7a4"],"c5a558d54519c651068ddb202f03befefb1514a7":["c2d1ec821a2d311389d0085f20e2b2698e4b3442"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","1390137e395d2f07f9ba5b8c43d293befe84d563"],"6e764e9a107f93be9fa3c922bc6a197b3eec387e":["a5cd9341c578f132de886964218bbefe52bdcd83"],"7ba13b1e8eb54daafdac40183a898b820ac9f73b":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fa0876236f0bd8be403747120d248bdd42b75a96"],"e66dec19143fe0dbc2d4a567ebef0b2669bc4158":["fbe8b2974b783dfe1b0160f39e4de0315fa51adb"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["1390137e395d2f07f9ba5b8c43d293befe84d563","d2638f781be724518ff6c2263d14a48cf6e68017"],"fbe8b2974b783dfe1b0160f39e4de0315fa51adb":["e66dec19143fe0dbc2d4a567ebef0b2669bc4158"],"1816753738ff1f27f11b38030e83c0ded050b7a4":["2e73db80cda3387e197641256d964f8c1c3992c7"],"89f828d954597b98a28942874636f35c719b8a5d":["407687e67faf6e1f02a211ca078d8e3eed631027","7076f869d198bd177040d04939016611b2e07d34"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"4115dda4435028a1f5e27c4236a1f4c1dae1dfb1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"fa0876236f0bd8be403747120d248bdd42b75a96":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c2d1ec821a2d311389d0085f20e2b2698e4b3442":["407687e67faf6e1f02a211ca078d8e3eed631027","c5a558d54519c651068ddb202f03befefb1514a7"],"e147cce225492338f15a94a427f51f867da574ee":["c2d1ec821a2d311389d0085f20e2b2698e4b3442","05a14b2611ead08655a2b2bdc61632eb31316e57"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["7ba13b1e8eb54daafdac40183a898b820ac9f73b"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"7076f869d198bd177040d04939016611b2e07d34":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"a5cd9341c578f132de886964218bbefe52bdcd83":["37a0f60745e53927c4c876cfe5b5a58170f0646c","6e764e9a107f93be9fa3c922bc6a197b3eec387e"],"1390137e395d2f07f9ba5b8c43d293befe84d563":["fa0876236f0bd8be403747120d248bdd42b75a96","d2638f781be724518ff6c2263d14a48cf6e68017"],"2e73db80cda3387e197641256d964f8c1c3992c7":["fbe8b2974b783dfe1b0160f39e4de0315fa51adb"],"c5a558d54519c651068ddb202f03befefb1514a7":["89f828d954597b98a28942874636f35c719b8a5d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e147cce225492338f15a94a427f51f867da574ee","05a14b2611ead08655a2b2bdc61632eb31316e57"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"6e764e9a107f93be9fa3c922bc6a197b3eec387e":["1816753738ff1f27f11b38030e83c0ded050b7a4","37a0f60745e53927c4c876cfe5b5a58170f0646c"],"7ba13b1e8eb54daafdac40183a898b820ac9f73b":["a5cd9341c578f132de886964218bbefe52bdcd83"],"e66dec19143fe0dbc2d4a567ebef0b2669bc4158":["4115dda4435028a1f5e27c4236a1f4c1dae1dfb1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","407687e67faf6e1f02a211ca078d8e3eed631027","05a14b2611ead08655a2b2bdc61632eb31316e57","d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}