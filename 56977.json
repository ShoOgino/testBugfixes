{"path":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","commits":[{"id":"21d36d0db865f7b84026b447bec653469a6e66df","date":1385495602,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/simple/SimpleDrillSideways#search(ScoreDoc,SimpleDrillDownQuery,int).mjava","sourceNew":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after,\n                                          DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    topN = Math.min(topN, limit);\n    TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after, true);\n    DrillSidewaysResult r = search(query, hitCollector);\n    return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public SimpleDrillSidewaysResult search(ScoreDoc after,\n                                          SimpleDrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    topN = Math.min(topN, limit);\n    TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after, true);\n    SimpleDrillSidewaysResult r = search(query, hitCollector);\n    return new SimpleDrillSidewaysResult(r.facets, hitCollector.topDocs());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after,\n                                          DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    topN = Math.min(topN, limit);\n    TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after, true);\n    DrillSidewaysResult r = search(query, hitCollector);\n    return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"40640359164f629dd440a47df2e145d084ce9645","date":1391711808,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","sourceNew":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after,\n                                    DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    topN = Math.min(topN, limit);\n    TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after, true);\n    DrillSidewaysResult r = search(query, hitCollector);\n    return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after,\n                                          DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    topN = Math.min(topN, limit);\n    TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after, true);\n    DrillSidewaysResult r = search(query, hitCollector);\n    return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","sourceNew":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after,\n                                    DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    topN = Math.min(topN, limit);\n    TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after);\n    DrillSidewaysResult r = search(query, hitCollector);\n    return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after,\n                                    DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    topN = Math.min(topN, limit);\n    TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after, true);\n    DrillSidewaysResult r = search(query, hitCollector);\n    return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91eb857a56b1a3a6659c666f88e2398347fc1c5a","date":1483442809,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","sourceNew":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after, DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    final int fTopN = Math.min(topN, limit);\n\n    if (executor != null) {  // We have an executor, let use the multi-threaded version\n\n      final CollectorManager<TopScoreDocCollector, TopDocs> collectorManager =\n              new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n                @Override\n                public TopScoreDocCollector newCollector() throws IOException {\n                  return TopScoreDocCollector.create(fTopN, after);\n                }\n\n                @Override\n                public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n                  final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                  int pos = 0;\n                  for (TopScoreDocCollector collector : collectors)\n                    topDocs[pos++] = collector.topDocs();\n                  return TopDocs.merge(topN, topDocs);\n                }\n\n              };\n      ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n      return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n    } else {\n\n      TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after,\n                                    DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    topN = Math.min(topN, limit);\n    TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after);\n    DrillSidewaysResult r = search(query, hitCollector);\n    return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","sourceNew":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after, DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    final int fTopN = Math.min(topN, limit);\n\n    if (executor != null) {  // We have an executor, let use the multi-threaded version\n\n      final CollectorManager<TopScoreDocCollector, TopDocs> collectorManager =\n              new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n                @Override\n                public TopScoreDocCollector newCollector() throws IOException {\n                  return TopScoreDocCollector.create(fTopN, after);\n                }\n\n                @Override\n                public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n                  final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                  int pos = 0;\n                  for (TopScoreDocCollector collector : collectors)\n                    topDocs[pos++] = collector.topDocs();\n                  return TopDocs.merge(topN, topDocs);\n                }\n\n              };\n      ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n      return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n    } else {\n\n      TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after,\n                                    DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    topN = Math.min(topN, limit);\n    TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after);\n    DrillSidewaysResult r = search(query, hitCollector);\n    return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","sourceNew":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after, DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    final int fTopN = Math.min(topN, limit);\n\n    if (executor != null) {  // We have an executor, let use the multi-threaded version\n\n      final CollectorManager<TopScoreDocCollector, TopDocs> collectorManager =\n              new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n                @Override\n                public TopScoreDocCollector newCollector() throws IOException {\n                  return TopScoreDocCollector.create(fTopN, after, true);\n                }\n\n                @Override\n                public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n                  final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                  int pos = 0;\n                  for (TopScoreDocCollector collector : collectors)\n                    topDocs[pos++] = collector.topDocs();\n                  return TopDocs.merge(topN, topDocs);\n                }\n\n              };\n      ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n      return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n    } else {\n\n      TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after, true);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after, DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    final int fTopN = Math.min(topN, limit);\n\n    if (executor != null) {  // We have an executor, let use the multi-threaded version\n\n      final CollectorManager<TopScoreDocCollector, TopDocs> collectorManager =\n              new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n                @Override\n                public TopScoreDocCollector newCollector() throws IOException {\n                  return TopScoreDocCollector.create(fTopN, after);\n                }\n\n                @Override\n                public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n                  final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                  int pos = 0;\n                  for (TopScoreDocCollector collector : collectors)\n                    topDocs[pos++] = collector.topDocs();\n                  return TopDocs.merge(topN, topDocs);\n                }\n\n              };\n      ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n      return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n    } else {\n\n      TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","sourceNew":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after, DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    final int fTopN = Math.min(topN, limit);\n\n    if (executor != null) {  // We have an executor, let use the multi-threaded version\n\n      final CollectorManager<TopScoreDocCollector, TopDocs> collectorManager =\n              new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n                @Override\n                public TopScoreDocCollector newCollector() throws IOException {\n                  return TopScoreDocCollector.create(fTopN, after, true);\n                }\n\n                @Override\n                public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n                  final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                  int pos = 0;\n                  for (TopScoreDocCollector collector : collectors)\n                    topDocs[pos++] = collector.topDocs();\n                  return TopDocs.merge(topN, topDocs);\n                }\n\n              };\n      ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n      return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n    } else {\n\n      TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after, true);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after, DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    final int fTopN = Math.min(topN, limit);\n\n    if (executor != null) {  // We have an executor, let use the multi-threaded version\n\n      final CollectorManager<TopScoreDocCollector, TopDocs> collectorManager =\n              new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n                @Override\n                public TopScoreDocCollector newCollector() throws IOException {\n                  return TopScoreDocCollector.create(fTopN, after);\n                }\n\n                @Override\n                public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n                  final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                  int pos = 0;\n                  for (TopScoreDocCollector collector : collectors)\n                    topDocs[pos++] = collector.topDocs();\n                  return TopDocs.merge(topN, topDocs);\n                }\n\n              };\n      ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n      return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n    } else {\n\n      TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","sourceNew":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after, DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    final int fTopN = Math.min(topN, limit);\n\n    if (executor != null) {  // We have an executor, let use the multi-threaded version\n\n      final CollectorManager<TopScoreDocCollector, TopDocs> collectorManager =\n              new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n                @Override\n                public TopScoreDocCollector newCollector() throws IOException {\n                  return TopScoreDocCollector.create(fTopN, after, Integer.MAX_VALUE);\n                }\n\n                @Override\n                public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n                  final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                  int pos = 0;\n                  for (TopScoreDocCollector collector : collectors)\n                    topDocs[pos++] = collector.topDocs();\n                  return TopDocs.merge(topN, topDocs);\n                }\n\n              };\n      ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n      return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n    } else {\n\n      TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after, Integer.MAX_VALUE);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after, DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    final int fTopN = Math.min(topN, limit);\n\n    if (executor != null) {  // We have an executor, let use the multi-threaded version\n\n      final CollectorManager<TopScoreDocCollector, TopDocs> collectorManager =\n              new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n                @Override\n                public TopScoreDocCollector newCollector() throws IOException {\n                  return TopScoreDocCollector.create(fTopN, after, true);\n                }\n\n                @Override\n                public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n                  final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                  int pos = 0;\n                  for (TopScoreDocCollector collector : collectors)\n                    topDocs[pos++] = collector.topDocs();\n                  return TopDocs.merge(topN, topDocs);\n                }\n\n              };\n      ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n      return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n    } else {\n\n      TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after, true);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSideways#search(ScoreDoc,DrillDownQuery,int).mjava","sourceNew":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after, DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    final int fTopN = Math.min(topN, limit);\n\n    if (executor != null) {  // We have an executor, let use the multi-threaded version\n\n      final CollectorManager<TopScoreDocCollector, TopDocs> collectorManager =\n              new CollectorManager<>() {\n\n                @Override\n                public TopScoreDocCollector newCollector() throws IOException {\n                  return TopScoreDocCollector.create(fTopN, after, Integer.MAX_VALUE);\n                }\n\n                @Override\n                public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n                  final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                  int pos = 0;\n                  for (TopScoreDocCollector collector : collectors)\n                    topDocs[pos++] = collector.topDocs();\n                  return TopDocs.merge(topN, topDocs);\n                }\n\n              };\n      ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n      return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n    } else {\n\n      TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after, Integer.MAX_VALUE);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    }\n  }\n\n","sourceOld":"  /**\n   * Search, sorting by score, and computing\n   * drill down and sideways counts.\n   */\n  public DrillSidewaysResult search(ScoreDoc after, DrillDownQuery query, int topN) throws IOException {\n    int limit = searcher.getIndexReader().maxDoc();\n    if (limit == 0) {\n      limit = 1; // the collector does not alow numHits = 0\n    }\n    final int fTopN = Math.min(topN, limit);\n\n    if (executor != null) {  // We have an executor, let use the multi-threaded version\n\n      final CollectorManager<TopScoreDocCollector, TopDocs> collectorManager =\n              new CollectorManager<TopScoreDocCollector, TopDocs>() {\n\n                @Override\n                public TopScoreDocCollector newCollector() throws IOException {\n                  return TopScoreDocCollector.create(fTopN, after, Integer.MAX_VALUE);\n                }\n\n                @Override\n                public TopDocs reduce(Collection<TopScoreDocCollector> collectors) throws IOException {\n                  final TopDocs[] topDocs = new TopDocs[collectors.size()];\n                  int pos = 0;\n                  for (TopScoreDocCollector collector : collectors)\n                    topDocs[pos++] = collector.topDocs();\n                  return TopDocs.merge(topN, topDocs);\n                }\n\n              };\n      ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);\n      return new DrillSidewaysResult(r.facets, r.collectorResult);\n\n    } else {\n\n      TopScoreDocCollector hitCollector = TopScoreDocCollector.create(topN, after, Integer.MAX_VALUE);\n      DrillSidewaysResult r = search(query, hitCollector);\n      return new DrillSidewaysResult(r.facets, hitCollector.topDocs());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["40640359164f629dd440a47df2e145d084ce9645"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"21d36d0db865f7b84026b447bec653469a6e66df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"91eb857a56b1a3a6659c666f88e2398347fc1c5a":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","21d36d0db865f7b84026b447bec653469a6e66df"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["91eb857a56b1a3a6659c666f88e2398347fc1c5a"],"40640359164f629dd440a47df2e145d084ce9645":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["417142ff08fda9cf0b72d5133e63097a166c6458"],"417142ff08fda9cf0b72d5133e63097a166c6458":["91eb857a56b1a3a6659c666f88e2398347fc1c5a","9fc47cb7b4346802411bb432f501ed0673d7119e"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","91eb857a56b1a3a6659c666f88e2398347fc1c5a"]},"commit2Childs":{"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["91eb857a56b1a3a6659c666f88e2398347fc1c5a","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["21d36d0db865f7b84026b447bec653469a6e66df","3cc728b07df73b197e6d940d27f9b08b63918f13"],"21d36d0db865f7b84026b447bec653469a6e66df":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"91eb857a56b1a3a6659c666f88e2398347fc1c5a":["9fc47cb7b4346802411bb432f501ed0673d7119e","417142ff08fda9cf0b72d5133e63097a166c6458","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["40640359164f629dd440a47df2e145d084ce9645"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"40640359164f629dd440a47df2e145d084ce9645":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"417142ff08fda9cf0b72d5133e63097a166c6458":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}