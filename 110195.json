{"path":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","commits":[{"id":"163fe85a71d778fd2b7747f65ca27b54829e2e57","date":1279898785,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","pathOld":"/dev/null","sourceNew":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {  // nocommit -- we can't cmp to prevTerm if we'd done a seek 3 or seek 2 before?\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, protoTerm.createTerm(scratchTerm));\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == fieldInfo.name) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9f6bb0c3d7b1c1dd8aeab43a34a89f050069e97","date":1280158618,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","sourceNew":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, protoTerm.createTerm(scratchTerm));\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == fieldInfo.name) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","sourceOld":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {  // nocommit -- we can't cmp to prevTerm if we'd done a seek 3 or seek 2 before?\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, protoTerm.createTerm(scratchTerm));\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == fieldInfo.name) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b103252dee6afa1b6d7a622c773d178788eb85a","date":1280180143,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","pathOld":"/dev/null","sourceNew":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, protoTerm.createTerm(scratchTerm));\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == fieldInfo.name) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","pathOld":"/dev/null","sourceNew":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, protoTerm.createTerm(scratchTerm));\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == fieldInfo.name) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"825bcb488bc228d1fb6a19c1f441a2181f7d766d","date":1285691504,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","sourceNew":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, protoTerm.createTerm(scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == fieldInfo.name) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","sourceOld":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, protoTerm.createTerm(scratchTerm));\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == fieldInfo.name) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","sourceNew":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, protoTerm.createTerm(scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == fieldInfo.name) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","sourceOld":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, protoTerm.createTerm(scratchTerm));\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == fieldInfo.name) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term());\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","date":1308670974,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","sourceNew":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, new Term(fieldInfo.name, scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == internedFieldName) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","sourceOld":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, protoTerm.createTerm(scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == fieldInfo.name) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","sourceNew":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, new Term(fieldInfo.name, scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == internedFieldName) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","sourceOld":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, protoTerm.createTerm(scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == fieldInfo.name) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","sourceNew":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, new Term(fieldInfo.name, scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == internedFieldName) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","sourceOld":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, protoTerm.createTerm(scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == fieldInfo.name) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.PreTermsEnum#doPushes().mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/preflex/PreFlexFields.PreTermsEnum#doPushes().mjava","sourceNew":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, new Term(fieldInfo.name, scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == internedFieldName) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","sourceOld":"    // Look for seek type 1 (\"push\"): if the newly added\n    // suffix contains any S, we must try to seek to the\n    // corresponding E.  If we find a match, we go there;\n    // else we keep looking for additional S's in the new\n    // suffix.  This \"starts\" the dance, at this character\n    // position:\n    private void doPushes() throws IOException {\n\n      int upTo = newSuffixStart;\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"  try push newSuffixStart=\" + newSuffixStart + \" scratchLen=\" + scratchTerm.length);\n      }\n\n      while(upTo < scratchTerm.length) {\n        if (isNonBMPChar(scratchTerm.bytes, upTo) &&\n            (upTo > newSuffixStart ||\n             (upTo >= prevTerm.length ||\n              (!isNonBMPChar(prevTerm.bytes, upTo) &&\n               !isHighBMPChar(prevTerm.bytes, upTo))))) {\n\n          // A non-BMP char (4 bytes UTF8) starts here:\n          assert scratchTerm.length >= upTo + 4;\n          \n          final int savLength = scratchTerm.length;\n          scratch[0] = scratchTerm.bytes[upTo];\n          scratch[1] = scratchTerm.bytes[upTo+1];\n          scratch[2] = scratchTerm.bytes[upTo+2];\n\n          scratchTerm.bytes[upTo] = UTF8_HIGH_BMP_LEAD;\n          scratchTerm.bytes[upTo+1] = (byte) 0x80;\n          scratchTerm.bytes[upTo+2] = (byte) 0x80;\n          scratchTerm.length = upTo+3;\n\n          if (DEBUG_SURROGATES) {\n            System.out.println(\"    try seek 1 pos=\" + upTo + \" term=\" + UnicodeUtil.toHexString(scratchTerm.utf8ToString()) + \" \" + scratchTerm.toString() + \" len=\" + scratchTerm.length);\n          }\n\n          // Seek \"forward\":\n          // TODO: more efficient seek?\n          getTermsDict().seekEnum(seekTermEnum, new Term(fieldInfo.name, scratchTerm), true);\n\n          scratchTerm.bytes[upTo] = scratch[0];\n          scratchTerm.bytes[upTo+1] = scratch[1];\n          scratchTerm.bytes[upTo+2] = scratch[2];\n          scratchTerm.length = savLength;\n\n          // Did we find a match?\n          final Term t2 = seekTermEnum.term();\n            \n          if (DEBUG_SURROGATES) {\n            if (t2 == null) {\n              System.out.println(\"      hit term=null\");\n            } else {\n              System.out.println(\"      hit term=\" + UnicodeUtil.toHexString(t2.text()) + \" \" + (t2==null? null:t2.bytes()));\n            }\n          }\n\n          // Since this was a seek \"forward\", we could hit\n          // EOF or a different field:\n          boolean matches;\n\n          if (t2 != null && t2.field() == internedFieldName) {\n            final BytesRef b2 = t2.bytes();\n            assert b2.offset == 0;\n            if (b2.length >= upTo+3 && isHighBMPChar(b2.bytes, upTo)) {\n              matches = true;\n              for(int i=0;i<upTo;i++) {\n                if (scratchTerm.bytes[i] != b2.bytes[i]) {\n                  matches = false;\n                  break;\n                }\n              }              \n                \n            } else {\n              matches = false;\n            }\n          } else {\n            matches = false;\n          }\n\n          if (matches) {\n\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"      matches!\");\n            }\n\n            // OK seek \"back\"\n            // TODO: more efficient seek?\n            getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);\n\n            scratchTerm.copy(seekTermEnum.term().bytes());\n\n            // +3 because we don't need to check the char\n            // at upTo: we know it's > BMP\n            upTo += 3;\n\n            // NOTE: we keep iterating, now, since this\n            // can easily \"recurse\".  Ie, after seeking\n            // forward at a certain char position, we may\n            // find another surrogate in our [new] suffix\n            // and must then do another seek (recurse)\n          } else {\n            upTo++;\n          }\n        } else {\n          upTo++;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4b103252dee6afa1b6d7a622c773d178788eb85a"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c9f6bb0c3d7b1c1dd8aeab43a34a89f050069e97"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"825bcb488bc228d1fb6a19c1f441a2181f7d766d":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["825bcb488bc228d1fb6a19c1f441a2181f7d766d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2553b00f699380c64959ccb27991289aae87be2e":["825bcb488bc228d1fb6a19c1f441a2181f7d766d","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["3242a09f703274d3b9283f2064a1a33064b53a1b","825bcb488bc228d1fb6a19c1f441a2181f7d766d"],"c9f6bb0c3d7b1c1dd8aeab43a34a89f050069e97":["163fe85a71d778fd2b7747f65ca27b54829e2e57"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["825bcb488bc228d1fb6a19c1f441a2181f7d766d","fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["3242a09f703274d3b9283f2064a1a33064b53a1b","825bcb488bc228d1fb6a19c1f441a2181f7d766d"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["c9f6bb0c3d7b1c1dd8aeab43a34a89f050069e97"],"825bcb488bc228d1fb6a19c1f441a2181f7d766d":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","2553b00f699380c64959ccb27991289aae87be2e","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["7b91922b55d15444d554721b352861d028eb8278","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3242a09f703274d3b9283f2064a1a33064b53a1b","4b103252dee6afa1b6d7a622c773d178788eb85a","163fe85a71d778fd2b7747f65ca27b54829e2e57"],"2553b00f699380c64959ccb27991289aae87be2e":[],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"c9f6bb0c3d7b1c1dd8aeab43a34a89f050069e97":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2553b00f699380c64959ccb27991289aae87be2e","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d083e83f225b11e5fdd900e83d26ddb385b6955c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}