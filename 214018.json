{"path":"contrib/miscellaneous/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","commits":[{"id":"74b183d06c98e975319fefb0a1bc672b66be868e","date":1148582944,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"contrib/miscellaneous/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"/dev/null","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n\tsearcher = new IndexSearcher(store);\n\tsearcher.search\n\t    (new TermQuery(new Term(\"field\", \"word\")),\n\t     new HitCollector() {\n\t\t public final void collect(int doc, float score) {\n\t\t     scores[doc] = score;\n\t\t }\n\t     });\n\tsearcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return (float)numTokens;\n\t\t}\n\t    };\n\tLengthNormModifier lnm = new LengthNormModifier(store, s);\n\tlnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store);\n\tsearcher.search\n\t    (new TermQuery(new Term(\"field\", \"word\")),\n\t     new HitCollector() {\n\t\t public final void collect(int doc, float score) {\n\t\t     scores[doc] = score;\n\t\t }\n\t     });\n\tsearcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"63bc3238545c6012bd44f5d294077997f236bc4e","date":1233087321,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/miscellaneous/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"contrib/miscellaneous/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new MultiReaderHitCollector() {\n    private int docBase = -1;\n    public final void collect(int doc, float score) {\n      scores[doc + docBase] = score;\n    }\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return (float)numTokens;\n\t\t}\n\t    };\n\tLengthNormModifier lnm = new LengthNormModifier(store, s);\n\tlnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new MultiReaderHitCollector() {\n      private int docBase = -1;\n      public final void collect(int doc, float score) {\n        scores[doc + docBase] = score;\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n\tsearcher = new IndexSearcher(store);\n\tsearcher.search\n\t    (new TermQuery(new Term(\"field\", \"word\")),\n\t     new HitCollector() {\n\t\t public final void collect(int doc, float score) {\n\t\t     scores[doc] = score;\n\t\t }\n\t     });\n\tsearcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return (float)numTokens;\n\t\t}\n\t    };\n\tLengthNormModifier lnm = new LengthNormModifier(store, s);\n\tlnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store);\n\tsearcher.search\n\t    (new TermQuery(new Term(\"field\", \"word\")),\n\t     new HitCollector() {\n\t\t public final void collect(int doc, float score) {\n\t\t     scores[doc] = score;\n\t\t }\n\t     });\n\tsearcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"64714133cf5ec732e3bbceee63351bb9af0117dc","date":1239647636,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/miscellaneous/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"contrib/miscellaneous/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return numTokens;\n\t\t}\n\t    };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new MultiReaderHitCollector() {\n    private int docBase = -1;\n    public final void collect(int doc, float score) {\n      scores[doc + docBase] = score;\n    }\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return (float)numTokens;\n\t\t}\n\t    };\n\tLengthNormModifier lnm = new LengthNormModifier(store, s);\n\tlnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new MultiReaderHitCollector() {\n      private int docBase = -1;\n      public final void collect(int doc, float score) {\n        scores[doc + docBase] = score;\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"052fac7830290bd38a04cddee1a121ee07656b56","date":1245780702,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"contrib/miscellaneous/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"contrib/miscellaneous/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return numTokens;\n\t\t}\n\t    };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return numTokens;\n\t\t}\n\t    };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"48bedd31c61edafb8baaff4bcbcac19449fb7c3a","date":1251468037,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/misc/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","pathOld":"contrib/miscellaneous/src/test/org/apache/lucene/misc/TestLengthNormModifier#testGoodCases().mjava","sourceNew":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return numTokens;\n\t\t}\n\t    };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","sourceOld":"    public void testGoodCases() throws Exception {\n\t\n\tIndexSearcher searcher;\n\tfinal float[] scores = new float[NUM_DOCS];\n\tfloat lastScore = 0.0f;\n\t\n\t// default similarity should put docs with shorter length first\n  searcher = new IndexSearcher(store);\n  searcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n    private int docBase = 0;\n    private Scorer scorer;\n    public final void collect(int doc) throws IOException {\n      scores[doc + docBase] = scorer.score();\n    }\n    public void setNextReader(IndexReader reader, int docBase) {\n      this.docBase = docBase;\n    }\n    public void setScorer(Scorer scorer) throws IOException {\n      this.scorer = scorer;\n    }\n    public boolean acceptsDocsOutOfOrder() {\n      return true;\n    }\n  });\n  searcher.close();\n\t\n\tlastScore = Float.MAX_VALUE;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" <= \"+lastScore;\n\t    assertTrue(msg, scores[i] <= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\n\t// override the norms to be inverted\n\tSimilarity s = new DefaultSimilarity() {\n\t\tpublic float lengthNorm(String fieldName, int numTokens) {\n\t\t    return numTokens;\n\t\t}\n\t    };\n\tFieldNormModifier fnm = new FieldNormModifier(store, s);\n\tfnm.reSetNorms(\"field\");\n\n\t// new norm (with default similarity) should put longer docs first\n\tsearcher = new IndexSearcher(store);\n\tsearcher.search(new TermQuery(new Term(\"field\", \"word\")), new Collector() {\n      private int docBase = 0;\n      private Scorer scorer;\n      public final void collect(int doc) throws IOException {\n        scores[doc + docBase] = scorer.score();\n      }\n      public void setNextReader(IndexReader reader, int docBase) {\n        this.docBase = docBase;\n      }\n      public void setScorer(Scorer scorer) throws IOException {\n        this.scorer = scorer;\n      }\n      public boolean acceptsDocsOutOfOrder() {\n        return true;\n      }\n    });\n    searcher.close();\n\t\n\tlastScore = 0.0f;\n\tfor (int i = 0; i < NUM_DOCS; i++) {\n\t    String msg = \"i=\" + i + \", \"+scores[i]+\" >= \"+lastScore;\n\t    assertTrue(msg, scores[i] >= lastScore);\n\t    //System.out.println(msg);\n\t    lastScore = scores[i];\n\t}\n\t\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"74b183d06c98e975319fefb0a1bc672b66be868e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"64714133cf5ec732e3bbceee63351bb9af0117dc":["63bc3238545c6012bd44f5d294077997f236bc4e"],"48bedd31c61edafb8baaff4bcbcac19449fb7c3a":["052fac7830290bd38a04cddee1a121ee07656b56"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"052fac7830290bd38a04cddee1a121ee07656b56":["64714133cf5ec732e3bbceee63351bb9af0117dc"],"63bc3238545c6012bd44f5d294077997f236bc4e":["74b183d06c98e975319fefb0a1bc672b66be868e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["48bedd31c61edafb8baaff4bcbcac19449fb7c3a"]},"commit2Childs":{"74b183d06c98e975319fefb0a1bc672b66be868e":["63bc3238545c6012bd44f5d294077997f236bc4e"],"64714133cf5ec732e3bbceee63351bb9af0117dc":["052fac7830290bd38a04cddee1a121ee07656b56"],"48bedd31c61edafb8baaff4bcbcac19449fb7c3a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["74b183d06c98e975319fefb0a1bc672b66be868e"],"63bc3238545c6012bd44f5d294077997f236bc4e":["64714133cf5ec732e3bbceee63351bb9af0117dc"],"052fac7830290bd38a04cddee1a121ee07656b56":["48bedd31c61edafb8baaff4bcbcac19449fb7c3a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}