{"path":"lucene/backward-codecs/src/java/org/apache/lucene/codecs/blocktree/Lucene40BlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","commits":[{"id":"0628077afea69a2955260949478afabab8e500d8","date":1413915332,"type":0,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/backward-codecs/src/java/org/apache/lucene/codecs/blocktree/Lucene40BlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"    /** Pushes the new term to the top of the stack, and writes new blocks. */\n    private void pushTerm(BytesRef text) throws IOException {\n      int limit = Math.min(lastTerm.length(), text.length);\n\n      // Find common prefix between last term and current term:\n      int pos = 0;\n      while (pos < limit && lastTerm.byteAt(pos) == text.bytes[text.offset+pos]) {\n        pos++;\n      }\n\n      // if (DEBUG) System.out.println(\"  shared=\" + pos + \"  lastTerm.length=\" + lastTerm.length);\n\n      // Close the \"abandoned\" suffix now:\n      for(int i=lastTerm.length()-1;i>=pos;i--) {\n\n        // How many items on top of the stack share the current suffix\n        // we are closing:\n        int prefixTopSize = pending.size() - prefixStarts[i];\n        if (prefixTopSize >= minItemsInBlock) {\n          // if (DEBUG) System.out.println(\"pushTerm i=\" + i + \" prefixTopSize=\" + prefixTopSize + \" minItemsInBlock=\" + minItemsInBlock);\n          writeBlocks(i+1, prefixTopSize);\n          prefixStarts[i] -= prefixTopSize-1;\n        }\n      }\n\n      if (prefixStarts.length < text.length) {\n        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);\n      }\n\n      // Init new tail:\n      for(int i=pos;i<text.length;i++) {\n        prefixStarts[i] = pending.size();\n      }\n\n      lastTerm.copyBytes(text);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6d238816bcdf9bbe4ec886226d89bd93834eb7e","date":1413925889,"type":5,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/blocktree/Lucene40BlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","pathOld":"lucene/backward-codecs/src/java/org/apache/lucene/codecs/blocktree/Lucene40BlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","sourceNew":"    /** Pushes the new term to the top of the stack, and writes new blocks. */\n    private void pushTerm(BytesRef text) throws IOException {\n      int limit = Math.min(lastTerm.length(), text.length);\n\n      // Find common prefix between last term and current term:\n      int pos = 0;\n      while (pos < limit && lastTerm.byteAt(pos) == text.bytes[text.offset+pos]) {\n        pos++;\n      }\n\n      // if (DEBUG) System.out.println(\"  shared=\" + pos + \"  lastTerm.length=\" + lastTerm.length);\n\n      // Close the \"abandoned\" suffix now:\n      for(int i=lastTerm.length()-1;i>=pos;i--) {\n\n        // How many items on top of the stack share the current suffix\n        // we are closing:\n        int prefixTopSize = pending.size() - prefixStarts[i];\n        if (prefixTopSize >= minItemsInBlock) {\n          // if (DEBUG) System.out.println(\"pushTerm i=\" + i + \" prefixTopSize=\" + prefixTopSize + \" minItemsInBlock=\" + minItemsInBlock);\n          writeBlocks(i+1, prefixTopSize);\n          prefixStarts[i] -= prefixTopSize-1;\n        }\n      }\n\n      if (prefixStarts.length < text.length) {\n        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);\n      }\n\n      // Init new tail:\n      for(int i=pos;i<text.length;i++) {\n        prefixStarts[i] = pending.size();\n      }\n\n      lastTerm.copyBytes(text);\n    }\n\n","sourceOld":"    /** Pushes the new term to the top of the stack, and writes new blocks. */\n    private void pushTerm(BytesRef text) throws IOException {\n      int limit = Math.min(lastTerm.length(), text.length);\n\n      // Find common prefix between last term and current term:\n      int pos = 0;\n      while (pos < limit && lastTerm.byteAt(pos) == text.bytes[text.offset+pos]) {\n        pos++;\n      }\n\n      // if (DEBUG) System.out.println(\"  shared=\" + pos + \"  lastTerm.length=\" + lastTerm.length);\n\n      // Close the \"abandoned\" suffix now:\n      for(int i=lastTerm.length()-1;i>=pos;i--) {\n\n        // How many items on top of the stack share the current suffix\n        // we are closing:\n        int prefixTopSize = pending.size() - prefixStarts[i];\n        if (prefixTopSize >= minItemsInBlock) {\n          // if (DEBUG) System.out.println(\"pushTerm i=\" + i + \" prefixTopSize=\" + prefixTopSize + \" minItemsInBlock=\" + minItemsInBlock);\n          writeBlocks(i+1, prefixTopSize);\n          prefixStarts[i] -= prefixTopSize-1;\n        }\n      }\n\n      if (prefixStarts.length < text.length) {\n        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);\n      }\n\n      // Init new tail:\n      for(int i=pos;i<text.length;i++) {\n        prefixStarts[i] = pending.size();\n      }\n\n      lastTerm.copyBytes(text);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c6d238816bcdf9bbe4ec886226d89bd93834eb7e":["0628077afea69a2955260949478afabab8e500d8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0628077afea69a2955260949478afabab8e500d8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"c6d238816bcdf9bbe4ec886226d89bd93834eb7e":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0628077afea69a2955260949478afabab8e500d8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0628077afea69a2955260949478afabab8e500d8":["c6d238816bcdf9bbe4ec886226d89bd93834eb7e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c6d238816bcdf9bbe4ec886226d89bd93834eb7e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}