{"path":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","commits":[{"id":"533890d1266aa8169162ec556395d0c5d0377566","date":1337173867,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"/dev/null","sourceNew":"  public void testConcurrency() throws Exception {\n    int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    Directory dir = newDirectory();\n    final ConcurrentHashMap<Integer,Integer> values = new ConcurrentHashMap<Integer,Integer>();\n    TaxonomyWriterCache cache = random().nextBoolean() \n        ? new Cl2oTaxonomyWriterCache(1024, 0.15f, 3) \n        : new LruTaxonomyWriterCache(ncats / 10);\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              tw.addCategory(new CategoryPath(\"a\", Integer.toString(value)));\n              values.put(value, value);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(values.size() + 2, dtr.getSize()); // +2 for root category + \"a\"\n    for (Integer value : values.keySet()) {\n      assertTrue(\"category not found a/\" + value, dtr.getOrdinal(new CategoryPath(\"a\", value.toString())) > 0);\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["209b03e6aa9098ac043cc757e46f758400427b15"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef0d8a69209261514c5739c770bba706c2308450","date":1337607597,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"/dev/null","sourceNew":"  public void testConcurrency() throws Exception {\n    int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    Directory dir = newDirectory();\n    final ConcurrentHashMap<Integer,Integer> values = new ConcurrentHashMap<Integer,Integer>();\n    TaxonomyWriterCache cache = random().nextBoolean() \n        ? new Cl2oTaxonomyWriterCache(1024, 0.15f, 3) \n        : new LruTaxonomyWriterCache(ncats / 10);\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              tw.addCategory(new CategoryPath(\"a\", Integer.toString(value)));\n              values.put(value, value);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(values.size() + 2, dtr.getSize()); // +2 for root category + \"a\"\n    for (Integer value : values.keySet()) {\n      assertTrue(\"category not found a/\" + value, dtr.getOrdinal(new CategoryPath(\"a\", value.toString())) > 0);\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b7a1bc6030c258e47d63eff3455a2b1bbf32683","date":1339494023,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<Integer,Integer> values = new ConcurrentHashMap<Integer,Integer>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = new NoOpCache();\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              tw.addCategory(new CategoryPath(\"a\", Integer.toString(value)));\n              values.put(value, value);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 2, dtr.getSize()); // +2 for root category + \"a\"\n    for (Integer value : values.keySet()) {\n      assertTrue(\"category not found a/\" + value, dtr.getOrdinal(new CategoryPath(\"a\", value.toString())) > 0);\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    Directory dir = newDirectory();\n    final ConcurrentHashMap<Integer,Integer> values = new ConcurrentHashMap<Integer,Integer>();\n    TaxonomyWriterCache cache = random().nextBoolean() \n        ? new Cl2oTaxonomyWriterCache(1024, 0.15f, 3) \n        : new LruTaxonomyWriterCache(ncats / 10);\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              tw.addCategory(new CategoryPath(\"a\", Integer.toString(value)));\n              values.put(value, value);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(values.size() + 2, dtr.getSize()); // +2 for root category + \"a\"\n    for (Integer value : values.keySet()) {\n      assertTrue(\"category not found a/\" + value, dtr.getOrdinal(new CategoryPath(\"a\", value.toString())) > 0);\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["209b03e6aa9098ac043cc757e46f758400427b15"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b52ea8b7f80d4a0600efc9765dc896387008ebd4","date":1340109038,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<Integer,Integer> values = new ConcurrentHashMap<Integer,Integer>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              tw.addCategory(new CategoryPath(\"a\", Integer.toString(value)));\n              values.put(value, value);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 2, dtr.getSize()); // +2 for root category + \"a\"\n    for (Integer value : values.keySet()) {\n      assertTrue(\"category not found a/\" + value, dtr.getOrdinal(new CategoryPath(\"a\", value.toString())) > 0);\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<Integer,Integer> values = new ConcurrentHashMap<Integer,Integer>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = new NoOpCache();\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              tw.addCategory(new CategoryPath(\"a\", Integer.toString(value)));\n              values.put(value, value);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 2, dtr.getSize()); // +2 for root category + \"a\"\n    for (Integer value : values.keySet()) {\n      assertTrue(\"category not found a/\" + value, dtr.getOrdinal(new CategoryPath(\"a\", value.toString())) > 0);\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"209b03e6aa9098ac043cc757e46f758400427b15","date":1355045906,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              CategoryPath cp = new CategoryPath(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = cp.toString('/', 1);\n              String l2 = cp.toString('/', 2);\n              String l3 = cp.toString('/', 3);\n              String l4 = cp.toString('/', 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length();\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = new CategoryPath();\n      for (int i = 0; i < level; i++) {\n        path.add(cp.getComponent(i));\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<Integer,Integer> values = new ConcurrentHashMap<Integer,Integer>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              tw.addCategory(new CategoryPath(\"a\", Integer.toString(value)));\n              values.put(value, value);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 2, dtr.getSize()); // +2 for root category + \"a\"\n    for (Integer value : values.keySet()) {\n      assertTrue(\"category not found a/\" + value, dtr.getOrdinal(new CategoryPath(\"a\", value.toString())) > 0);\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","bugFix":["8b7a1bc6030c258e47d63eff3455a2b1bbf32683","533890d1266aa8169162ec556395d0c5d0377566"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              CategoryPath cp = new CategoryPath(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = cp.toString('/', 1);\n              String l2 = cp.toString('/', 2);\n              String l3 = cp.toString('/', 3);\n              String l4 = cp.toString('/', 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length();\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = new CategoryPath();\n      for (int i = 0; i < level; i++) {\n        path.add(cp.getComponent(i));\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<Integer,Integer> values = new ConcurrentHashMap<Integer,Integer>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              tw.addCategory(new CategoryPath(\"a\", Integer.toString(value)));\n              values.put(value, value);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 2, dtr.getSize()); // +2 for root category + \"a\"\n    for (Integer value : values.keySet()) {\n      assertTrue(\"category not found a/\" + value, dtr.getOrdinal(new CategoryPath(\"a\", value.toString())) > 0);\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1","date":1357499264,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              CategoryPath cp = new CategoryPath(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = cp.subpath(1).toString('/');\n              String l2 = cp.subpath(2).toString('/');\n              String l3 = cp.subpath(3).toString('/');\n              String l4 = cp.subpath(4).toString('/');\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = CategoryPath.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              CategoryPath cp = new CategoryPath(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = cp.toString('/', 1);\n              String l2 = cp.toString('/', 2);\n              String l3 = cp.toString('/', 3);\n              String l4 = cp.toString('/', 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length();\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = new CategoryPath();\n      for (int i = 0; i < level; i++) {\n        path.add(cp.getComponent(i));\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              CategoryPath cp = new CategoryPath(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = cp.subpath(1).toString('/');\n              String l2 = cp.subpath(2).toString('/');\n              String l3 = cp.subpath(3).toString('/');\n              String l4 = cp.subpath(4).toString('/');\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = CategoryPath.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              CategoryPath cp = new CategoryPath(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = cp.toString('/', 1);\n              String l2 = cp.toString('/', 2);\n              String l3 = cp.toString('/', 3);\n              String l4 = cp.toString('/', 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length();\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = new CategoryPath();\n      for (int i = 0; i < level; i++) {\n        path.add(cp.getComponent(i));\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = cp.subpath(1).toString('/');\n              String l2 = cp.subpath(2).toString('/');\n              String l3 = cp.subpath(3).toString('/');\n              String l4 = cp.subpath(4).toString('/');\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(cat, '/');\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = FacetLabel.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              CategoryPath cp = new CategoryPath(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = cp.subpath(1).toString('/');\n              String l2 = cp.subpath(2).toString('/');\n              String l3 = cp.subpath(3).toString('/');\n              String l4 = cp.subpath(4).toString('/');\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = CategoryPath.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bbe9946d3cd818d329255e4c325597ac3480503e","date":1385580921,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = FacetsConfig.pathToString(cp.components, 1);\n              String l2 = FacetsConfig.pathToString(cp.components, 2);\n              String l3 = FacetsConfig.pathToString(cp.components, 3);\n              String l4 = FacetsConfig.pathToString(cp.components, 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = FacetLabel.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = cp.subpath(1).toString('/');\n              String l2 = cp.subpath(2).toString('/');\n              String l3 = cp.subpath(3).toString('/');\n              String l4 = cp.subpath(4).toString('/');\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(cat, '/');\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = FacetLabel.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56d44586f4c409c6c6c5942b9f0227df806b7300","date":1386027853,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = FacetsConfig.pathToString(cp.components, 1);\n              String l2 = FacetsConfig.pathToString(cp.components, 2);\n              String l3 = FacetsConfig.pathToString(cp.components, 3);\n              String l4 = FacetsConfig.pathToString(cp.components, 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = new FacetLabel();\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = FacetsConfig.pathToString(cp.components, 1);\n              String l2 = FacetsConfig.pathToString(cp.components, 2);\n              String l3 = FacetsConfig.pathToString(cp.components, 3);\n              String l4 = FacetsConfig.pathToString(cp.components, 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = FacetLabel.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9264c0cc71ca63967ca4c832e5d3514c000b55e6","date":1386094934,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    if (VERBOSE) {\n      System.out.println(\"TEST: use cache=\" + cache);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = FacetsConfig.pathToString(cp.components, 1);\n              String l2 = FacetsConfig.pathToString(cp.components, 2);\n              String l3 = FacetsConfig.pathToString(cp.components, 3);\n              String l4 = FacetsConfig.pathToString(cp.components, 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    // +1 for root category\n    if (values.size() + 1 != dtr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (dtr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = new FacetLabel();\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(dtr, dir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = FacetsConfig.pathToString(cp.components, 1);\n              String l2 = FacetsConfig.pathToString(cp.components, 2);\n              String l3 = FacetsConfig.pathToString(cp.components, 3);\n              String l4 = FacetsConfig.pathToString(cp.components, 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = new FacetLabel();\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    if (VERBOSE) {\n      System.out.println(\"TEST: use cache=\" + cache);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = FacetsConfig.pathToString(cp.components, 1);\n              String l2 = FacetsConfig.pathToString(cp.components, 2);\n              String l3 = FacetsConfig.pathToString(cp.components, 3);\n              String l4 = FacetsConfig.pathToString(cp.components, 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    // +1 for root category\n    if (values.size() + 1 != dtr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (dtr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = new FacetLabel();\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(dtr, dir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              CategoryPath cp = new CategoryPath(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = cp.subpath(1).toString('/');\n              String l2 = cp.subpath(2).toString('/');\n              String l3 = cp.subpath(3).toString('/');\n              String l4 = cp.subpath(4).toString('/');\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    assertEquals(\"mismatch number of categories\", values.size() + 1, dtr.getSize()); // +1 for root category\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      CategoryPath cp = new CategoryPath(cat, '/');\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      CategoryPath path = CategoryPath.EMPTY;\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n    dtr.close();\n    \n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    if (VERBOSE) {\n      System.out.println(\"TEST: use cache=\" + cache);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = FacetsConfig.pathToString(cp.components, 1);\n              String l2 = FacetsConfig.pathToString(cp.components, 2);\n              String l3 = FacetsConfig.pathToString(cp.components, 3);\n              String l4 = FacetsConfig.pathToString(cp.components, 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    // +1 for root category\n    if (values.size() + 1 != dtr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (dtr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = new FacetLabel();\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(dtr, dir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<String,String>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    if (VERBOSE) {\n      System.out.println(\"TEST: use cache=\" + cache);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = FacetsConfig.pathToString(cp.components, 1);\n              String l2 = FacetsConfig.pathToString(cp.components, 2);\n              String l3 = FacetsConfig.pathToString(cp.components, 3);\n              String l4 = FacetsConfig.pathToString(cp.components, 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    // +1 for root category\n    if (values.size() + 1 != dtr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (dtr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = new FacetLabel();\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(dtr, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ae0982c0457fa3cfe0cda93a327c573fbe6f874","date":1507039114,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new UTF8TaxonomyWriterCache();\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than UTF8, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    if (VERBOSE) {\n      System.out.println(\"TEST: use cache=\" + cache);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = FacetsConfig.pathToString(cp.components, 1);\n              String l2 = FacetsConfig.pathToString(cp.components, 2);\n              String l3 = FacetsConfig.pathToString(cp.components, 3);\n              String l4 = FacetsConfig.pathToString(cp.components, 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    // +1 for root category\n    if (values.size() + 1 != dtr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (dtr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = new FacetLabel();\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(dtr, dir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new Cl2oTaxonomyWriterCache(1024, 0.15f, 3);\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than CL2O, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    if (VERBOSE) {\n      System.out.println(\"TEST: use cache=\" + cache);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = FacetsConfig.pathToString(cp.components, 1);\n              String l2 = FacetsConfig.pathToString(cp.components, 2);\n              String l3 = FacetsConfig.pathToString(cp.components, 3);\n              String l4 = FacetsConfig.pathToString(cp.components, 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    // +1 for root category\n    if (values.size() + 1 != dtr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (dtr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = new FacetLabel();\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(dtr, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c6c784f777a2cc8fa014507ea129526822714d","date":1579733373,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/taxonomy/directory/TestDirectoryTaxonomyWriter#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Exception {\n    final int ncats = TEST_NIGHTLY ? atLeast(100000)  : atLeast(1000); // at night, add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new UTF8TaxonomyWriterCache();\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than UTF8, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    if (VERBOSE) {\n      System.out.println(\"TEST: use cache=\" + cache);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = FacetsConfig.pathToString(cp.components, 1);\n              String l2 = FacetsConfig.pathToString(cp.components, 2);\n              String l3 = FacetsConfig.pathToString(cp.components, 3);\n              String l4 = FacetsConfig.pathToString(cp.components, 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    // +1 for root category\n    if (values.size() + 1 != dtr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (dtr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = new FacetLabel();\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(dtr, dir);\n  }\n\n","sourceOld":"  public void testConcurrency() throws Exception {\n    final int ncats = atLeast(100000); // add many categories\n    final int range = ncats * 3; // affects the categories selection\n    final AtomicInteger numCats = new AtomicInteger(ncats);\n    final Directory dir = newDirectory();\n    final ConcurrentHashMap<String,String> values = new ConcurrentHashMap<>();\n    final double d = random().nextDouble();\n    final TaxonomyWriterCache cache;\n    if (d < 0.7) {\n      // this is the fastest, yet most memory consuming\n      cache = new UTF8TaxonomyWriterCache();\n    } else if (TEST_NIGHTLY && d > 0.98) {\n      // this is the slowest, but tests the writer concurrency when no caching is done.\n      // only pick it during NIGHTLY tests, and even then, with very low chances.\n      cache = NO_OP_CACHE;\n    } else {\n      // this is slower than UTF8, but less memory consuming, and exercises finding categories on disk too.\n      cache = new LruTaxonomyWriterCache(ncats / 10);\n    }\n    if (VERBOSE) {\n      System.out.println(\"TEST: use cache=\" + cache);\n    }\n    final DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(dir, OpenMode.CREATE, cache);\n    Thread[] addThreads = new Thread[atLeast(4)];\n    for (int z = 0; z < addThreads.length; z++) {\n      addThreads[z] = new Thread() {\n        @Override\n        public void run() {\n          Random random = random();\n          while (numCats.decrementAndGet() > 0) {\n            try {\n              int value = random.nextInt(range);\n              FacetLabel cp = new FacetLabel(Integer.toString(value / 1000), Integer.toString(value / 10000),\n                  Integer.toString(value / 100000), Integer.toString(value));\n              int ord = tw.addCategory(cp);\n              assertTrue(\"invalid parent for ordinal \" + ord + \", category \" + cp, tw.getParent(ord) != -1);\n              String l1 = FacetsConfig.pathToString(cp.components, 1);\n              String l2 = FacetsConfig.pathToString(cp.components, 2);\n              String l3 = FacetsConfig.pathToString(cp.components, 3);\n              String l4 = FacetsConfig.pathToString(cp.components, 4);\n              values.put(l1, l1);\n              values.put(l2, l2);\n              values.put(l3, l3);\n              values.put(l4, l4);\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n      };\n    }\n    \n    for (Thread t : addThreads) t.start();\n    for (Thread t : addThreads) t.join();\n    tw.close();\n    \n    DirectoryTaxonomyReader dtr = new DirectoryTaxonomyReader(dir);\n    // +1 for root category\n    if (values.size() + 1 != dtr.getSize()) {\n      for(String value : values.keySet()) {\n        FacetLabel label = new FacetLabel(FacetsConfig.stringToPath(value));\n        if (dtr.getOrdinal(label) == -1) {\n          System.out.println(\"FAIL: path=\" + label + \" not recognized\");\n        }\n      }\n      fail(\"mismatch number of categories\");\n    }\n\n    int[] parents = dtr.getParallelTaxonomyArrays().parents();\n    for (String cat : values.keySet()) {\n      FacetLabel cp = new FacetLabel(FacetsConfig.stringToPath(cat));\n      assertTrue(\"category not found \" + cp, dtr.getOrdinal(cp) > 0);\n      int level = cp.length;\n      int parentOrd = 0; // for root, parent is always virtual ROOT (ord=0)\n      FacetLabel path = new FacetLabel();\n      for (int i = 0; i < level; i++) {\n        path = cp.subpath(i + 1);\n        int ord = dtr.getOrdinal(path);\n        assertEquals(\"invalid parent for cp=\" + path, parentOrd, parents[ord]);\n        parentOrd = ord; // next level should have this parent\n      }\n    }\n\n    IOUtils.close(dtr, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2ae0982c0457fa3cfe0cda93a327c573fbe6f874":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"56d44586f4c409c6c6c5942b9f0227df806b7300":["bbe9946d3cd818d329255e4c325597ac3480503e"],"407687e67faf6e1f02a211ca078d8e3eed631027":["b52ea8b7f80d4a0600efc9765dc896387008ebd4","209b03e6aa9098ac043cc757e46f758400427b15"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"57c6c784f777a2cc8fa014507ea129526822714d":["2ae0982c0457fa3cfe0cda93a327c573fbe6f874"],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["209b03e6aa9098ac043cc757e46f758400427b15"],"209b03e6aa9098ac043cc757e46f758400427b15":["b52ea8b7f80d4a0600efc9765dc896387008ebd4"],"9264c0cc71ca63967ca4c832e5d3514c000b55e6":["56d44586f4c409c6c6c5942b9f0227df806b7300"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b52ea8b7f80d4a0600efc9765dc896387008ebd4":["8b7a1bc6030c258e47d63eff3455a2b1bbf32683"],"8b7a1bc6030c258e47d63eff3455a2b1bbf32683":["533890d1266aa8169162ec556395d0c5d0377566"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["d90771c07d45c6ad884c5ef9cb3a6eeb257238d1","9264c0cc71ca63967ca4c832e5d3514c000b55e6"],"533890d1266aa8169162ec556395d0c5d0377566":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ef0d8a69209261514c5739c770bba706c2308450":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","533890d1266aa8169162ec556395d0c5d0377566"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57c6c784f777a2cc8fa014507ea129526822714d"],"bbe9946d3cd818d329255e4c325597ac3480503e":["c190847801a50f4dd20fd639bdc29b54ea3b288b"]},"commit2Childs":{"2ae0982c0457fa3cfe0cda93a327c573fbe6f874":["57c6c784f777a2cc8fa014507ea129526822714d"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2ae0982c0457fa3cfe0cda93a327c573fbe6f874"],"56d44586f4c409c6c6c5942b9f0227df806b7300":["9264c0cc71ca63967ca4c832e5d3514c000b55e6"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["bbe9946d3cd818d329255e4c325597ac3480503e"],"d90771c07d45c6ad884c5ef9cb3a6eeb257238d1":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","c190847801a50f4dd20fd639bdc29b54ea3b288b","3cc728b07df73b197e6d940d27f9b08b63918f13"],"57c6c784f777a2cc8fa014507ea129526822714d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"209b03e6aa9098ac043cc757e46f758400427b15":["407687e67faf6e1f02a211ca078d8e3eed631027","d90771c07d45c6ad884c5ef9cb3a6eeb257238d1"],"9264c0cc71ca63967ca4c832e5d3514c000b55e6":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["533890d1266aa8169162ec556395d0c5d0377566","ef0d8a69209261514c5739c770bba706c2308450"],"b52ea8b7f80d4a0600efc9765dc896387008ebd4":["407687e67faf6e1f02a211ca078d8e3eed631027","209b03e6aa9098ac043cc757e46f758400427b15"],"8b7a1bc6030c258e47d63eff3455a2b1bbf32683":["b52ea8b7f80d4a0600efc9765dc896387008ebd4"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"533890d1266aa8169162ec556395d0c5d0377566":["8b7a1bc6030c258e47d63eff3455a2b1bbf32683","ef0d8a69209261514c5739c770bba706c2308450"],"ef0d8a69209261514c5739c770bba706c2308450":[],"bbe9946d3cd818d329255e4c325597ac3480503e":["56d44586f4c409c6c6c5942b9f0227df806b7300"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","ef0d8a69209261514c5739c770bba706c2308450","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}