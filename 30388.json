{"path":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","commits":[{"id":"71b83dcf02fe2854488bc83d70dee29c5baa7e5c","date":1383232808,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int i = 0 ; i < dependencies.getLength() ; ++i) {\n      Element dependency = (Element)dependencies.item(i);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      String classifier = null;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      if (dependency.hasChildNodes()) {\n        NodeList artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n        Element firstArtifact = (Element)artifacts.item(0);\n        if (artifacts.getLength() > 0) {\n          if (  ! \"jar\".equals(firstArtifact.getAttribute(\"type\"))\n             && ! \"jar\".equals(firstArtifact.getAttribute(\"ext\"))) {\n            nonJarDependencies.add(dependencyCoordinate);\n            continue; // ignore non-jar dependencies\n          }\n          String mavenClassifier = firstArtifact.getAttribute(\"maven:classifier\");\n          if ( ! mavenClassifier.isEmpty()) {\n            classifier = mavenClassifier;\n            classifiers.add(classifier);\n          }\n        }\n      }\n      classifiers.add(classifier);\n      String conf = dependency.getAttribute(\"conf\");\n      boolean isTestDependency = conf.contains(\"test\");\n      boolean isOptional = optionalExternalDependencies.contains(dependencyCoordinate);\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<ExternalDependency>();\n        allExternalDependencies.put(module, deps);\n      }\n      deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1895a927902788cc1b62e5cfd03b0848303689ad"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"582a32eeb049d563d59e2958fe2d130e473101ff","date":1385502371,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","sourceNew":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean isTestDependency = conf.contains(\"test\");\n      boolean isOptional = optionalExternalDependencies.contains(dependencyCoordinate);\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<ExternalDependency>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, isTestDependency, isOptional));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int i = 0 ; i < dependencies.getLength() ; ++i) {\n      Element dependency = (Element)dependencies.item(i);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      String classifier = null;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      if (dependency.hasChildNodes()) {\n        NodeList artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n        Element firstArtifact = (Element)artifacts.item(0);\n        if (artifacts.getLength() > 0) {\n          if (  ! \"jar\".equals(firstArtifact.getAttribute(\"type\"))\n             && ! \"jar\".equals(firstArtifact.getAttribute(\"ext\"))) {\n            nonJarDependencies.add(dependencyCoordinate);\n            continue; // ignore non-jar dependencies\n          }\n          String mavenClassifier = firstArtifact.getAttribute(\"maven:classifier\");\n          if ( ! mavenClassifier.isEmpty()) {\n            classifier = mavenClassifier;\n            classifiers.add(classifier);\n          }\n        }\n      }\n      classifiers.add(classifier);\n      String conf = dependency.getAttribute(\"conf\");\n      boolean isTestDependency = conf.contains(\"test\");\n      boolean isOptional = optionalExternalDependencies.contains(dependencyCoordinate);\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<ExternalDependency>();\n        allExternalDependencies.put(module, deps);\n      }\n      deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"690c3ac413de53ffc086a32ce5351ab6257e03ea","date":1386090491,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","sourceNew":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = optionalExternalDependencies.contains(dependencyCoordinate);\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<ExternalDependency>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean isTestDependency = conf.contains(\"test\");\n      boolean isOptional = optionalExternalDependencies.contains(dependencyCoordinate);\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<ExternalDependency>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, isTestDependency, isOptional));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","sourceNew":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = optionalExternalDependencies.contains(dependencyCoordinate);\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<ExternalDependency>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int i = 0 ; i < dependencies.getLength() ; ++i) {\n      Element dependency = (Element)dependencies.item(i);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      String classifier = null;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      if (dependency.hasChildNodes()) {\n        NodeList artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n        Element firstArtifact = (Element)artifacts.item(0);\n        if (artifacts.getLength() > 0) {\n          if (  ! \"jar\".equals(firstArtifact.getAttribute(\"type\"))\n             && ! \"jar\".equals(firstArtifact.getAttribute(\"ext\"))) {\n            nonJarDependencies.add(dependencyCoordinate);\n            continue; // ignore non-jar dependencies\n          }\n          String mavenClassifier = firstArtifact.getAttribute(\"maven:classifier\");\n          if ( ! mavenClassifier.isEmpty()) {\n            classifier = mavenClassifier;\n            classifiers.add(classifier);\n          }\n        }\n      }\n      classifiers.add(classifier);\n      String conf = dependency.getAttribute(\"conf\");\n      boolean isTestDependency = conf.contains(\"test\");\n      boolean isOptional = optionalExternalDependencies.contains(dependencyCoordinate);\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<ExternalDependency>();\n        allExternalDependencies.put(module, deps);\n      }\n      deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","sourceNew":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = optionalExternalDependencies.contains(dependencyCoordinate);\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = optionalExternalDependencies.contains(dependencyCoordinate);\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<ExternalDependency>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1895a927902788cc1b62e5cfd03b0848303689ad","date":1396568948,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","sourceNew":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = globalOptionalExternalDependencies.contains(dependencyCoordinate)\n          || ( perModuleOptionalExternalDependencies.containsKey(module)\n              && perModuleOptionalExternalDependencies.get(module).contains(dependencyCoordinate));\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = optionalExternalDependencies.contains(dependencyCoordinate);\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","bugFix":["71b83dcf02fe2854488bc83d70dee29c5baa7e5c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","sourceNew":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = globalOptionalExternalDependencies.contains(dependencyCoordinate)\n          || ( perModuleOptionalExternalDependencies.containsKey(module)\n              && perModuleOptionalExternalDependencies.get(module).contains(dependencyCoordinate));\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = optionalExternalDependencies.contains(dependencyCoordinate);\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0817071eecb9726181042f05f38d8a41ad215f27","date":1413658865,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","sourceNew":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    // Exclude the 'start' configuration in solr/example/ivy.xml\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = globalOptionalExternalDependencies.contains(dependencyCoordinate)\n          || ( perModuleOptionalExternalDependencies.containsKey(module)\n              && perModuleOptionalExternalDependencies.get(module).contains(dependencyCoordinate));\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = globalOptionalExternalDependencies.contains(dependencyCoordinate)\n          || ( perModuleOptionalExternalDependencies.containsKey(module)\n              && perModuleOptionalExternalDependencies.get(module).contains(dependencyCoordinate));\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a22eafe3f72a4c2945eaad9547e6c78816978f4","date":1413956657,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","sourceNew":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    // Exclude the 'start' configuration in solr/example/ivy.xml\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = globalOptionalExternalDependencies.contains(dependencyCoordinate)\n          || ( perModuleOptionalExternalDependencies.containsKey(module)\n              && perModuleOptionalExternalDependencies.get(module).contains(dependencyCoordinate));\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start->'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = globalOptionalExternalDependencies.contains(dependencyCoordinate)\n          || ( perModuleOptionalExternalDependencies.containsKey(module)\n              && perModuleOptionalExternalDependencies.get(module).contains(dependencyCoordinate));\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3664979e90fe16c4d429c1a1b16cbc4f244ab4a1","date":1421196403,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","sourceNew":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    // Exclude the 'start' configuration in solr/server/ivy.xml\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = globalOptionalExternalDependencies.contains(dependencyCoordinate)\n          || ( perModuleOptionalExternalDependencies.containsKey(module)\n              && perModuleOptionalExternalDependencies.get(module).contains(dependencyCoordinate));\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    // Exclude the 'start' configuration in solr/example/ivy.xml\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = globalOptionalExternalDependencies.contains(dependencyCoordinate)\n          || ( perModuleOptionalExternalDependencies.containsKey(module)\n              && perModuleOptionalExternalDependencies.get(module).contains(dependencyCoordinate));\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e025cf1c07150c8db28879d785db17eb3a66ca9f","date":1598788864,"type":4,"author":"Dawid Weiss","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#collectExternalDependenciesFromIvyXmlFile(File).mjava","sourceNew":null,"sourceOld":"  /**\n   * Collect external dependencies from the given ivy.xml file, constructing\n   * property values containing &lt;dependency&gt; snippets, which will be\n   * filtered (substituted) when copying the POM for the module corresponding\n   * to the given ivy.xml file.\n   */\n  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)\n      throws XPathExpressionException, IOException, SAXException {\n    String module = getModuleName(ivyXmlFile);\n    log(\"Collecting external dependencies from: \" + ivyXmlFile.getPath(), verboseLevel);\n    Document document = documentBuilder.parse(ivyXmlFile);\n    // Exclude the 'start' configuration in solr/server/ivy.xml\n    String dependencyPath = \"/ivy-module/dependencies/dependency[not(starts-with(@conf,'start'))]\";\n    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);\n    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {\n      Element dependency = (Element)dependencies.item(depNum);\n      String groupId = dependency.getAttribute(\"org\");\n      String artifactId = dependency.getAttribute(\"name\");\n      String dependencyCoordinate = groupId + ':' + artifactId;\n      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);\n      if (null == classifiers) {\n        classifiers = new HashSet<>();\n        dependencyClassifiers.put(dependencyCoordinate, classifiers);\n      }\n      String conf = dependency.getAttribute(\"conf\");\n      boolean confContainsTest = conf.contains(\"test\");\n      boolean isOptional = globalOptionalExternalDependencies.contains(dependencyCoordinate)\n          || ( perModuleOptionalExternalDependencies.containsKey(module)\n              && perModuleOptionalExternalDependencies.get(module).contains(dependencyCoordinate));\n      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);\n      if (null == deps) {\n        deps = new TreeSet<>();\n        allExternalDependencies.put(module, deps);\n      }\n      NodeList artifacts = null;\n      if (dependency.hasChildNodes()) {\n        artifacts = (NodeList)xpath.evaluate(\"artifact\", dependency, XPathConstants.NODESET);\n      }\n      if (null != artifacts && artifacts.getLength() > 0) {\n        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {\n          Element artifact = (Element)artifacts.item(artifactNum);\n          String type = artifact.getAttribute(\"type\");\n          String ext = artifact.getAttribute(\"ext\");\n          // When conf contains BOTH \"test\" and \"compile\", and type != \"test\", this is NOT a test dependency\n          boolean isTestDependency = confContainsTest && (type.equals(\"test\") || ! conf.contains(\"compile\"));\n          if ((type.isEmpty() && ext.isEmpty()) || type.equals(\"jar\") || ext.equals(\"jar\")) {\n            String classifier = artifact.getAttribute(\"maven:classifier\");\n            if (classifier.isEmpty()) {\n              classifier = null;\n            }\n            classifiers.add(classifier);\n            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));\n          } else { // not a jar\n            nonJarDependencies.add(dependencyCoordinate);\n          }\n        }\n      } else {\n        classifiers.add(null);\n        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","1895a927902788cc1b62e5cfd03b0848303689ad"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["690c3ac413de53ffc086a32ce5351ab6257e03ea"],"0817071eecb9726181042f05f38d8a41ad215f27":["1895a927902788cc1b62e5cfd03b0848303689ad"],"582a32eeb049d563d59e2958fe2d130e473101ff":["71b83dcf02fe2854488bc83d70dee29c5baa7e5c"],"e025cf1c07150c8db28879d785db17eb3a66ca9f":["3664979e90fe16c4d429c1a1b16cbc4f244ab4a1"],"71b83dcf02fe2854488bc83d70dee29c5baa7e5c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1895a927902788cc1b62e5cfd03b0848303689ad":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"690c3ac413de53ffc086a32ce5351ab6257e03ea":["582a32eeb049d563d59e2958fe2d130e473101ff"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":["1895a927902788cc1b62e5cfd03b0848303689ad","0817071eecb9726181042f05f38d8a41ad215f27"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["71b83dcf02fe2854488bc83d70dee29c5baa7e5c","690c3ac413de53ffc086a32ce5351ab6257e03ea"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e025cf1c07150c8db28879d785db17eb3a66ca9f"],"3664979e90fe16c4d429c1a1b16cbc4f244ab4a1":["0817071eecb9726181042f05f38d8a41ad215f27"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["5eb2511ababf862ea11e10761c70ee560cd84510","1895a927902788cc1b62e5cfd03b0848303689ad"],"0817071eecb9726181042f05f38d8a41ad215f27":["0a22eafe3f72a4c2945eaad9547e6c78816978f4","3664979e90fe16c4d429c1a1b16cbc4f244ab4a1"],"582a32eeb049d563d59e2958fe2d130e473101ff":["690c3ac413de53ffc086a32ce5351ab6257e03ea"],"71b83dcf02fe2854488bc83d70dee29c5baa7e5c":["582a32eeb049d563d59e2958fe2d130e473101ff","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"e025cf1c07150c8db28879d785db17eb3a66ca9f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1895a927902788cc1b62e5cfd03b0848303689ad":["5eb2511ababf862ea11e10761c70ee560cd84510","0817071eecb9726181042f05f38d8a41ad215f27","0a22eafe3f72a4c2945eaad9547e6c78816978f4"],"690c3ac413de53ffc086a32ce5351ab6257e03ea":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"0a22eafe3f72a4c2945eaad9547e6c78816978f4":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["71b83dcf02fe2854488bc83d70dee29c5baa7e5c"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"3664979e90fe16c4d429c1a1b16cbc4f244ab4a1":["e025cf1c07150c8db28879d785db17eb3a66ca9f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","0a22eafe3f72a4c2945eaad9547e6c78816978f4","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}