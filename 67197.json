{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/UniformSplitTermsWriter#UniformSplitTermsWriter(PostingsWriterBase,SegmentWriteState,int,int,BlockEncoder,FieldMetadata.Serializer,String,int,String,String).mjava","commits":[{"id":"d28da8a459f5f0c930da7185c56d0c25edd3fbd1","date":1577783695,"type":1,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/UniformSplitTermsWriter#UniformSplitTermsWriter(PostingsWriterBase,SegmentWriteState,int,int,BlockEncoder,FieldMetadata.Serializer,String,int,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/UniformSplitTermsWriter#UniformSplitTermsWriter(PostingsWriterBase,SegmentWriteState,int,int,BlockEncoder,String,int,String,String).mjava","sourceNew":"  /**\n   * @param targetNumBlockLines Target number of lines per block.\n   *                            Must be strictly greater than 0.\n   *                            The parameters can be pre-validated with {@link #validateSettings(int, int)}.\n   *                            There is one term per block line, with its corresponding details ({@link org.apache.lucene.index.TermState}).\n   * @param deltaNumLines       Maximum allowed delta variation of the number of lines per block.\n   *                            Must be greater than or equal to 0 and strictly less than {@code targetNumBlockLines}.\n   *                            The block size will be {@code targetNumBlockLines}+-{@code deltaNumLines}.\n   *                            The block size must always be less than or equal to {@link #MAX_NUM_BLOCK_LINES}.\n   * @param blockEncoder        Optional block encoder, may be null if none.\n   *                            It can be used for compression or encryption.\n   */\n  protected UniformSplitTermsWriter(PostingsWriterBase postingsWriter, SegmentWriteState state,\n                          int targetNumBlockLines, int deltaNumLines, BlockEncoder blockEncoder, FieldMetadata.Serializer fieldMetadataWriter,\n                          String codecName, int versionCurrent, String termsBlocksExtension, String dictionaryExtension) throws IOException {\n    validateSettings(targetNumBlockLines, deltaNumLines);\n    IndexOutput blockOutput = null;\n    IndexOutput dictionaryOutput = null;\n    boolean success = false;\n    try {\n      this.fieldInfos = state.fieldInfos;\n      this.postingsWriter = postingsWriter;\n      this.maxDoc = state.segmentInfo.maxDoc();\n      this.targetNumBlockLines = targetNumBlockLines;\n      this.deltaNumLines = deltaNumLines;\n      this.blockEncoder = blockEncoder;\n      this.fieldMetadataWriter = fieldMetadataWriter;\n\n      String termsName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, termsBlocksExtension);\n      blockOutput = state.directory.createOutput(termsName, state.context);\n      CodecUtil.writeIndexHeader(blockOutput, codecName, versionCurrent, state.segmentInfo.getId(), state.segmentSuffix);\n\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dictionaryExtension);\n      dictionaryOutput = state.directory.createOutput(indexName, state.context);\n      CodecUtil.writeIndexHeader(dictionaryOutput, codecName, versionCurrent, state.segmentInfo.getId(), state.segmentSuffix);\n\n      postingsWriter.init(blockOutput, state);\n\n      this.blockOutput = blockOutput;\n      this.dictionaryOutput = dictionaryOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(blockOutput, dictionaryOutput);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param targetNumBlockLines Target number of lines per block.\n   *                            Must be strictly greater than 0.\n   *                            The parameters can be pre-validated with {@link #validateSettings(int, int)}.\n   *                            There is one term per block line, with its corresponding details ({@link org.apache.lucene.index.TermState}).\n   * @param deltaNumLines       Maximum allowed delta variation of the number of lines per block.\n   *                            Must be greater than or equal to 0 and strictly less than {@code targetNumBlockLines}.\n   *                            The block size will be {@code targetNumBlockLines}+-{@code deltaNumLines}.\n   *                            The block size must always be less than or equal to {@link #MAX_NUM_BLOCK_LINES}.\n   * @param blockEncoder        Optional block encoder, may be null if none.\n   *                            It can be used for compression or encryption.\n   */\n  protected UniformSplitTermsWriter(PostingsWriterBase postingsWriter, SegmentWriteState state,\n                          int targetNumBlockLines, int deltaNumLines, BlockEncoder blockEncoder,\n                          String codecName, int versionCurrent, String termsBlocksExtension, String dictionaryExtension) throws IOException {\n    validateSettings(targetNumBlockLines, deltaNumLines);\n    IndexOutput blockOutput = null;\n    IndexOutput dictionaryOutput = null;\n    boolean success = false;\n    try {\n      this.fieldInfos = state.fieldInfos;\n      this.postingsWriter = postingsWriter;\n      this.maxDoc = state.segmentInfo.maxDoc();\n      this.targetNumBlockLines = targetNumBlockLines;\n      this.deltaNumLines = deltaNumLines;\n      this.blockEncoder = blockEncoder;\n\n      String termsName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, termsBlocksExtension);\n      blockOutput = state.directory.createOutput(termsName, state.context);\n      CodecUtil.writeIndexHeader(blockOutput, codecName, versionCurrent, state.segmentInfo.getId(), state.segmentSuffix);\n\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dictionaryExtension);\n      dictionaryOutput = state.directory.createOutput(indexName, state.context);\n      CodecUtil.writeIndexHeader(dictionaryOutput, codecName, versionCurrent, state.segmentInfo.getId(), state.segmentSuffix);\n\n      postingsWriter.init(blockOutput, state);\n\n      this.blockOutput = blockOutput;\n      this.dictionaryOutput = dictionaryOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(blockOutput, dictionaryOutput);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c606b777c4250f3f3f6f66d659c7c4c403679b71","date":1577958559,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/UniformSplitTermsWriter#UniformSplitTermsWriter(PostingsWriterBase,SegmentWriteState,int,int,BlockEncoder,FieldMetadata.Serializer,String,int,String,String).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/uniformsplit/UniformSplitTermsWriter#UniformSplitTermsWriter(PostingsWriterBase,SegmentWriteState,int,int,BlockEncoder,String,int,String,String).mjava","sourceNew":"  /**\n   * @param targetNumBlockLines Target number of lines per block.\n   *                            Must be strictly greater than 0.\n   *                            The parameters can be pre-validated with {@link #validateSettings(int, int)}.\n   *                            There is one term per block line, with its corresponding details ({@link org.apache.lucene.index.TermState}).\n   * @param deltaNumLines       Maximum allowed delta variation of the number of lines per block.\n   *                            Must be greater than or equal to 0 and strictly less than {@code targetNumBlockLines}.\n   *                            The block size will be {@code targetNumBlockLines}+-{@code deltaNumLines}.\n   *                            The block size must always be less than or equal to {@link #MAX_NUM_BLOCK_LINES}.\n   * @param blockEncoder        Optional block encoder, may be null if none.\n   *                            It can be used for compression or encryption.\n   */\n  protected UniformSplitTermsWriter(PostingsWriterBase postingsWriter, SegmentWriteState state,\n                          int targetNumBlockLines, int deltaNumLines, BlockEncoder blockEncoder, FieldMetadata.Serializer fieldMetadataWriter,\n                          String codecName, int versionCurrent, String termsBlocksExtension, String dictionaryExtension) throws IOException {\n    validateSettings(targetNumBlockLines, deltaNumLines);\n    IndexOutput blockOutput = null;\n    IndexOutput dictionaryOutput = null;\n    boolean success = false;\n    try {\n      this.fieldInfos = state.fieldInfos;\n      this.postingsWriter = postingsWriter;\n      this.maxDoc = state.segmentInfo.maxDoc();\n      this.targetNumBlockLines = targetNumBlockLines;\n      this.deltaNumLines = deltaNumLines;\n      this.blockEncoder = blockEncoder;\n      this.fieldMetadataWriter = fieldMetadataWriter;\n\n      String termsName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, termsBlocksExtension);\n      blockOutput = state.directory.createOutput(termsName, state.context);\n      CodecUtil.writeIndexHeader(blockOutput, codecName, versionCurrent, state.segmentInfo.getId(), state.segmentSuffix);\n\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dictionaryExtension);\n      dictionaryOutput = state.directory.createOutput(indexName, state.context);\n      CodecUtil.writeIndexHeader(dictionaryOutput, codecName, versionCurrent, state.segmentInfo.getId(), state.segmentSuffix);\n\n      postingsWriter.init(blockOutput, state);\n\n      this.blockOutput = blockOutput;\n      this.dictionaryOutput = dictionaryOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(blockOutput, dictionaryOutput);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @param targetNumBlockLines Target number of lines per block.\n   *                            Must be strictly greater than 0.\n   *                            The parameters can be pre-validated with {@link #validateSettings(int, int)}.\n   *                            There is one term per block line, with its corresponding details ({@link org.apache.lucene.index.TermState}).\n   * @param deltaNumLines       Maximum allowed delta variation of the number of lines per block.\n   *                            Must be greater than or equal to 0 and strictly less than {@code targetNumBlockLines}.\n   *                            The block size will be {@code targetNumBlockLines}+-{@code deltaNumLines}.\n   *                            The block size must always be less than or equal to {@link #MAX_NUM_BLOCK_LINES}.\n   * @param blockEncoder        Optional block encoder, may be null if none.\n   *                            It can be used for compression or encryption.\n   */\n  protected UniformSplitTermsWriter(PostingsWriterBase postingsWriter, SegmentWriteState state,\n                          int targetNumBlockLines, int deltaNumLines, BlockEncoder blockEncoder,\n                          String codecName, int versionCurrent, String termsBlocksExtension, String dictionaryExtension) throws IOException {\n    validateSettings(targetNumBlockLines, deltaNumLines);\n    IndexOutput blockOutput = null;\n    IndexOutput dictionaryOutput = null;\n    boolean success = false;\n    try {\n      this.fieldInfos = state.fieldInfos;\n      this.postingsWriter = postingsWriter;\n      this.maxDoc = state.segmentInfo.maxDoc();\n      this.targetNumBlockLines = targetNumBlockLines;\n      this.deltaNumLines = deltaNumLines;\n      this.blockEncoder = blockEncoder;\n\n      String termsName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, termsBlocksExtension);\n      blockOutput = state.directory.createOutput(termsName, state.context);\n      CodecUtil.writeIndexHeader(blockOutput, codecName, versionCurrent, state.segmentInfo.getId(), state.segmentSuffix);\n\n      String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, dictionaryExtension);\n      dictionaryOutput = state.directory.createOutput(indexName, state.context);\n      CodecUtil.writeIndexHeader(dictionaryOutput, codecName, versionCurrent, state.segmentInfo.getId(), state.segmentSuffix);\n\n      postingsWriter.init(blockOutput, state);\n\n      this.blockOutput = blockOutput;\n      this.dictionaryOutput = dictionaryOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        IOUtils.closeWhileHandlingException(blockOutput, dictionaryOutput);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c606b777c4250f3f3f6f66d659c7c4c403679b71":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d28da8a459f5f0c930da7185c56d0c25edd3fbd1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d28da8a459f5f0c930da7185c56d0c25edd3fbd1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d28da8a459f5f0c930da7185c56d0c25edd3fbd1"]},"commit2Childs":{"c606b777c4250f3f3f6f66d659c7c4c403679b71":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c606b777c4250f3f3f6f66d659c7c4c403679b71","d28da8a459f5f0c930da7185c56d0c25edd3fbd1"],"d28da8a459f5f0c930da7185c56d0c25edd3fbd1":["c606b777c4250f3f3f6f66d659c7c4c403679b71","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c606b777c4250f3f3f6f66d659c7c4c403679b71","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}