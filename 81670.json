{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaFileDeleter#deletePending().mjava","commits":[{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaFileDeleter#deletePending().mjava","pathOld":"/dev/null","sourceNew":"  public synchronized void deletePending() {\n    if (Node.VERBOSE_FILES) {\n      node.message(\"now deletePending: \" + pending.size() + \" files to try: \" + pending);\n    }\n\n    // Clone the set because it will change as we iterate:\n    List<String> toDelete = new ArrayList<>(pending);\n\n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files\n    // undeleted so index is never in a corrupt state:\n    for (String fileName : toDelete) {\n      Integer rc = refCounts.get(fileName);\n      if (rc != null && rc > 0) {\n        // Should never happen!  This means we are about to pending-delete a referenced index file\n        throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" is in pending delete set but has non-zero refCount=\" + rc);\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        if (delete(fileName) == false) {\n          if (Node.VERBOSE_FILES) {\n            node.message(\"failed to remove commit point \\\"\" + fileName + \"\\\"; skipping deletion of all other pending files\");\n          }\n          return;\n        }\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        delete(fileName);\n      }\n    }\n\n    Set<String> copy = new HashSet<String>(pending);\n    pending.clear();\n    for(String fileName : copy) {\n      delete(fileName);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b72a3c8c250ce67d9dd59e06316f982cd77bdb3c","date":1454874368,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaFileDeleter#delete(Collection[String]).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaFileDeleter#deletePending().mjava","sourceNew":"  private synchronized void delete(Collection<String> toDelete) throws IOException {\n    if (Node.VERBOSE_FILES) {\n      node.message(\"now delete \" + toDelete.size() + \" files: \" + toDelete);\n    }\n\n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference, in case we crash right now:\n    for (String fileName : toDelete) {\n      assert refCounts.containsKey(fileName) == false;\n      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        delete(fileName);\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      assert refCounts.containsKey(fileName) == false;\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        delete(fileName);\n      }\n    }\n\n  }\n\n","sourceOld":"  public synchronized void deletePending() {\n    if (Node.VERBOSE_FILES) {\n      node.message(\"now deletePending: \" + pending.size() + \" files to try: \" + pending);\n    }\n\n    // Clone the set because it will change as we iterate:\n    List<String> toDelete = new ArrayList<>(pending);\n\n    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed\n    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files\n    // undeleted so index is never in a corrupt state:\n    for (String fileName : toDelete) {\n      Integer rc = refCounts.get(fileName);\n      if (rc != null && rc > 0) {\n        // Should never happen!  This means we are about to pending-delete a referenced index file\n        throw new IllegalStateException(\"file \\\"\" + fileName + \"\\\" is in pending delete set but has non-zero refCount=\" + rc);\n      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n        if (delete(fileName) == false) {\n          if (Node.VERBOSE_FILES) {\n            node.message(\"failed to remove commit point \\\"\" + fileName + \"\\\"; skipping deletion of all other pending files\");\n          }\n          return;\n        }\n      }\n    }\n\n    // Only delete other files if we were able to remove the segments_N files; this way we never\n    // leave a corrupt commit in the index even in the presense of virus checkers:\n    for(String fileName : toDelete) {\n      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {\n        delete(fileName);\n      }\n    }\n\n    Set<String> copy = new HashSet<String>(pending);\n    pending.clear();\n    for(String fileName : copy) {\n      delete(fileName);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b72a3c8c250ce67d9dd59e06316f982cd77bdb3c":["0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"b72a3c8c250ce67d9dd59e06316f982cd77bdb3c":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["b72a3c8c250ce67d9dd59e06316f982cd77bdb3c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b72a3c8c250ce67d9dd59e06316f982cd77bdb3c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}