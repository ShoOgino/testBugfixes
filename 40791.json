{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","commits":[{"id":"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d","date":1426480823,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"/dev/null","sourceNew":"  SimpleOrderedMap<Object> getRangeCountsIndexed() throws IOException {\n    final FieldType ft = sf.getType();\n\n    RangeEndpointCalculator<?> calc = null;\n\n    if (ft instanceof TrieField) {\n      final TrieField trie = (TrieField)ft;\n\n      switch (trie.getType()) {\n        case FLOAT:\n          calc = new FloatRangeEndpointCalculator(sf);\n          break;\n        case DOUBLE:\n          calc = new DoubleRangeEndpointCalculator(sf);\n          break;\n        case INTEGER:\n          calc = new IntegerRangeEndpointCalculator(sf);\n          break;\n        case LONG:\n          calc = new LongRangeEndpointCalculator(sf);\n          break;\n        default:\n          throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n                  \"Unable to range facet on tried field of unexpected type:\" + freq.field);\n      }\n    } else {\n      throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n              \"Unable to range facet on field:\" + sf);\n    }\n\n    return getRangeCountsIndexed(calc);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"/dev/null","sourceNew":"  SimpleOrderedMap<Object> getRangeCountsIndexed() throws IOException {\n    final FieldType ft = sf.getType();\n\n    RangeEndpointCalculator<?> calc = null;\n\n    if (ft instanceof TrieField) {\n      final TrieField trie = (TrieField)ft;\n\n      switch (trie.getType()) {\n        case FLOAT:\n          calc = new FloatRangeEndpointCalculator(sf);\n          break;\n        case DOUBLE:\n          calc = new DoubleRangeEndpointCalculator(sf);\n          break;\n        case INTEGER:\n          calc = new IntegerRangeEndpointCalculator(sf);\n          break;\n        case LONG:\n          calc = new LongRangeEndpointCalculator(sf);\n          break;\n        default:\n          throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n                  \"Unable to range facet on tried field of unexpected type:\" + freq.field);\n      }\n    } else {\n      throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n              \"Unable to range facet on field:\" + sf);\n    }\n\n    return getRangeCountsIndexed(calc);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d9277507444d59b3e010e1208066807ee408bc3","date":1429669389,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  SimpleOrderedMap<Object> getRangeCountsIndexed() throws IOException {\n    final FieldType ft = sf.getType();\n\n    RangeEndpointCalculator<?> calc = null;\n\n    if (ft instanceof TrieField) {\n      final TrieField trie = (TrieField)ft;\n\n      switch (trie.getType()) {\n        case FLOAT:\n          calc = new FloatRangeEndpointCalculator(sf);\n          break;\n        case DOUBLE:\n          calc = new DoubleRangeEndpointCalculator(sf);\n          break;\n        case INTEGER:\n          calc = new IntegerRangeEndpointCalculator(sf);\n          break;\n        case LONG:\n          calc = new LongRangeEndpointCalculator(sf);\n          break;\n        case DATE:\n          calc = new DateRangeEndpointCalculator(sf, null);\n          break;\n        default:\n          throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n                  \"Unable to range facet on tried field of unexpected type:\" + freq.field);\n      }\n    } else {\n      throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n              \"Unable to range facet on field:\" + sf);\n    }\n\n    return getRangeCountsIndexed(calc);\n  }\n\n","sourceOld":"  SimpleOrderedMap<Object> getRangeCountsIndexed() throws IOException {\n    final FieldType ft = sf.getType();\n\n    RangeEndpointCalculator<?> calc = null;\n\n    if (ft instanceof TrieField) {\n      final TrieField trie = (TrieField)ft;\n\n      switch (trie.getType()) {\n        case FLOAT:\n          calc = new FloatRangeEndpointCalculator(sf);\n          break;\n        case DOUBLE:\n          calc = new DoubleRangeEndpointCalculator(sf);\n          break;\n        case INTEGER:\n          calc = new IntegerRangeEndpointCalculator(sf);\n          break;\n        case LONG:\n          calc = new LongRangeEndpointCalculator(sf);\n          break;\n        default:\n          throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n                  \"Unable to range facet on tried field of unexpected type:\" + freq.field);\n      }\n    } else {\n      throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n              \"Unable to range facet on field:\" + sf);\n    }\n\n    return getRangeCountsIndexed(calc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"330e80d31a51e837b9cc906035e114377c0501dc","date":1429994103,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    final SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n\n    List<SimpleOrderedMap<Object>> buckets = null;\n\n    buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n    \n    for (Range range : rangeList) {\n      buckets.add( rangeStats( range, false) );\n    }\n\n    for (Range range : otherList) {\n      res.add(range.label.toString(), rangeStats( range, true));\n    }\n\n    return res;\n  }\n\n","sourceOld":"  SimpleOrderedMap<Object> getRangeCountsIndexed() throws IOException {\n    final FieldType ft = sf.getType();\n\n    RangeEndpointCalculator<?> calc = null;\n\n    if (ft instanceof TrieField) {\n      final TrieField trie = (TrieField)ft;\n\n      switch (trie.getType()) {\n        case FLOAT:\n          calc = new FloatRangeEndpointCalculator(sf);\n          break;\n        case DOUBLE:\n          calc = new DoubleRangeEndpointCalculator(sf);\n          break;\n        case INTEGER:\n          calc = new IntegerRangeEndpointCalculator(sf);\n          break;\n        case LONG:\n          calc = new LongRangeEndpointCalculator(sf);\n          break;\n        case DATE:\n          calc = new DateRangeEndpointCalculator(sf, null);\n          break;\n        default:\n          throw new SolrException\n              (SolrException.ErrorCode.BAD_REQUEST,\n                  \"Unable to range facet on tried field of unexpected type:\" + freq.field);\n      }\n    } else {\n      throw new SolrException\n          (SolrException.ErrorCode.BAD_REQUEST,\n              \"Unable to range facet on field:\" + sf);\n    }\n\n    return getRangeCountsIndexed(calc);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad96108474aafa94aa3be9844152c42c7ed43fca","date":1430010887,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    createAccs(fcontext.base.size(), slotCount);\n    prepareForCollection();\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    final SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n\n    List<SimpleOrderedMap<Object>> buckets = null;\n\n    buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n    \n    for (Range range : rangeList) {\n      buckets.add( rangeStats( range, false) );\n    }\n\n    for (Range range : otherList) {\n      res.add(range.label.toString(), rangeStats( range, true));\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"637b14d3587fbf956ba5f8d39409d579d34f69de","date":1430057809,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    createAccs(fcontext.base.size(), slotCount);\n    prepareForCollection();\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we dont' skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    createAccs(fcontext.base.size(), slotCount);\n    prepareForCollection();\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"faf1236ae092482293a7e0659e347d172185ef6f","date":1430314113,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n    prepareForCollection();\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we dont' skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    createAccs(fcontext.base.size(), slotCount);\n    prepareForCollection();\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we dont' skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e13d0d4d8b6dc352cb304974502b9a36c153f78","date":1436492687,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we dont' skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n    prepareForCollection();\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we dont' skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1794a0eb180b7d4e51424fbb32694cbb787ebc93","date":1496796881,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we dont' skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f344bb33ca91f48e99c061980115b46fa84fc8f5","date":1496903283,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we dont' skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we dont' skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we dont' skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c05b634713ca09b2267477408773904d4c69dd9d","date":1530894845,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n      \n    if (null != actual_end) {\n      res.add(FacetRange.ACTUAL_END_JSON_KEY, calc.formatValue(actual_end));\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n      \n    if (null != actual_end) {\n      res.add(FacetRange.ACTUAL_END_JSON_KEY, calc.formatValue(actual_end));\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n      \n    if (null != actual_end) {\n      res.add(FacetRange.ACTUAL_END_JSON_KEY, calc.formatValue(actual_end));\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45","date":1569046571,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    if (null != actual_end) {\n      res.add(FacetRange.ACTUAL_END_JSON_KEY, calc.formatValue(actual_end));\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n      \n    if (null != actual_end) {\n      res.add(FacetRange.ACTUAL_END_JSON_KEY, calc.formatValue(actual_end));\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56a9893014b284af4d1af451e6c02e7ffdf5b6e","date":1590065972,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor#getRangeCountsIndexed().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetRangeProcessor[FacetRange]#getRangeCountsIndexed().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    if (null != actual_end) {\n      res.add(FacetRange.ACTUAL_END_JSON_KEY, calc.formatValue(actual_end));\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private  SimpleOrderedMap getRangeCountsIndexed() throws IOException {\n\n    int slotCount = rangeList.size() + otherList.size();\n    intersections = new DocSet[slotCount];\n    filters = new Query[slotCount];\n\n\n    createAccs(fcontext.base.size(), slotCount);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      rangeStats(rangeList.get(idx), idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      rangeStats(otherList.get(idx), rangeList.size() + idx);\n    }\n\n\n    final SimpleOrderedMap res = new SimpleOrderedMap<>();\n    List<SimpleOrderedMap> buckets = new ArrayList<>();\n    res.add(\"buckets\", buckets);\n\n    for (int idx = 0; idx<rangeList.size(); idx++) {\n      if (effectiveMincount > 0 && countAcc.getCount(idx) < effectiveMincount) continue;\n      Range range = rangeList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      buckets.add(bucket);\n      bucket.add(\"val\", range.label);\n      addStats(bucket, idx);\n      doSubs(bucket, idx);\n    }\n\n    for (int idx = 0; idx<otherList.size(); idx++) {\n      // we don't skip these buckets based on mincount\n      Range range = otherList.get(idx);\n      SimpleOrderedMap bucket = new SimpleOrderedMap();\n      res.add(range.label.toString(), bucket);\n      addStats(bucket, rangeList.size() + idx);\n      doSubs(bucket, rangeList.size() + idx);\n    }\n\n    if (null != actual_end) {\n      res.add(FacetRange.ACTUAL_END_JSON_KEY, calc.formatValue(actual_end));\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1794a0eb180b7d4e51424fbb32694cbb787ebc93":["9e13d0d4d8b6dc352cb304974502b9a36c153f78"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["9e13d0d4d8b6dc352cb304974502b9a36c153f78","1794a0eb180b7d4e51424fbb32694cbb787ebc93"],"a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45":["c05b634713ca09b2267477408773904d4c69dd9d"],"637b14d3587fbf956ba5f8d39409d579d34f69de":["ad96108474aafa94aa3be9844152c42c7ed43fca"],"faf1236ae092482293a7e0659e347d172185ef6f":["637b14d3587fbf956ba5f8d39409d579d34f69de"],"c05b634713ca09b2267477408773904d4c69dd9d":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["9e13d0d4d8b6dc352cb304974502b9a36c153f78","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"330e80d31a51e837b9cc906035e114377c0501dc":["2d9277507444d59b3e010e1208066807ee408bc3"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["28288370235ed02234a64753cdbf0c6ec096304a","c05b634713ca09b2267477408773904d4c69dd9d"],"9e13d0d4d8b6dc352cb304974502b9a36c153f78":["faf1236ae092482293a7e0659e347d172185ef6f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ad96108474aafa94aa3be9844152c42c7ed43fca":["330e80d31a51e837b9cc906035e114377c0501dc"],"2d9277507444d59b3e010e1208066807ee408bc3":["ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["9e13d0d4d8b6dc352cb304974502b9a36c153f78","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["28288370235ed02234a64753cdbf0c6ec096304a","c05b634713ca09b2267477408773904d4c69dd9d"]},"commit2Childs":{"1794a0eb180b7d4e51424fbb32694cbb787ebc93":["f344bb33ca91f48e99c061980115b46fa84fc8f5"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"637b14d3587fbf956ba5f8d39409d579d34f69de":["faf1236ae092482293a7e0659e347d172185ef6f"],"faf1236ae092482293a7e0659e347d172185ef6f":["9e13d0d4d8b6dc352cb304974502b9a36c153f78"],"c05b634713ca09b2267477408773904d4c69dd9d":["a1b7f1cd68896fbbc518d7cc9ce49cb9cda9ab45","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"28288370235ed02234a64753cdbf0c6ec096304a":["c05b634713ca09b2267477408773904d4c69dd9d","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"330e80d31a51e837b9cc906035e114377c0501dc":["ad96108474aafa94aa3be9844152c42c7ed43fca"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"9e13d0d4d8b6dc352cb304974502b9a36c153f78":["1794a0eb180b7d4e51424fbb32694cbb787ebc93","f344bb33ca91f48e99c061980115b46fa84fc8f5","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d"],"ac53eb8ed1d40ceac7330e9dc2e5c258e8fc155d":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","2d9277507444d59b3e010e1208066807ee408bc3"],"ad96108474aafa94aa3be9844152c42c7ed43fca":["637b14d3587fbf956ba5f8d39409d579d34f69de"],"2d9277507444d59b3e010e1208066807ee408bc3":["330e80d31a51e837b9cc906035e114377c0501dc"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}