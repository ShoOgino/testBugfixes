{"path":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","commits":[{"id":"a5093a9e893633cc091cf2f729d7863671c2b715","date":1339132888,"type":0,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   * @throws NoSuchElementException\n   * @throws KeeperException\n   * @throws InterruptedException\n   */\n  public byte[] element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return zookeeper.getData(dir + \"/\" + headNode, false, null);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2d0da1152c8dd998675c30a3f6f599a91770c2b","date":1342792640,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","sourceNew":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   * @throws NoSuchElementException\n   * @throws KeeperException\n   * @throws InterruptedException\n   */\n  public byte[] element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return zookeeper.getData(dir + \"/\" + headNode, null, null, true);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   * @throws NoSuchElementException\n   * @throws KeeperException\n   * @throws InterruptedException\n   */\n  public byte[] element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return zookeeper.getData(dir + \"/\" + headNode, false, null);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","sourceNew":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   * @throws NoSuchElementException\n   * @throws KeeperException\n   * @throws InterruptedException\n   */\n  public byte[] element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return zookeeper.getData(dir + \"/\" + headNode, null, null, true);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   * @throws NoSuchElementException\n   * @throws KeeperException\n   * @throws InterruptedException\n   */\n  public byte[] element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return zookeeper.getData(dir + \"/\" + headNode, false, null);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","sourceNew":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   * @throws NoSuchElementException\n   * @throws KeeperException\n   * @throws InterruptedException\n   */\n  public byte[] element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return zookeeper.getData(dir + \"/\" + headNode, null, null, true);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   * @throws NoSuchElementException\n   * @throws KeeperException\n   * @throws InterruptedException\n   */\n  public byte[] element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return zookeeper.getData(dir + \"/\" + headNode, false, null);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","sourceNew":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   */\n  public byte[] element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return zookeeper.getData(dir + \"/\" + headNode, null, null, true);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   * @throws NoSuchElementException\n   * @throws KeeperException\n   * @throws InterruptedException\n   */\n  public byte[] element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return zookeeper.getData(dir + \"/\" + headNode, null, null, true);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c986b1ea9768aff3c903f05a2c85b7b672b5c225","date":1359126891,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","sourceNew":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   */\n  private QueueEvent element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return new QueueEvent(dir + \"/\" + headNode, zookeeper.getData(dir + \"/\" + headNode, null, null, true), null);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   */\n  public byte[] element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return zookeeper.getData(dir + \"/\" + headNode, null, null, true);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd45d4a2ee01a1932d33eec42f5272c2402da679","date":1359316912,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","sourceNew":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   */\n  private QueueEvent element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return new QueueEvent(dir + \"/\" + headNode, zookeeper.getData(dir + \"/\" + headNode, null, null, true), null);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   */\n  public byte[] element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return zookeeper.getData(dir + \"/\" + headNode, null, null, true);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e6c873b95174ff04c895232927baa76a95925eb","date":1385054916,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","sourceNew":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   */\n  private QueueEvent element() throws KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        return null;\n      }\n      if (orderedChildren.size() == 0) return null;\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return new QueueEvent(dir + \"/\" + headNode, zookeeper.getData(dir + \"/\" + headNode, null, null, true), null);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   */\n  private QueueEvent element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return new QueueEvent(dir + \"/\" + headNode, zookeeper.getData(dir + \"/\" + headNode, null, null, true), null);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","sourceNew":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   */\n  private QueueEvent element() throws KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        return null;\n      }\n      if (orderedChildren.size() == 0) return null;\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return new QueueEvent(dir + \"/\" + headNode, zookeeper.getData(dir + \"/\" + headNode, null, null, true), null);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   */\n  private QueueEvent element() throws NoSuchElementException, KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        throw new NoSuchElementException();\n      }\n      if (orderedChildren.size() == 0) throw new NoSuchElementException();\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return new QueueEvent(dir + \"/\" + headNode, zookeeper.getData(dir + \"/\" + headNode, null, null, true), null);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a282020d6c9a4ea32a359539e283e4771a2fda8","date":1440047542,"type":4,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/DistributedQueue#element().mjava","sourceNew":null,"sourceOld":"  /**\n   * Return the head of the queue without modifying the queue.\n   * \n   * @return the data at the head of the queue.\n   */\n  private QueueEvent element() throws KeeperException,\n      InterruptedException {\n    TreeMap<Long,String> orderedChildren;\n    \n    // element, take, and remove follow the same pattern.\n    // We want to return the child node with the smallest sequence number.\n    // Since other clients are remove()ing and take()ing nodes concurrently,\n    // the child with the smallest sequence number in orderedChildren might be\n    // gone by the time we check.\n    // We don't call getChildren again until we have tried the rest of the nodes\n    // in sequence order.\n    while (true) {\n      try {\n        orderedChildren = orderedChildren(null);\n      } catch (KeeperException.NoNodeException e) {\n        return null;\n      }\n      if (orderedChildren.size() == 0) return null;\n      \n      for (String headNode : orderedChildren.values()) {\n        if (headNode != null) {\n          try {\n            return new QueueEvent(dir + \"/\" + headNode, zookeeper.getData(dir + \"/\" + headNode, null, null, true), null);\n          } catch (KeeperException.NoNodeException e) {\n            // Another client removed the node first, try next\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["c2d0da1152c8dd998675c30a3f6f599a91770c2b"],"c2d0da1152c8dd998675c30a3f6f599a91770c2b":["a5093a9e893633cc091cf2f729d7863671c2b715"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a5093a9e893633cc091cf2f729d7863671c2b715","c2d0da1152c8dd998675c30a3f6f599a91770c2b"],"9e6c873b95174ff04c895232927baa76a95925eb":["c986b1ea9768aff3c903f05a2c85b7b672b5c225"],"c986b1ea9768aff3c903f05a2c85b7b672b5c225":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a5093a9e893633cc091cf2f729d7863671c2b715":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["c986b1ea9768aff3c903f05a2c85b7b672b5c225","9e6c873b95174ff04c895232927baa76a95925eb"],"dd45d4a2ee01a1932d33eec42f5272c2402da679":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","c986b1ea9768aff3c903f05a2c85b7b672b5c225"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["a5093a9e893633cc091cf2f729d7863671c2b715","c2d0da1152c8dd998675c30a3f6f599a91770c2b"],"2a282020d6c9a4ea32a359539e283e4771a2fda8":["9e6c873b95174ff04c895232927baa76a95925eb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2a282020d6c9a4ea32a359539e283e4771a2fda8"]},"commit2Childs":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["c986b1ea9768aff3c903f05a2c85b7b672b5c225","dd45d4a2ee01a1932d33eec42f5272c2402da679"],"c2d0da1152c8dd998675c30a3f6f599a91770c2b":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"9e6c873b95174ff04c895232927baa76a95925eb":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","2a282020d6c9a4ea32a359539e283e4771a2fda8"],"c986b1ea9768aff3c903f05a2c85b7b672b5c225":["9e6c873b95174ff04c895232927baa76a95925eb","74f45af4339b0daf7a95c820ab88c1aea74fbce0","dd45d4a2ee01a1932d33eec42f5272c2402da679"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a5093a9e893633cc091cf2f729d7863671c2b715"],"a5093a9e893633cc091cf2f729d7863671c2b715":["c2d0da1152c8dd998675c30a3f6f599a91770c2b","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"dd45d4a2ee01a1932d33eec42f5272c2402da679":[],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":[],"2a282020d6c9a4ea32a359539e283e4771a2fda8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aba371508186796cc6151d8223a5b4e16d02e26e","74f45af4339b0daf7a95c820ab88c1aea74fbce0","dd45d4a2ee01a1932d33eec42f5272c2402da679","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}