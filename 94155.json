{"path":"modules/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","commits":[{"id":"0f080986da691a3bba7b757f43ab72cdc82b57ce","date":1273069619,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","pathOld":"lucene/contrib/analyzers/common/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","sourceNew":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current[c + common] - w.s[i2];\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject, EMPTY_ARGS);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","sourceOld":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current[c + common] - w.s[i2];\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject, EMPTY_ARGS);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","pathOld":"modules/analysis/common/src/java/org/tartarus/snowball/SnowballProgram#find_among(Among[],int).mjava","sourceNew":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current[c + common] - w.s[i2];\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject, EMPTY_ARGS);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","sourceOld":"    protected int find_among(Among v[], int v_size)\n    {\n\tint i = 0;\n\tint j = v_size;\n\n\tint c = cursor;\n\tint l = limit;\n\n\tint common_i = 0;\n\tint common_j = 0;\n\n\tboolean first_key_inspected = false;\n\n\twhile(true) {\n\t    int k = i + ((j - i) >> 1);\n\t    int diff = 0;\n\t    int common = common_i < common_j ? common_i : common_j; // smaller\n\t    Among w = v[k];\n\t    int i2;\n\t    for (i2 = common; i2 < w.s_size; i2++) {\n\t\tif (c + common == l) {\n\t\t    diff = -1;\n\t\t    break;\n\t\t}\n\t\tdiff = current[c + common] - w.s[i2];\n\t\tif (diff != 0) break;\n\t\tcommon++;\n\t    }\n\t    if (diff < 0) {\n\t\tj = k;\n\t\tcommon_j = common;\n\t    } else {\n\t\ti = k;\n\t\tcommon_i = common;\n\t    }\n\t    if (j - i <= 1) {\n\t\tif (i > 0) break; // v->s has been inspected\n\t\tif (j == i) break; // only one item in v\n\n\t\t// - but now we need to go round once more to get\n\t\t// v->s inspected. This looks messy, but is actually\n\t\t// the optimal approach.\n\n\t\tif (first_key_inspected) break;\n\t\tfirst_key_inspected = true;\n\t    }\n\t}\n\twhile(true) {\n\t    Among w = v[i];\n\t    if (common_i >= w.s_size) {\n\t\tcursor = c + w.s_size;\n\t\tif (w.method == null) return w.result;\n\t\tboolean res;\n\t\ttry {\n\t\t    Object resobj = w.method.invoke(w.methodobject, EMPTY_ARGS);\n\t\t    res = resobj.toString().equals(\"true\");\n\t\t} catch (InvocationTargetException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t} catch (IllegalAccessException e) {\n\t\t    res = false;\n\t\t    // FIXME - debug message\n\t\t}\n\t\tcursor = c + w.s_size;\n\t\tif (res) return w.result;\n\t    }\n\t    i = w.substring_i;\n\t    if (i < 0) return 0;\n\t}\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["0f080986da691a3bba7b757f43ab72cdc82b57ce"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0f080986da691a3bba7b757f43ab72cdc82b57ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0f080986da691a3bba7b757f43ab72cdc82b57ce"],"0f080986da691a3bba7b757f43ab72cdc82b57ce":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}