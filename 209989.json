{"path":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","sourceNew":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random.nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random.nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random.nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random.nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random.nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t, random.nextBoolean()));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t, random.nextBoolean());\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random.nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random.nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random.nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random.nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random.nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random.nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random.nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t, random.nextBoolean()));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t, random.nextBoolean());\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random.nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random.nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","sourceNew":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random().nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random().nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random().nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random().nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random().nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t, random().nextBoolean()));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t, random().nextBoolean());\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random().nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random().nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random.nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random.nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random.nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random.nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random.nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t, random.nextBoolean()));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t, random.nextBoolean());\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random.nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random.nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","date":1373996650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","sourceNew":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random().nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random().nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random().nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random().nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random().nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t);\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random().nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random().nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random().nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random().nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random().nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random().nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random().nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t, random().nextBoolean()));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t, random().nextBoolean());\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random().nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random().nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","sourceNew":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random().nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random().nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random().nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random().nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random().nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t);\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random().nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random().nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random().nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random().nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random().nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random().nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random().nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t, random().nextBoolean()));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t, random().nextBoolean());\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random().nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random().nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","sourceNew":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random().nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random().nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random().nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random().nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random().nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t);\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random().nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random().nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<TermAndState>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random().nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random().nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random().nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random().nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random().nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t);\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random().nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random().nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","sourceNew":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator();\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random().nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random().nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random().nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random().nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random().nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t);\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random().nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random().nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator(null);\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random().nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random().nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random().nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random().nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random().nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t);\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random().nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random().nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestTermsEnum#testRandomSeeks(IndexReader,String...).mjava","sourceNew":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiTerms.getTerms(r, FIELD).iterator();\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random().nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random().nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random().nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random().nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random().nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t);\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random().nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random().nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void testRandomSeeks(IndexReader r, String... validTermStrings) throws IOException {\n    final BytesRef[] validTerms = new BytesRef[validTermStrings.length];\n    for(int termIDX=0;termIDX<validTermStrings.length;termIDX++) {\n      validTerms[termIDX] = new BytesRef(validTermStrings[termIDX]);\n    }\n    Arrays.sort(validTerms);\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + validTerms.length + \" terms:\");\n      for(BytesRef t : validTerms) {\n        System.out.println(\"  \" + t.utf8ToString() + \" \" + t);\n      }\n    }\n    final TermsEnum te = MultiFields.getTerms(r, FIELD).iterator();\n\n    final int END_LOC = -validTerms.length-1;\n    \n    final List<TermAndState> termStates = new ArrayList<>();\n\n    for(int iter=0;iter<100*RANDOM_MULTIPLIER;iter++) {\n\n      final BytesRef t;\n      int loc;\n      final TermState termState;\n      if (random().nextInt(6) == 4) {\n        // pick term that doens't exist:\n        t = getNonExistTerm(validTerms);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: invalid term=\" + t.utf8ToString());\n        }\n        loc = Arrays.binarySearch(validTerms, t);\n      } else if (termStates.size() != 0 && random().nextInt(4) == 1) {\n        final TermAndState ts = termStates.get(random().nextInt(termStates.size()));\n        t = ts.term;\n        loc = Arrays.binarySearch(validTerms, t);\n        assertTrue(loc >= 0);\n        termState = ts.state;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid termState term=\" + t.utf8ToString());\n        }\n      } else {\n        // pick valid term\n        loc = random().nextInt(validTerms.length);\n        t = BytesRef.deepCopyOf(validTerms[loc]);\n        termState = null;\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: valid term=\" + t.utf8ToString());\n        }\n      }\n\n      // seekCeil or seekExact:\n      final boolean doSeekExact = random().nextBoolean();\n      if (termState != null) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact termState\");\n        }\n        te.seekExact(t, termState);\n      } else if (doSeekExact) {\n        if (VERBOSE) {\n          System.out.println(\"  seekExact\");\n        }\n        assertEquals(loc >= 0, te.seekExact(t));\n      } else {\n        if (VERBOSE) {\n          System.out.println(\"  seekCeil\");\n        }\n\n        final TermsEnum.SeekStatus result = te.seekCeil(t);\n        if (VERBOSE) {\n          System.out.println(\"  got \" + result);\n        }\n\n        if (loc >= 0) {\n          assertEquals(TermsEnum.SeekStatus.FOUND, result);\n        } else if (loc == END_LOC) {\n          assertEquals(TermsEnum.SeekStatus.END, result);\n        } else {\n          assert loc >= -validTerms.length;\n          assertEquals(TermsEnum.SeekStatus.NOT_FOUND, result);\n        }\n      }\n\n      if (loc >= 0) {\n        assertEquals(t, te.term());\n      } else if (doSeekExact) {\n        // TermsEnum is unpositioned if seekExact returns false\n        continue;\n      } else if (loc == END_LOC) {\n        continue;\n      } else {\n        loc = -loc-1;\n        assertEquals(validTerms[loc], te.term());\n      }\n\n      // Do a bunch of next's after the seek\n      final int numNext = random().nextInt(validTerms.length);\n\n      for(int nextCount=0;nextCount<numNext;nextCount++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: next loc=\" + loc + \" of \" + validTerms.length);\n        }\n        final BytesRef t2 = te.next();\n        loc++;\n        if (loc == validTerms.length) {\n          assertNull(t2);\n          break;\n        } else {\n          assertEquals(validTerms[loc], t2);\n          if (random().nextInt(40) == 17 && termStates.size() < 100) {\n            termStates.add(new TermAndState(validTerms[loc], te.termState()));\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["04e775de416dd2d8067b10db1c8af975a1d5017e"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"04e775de416dd2d8067b10db1c8af975a1d5017e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}