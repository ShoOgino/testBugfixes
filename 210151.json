{"path":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(List[Result],String,int,int,String...).mjava","commits":[{"id":"f7e7599efe704cd8a873a909e546525ace4b5502","date":1491388304,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(List[Result],String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SharedFSAutoReplicaFailoverUtilsTest#buildClusterState(String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ClusterStateMockUtil.Result buildClusterState(List<Result> results, String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    ClusterStateMockUtil.Result result = new ClusterStateMockUtil.Result();\n\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new OverseerAutoReplicaFailoverThread.DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(json);\n\n    // todo remove the limitation of always having a bad replica\n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n\n    result.reader = reader;\n\n    if (results != null) {\n      results.add(result);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   * \n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2), \n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   * \n   * For example:\n   * csrr2rD*sr2csr\n   * \n   * Creates:\n   * \n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   * \n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   * \n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   * \n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   * \n   */\n  @SuppressWarnings(\"resource\")\n  private Result buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Result result = new Result();\n    \n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n    \n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n          \n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n          \n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n          \n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n          \n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n          \n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n          \n          replica = new Replica(replicaName, replicaPropMap);\n          \n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n          \n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n  \n    // trunk briefly had clusterstate taking a zkreader :( this was required to work around that - leaving\n    // until that issue is resolved.\n    MockZkStateReader reader = new MockZkStateReader(null, collectionStates.keySet());\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n    \n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(\"build:\" + buildNumber++);\n    System.err.println(json);\n    \n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n    \n    result.reader = reader;\n    \n    results.add(result);\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(List[Result],String,int,int,String...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ClusterStateMockUtil.Result buildClusterState(List<Result> results, String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    ClusterStateMockUtil.Result result = new ClusterStateMockUtil.Result();\n\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new OverseerAutoReplicaFailoverThread.DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(json);\n\n    // todo remove the limitation of always having a bad replica\n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n\n    result.reader = reader;\n\n    if (results != null) {\n      results.add(result);\n    }\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"717e5ceb2acae36d422ec75e5a4ce9fac40506e1","date":1501239603,"type":5,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(List[Result],String,int,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(json);\n\n    return reader;\n  }\n\n","sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ClusterStateMockUtil.Result buildClusterState(List<Result> results, String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    ClusterStateMockUtil.Result result = new ClusterStateMockUtil.Result();\n\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new OverseerAutoReplicaFailoverThread.DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(json);\n\n    // todo remove the limitation of always having a bad replica\n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n\n    result.reader = reader;\n\n    if (results != null) {\n      results.add(result);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(List[Result],String,int,int,String...).mjava","sourceNew":null,"sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ClusterStateMockUtil.Result buildClusterState(List<Result> results, String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    ClusterStateMockUtil.Result result = new ClusterStateMockUtil.Result();\n\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new OverseerAutoReplicaFailoverThread.DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(json);\n\n    // todo remove the limitation of always having a bad replica\n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n\n    result.reader = reader;\n\n    if (results != null) {\n      results.add(result);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":4,"author":"Cao Manh Dat","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(List[Result],String,int,int,String...).mjava","sourceNew":null,"sourceOld":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"maxShardsPerNode\":\"1\",\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  protected static ClusterStateMockUtil.Result buildClusterState(List<Result> results, String clusterDescription, int replicationFactor, int maxShardsPerNode, String ... liveNodes) {\n    ClusterStateMockUtil.Result result = new ClusterStateMockUtil.Result();\n\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.MAX_SHARDS_PER_NODE, Integer.toString(maxShardsPerNode));\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(\"collection\" + (collectionStates.size() + 1), slices, collectionProps, null);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          slice = new Slice(\"slice\" + (slices.size() + 1), replicas, null);\n          slices.put(slice.getName(), slice);\n          break;\n        case \"r\":\n          Map<String,Object> replicaPropMap = new HashMap<>();\n          String node;\n\n          node = m.group(2);\n\n          if (node == null || node.trim().length() == 0) {\n            node = \"1\";\n          }\n\n          Replica.State state = Replica.State.ACTIVE;\n          String stateCode = m.group(3);\n\n          if (stateCode != null) {\n            switch (stateCode.charAt(0)) {\n              case 'S':\n                state = Replica.State.ACTIVE;\n                break;\n              case 'R':\n                state = Replica.State.RECOVERING;\n                break;\n              case 'D':\n                state = Replica.State.DOWN;\n                break;\n              case 'F':\n                state = Replica.State.RECOVERY_FAILED;\n                break;\n              default:\n                throw new IllegalArgumentException(\n                    \"Unexpected state for replica: \" + stateCode);\n            }\n          }\n\n          String nodeName = \"baseUrl\" + node + \"_\";\n          String replicaName = \"replica\" + replicaCount++;\n\n          if (\"*\".equals(m.group(4))) {\n            replicaName += \" (bad)\";\n          }\n\n          replicaPropMap.put(ZkStateReader.NODE_NAME_PROP, nodeName);\n          replicaPropMap.put(ZkStateReader.BASE_URL_PROP, \"http://baseUrl\" + node);\n          replicaPropMap.put(ZkStateReader.STATE_PROP, state.toString());\n\n          replica = new Replica(replicaName, replicaPropMap);\n\n          if (\"*\".equals(m.group(4))) {\n            result.badReplica = new OverseerAutoReplicaFailoverThread.DownReplica();\n            result.badReplica.replica = replica;\n            result.badReplica.slice = slice;\n            result.badReplica.collection = docCollection;\n          }\n\n          replicas.put(replica.getName(), replica);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(1, new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    try {\n      json = new String(Utils.toJSON(clusterState), \"UTF-8\");\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unexpected\");\n    }\n    System.err.println(json);\n\n    // todo remove the limitation of always having a bad replica\n    assert result.badReplica != null : \"Is there no bad replica?\";\n    assert result.badReplica.slice != null : \"Is there no bad replica?\";\n\n    result.reader = reader;\n\n    if (results != null) {\n      results.add(result);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["f7e7599efe704cd8a873a909e546525ace4b5502","717e5ceb2acae36d422ec75e5a4ce9fac40506e1"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"560c18d71dad43d675158783c3840f8c80d6d39c":["f7e7599efe704cd8a873a909e546525ace4b5502","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["560c18d71dad43d675158783c3840f8c80d6d39c"],"f7e7599efe704cd8a873a909e546525ace4b5502":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["717e5ceb2acae36d422ec75e5a4ce9fac40506e1"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","f7e7599efe704cd8a873a909e546525ace4b5502"],"560c18d71dad43d675158783c3840f8c80d6d39c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f7e7599efe704cd8a873a909e546525ace4b5502":["c304e97e7c1d472bc70e801b35ee78583916c6cd","560c18d71dad43d675158783c3840f8c80d6d39c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}