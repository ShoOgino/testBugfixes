{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester#createResults(TopDocs,int,CharSequence,boolean,Set[String],String).mjava","commits":[{"id":"f13ec1b606a28789743a563929e7c556e8218297","date":1389302034,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester#createResults(TopDocs,int,CharSequence,boolean,Set[String],String).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected List<Lookup.LookupResult> createResults(TopDocs hits, int num, CharSequence key,\n                                                    boolean doHighlight, Set<String> matchedTokens, String prefixToken)\n      throws IOException {\n\n    TreeSet<Lookup.LookupResult> results = new TreeSet<>(LOOKUP_COMP);\n\n    // we reduce the num to the one initially requested\n    int actualNum = num / numFactor;\n\n    BytesRef scratch = new BytesRef();\n    for (int i = 0; i < hits.scoreDocs.length; i++) {\n\n      ScoreDoc sd = hits.scoreDocs[i];\n      textDV.get(sd.doc, scratch);\n      String text = scratch.utf8ToString();\n      long weight = weightsDV.get(sd.doc);\n\n      BytesRef payload;\n      if (payloadsDV != null) {\n        payload = new BytesRef();\n        payloadsDV.get(sd.doc, payload);\n      } else {\n        payload = null;\n      }\n\n      double coefficient;\n      if (text.startsWith(key.toString())) {\n        // if hit starts with the key, we don't change the score\n        coefficient = 1;\n      } else {\n        coefficient = createCoefficient(sd.doc, matchedTokens, prefixToken);\n      }\n\n      long score = (long) (weight * coefficient);\n\n      LookupResult result;\n      if (doHighlight) {\n        Object highlightKey = highlight(text, matchedTokens, prefixToken);\n        result = new LookupResult(highlightKey.toString(), highlightKey, score, payload);\n      } else {\n        result = new LookupResult(text, score, payload);\n      }\n\n      boundedTreeAdd(results, result, actualNum);\n    }\n\n    return new ArrayList<>(results.descendingSet());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ec083aa3f3ecd55f91c47009d49e45553f99bd77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a371aa649cc243e82cb8677ca960a1e0232ecedf","date":1393605574,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester#createResults(IndexSearcher,TopFieldDocs,int,CharSequence,boolean,Set[String],String).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester#createResults(TopDocs,int,CharSequence,boolean,Set[String],String).mjava","sourceNew":"  @Override\n  protected List<Lookup.LookupResult> createResults(IndexSearcher searcher, TopFieldDocs hits, int num, CharSequence key,\n                                                    boolean doHighlight, Set<String> matchedTokens, String prefixToken)\n      throws IOException {\n\n    BinaryDocValues textDV = MultiDocValues.getBinaryValues(searcher.getIndexReader(), TEXT_FIELD_NAME);\n    assert textDV != null;\n\n    // This will just be null if app didn't pass payloads to build():\n    // TODO: maybe just stored fields?  they compress...\n    BinaryDocValues payloadsDV = MultiDocValues.getBinaryValues(searcher.getIndexReader(), \"payloads\");\n\n    TreeSet<Lookup.LookupResult> results = new TreeSet<>(LOOKUP_COMP);\n\n    // we reduce the num to the one initially requested\n    int actualNum = num / numFactor;\n\n    BytesRef scratch = new BytesRef();\n    for (int i = 0; i < hits.scoreDocs.length; i++) {\n      FieldDoc fd = (FieldDoc) hits.scoreDocs[i];\n\n      textDV.get(fd.doc, scratch);\n      String text = scratch.utf8ToString();\n      long weight = (Long) fd.fields[0];\n\n      BytesRef payload;\n      if (payloadsDV != null) {\n        payload = new BytesRef();\n        payloadsDV.get(fd.doc, payload);\n      } else {\n        payload = null;\n      }\n\n      double coefficient;\n      if (text.startsWith(key.toString())) {\n        // if hit starts with the key, we don't change the score\n        coefficient = 1;\n      } else {\n        coefficient = createCoefficient(searcher, fd.doc, matchedTokens, prefixToken);\n      }\n\n      long score = (long) (weight * coefficient);\n\n      LookupResult result;\n      if (doHighlight) {\n        Object highlightKey = highlight(text, matchedTokens, prefixToken);\n        result = new LookupResult(highlightKey.toString(), highlightKey, score, payload);\n      } else {\n        result = new LookupResult(text, score, payload);\n      }\n\n      boundedTreeAdd(results, result, actualNum);\n    }\n\n    return new ArrayList<>(results.descendingSet());\n  }\n\n","sourceOld":"  @Override\n  protected List<Lookup.LookupResult> createResults(TopDocs hits, int num, CharSequence key,\n                                                    boolean doHighlight, Set<String> matchedTokens, String prefixToken)\n      throws IOException {\n\n    TreeSet<Lookup.LookupResult> results = new TreeSet<>(LOOKUP_COMP);\n\n    // we reduce the num to the one initially requested\n    int actualNum = num / numFactor;\n\n    BytesRef scratch = new BytesRef();\n    for (int i = 0; i < hits.scoreDocs.length; i++) {\n\n      ScoreDoc sd = hits.scoreDocs[i];\n      textDV.get(sd.doc, scratch);\n      String text = scratch.utf8ToString();\n      long weight = weightsDV.get(sd.doc);\n\n      BytesRef payload;\n      if (payloadsDV != null) {\n        payload = new BytesRef();\n        payloadsDV.get(sd.doc, payload);\n      } else {\n        payload = null;\n      }\n\n      double coefficient;\n      if (text.startsWith(key.toString())) {\n        // if hit starts with the key, we don't change the score\n        coefficient = 1;\n      } else {\n        coefficient = createCoefficient(sd.doc, matchedTokens, prefixToken);\n      }\n\n      long score = (long) (weight * coefficient);\n\n      LookupResult result;\n      if (doHighlight) {\n        Object highlightKey = highlight(text, matchedTokens, prefixToken);\n        result = new LookupResult(highlightKey.toString(), highlightKey, score, payload);\n      } else {\n        result = new LookupResult(text, score, payload);\n      }\n\n      boundedTreeAdd(results, result, actualNum);\n    }\n\n    return new ArrayList<>(results.descendingSet());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"f13ec1b606a28789743a563929e7c556e8218297":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a371aa649cc243e82cb8677ca960a1e0232ecedf":["f13ec1b606a28789743a563929e7c556e8218297"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a371aa649cc243e82cb8677ca960a1e0232ecedf"]},"commit2Childs":{"f13ec1b606a28789743a563929e7c556e8218297":["a371aa649cc243e82cb8677ca960a1e0232ecedf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f13ec1b606a28789743a563929e7c556e8218297"],"a371aa649cc243e82cb8677ca960a1e0232ecedf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}