{"path":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","pathOld":"modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","sourceNew":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      TokenStream source;\n      try {\n        source = this.analyzer.tokenStream(field, new StringReader(text));\n        source.reset();\n      } catch (IOException e1) {\n        throw new RuntimeException(e1);\n      }\n      CachingTokenFilter buffer = new CachingTokenFilter(source);\n\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      try {\n\n        while (buffer.incrementToken()) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n              .getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n\n        }\n\n      } catch (IOException e) {\n        // ignore\n      }\n\n      try {\n        // rewind the buffer stream\n        buffer.reset();\n\n        // close original stream - all tokens buffered\n        source.close();\n      } catch (IOException e) {\n        // ignore\n      }\n\n      if (!buffer.hasAttribute(CharTermAttribute.class)) {\n        return new NoTokenFoundQueryNode();\n      }\n\n      CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n\n      if (numTokens == 0) {\n        return new NoTokenFoundQueryNode();\n\n      } else if (numTokens == 1) {\n        String term = null;\n        try {\n          boolean hasNext;\n          hasNext = buffer.incrementToken();\n          assert hasNext == true;\n          term = termAtt.toString();\n\n        } catch (IOException e) {\n          // safe to ignore, because we know the number of tokens\n        }\n\n        fieldNode.setText(term);\n\n        return fieldNode;\n\n      } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n        if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n          // no phrase query:\n          LinkedList<QueryNode> children = new LinkedList<QueryNode>();\n\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            children.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n          return new GroupQueryNode(\n            new StandardBooleanQueryNode(children, positionCount==1));\n        } else {\n          // phrase query:\n          MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n\n          List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();\n          int position = -1;\n          int i = 0;\n          int termGroupCount = 0;\n          for (; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n\n              for (FieldQueryNode termNode : multiTerms) {\n\n                if (this.positionIncrementsEnabled) {\n                  termNode.setPositionIncrement(position);\n                } else {\n                  termNode.setPositionIncrement(termGroupCount);\n                }\n\n                mpq.add(termNode);\n\n              }\n\n              // Only increment once for each \"group\" of\n              // terms that were in the same position:\n              termGroupCount++;\n\n              multiTerms.clear();\n\n            }\n\n            position += positionIncrement;\n            multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n\n          for (FieldQueryNode termNode : multiTerms) {\n\n            if (this.positionIncrementsEnabled) {\n              termNode.setPositionIncrement(position);\n\n            } else {\n              termNode.setPositionIncrement(termGroupCount);\n            }\n\n            mpq.add(termNode);\n\n          }\n\n          return mpq;\n\n        }\n\n      } else {\n\n        TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n\n          if (this.positionIncrementsEnabled) {\n            position += positionIncrement;\n            newFieldNode.setPositionIncrement(position);\n\n          } else {\n            newFieldNode.setPositionIncrement(i);\n          }\n\n          pq.add(newFieldNode);\n\n        }\n\n        return pq;\n\n      }\n\n    }\n\n    return node;\n\n  }\n\n","sourceOld":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      TokenStream source;\n      try {\n        source = this.analyzer.tokenStream(field, new StringReader(text));\n        source.reset();\n      } catch (IOException e1) {\n        throw new RuntimeException(e1);\n      }\n      CachingTokenFilter buffer = new CachingTokenFilter(source);\n\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      try {\n\n        while (buffer.incrementToken()) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n              .getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n\n        }\n\n      } catch (IOException e) {\n        // ignore\n      }\n\n      try {\n        // rewind the buffer stream\n        buffer.reset();\n\n        // close original stream - all tokens buffered\n        source.close();\n      } catch (IOException e) {\n        // ignore\n      }\n\n      if (!buffer.hasAttribute(CharTermAttribute.class)) {\n        return new NoTokenFoundQueryNode();\n      }\n\n      CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n\n      if (numTokens == 0) {\n        return new NoTokenFoundQueryNode();\n\n      } else if (numTokens == 1) {\n        String term = null;\n        try {\n          boolean hasNext;\n          hasNext = buffer.incrementToken();\n          assert hasNext == true;\n          term = termAtt.toString();\n\n        } catch (IOException e) {\n          // safe to ignore, because we know the number of tokens\n        }\n\n        fieldNode.setText(term);\n\n        return fieldNode;\n\n      } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n        if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n          // no phrase query:\n          LinkedList<QueryNode> children = new LinkedList<QueryNode>();\n\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            children.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n          return new GroupQueryNode(\n            new StandardBooleanQueryNode(children, positionCount==1));\n        } else {\n          // phrase query:\n          MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n\n          List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();\n          int position = -1;\n          int i = 0;\n          int termGroupCount = 0;\n          for (; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n\n              for (FieldQueryNode termNode : multiTerms) {\n\n                if (this.positionIncrementsEnabled) {\n                  termNode.setPositionIncrement(position);\n                } else {\n                  termNode.setPositionIncrement(termGroupCount);\n                }\n\n                mpq.add(termNode);\n\n              }\n\n              // Only increment once for each \"group\" of\n              // terms that were in the same position:\n              termGroupCount++;\n\n              multiTerms.clear();\n\n            }\n\n            position += positionIncrement;\n            multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n\n          for (FieldQueryNode termNode : multiTerms) {\n\n            if (this.positionIncrementsEnabled) {\n              termNode.setPositionIncrement(position);\n\n            } else {\n              termNode.setPositionIncrement(termGroupCount);\n            }\n\n            mpq.add(termNode);\n\n          }\n\n          return mpq;\n\n        }\n\n      } else {\n\n        TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n\n          if (this.positionIncrementsEnabled) {\n            position += positionIncrement;\n            newFieldNode.setPositionIncrement(position);\n\n          } else {\n            newFieldNode.setPositionIncrement(i);\n          }\n\n          pq.add(newFieldNode);\n\n        }\n\n        return pq;\n\n      }\n\n    }\n\n    return node;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb09d349a44ec933e41f1cfa536d5efb2c207752","date":1338937039,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","sourceNew":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      TokenStream source;\n      try {\n        source = this.analyzer.tokenStream(field, new StringReader(text));\n        source.reset();\n      } catch (IOException e1) {\n        throw new RuntimeException(e1);\n      }\n      CachingTokenFilter buffer = new CachingTokenFilter(source);\n\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      try {\n\n        while (buffer.incrementToken()) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n              .getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n\n        }\n\n      } catch (IOException e) {\n        // ignore\n      }\n\n      try {\n        // rewind the buffer stream\n        buffer.reset();\n\n        // close original stream - all tokens buffered\n        source.close();\n      } catch (IOException e) {\n        // ignore\n      }\n\n      if (!buffer.hasAttribute(CharTermAttribute.class)) {\n        return new NoTokenFoundQueryNode();\n      }\n\n      CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n\n      if (numTokens == 0) {\n        return new NoTokenFoundQueryNode();\n\n      } else if (numTokens == 1) {\n        String term = null;\n        try {\n          boolean hasNext;\n          hasNext = buffer.incrementToken();\n          assert hasNext == true;\n          term = termAtt.toString();\n\n        } catch (IOException e) {\n          // safe to ignore, because we know the number of tokens\n        }\n\n        fieldNode.setText(term);\n\n        return fieldNode;\n\n      } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n        if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n          // no phrase query:\n          LinkedList<QueryNode> children = new LinkedList<QueryNode>();\n\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            children.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n          return new GroupQueryNode(\n            new StandardBooleanQueryNode(children, positionCount==1));\n        } else {\n          // phrase query:\n          MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n\n          List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();\n          int position = -1;\n          int i = 0;\n          int termGroupCount = 0;\n          for (; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n\n              for (FieldQueryNode termNode : multiTerms) {\n\n                if (this.positionIncrementsEnabled) {\n                  termNode.setPositionIncrement(position);\n                } else {\n                  termNode.setPositionIncrement(termGroupCount);\n                }\n\n                mpq.add(termNode);\n\n              }\n\n              // Only increment once for each \"group\" of\n              // terms that were in the same position:\n              termGroupCount++;\n\n              multiTerms.clear();\n\n            }\n\n            position += positionIncrement;\n            multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n\n          for (FieldQueryNode termNode : multiTerms) {\n\n            if (this.positionIncrementsEnabled) {\n              termNode.setPositionIncrement(position);\n\n            } else {\n              termNode.setPositionIncrement(termGroupCount);\n            }\n\n            mpq.add(termNode);\n\n          }\n\n          return mpq;\n\n        }\n\n      } else {\n\n        TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n\n          if (this.positionIncrementsEnabled) {\n            position += positionIncrement;\n            newFieldNode.setPositionIncrement(position);\n\n          } else {\n            newFieldNode.setPositionIncrement(i);\n          }\n\n          pq.add(newFieldNode);\n\n        }\n\n        return pq;\n\n      }\n\n    }\n\n    return node;\n\n  }\n\n","sourceOld":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      TokenStream source;\n      try {\n        source = this.analyzer.tokenStream(field, new StringReader(text));\n        source.reset();\n      } catch (IOException e1) {\n        throw new RuntimeException(e1);\n      }\n      CachingTokenFilter buffer = new CachingTokenFilter(source);\n\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      try {\n\n        while (buffer.incrementToken()) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n              .getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n\n        }\n\n      } catch (IOException e) {\n        // ignore\n      }\n\n      try {\n        // rewind the buffer stream\n        buffer.reset();\n\n        // close original stream - all tokens buffered\n        source.close();\n      } catch (IOException e) {\n        // ignore\n      }\n\n      if (!buffer.hasAttribute(CharTermAttribute.class)) {\n        return new NoTokenFoundQueryNode();\n      }\n\n      CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n\n      if (numTokens == 0) {\n        return new NoTokenFoundQueryNode();\n\n      } else if (numTokens == 1) {\n        String term = null;\n        try {\n          boolean hasNext;\n          hasNext = buffer.incrementToken();\n          assert hasNext == true;\n          term = termAtt.toString();\n\n        } catch (IOException e) {\n          // safe to ignore, because we know the number of tokens\n        }\n\n        fieldNode.setText(term);\n\n        return fieldNode;\n\n      } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n        if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n          // no phrase query:\n          LinkedList<QueryNode> children = new LinkedList<QueryNode>();\n\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            children.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n          return new GroupQueryNode(\n            new StandardBooleanQueryNode(children, positionCount==1));\n        } else {\n          // phrase query:\n          MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n\n          List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();\n          int position = -1;\n          int i = 0;\n          int termGroupCount = 0;\n          for (; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n\n              for (FieldQueryNode termNode : multiTerms) {\n\n                if (this.positionIncrementsEnabled) {\n                  termNode.setPositionIncrement(position);\n                } else {\n                  termNode.setPositionIncrement(termGroupCount);\n                }\n\n                mpq.add(termNode);\n\n              }\n\n              // Only increment once for each \"group\" of\n              // terms that were in the same position:\n              termGroupCount++;\n\n              multiTerms.clear();\n\n            }\n\n            position += positionIncrement;\n            multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n\n          for (FieldQueryNode termNode : multiTerms) {\n\n            if (this.positionIncrementsEnabled) {\n              termNode.setPositionIncrement(position);\n\n            } else {\n              termNode.setPositionIncrement(termGroupCount);\n            }\n\n            mpq.add(termNode);\n\n          }\n\n          return mpq;\n\n        }\n\n      } else {\n\n        TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n\n          if (this.positionIncrementsEnabled) {\n            position += positionIncrement;\n            newFieldNode.setPositionIncrement(position);\n\n          } else {\n            newFieldNode.setPositionIncrement(i);\n          }\n\n          pq.add(newFieldNode);\n\n        }\n\n        return pq;\n\n      }\n\n    }\n\n    return node;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c83d6c4335f31cae14f625a222bc842f20073dcd","date":1373306148,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","sourceNew":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      TokenStream source;\n      try {\n        source = this.analyzer.tokenStream(field, text);\n        source.reset();\n      } catch (IOException e1) {\n        throw new RuntimeException(e1);\n      }\n      CachingTokenFilter buffer = new CachingTokenFilter(source);\n\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      try {\n\n        while (buffer.incrementToken()) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n              .getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n\n        }\n\n      } catch (IOException e) {\n        // ignore\n      }\n\n      try {\n        // rewind the buffer stream\n        buffer.reset();\n\n        // close original stream - all tokens buffered\n        source.close();\n      } catch (IOException e) {\n        // ignore\n      }\n\n      if (!buffer.hasAttribute(CharTermAttribute.class)) {\n        return new NoTokenFoundQueryNode();\n      }\n\n      CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n\n      if (numTokens == 0) {\n        return new NoTokenFoundQueryNode();\n\n      } else if (numTokens == 1) {\n        String term = null;\n        try {\n          boolean hasNext;\n          hasNext = buffer.incrementToken();\n          assert hasNext == true;\n          term = termAtt.toString();\n\n        } catch (IOException e) {\n          // safe to ignore, because we know the number of tokens\n        }\n\n        fieldNode.setText(term);\n\n        return fieldNode;\n\n      } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n        if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n          // no phrase query:\n          LinkedList<QueryNode> children = new LinkedList<QueryNode>();\n\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            children.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n          return new GroupQueryNode(\n            new StandardBooleanQueryNode(children, positionCount==1));\n        } else {\n          // phrase query:\n          MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n\n          List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();\n          int position = -1;\n          int i = 0;\n          int termGroupCount = 0;\n          for (; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n\n              for (FieldQueryNode termNode : multiTerms) {\n\n                if (this.positionIncrementsEnabled) {\n                  termNode.setPositionIncrement(position);\n                } else {\n                  termNode.setPositionIncrement(termGroupCount);\n                }\n\n                mpq.add(termNode);\n\n              }\n\n              // Only increment once for each \"group\" of\n              // terms that were in the same position:\n              termGroupCount++;\n\n              multiTerms.clear();\n\n            }\n\n            position += positionIncrement;\n            multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n\n          for (FieldQueryNode termNode : multiTerms) {\n\n            if (this.positionIncrementsEnabled) {\n              termNode.setPositionIncrement(position);\n\n            } else {\n              termNode.setPositionIncrement(termGroupCount);\n            }\n\n            mpq.add(termNode);\n\n          }\n\n          return mpq;\n\n        }\n\n      } else {\n\n        TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n\n          if (this.positionIncrementsEnabled) {\n            position += positionIncrement;\n            newFieldNode.setPositionIncrement(position);\n\n          } else {\n            newFieldNode.setPositionIncrement(i);\n          }\n\n          pq.add(newFieldNode);\n\n        }\n\n        return pq;\n\n      }\n\n    }\n\n    return node;\n\n  }\n\n","sourceOld":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      TokenStream source;\n      try {\n        source = this.analyzer.tokenStream(field, new StringReader(text));\n        source.reset();\n      } catch (IOException e1) {\n        throw new RuntimeException(e1);\n      }\n      CachingTokenFilter buffer = new CachingTokenFilter(source);\n\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      try {\n\n        while (buffer.incrementToken()) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n              .getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n\n        }\n\n      } catch (IOException e) {\n        // ignore\n      }\n\n      try {\n        // rewind the buffer stream\n        buffer.reset();\n\n        // close original stream - all tokens buffered\n        source.close();\n      } catch (IOException e) {\n        // ignore\n      }\n\n      if (!buffer.hasAttribute(CharTermAttribute.class)) {\n        return new NoTokenFoundQueryNode();\n      }\n\n      CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n\n      if (numTokens == 0) {\n        return new NoTokenFoundQueryNode();\n\n      } else if (numTokens == 1) {\n        String term = null;\n        try {\n          boolean hasNext;\n          hasNext = buffer.incrementToken();\n          assert hasNext == true;\n          term = termAtt.toString();\n\n        } catch (IOException e) {\n          // safe to ignore, because we know the number of tokens\n        }\n\n        fieldNode.setText(term);\n\n        return fieldNode;\n\n      } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n        if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n          // no phrase query:\n          LinkedList<QueryNode> children = new LinkedList<QueryNode>();\n\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            children.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n          return new GroupQueryNode(\n            new StandardBooleanQueryNode(children, positionCount==1));\n        } else {\n          // phrase query:\n          MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n\n          List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();\n          int position = -1;\n          int i = 0;\n          int termGroupCount = 0;\n          for (; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n\n              for (FieldQueryNode termNode : multiTerms) {\n\n                if (this.positionIncrementsEnabled) {\n                  termNode.setPositionIncrement(position);\n                } else {\n                  termNode.setPositionIncrement(termGroupCount);\n                }\n\n                mpq.add(termNode);\n\n              }\n\n              // Only increment once for each \"group\" of\n              // terms that were in the same position:\n              termGroupCount++;\n\n              multiTerms.clear();\n\n            }\n\n            position += positionIncrement;\n            multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n\n          for (FieldQueryNode termNode : multiTerms) {\n\n            if (this.positionIncrementsEnabled) {\n              termNode.setPositionIncrement(position);\n\n            } else {\n              termNode.setPositionIncrement(termGroupCount);\n            }\n\n            mpq.add(termNode);\n\n          }\n\n          return mpq;\n\n        }\n\n      } else {\n\n        TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n\n          if (this.positionIncrementsEnabled) {\n            position += positionIncrement;\n            newFieldNode.setPositionIncrement(position);\n\n          } else {\n            newFieldNode.setPositionIncrement(i);\n          }\n\n          pq.add(newFieldNode);\n\n        }\n\n        return pq;\n\n      }\n\n    }\n\n    return node;\n\n  }\n\n","bugFix":["69e043c521d4e8db770cc140c63f5ef51f03426a"],"bugIntro":["782ed6a4b4ba50ec19734fc8db4e570ee193d627"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","sourceNew":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      TokenStream source;\n      try {\n        source = this.analyzer.tokenStream(field, text);\n        source.reset();\n      } catch (IOException e1) {\n        throw new RuntimeException(e1);\n      }\n      CachingTokenFilter buffer = new CachingTokenFilter(source);\n\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      try {\n\n        while (buffer.incrementToken()) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n              .getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n\n        }\n\n      } catch (IOException e) {\n        // ignore\n      }\n\n      try {\n        // rewind the buffer stream\n        buffer.reset();\n\n        // close original stream - all tokens buffered\n        source.close();\n      } catch (IOException e) {\n        // ignore\n      }\n\n      if (!buffer.hasAttribute(CharTermAttribute.class)) {\n        return new NoTokenFoundQueryNode();\n      }\n\n      CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n\n      if (numTokens == 0) {\n        return new NoTokenFoundQueryNode();\n\n      } else if (numTokens == 1) {\n        String term = null;\n        try {\n          boolean hasNext;\n          hasNext = buffer.incrementToken();\n          assert hasNext == true;\n          term = termAtt.toString();\n\n        } catch (IOException e) {\n          // safe to ignore, because we know the number of tokens\n        }\n\n        fieldNode.setText(term);\n\n        return fieldNode;\n\n      } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n        if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n          // no phrase query:\n          LinkedList<QueryNode> children = new LinkedList<QueryNode>();\n\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            children.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n          return new GroupQueryNode(\n            new StandardBooleanQueryNode(children, positionCount==1));\n        } else {\n          // phrase query:\n          MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n\n          List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();\n          int position = -1;\n          int i = 0;\n          int termGroupCount = 0;\n          for (; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n\n              for (FieldQueryNode termNode : multiTerms) {\n\n                if (this.positionIncrementsEnabled) {\n                  termNode.setPositionIncrement(position);\n                } else {\n                  termNode.setPositionIncrement(termGroupCount);\n                }\n\n                mpq.add(termNode);\n\n              }\n\n              // Only increment once for each \"group\" of\n              // terms that were in the same position:\n              termGroupCount++;\n\n              multiTerms.clear();\n\n            }\n\n            position += positionIncrement;\n            multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n\n          for (FieldQueryNode termNode : multiTerms) {\n\n            if (this.positionIncrementsEnabled) {\n              termNode.setPositionIncrement(position);\n\n            } else {\n              termNode.setPositionIncrement(termGroupCount);\n            }\n\n            mpq.add(termNode);\n\n          }\n\n          return mpq;\n\n        }\n\n      } else {\n\n        TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n\n          if (this.positionIncrementsEnabled) {\n            position += positionIncrement;\n            newFieldNode.setPositionIncrement(position);\n\n          } else {\n            newFieldNode.setPositionIncrement(i);\n          }\n\n          pq.add(newFieldNode);\n\n        }\n\n        return pq;\n\n      }\n\n    }\n\n    return node;\n\n  }\n\n","sourceOld":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      TokenStream source;\n      try {\n        source = this.analyzer.tokenStream(field, new StringReader(text));\n        source.reset();\n      } catch (IOException e1) {\n        throw new RuntimeException(e1);\n      }\n      CachingTokenFilter buffer = new CachingTokenFilter(source);\n\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      try {\n\n        while (buffer.incrementToken()) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n              .getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n\n        }\n\n      } catch (IOException e) {\n        // ignore\n      }\n\n      try {\n        // rewind the buffer stream\n        buffer.reset();\n\n        // close original stream - all tokens buffered\n        source.close();\n      } catch (IOException e) {\n        // ignore\n      }\n\n      if (!buffer.hasAttribute(CharTermAttribute.class)) {\n        return new NoTokenFoundQueryNode();\n      }\n\n      CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n\n      if (numTokens == 0) {\n        return new NoTokenFoundQueryNode();\n\n      } else if (numTokens == 1) {\n        String term = null;\n        try {\n          boolean hasNext;\n          hasNext = buffer.incrementToken();\n          assert hasNext == true;\n          term = termAtt.toString();\n\n        } catch (IOException e) {\n          // safe to ignore, because we know the number of tokens\n        }\n\n        fieldNode.setText(term);\n\n        return fieldNode;\n\n      } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n        if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n          // no phrase query:\n          LinkedList<QueryNode> children = new LinkedList<QueryNode>();\n\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            children.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n          return new GroupQueryNode(\n            new StandardBooleanQueryNode(children, positionCount==1));\n        } else {\n          // phrase query:\n          MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n\n          List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();\n          int position = -1;\n          int i = 0;\n          int termGroupCount = 0;\n          for (; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n\n              for (FieldQueryNode termNode : multiTerms) {\n\n                if (this.positionIncrementsEnabled) {\n                  termNode.setPositionIncrement(position);\n                } else {\n                  termNode.setPositionIncrement(termGroupCount);\n                }\n\n                mpq.add(termNode);\n\n              }\n\n              // Only increment once for each \"group\" of\n              // terms that were in the same position:\n              termGroupCount++;\n\n              multiTerms.clear();\n\n            }\n\n            position += positionIncrement;\n            multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n\n          for (FieldQueryNode termNode : multiTerms) {\n\n            if (this.positionIncrementsEnabled) {\n              termNode.setPositionIncrement(position);\n\n            } else {\n              termNode.setPositionIncrement(termGroupCount);\n            }\n\n            mpq.add(termNode);\n\n          }\n\n          return mpq;\n\n        }\n\n      } else {\n\n        TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n\n          if (this.positionIncrementsEnabled) {\n            position += positionIncrement;\n            newFieldNode.setPositionIncrement(position);\n\n          } else {\n            newFieldNode.setPositionIncrement(i);\n          }\n\n          pq.add(newFieldNode);\n\n        }\n\n        return pq;\n\n      }\n\n    }\n\n    return node;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"782ed6a4b4ba50ec19734fc8db4e570ee193d627","date":1381127065,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","sourceNew":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      CachingTokenFilter buffer = null;\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n      \n      try (TokenStream source = this.analyzer.tokenStream(field, text)) {\n        source.reset();\n        buffer = new CachingTokenFilter(source);\n\n        if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n          posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n        }\n\n        try {\n\n          while (buffer.incrementToken()) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n                .getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n\n          }\n\n        } catch (IOException e) {\n          // ignore\n        }\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // rewind the buffer stream\n      buffer.reset();\n\n      if (!buffer.hasAttribute(CharTermAttribute.class)) {\n        return new NoTokenFoundQueryNode();\n      }\n\n      CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n\n      if (numTokens == 0) {\n        return new NoTokenFoundQueryNode();\n\n      } else if (numTokens == 1) {\n        String term = null;\n        try {\n          boolean hasNext;\n          hasNext = buffer.incrementToken();\n          assert hasNext == true;\n          term = termAtt.toString();\n\n        } catch (IOException e) {\n          // safe to ignore, because we know the number of tokens\n        }\n\n        fieldNode.setText(term);\n\n        return fieldNode;\n\n      } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n        if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n          // no phrase query:\n          LinkedList<QueryNode> children = new LinkedList<QueryNode>();\n\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            children.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n          return new GroupQueryNode(\n            new StandardBooleanQueryNode(children, positionCount==1));\n        } else {\n          // phrase query:\n          MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n\n          List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();\n          int position = -1;\n          int i = 0;\n          int termGroupCount = 0;\n          for (; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n\n              for (FieldQueryNode termNode : multiTerms) {\n\n                if (this.positionIncrementsEnabled) {\n                  termNode.setPositionIncrement(position);\n                } else {\n                  termNode.setPositionIncrement(termGroupCount);\n                }\n\n                mpq.add(termNode);\n\n              }\n\n              // Only increment once for each \"group\" of\n              // terms that were in the same position:\n              termGroupCount++;\n\n              multiTerms.clear();\n\n            }\n\n            position += positionIncrement;\n            multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n\n          for (FieldQueryNode termNode : multiTerms) {\n\n            if (this.positionIncrementsEnabled) {\n              termNode.setPositionIncrement(position);\n\n            } else {\n              termNode.setPositionIncrement(termGroupCount);\n            }\n\n            mpq.add(termNode);\n\n          }\n\n          return mpq;\n\n        }\n\n      } else {\n\n        TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n\n          if (this.positionIncrementsEnabled) {\n            position += positionIncrement;\n            newFieldNode.setPositionIncrement(position);\n\n          } else {\n            newFieldNode.setPositionIncrement(i);\n          }\n\n          pq.add(newFieldNode);\n\n        }\n\n        return pq;\n\n      }\n\n    }\n\n    return node;\n\n  }\n\n","sourceOld":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      TokenStream source;\n      try {\n        source = this.analyzer.tokenStream(field, text);\n        source.reset();\n      } catch (IOException e1) {\n        throw new RuntimeException(e1);\n      }\n      CachingTokenFilter buffer = new CachingTokenFilter(source);\n\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n\n      try {\n\n        while (buffer.incrementToken()) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n              .getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n\n        }\n\n      } catch (IOException e) {\n        // ignore\n      }\n\n      try {\n        // rewind the buffer stream\n        buffer.reset();\n\n        // close original stream - all tokens buffered\n        source.close();\n      } catch (IOException e) {\n        // ignore\n      }\n\n      if (!buffer.hasAttribute(CharTermAttribute.class)) {\n        return new NoTokenFoundQueryNode();\n      }\n\n      CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n\n      if (numTokens == 0) {\n        return new NoTokenFoundQueryNode();\n\n      } else if (numTokens == 1) {\n        String term = null;\n        try {\n          boolean hasNext;\n          hasNext = buffer.incrementToken();\n          assert hasNext == true;\n          term = termAtt.toString();\n\n        } catch (IOException e) {\n          // safe to ignore, because we know the number of tokens\n        }\n\n        fieldNode.setText(term);\n\n        return fieldNode;\n\n      } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n        if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n          // no phrase query:\n          LinkedList<QueryNode> children = new LinkedList<QueryNode>();\n\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            children.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n          return new GroupQueryNode(\n            new StandardBooleanQueryNode(children, positionCount==1));\n        } else {\n          // phrase query:\n          MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n\n          List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();\n          int position = -1;\n          int i = 0;\n          int termGroupCount = 0;\n          for (; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n\n              for (FieldQueryNode termNode : multiTerms) {\n\n                if (this.positionIncrementsEnabled) {\n                  termNode.setPositionIncrement(position);\n                } else {\n                  termNode.setPositionIncrement(termGroupCount);\n                }\n\n                mpq.add(termNode);\n\n              }\n\n              // Only increment once for each \"group\" of\n              // terms that were in the same position:\n              termGroupCount++;\n\n              multiTerms.clear();\n\n            }\n\n            position += positionIncrement;\n            multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n\n          for (FieldQueryNode termNode : multiTerms) {\n\n            if (this.positionIncrementsEnabled) {\n              termNode.setPositionIncrement(position);\n\n            } else {\n              termNode.setPositionIncrement(termGroupCount);\n            }\n\n            mpq.add(termNode);\n\n          }\n\n          return mpq;\n\n        }\n\n      } else {\n\n        TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n\n          if (this.positionIncrementsEnabled) {\n            position += positionIncrement;\n            newFieldNode.setPositionIncrement(position);\n\n          } else {\n            newFieldNode.setPositionIncrement(i);\n          }\n\n          pq.add(newFieldNode);\n\n        }\n\n        return pq;\n\n      }\n\n    }\n\n    return node;\n\n  }\n\n","bugFix":["00746ad002a54281629e3b6f3eb39833a33f093e","8d78f014fded44fbde905f4f84cdc21907b371e8","b955a87bc7c5daeda1ed56821ec0bec2e8789e44","e2efdd13c0f37dbe4a292a6f98ddcf8e8f872ac4","c83d6c4335f31cae14f625a222bc842f20073dcd"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"caaf8f27a34037f65ab81e92835f18a303d8d2f1","date":1389767794,"type":3,"author":"Adriano Crestani Campos","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","sourceNew":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      CachingTokenFilter buffer = null;\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n      \n      try {\n        try (TokenStream source = this.analyzer.tokenStream(field, text)) {\n          source.reset();\n          buffer = new CachingTokenFilter(source);\n  \n          if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n            posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n          }\n  \n          try {\n  \n            while (buffer.incrementToken()) {\n              numTokens++;\n              int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n                  .getPositionIncrement() : 1;\n              if (positionIncrement != 0) {\n                positionCount += positionIncrement;\n  \n              } else {\n                severalTokensAtSamePosition = true;\n              }\n  \n            }\n  \n          } catch (IOException e) {\n            // ignore\n          }\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n        \n        // rewind the buffer stream\n        buffer.reset();\n  \n        if (!buffer.hasAttribute(CharTermAttribute.class)) {\n          return new NoTokenFoundQueryNode();\n        }\n  \n        CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n  \n        if (numTokens == 0) {\n          return new NoTokenFoundQueryNode();\n  \n        } else if (numTokens == 1) {\n          String term = null;\n          try {\n            boolean hasNext;\n            hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n  \n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n  \n          fieldNode.setText(term);\n  \n          return fieldNode;\n  \n        } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n          if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n            // no phrase query:\n            \n            if (positionCount == 1) {\n              // simple case: only one position, with synonyms\n              LinkedList<QueryNode> children = new LinkedList<QueryNode>();\n              \n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                  \n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                \n                children.add(new FieldQueryNode(field, term, -1, -1));\n                \n              }\n              return new GroupQueryNode(\n                  new StandardBooleanQueryNode(children, positionCount==1));\n            } else {\n              // multiple positions\n              QueryNode q = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(),false);\n              QueryNode currentQuery = null;\n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                  if (!(currentQuery instanceof BooleanQueryNode)) {\n                    QueryNode t = currentQuery;\n                    currentQuery = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(), true);\n                    ((BooleanQueryNode)currentQuery).add(t);\n                  }\n                  ((BooleanQueryNode)currentQuery).add(new FieldQueryNode(field, term, -1, -1));\n                } else {\n                  if (currentQuery != null) {\n                    if (this.defaultOperator == Operator.OR) {\n                      q.add(currentQuery);\n                    } else {\n                      q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n                    }\n                  }\n                  currentQuery = new FieldQueryNode(field, term, -1, -1);\n                }\n              }\n              if (this.defaultOperator == Operator.OR) {\n                q.add(currentQuery);\n              } else {\n                q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n              }\n              \n              if (q instanceof BooleanQueryNode) {\n                q = new GroupQueryNode(q);\n              }\n              return q;\n            }\n          } else {\n            // phrase query:\n            MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n  \n            List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();\n            int position = -1;\n            int i = 0;\n            int termGroupCount = 0;\n            for (; i < numTokens; i++) {\n              String term = null;\n              int positionIncrement = 1;\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                term = termAtt.toString();\n                if (posIncrAtt != null) {\n                  positionIncrement = posIncrAtt.getPositionIncrement();\n                }\n  \n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n  \n              if (positionIncrement > 0 && multiTerms.size() > 0) {\n  \n                for (FieldQueryNode termNode : multiTerms) {\n  \n                  if (this.positionIncrementsEnabled) {\n                    termNode.setPositionIncrement(position);\n                  } else {\n                    termNode.setPositionIncrement(termGroupCount);\n                  }\n  \n                  mpq.add(termNode);\n  \n                }\n  \n                // Only increment once for each \"group\" of\n                // terms that were in the same position:\n                termGroupCount++;\n  \n                multiTerms.clear();\n  \n              }\n  \n              position += positionIncrement;\n              multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n  \n            }\n  \n            for (FieldQueryNode termNode : multiTerms) {\n  \n              if (this.positionIncrementsEnabled) {\n                termNode.setPositionIncrement(position);\n  \n              } else {\n                termNode.setPositionIncrement(termGroupCount);\n              }\n  \n              mpq.add(termNode);\n  \n            }\n  \n            return mpq;\n  \n          }\n  \n        } else {\n  \n          TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n  \n          int position = -1;\n  \n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n  \n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n  \n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n  \n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n  \n            FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n  \n            if (this.positionIncrementsEnabled) {\n              position += positionIncrement;\n              newFieldNode.setPositionIncrement(position);\n  \n            } else {\n              newFieldNode.setPositionIncrement(i);\n            }\n  \n            pq.add(newFieldNode);\n  \n          }\n  \n          return pq;\n  \n        }\n      } finally {\n        if (buffer != null) {\n          try {\n            buffer.close();\n          } catch (IOException e) {\n            // safe to ignore\n          }\n        }\n      }\n    }\n\n    return node;\n  }\n\n","sourceOld":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      CachingTokenFilter buffer = null;\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n      \n      try (TokenStream source = this.analyzer.tokenStream(field, text)) {\n        source.reset();\n        buffer = new CachingTokenFilter(source);\n\n        if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n          posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n        }\n\n        try {\n\n          while (buffer.incrementToken()) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n                .getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n\n          }\n\n        } catch (IOException e) {\n          // ignore\n        }\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      \n      // rewind the buffer stream\n      buffer.reset();\n\n      if (!buffer.hasAttribute(CharTermAttribute.class)) {\n        return new NoTokenFoundQueryNode();\n      }\n\n      CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n\n      if (numTokens == 0) {\n        return new NoTokenFoundQueryNode();\n\n      } else if (numTokens == 1) {\n        String term = null;\n        try {\n          boolean hasNext;\n          hasNext = buffer.incrementToken();\n          assert hasNext == true;\n          term = termAtt.toString();\n\n        } catch (IOException e) {\n          // safe to ignore, because we know the number of tokens\n        }\n\n        fieldNode.setText(term);\n\n        return fieldNode;\n\n      } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n        if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n          // no phrase query:\n          LinkedList<QueryNode> children = new LinkedList<QueryNode>();\n\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            children.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n          return new GroupQueryNode(\n            new StandardBooleanQueryNode(children, positionCount==1));\n        } else {\n          // phrase query:\n          MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n\n          List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();\n          int position = -1;\n          int i = 0;\n          int termGroupCount = 0;\n          for (; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n\n              for (FieldQueryNode termNode : multiTerms) {\n\n                if (this.positionIncrementsEnabled) {\n                  termNode.setPositionIncrement(position);\n                } else {\n                  termNode.setPositionIncrement(termGroupCount);\n                }\n\n                mpq.add(termNode);\n\n              }\n\n              // Only increment once for each \"group\" of\n              // terms that were in the same position:\n              termGroupCount++;\n\n              multiTerms.clear();\n\n            }\n\n            position += positionIncrement;\n            multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n\n          }\n\n          for (FieldQueryNode termNode : multiTerms) {\n\n            if (this.positionIncrementsEnabled) {\n              termNode.setPositionIncrement(position);\n\n            } else {\n              termNode.setPositionIncrement(termGroupCount);\n            }\n\n            mpq.add(termNode);\n\n          }\n\n          return mpq;\n\n        }\n\n      } else {\n\n        TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n\n        int position = -1;\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n\n          if (this.positionIncrementsEnabled) {\n            position += positionIncrement;\n            newFieldNode.setPositionIncrement(position);\n\n          } else {\n            newFieldNode.setPositionIncrement(i);\n          }\n\n          pq.add(newFieldNode);\n\n        }\n\n        return pq;\n\n      }\n\n    }\n\n    return node;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","sourceNew":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      CachingTokenFilter buffer = null;\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n      \n      try {\n        try (TokenStream source = this.analyzer.tokenStream(field, text)) {\n          source.reset();\n          buffer = new CachingTokenFilter(source);\n  \n          if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n            posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n          }\n  \n          try {\n  \n            while (buffer.incrementToken()) {\n              numTokens++;\n              int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n                  .getPositionIncrement() : 1;\n              if (positionIncrement != 0) {\n                positionCount += positionIncrement;\n  \n              } else {\n                severalTokensAtSamePosition = true;\n              }\n  \n            }\n  \n          } catch (IOException e) {\n            // ignore\n          }\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n        \n        // rewind the buffer stream\n        buffer.reset();\n  \n        if (!buffer.hasAttribute(CharTermAttribute.class)) {\n          return new NoTokenFoundQueryNode();\n        }\n  \n        CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n  \n        if (numTokens == 0) {\n          return new NoTokenFoundQueryNode();\n  \n        } else if (numTokens == 1) {\n          String term = null;\n          try {\n            boolean hasNext;\n            hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n  \n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n  \n          fieldNode.setText(term);\n  \n          return fieldNode;\n  \n        } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n          if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n            // no phrase query:\n            \n            if (positionCount == 1) {\n              // simple case: only one position, with synonyms\n              LinkedList<QueryNode> children = new LinkedList<>();\n              \n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                  \n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                \n                children.add(new FieldQueryNode(field, term, -1, -1));\n                \n              }\n              return new GroupQueryNode(\n                  new StandardBooleanQueryNode(children, positionCount==1));\n            } else {\n              // multiple positions\n              QueryNode q = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(),false);\n              QueryNode currentQuery = null;\n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                  if (!(currentQuery instanceof BooleanQueryNode)) {\n                    QueryNode t = currentQuery;\n                    currentQuery = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(), true);\n                    ((BooleanQueryNode)currentQuery).add(t);\n                  }\n                  ((BooleanQueryNode)currentQuery).add(new FieldQueryNode(field, term, -1, -1));\n                } else {\n                  if (currentQuery != null) {\n                    if (this.defaultOperator == Operator.OR) {\n                      q.add(currentQuery);\n                    } else {\n                      q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n                    }\n                  }\n                  currentQuery = new FieldQueryNode(field, term, -1, -1);\n                }\n              }\n              if (this.defaultOperator == Operator.OR) {\n                q.add(currentQuery);\n              } else {\n                q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n              }\n              \n              if (q instanceof BooleanQueryNode) {\n                q = new GroupQueryNode(q);\n              }\n              return q;\n            }\n          } else {\n            // phrase query:\n            MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n  \n            List<FieldQueryNode> multiTerms = new ArrayList<>();\n            int position = -1;\n            int i = 0;\n            int termGroupCount = 0;\n            for (; i < numTokens; i++) {\n              String term = null;\n              int positionIncrement = 1;\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                term = termAtt.toString();\n                if (posIncrAtt != null) {\n                  positionIncrement = posIncrAtt.getPositionIncrement();\n                }\n  \n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n  \n              if (positionIncrement > 0 && multiTerms.size() > 0) {\n  \n                for (FieldQueryNode termNode : multiTerms) {\n  \n                  if (this.positionIncrementsEnabled) {\n                    termNode.setPositionIncrement(position);\n                  } else {\n                    termNode.setPositionIncrement(termGroupCount);\n                  }\n  \n                  mpq.add(termNode);\n  \n                }\n  \n                // Only increment once for each \"group\" of\n                // terms that were in the same position:\n                termGroupCount++;\n  \n                multiTerms.clear();\n  \n              }\n  \n              position += positionIncrement;\n              multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n  \n            }\n  \n            for (FieldQueryNode termNode : multiTerms) {\n  \n              if (this.positionIncrementsEnabled) {\n                termNode.setPositionIncrement(position);\n  \n              } else {\n                termNode.setPositionIncrement(termGroupCount);\n              }\n  \n              mpq.add(termNode);\n  \n            }\n  \n            return mpq;\n  \n          }\n  \n        } else {\n  \n          TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n  \n          int position = -1;\n  \n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n  \n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n  \n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n  \n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n  \n            FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n  \n            if (this.positionIncrementsEnabled) {\n              position += positionIncrement;\n              newFieldNode.setPositionIncrement(position);\n  \n            } else {\n              newFieldNode.setPositionIncrement(i);\n            }\n  \n            pq.add(newFieldNode);\n  \n          }\n  \n          return pq;\n  \n        }\n      } finally {\n        if (buffer != null) {\n          try {\n            buffer.close();\n          } catch (IOException e) {\n            // safe to ignore\n          }\n        }\n      }\n    }\n\n    return node;\n  }\n\n","sourceOld":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      CachingTokenFilter buffer = null;\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n      \n      try {\n        try (TokenStream source = this.analyzer.tokenStream(field, text)) {\n          source.reset();\n          buffer = new CachingTokenFilter(source);\n  \n          if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n            posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n          }\n  \n          try {\n  \n            while (buffer.incrementToken()) {\n              numTokens++;\n              int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n                  .getPositionIncrement() : 1;\n              if (positionIncrement != 0) {\n                positionCount += positionIncrement;\n  \n              } else {\n                severalTokensAtSamePosition = true;\n              }\n  \n            }\n  \n          } catch (IOException e) {\n            // ignore\n          }\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n        \n        // rewind the buffer stream\n        buffer.reset();\n  \n        if (!buffer.hasAttribute(CharTermAttribute.class)) {\n          return new NoTokenFoundQueryNode();\n        }\n  \n        CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n  \n        if (numTokens == 0) {\n          return new NoTokenFoundQueryNode();\n  \n        } else if (numTokens == 1) {\n          String term = null;\n          try {\n            boolean hasNext;\n            hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n  \n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n  \n          fieldNode.setText(term);\n  \n          return fieldNode;\n  \n        } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n          if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n            // no phrase query:\n            \n            if (positionCount == 1) {\n              // simple case: only one position, with synonyms\n              LinkedList<QueryNode> children = new LinkedList<QueryNode>();\n              \n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                  \n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                \n                children.add(new FieldQueryNode(field, term, -1, -1));\n                \n              }\n              return new GroupQueryNode(\n                  new StandardBooleanQueryNode(children, positionCount==1));\n            } else {\n              // multiple positions\n              QueryNode q = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(),false);\n              QueryNode currentQuery = null;\n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                  if (!(currentQuery instanceof BooleanQueryNode)) {\n                    QueryNode t = currentQuery;\n                    currentQuery = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(), true);\n                    ((BooleanQueryNode)currentQuery).add(t);\n                  }\n                  ((BooleanQueryNode)currentQuery).add(new FieldQueryNode(field, term, -1, -1));\n                } else {\n                  if (currentQuery != null) {\n                    if (this.defaultOperator == Operator.OR) {\n                      q.add(currentQuery);\n                    } else {\n                      q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n                    }\n                  }\n                  currentQuery = new FieldQueryNode(field, term, -1, -1);\n                }\n              }\n              if (this.defaultOperator == Operator.OR) {\n                q.add(currentQuery);\n              } else {\n                q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n              }\n              \n              if (q instanceof BooleanQueryNode) {\n                q = new GroupQueryNode(q);\n              }\n              return q;\n            }\n          } else {\n            // phrase query:\n            MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n  \n            List<FieldQueryNode> multiTerms = new ArrayList<FieldQueryNode>();\n            int position = -1;\n            int i = 0;\n            int termGroupCount = 0;\n            for (; i < numTokens; i++) {\n              String term = null;\n              int positionIncrement = 1;\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                term = termAtt.toString();\n                if (posIncrAtt != null) {\n                  positionIncrement = posIncrAtt.getPositionIncrement();\n                }\n  \n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n  \n              if (positionIncrement > 0 && multiTerms.size() > 0) {\n  \n                for (FieldQueryNode termNode : multiTerms) {\n  \n                  if (this.positionIncrementsEnabled) {\n                    termNode.setPositionIncrement(position);\n                  } else {\n                    termNode.setPositionIncrement(termGroupCount);\n                  }\n  \n                  mpq.add(termNode);\n  \n                }\n  \n                // Only increment once for each \"group\" of\n                // terms that were in the same position:\n                termGroupCount++;\n  \n                multiTerms.clear();\n  \n              }\n  \n              position += positionIncrement;\n              multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n  \n            }\n  \n            for (FieldQueryNode termNode : multiTerms) {\n  \n              if (this.positionIncrementsEnabled) {\n                termNode.setPositionIncrement(position);\n  \n              } else {\n                termNode.setPositionIncrement(termGroupCount);\n              }\n  \n              mpq.add(termNode);\n  \n            }\n  \n            return mpq;\n  \n          }\n  \n        } else {\n  \n          TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n  \n          int position = -1;\n  \n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n  \n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n  \n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n  \n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n  \n            FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n  \n            if (this.positionIncrementsEnabled) {\n              position += positionIncrement;\n              newFieldNode.setPositionIncrement(position);\n  \n            } else {\n              newFieldNode.setPositionIncrement(i);\n            }\n  \n            pq.add(newFieldNode);\n  \n          }\n  \n          return pq;\n  \n        }\n      } finally {\n        if (buffer != null) {\n          try {\n            buffer.close();\n          } catch (IOException e) {\n            // safe to ignore\n          }\n        }\n      }\n    }\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55244759f906151d96839f8451dee793acb06e75","date":1418999882,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","sourceNew":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      CachingTokenFilter buffer = null;\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n      \n      try {\n        try (TokenStream source = this.analyzer.tokenStream(field, text)) {\n          buffer = new CachingTokenFilter(source);\n          buffer.reset();\n\n          if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n            posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n          }\n  \n          try {\n  \n            while (buffer.incrementToken()) {\n              numTokens++;\n              int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n                  .getPositionIncrement() : 1;\n              if (positionIncrement != 0) {\n                positionCount += positionIncrement;\n  \n              } else {\n                severalTokensAtSamePosition = true;\n              }\n  \n            }\n  \n          } catch (IOException e) {\n            // ignore\n          }\n\n          // rewind the buffer stream\n          buffer.reset();//will never through on subsequent reset calls\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        if (!buffer.hasAttribute(CharTermAttribute.class)) {\n          return new NoTokenFoundQueryNode();\n        }\n  \n        CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n  \n        if (numTokens == 0) {\n          return new NoTokenFoundQueryNode();\n  \n        } else if (numTokens == 1) {\n          String term = null;\n          try {\n            boolean hasNext;\n            hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n  \n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n  \n          fieldNode.setText(term);\n  \n          return fieldNode;\n  \n        } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n          if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n            // no phrase query:\n            \n            if (positionCount == 1) {\n              // simple case: only one position, with synonyms\n              LinkedList<QueryNode> children = new LinkedList<>();\n              \n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                  \n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                \n                children.add(new FieldQueryNode(field, term, -1, -1));\n                \n              }\n              return new GroupQueryNode(\n                  new StandardBooleanQueryNode(children, positionCount==1));\n            } else {\n              // multiple positions\n              QueryNode q = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(),false);\n              QueryNode currentQuery = null;\n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                  if (!(currentQuery instanceof BooleanQueryNode)) {\n                    QueryNode t = currentQuery;\n                    currentQuery = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(), true);\n                    ((BooleanQueryNode)currentQuery).add(t);\n                  }\n                  ((BooleanQueryNode)currentQuery).add(new FieldQueryNode(field, term, -1, -1));\n                } else {\n                  if (currentQuery != null) {\n                    if (this.defaultOperator == Operator.OR) {\n                      q.add(currentQuery);\n                    } else {\n                      q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n                    }\n                  }\n                  currentQuery = new FieldQueryNode(field, term, -1, -1);\n                }\n              }\n              if (this.defaultOperator == Operator.OR) {\n                q.add(currentQuery);\n              } else {\n                q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n              }\n              \n              if (q instanceof BooleanQueryNode) {\n                q = new GroupQueryNode(q);\n              }\n              return q;\n            }\n          } else {\n            // phrase query:\n            MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n  \n            List<FieldQueryNode> multiTerms = new ArrayList<>();\n            int position = -1;\n            int i = 0;\n            int termGroupCount = 0;\n            for (; i < numTokens; i++) {\n              String term = null;\n              int positionIncrement = 1;\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                term = termAtt.toString();\n                if (posIncrAtt != null) {\n                  positionIncrement = posIncrAtt.getPositionIncrement();\n                }\n  \n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n  \n              if (positionIncrement > 0 && multiTerms.size() > 0) {\n  \n                for (FieldQueryNode termNode : multiTerms) {\n  \n                  if (this.positionIncrementsEnabled) {\n                    termNode.setPositionIncrement(position);\n                  } else {\n                    termNode.setPositionIncrement(termGroupCount);\n                  }\n  \n                  mpq.add(termNode);\n  \n                }\n  \n                // Only increment once for each \"group\" of\n                // terms that were in the same position:\n                termGroupCount++;\n  \n                multiTerms.clear();\n  \n              }\n  \n              position += positionIncrement;\n              multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n  \n            }\n  \n            for (FieldQueryNode termNode : multiTerms) {\n  \n              if (this.positionIncrementsEnabled) {\n                termNode.setPositionIncrement(position);\n  \n              } else {\n                termNode.setPositionIncrement(termGroupCount);\n              }\n  \n              mpq.add(termNode);\n  \n            }\n  \n            return mpq;\n  \n          }\n  \n        } else {\n  \n          TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n  \n          int position = -1;\n  \n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n  \n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n  \n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n  \n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n  \n            FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n  \n            if (this.positionIncrementsEnabled) {\n              position += positionIncrement;\n              newFieldNode.setPositionIncrement(position);\n  \n            } else {\n              newFieldNode.setPositionIncrement(i);\n            }\n  \n            pq.add(newFieldNode);\n  \n          }\n  \n          return pq;\n  \n        }\n      } finally {\n        if (buffer != null) {\n          try {\n            buffer.close();\n          } catch (IOException e) {\n            // safe to ignore\n          }\n        }\n      }\n    }\n\n    return node;\n  }\n\n","sourceOld":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      CachingTokenFilter buffer = null;\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n      \n      try {\n        try (TokenStream source = this.analyzer.tokenStream(field, text)) {\n          source.reset();\n          buffer = new CachingTokenFilter(source);\n  \n          if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n            posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n          }\n  \n          try {\n  \n            while (buffer.incrementToken()) {\n              numTokens++;\n              int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n                  .getPositionIncrement() : 1;\n              if (positionIncrement != 0) {\n                positionCount += positionIncrement;\n  \n              } else {\n                severalTokensAtSamePosition = true;\n              }\n  \n            }\n  \n          } catch (IOException e) {\n            // ignore\n          }\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n        \n        // rewind the buffer stream\n        buffer.reset();\n  \n        if (!buffer.hasAttribute(CharTermAttribute.class)) {\n          return new NoTokenFoundQueryNode();\n        }\n  \n        CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n  \n        if (numTokens == 0) {\n          return new NoTokenFoundQueryNode();\n  \n        } else if (numTokens == 1) {\n          String term = null;\n          try {\n            boolean hasNext;\n            hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n  \n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n  \n          fieldNode.setText(term);\n  \n          return fieldNode;\n  \n        } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n          if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n            // no phrase query:\n            \n            if (positionCount == 1) {\n              // simple case: only one position, with synonyms\n              LinkedList<QueryNode> children = new LinkedList<>();\n              \n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                  \n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                \n                children.add(new FieldQueryNode(field, term, -1, -1));\n                \n              }\n              return new GroupQueryNode(\n                  new StandardBooleanQueryNode(children, positionCount==1));\n            } else {\n              // multiple positions\n              QueryNode q = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(),false);\n              QueryNode currentQuery = null;\n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                  if (!(currentQuery instanceof BooleanQueryNode)) {\n                    QueryNode t = currentQuery;\n                    currentQuery = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(), true);\n                    ((BooleanQueryNode)currentQuery).add(t);\n                  }\n                  ((BooleanQueryNode)currentQuery).add(new FieldQueryNode(field, term, -1, -1));\n                } else {\n                  if (currentQuery != null) {\n                    if (this.defaultOperator == Operator.OR) {\n                      q.add(currentQuery);\n                    } else {\n                      q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n                    }\n                  }\n                  currentQuery = new FieldQueryNode(field, term, -1, -1);\n                }\n              }\n              if (this.defaultOperator == Operator.OR) {\n                q.add(currentQuery);\n              } else {\n                q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n              }\n              \n              if (q instanceof BooleanQueryNode) {\n                q = new GroupQueryNode(q);\n              }\n              return q;\n            }\n          } else {\n            // phrase query:\n            MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n  \n            List<FieldQueryNode> multiTerms = new ArrayList<>();\n            int position = -1;\n            int i = 0;\n            int termGroupCount = 0;\n            for (; i < numTokens; i++) {\n              String term = null;\n              int positionIncrement = 1;\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                term = termAtt.toString();\n                if (posIncrAtt != null) {\n                  positionIncrement = posIncrAtt.getPositionIncrement();\n                }\n  \n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n  \n              if (positionIncrement > 0 && multiTerms.size() > 0) {\n  \n                for (FieldQueryNode termNode : multiTerms) {\n  \n                  if (this.positionIncrementsEnabled) {\n                    termNode.setPositionIncrement(position);\n                  } else {\n                    termNode.setPositionIncrement(termGroupCount);\n                  }\n  \n                  mpq.add(termNode);\n  \n                }\n  \n                // Only increment once for each \"group\" of\n                // terms that were in the same position:\n                termGroupCount++;\n  \n                multiTerms.clear();\n  \n              }\n  \n              position += positionIncrement;\n              multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n  \n            }\n  \n            for (FieldQueryNode termNode : multiTerms) {\n  \n              if (this.positionIncrementsEnabled) {\n                termNode.setPositionIncrement(position);\n  \n              } else {\n                termNode.setPositionIncrement(termGroupCount);\n              }\n  \n              mpq.add(termNode);\n  \n            }\n  \n            return mpq;\n  \n          }\n  \n        } else {\n  \n          TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n  \n          int position = -1;\n  \n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n  \n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n  \n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n  \n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n  \n            FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n  \n            if (this.positionIncrementsEnabled) {\n              position += positionIncrement;\n              newFieldNode.setPositionIncrement(position);\n  \n            } else {\n              newFieldNode.setPositionIncrement(i);\n            }\n  \n            pq.add(newFieldNode);\n  \n          }\n  \n          return pq;\n  \n        }\n      } finally {\n        if (buffer != null) {\n          try {\n            buffer.close();\n          } catch (IOException e) {\n            // safe to ignore\n          }\n        }\n      }\n    }\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","sourceNew":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      CachingTokenFilter buffer = null;\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n      \n      try {\n        try (TokenStream source = this.analyzer.tokenStream(field, text)) {\n          buffer = new CachingTokenFilter(source);\n          buffer.reset();\n\n          if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n            posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n          }\n  \n          try {\n  \n            while (buffer.incrementToken()) {\n              numTokens++;\n              int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n                  .getPositionIncrement() : 1;\n              if (positionIncrement != 0) {\n                positionCount += positionIncrement;\n  \n              } else {\n                severalTokensAtSamePosition = true;\n              }\n  \n            }\n  \n          } catch (IOException e) {\n            // ignore\n          }\n\n          // rewind the buffer stream\n          buffer.reset();//will never through on subsequent reset calls\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        if (!buffer.hasAttribute(CharTermAttribute.class)) {\n          return new NoTokenFoundQueryNode();\n        }\n  \n        CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n  \n        if (numTokens == 0) {\n          return new NoTokenFoundQueryNode();\n  \n        } else if (numTokens == 1) {\n          String term = null;\n          try {\n            boolean hasNext;\n            hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n  \n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n  \n          fieldNode.setText(term);\n  \n          return fieldNode;\n  \n        } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n          if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n            // no phrase query:\n            \n            if (positionCount == 1) {\n              // simple case: only one position, with synonyms\n              LinkedList<QueryNode> children = new LinkedList<>();\n              \n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                  \n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                \n                children.add(new FieldQueryNode(field, term, -1, -1));\n                \n              }\n              return new GroupQueryNode(\n                  new SynonymQueryNode(children));\n            } else {\n              // multiple positions\n              QueryNode q = new BooleanQueryNode(Collections.<QueryNode>emptyList());\n              QueryNode currentQuery = null;\n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                  if (!(currentQuery instanceof BooleanQueryNode)) {\n                    QueryNode t = currentQuery;\n                    currentQuery = new SynonymQueryNode(Collections.<QueryNode>emptyList());\n                    ((BooleanQueryNode)currentQuery).add(t);\n                  }\n                  ((BooleanQueryNode)currentQuery).add(new FieldQueryNode(field, term, -1, -1));\n                } else {\n                  if (currentQuery != null) {\n                    if (this.defaultOperator == Operator.OR) {\n                      q.add(currentQuery);\n                    } else {\n                      q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n                    }\n                  }\n                  currentQuery = new FieldQueryNode(field, term, -1, -1);\n                }\n              }\n              if (this.defaultOperator == Operator.OR) {\n                q.add(currentQuery);\n              } else {\n                q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n              }\n              \n              if (q instanceof BooleanQueryNode) {\n                q = new GroupQueryNode(q);\n              }\n              return q;\n            }\n          } else {\n            // phrase query:\n            MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n  \n            List<FieldQueryNode> multiTerms = new ArrayList<>();\n            int position = -1;\n            int i = 0;\n            int termGroupCount = 0;\n            for (; i < numTokens; i++) {\n              String term = null;\n              int positionIncrement = 1;\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                term = termAtt.toString();\n                if (posIncrAtt != null) {\n                  positionIncrement = posIncrAtt.getPositionIncrement();\n                }\n  \n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n  \n              if (positionIncrement > 0 && multiTerms.size() > 0) {\n  \n                for (FieldQueryNode termNode : multiTerms) {\n  \n                  if (this.positionIncrementsEnabled) {\n                    termNode.setPositionIncrement(position);\n                  } else {\n                    termNode.setPositionIncrement(termGroupCount);\n                  }\n  \n                  mpq.add(termNode);\n  \n                }\n  \n                // Only increment once for each \"group\" of\n                // terms that were in the same position:\n                termGroupCount++;\n  \n                multiTerms.clear();\n  \n              }\n  \n              position += positionIncrement;\n              multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n  \n            }\n  \n            for (FieldQueryNode termNode : multiTerms) {\n  \n              if (this.positionIncrementsEnabled) {\n                termNode.setPositionIncrement(position);\n  \n              } else {\n                termNode.setPositionIncrement(termGroupCount);\n              }\n  \n              mpq.add(termNode);\n  \n            }\n  \n            return mpq;\n  \n          }\n  \n        } else {\n  \n          TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n  \n          int position = -1;\n  \n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n  \n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n  \n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n  \n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n  \n            FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n  \n            if (this.positionIncrementsEnabled) {\n              position += positionIncrement;\n              newFieldNode.setPositionIncrement(position);\n  \n            } else {\n              newFieldNode.setPositionIncrement(i);\n            }\n  \n            pq.add(newFieldNode);\n  \n          }\n  \n          return pq;\n  \n        }\n      } finally {\n        if (buffer != null) {\n          try {\n            buffer.close();\n          } catch (IOException e) {\n            // safe to ignore\n          }\n        }\n      }\n    }\n\n    return node;\n  }\n\n","sourceOld":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      CachingTokenFilter buffer = null;\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n      \n      try {\n        try (TokenStream source = this.analyzer.tokenStream(field, text)) {\n          buffer = new CachingTokenFilter(source);\n          buffer.reset();\n\n          if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n            posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n          }\n  \n          try {\n  \n            while (buffer.incrementToken()) {\n              numTokens++;\n              int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n                  .getPositionIncrement() : 1;\n              if (positionIncrement != 0) {\n                positionCount += positionIncrement;\n  \n              } else {\n                severalTokensAtSamePosition = true;\n              }\n  \n            }\n  \n          } catch (IOException e) {\n            // ignore\n          }\n\n          // rewind the buffer stream\n          buffer.reset();//will never through on subsequent reset calls\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        if (!buffer.hasAttribute(CharTermAttribute.class)) {\n          return new NoTokenFoundQueryNode();\n        }\n  \n        CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n  \n        if (numTokens == 0) {\n          return new NoTokenFoundQueryNode();\n  \n        } else if (numTokens == 1) {\n          String term = null;\n          try {\n            boolean hasNext;\n            hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n  \n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n  \n          fieldNode.setText(term);\n  \n          return fieldNode;\n  \n        } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n          if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n            // no phrase query:\n            \n            if (positionCount == 1) {\n              // simple case: only one position, with synonyms\n              LinkedList<QueryNode> children = new LinkedList<>();\n              \n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                  \n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                \n                children.add(new FieldQueryNode(field, term, -1, -1));\n                \n              }\n              return new GroupQueryNode(\n                  new StandardBooleanQueryNode(children, positionCount==1));\n            } else {\n              // multiple positions\n              QueryNode q = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(),false);\n              QueryNode currentQuery = null;\n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                  if (!(currentQuery instanceof BooleanQueryNode)) {\n                    QueryNode t = currentQuery;\n                    currentQuery = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(), true);\n                    ((BooleanQueryNode)currentQuery).add(t);\n                  }\n                  ((BooleanQueryNode)currentQuery).add(new FieldQueryNode(field, term, -1, -1));\n                } else {\n                  if (currentQuery != null) {\n                    if (this.defaultOperator == Operator.OR) {\n                      q.add(currentQuery);\n                    } else {\n                      q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n                    }\n                  }\n                  currentQuery = new FieldQueryNode(field, term, -1, -1);\n                }\n              }\n              if (this.defaultOperator == Operator.OR) {\n                q.add(currentQuery);\n              } else {\n                q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n              }\n              \n              if (q instanceof BooleanQueryNode) {\n                q = new GroupQueryNode(q);\n              }\n              return q;\n            }\n          } else {\n            // phrase query:\n            MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n  \n            List<FieldQueryNode> multiTerms = new ArrayList<>();\n            int position = -1;\n            int i = 0;\n            int termGroupCount = 0;\n            for (; i < numTokens; i++) {\n              String term = null;\n              int positionIncrement = 1;\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                term = termAtt.toString();\n                if (posIncrAtt != null) {\n                  positionIncrement = posIncrAtt.getPositionIncrement();\n                }\n  \n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n  \n              if (positionIncrement > 0 && multiTerms.size() > 0) {\n  \n                for (FieldQueryNode termNode : multiTerms) {\n  \n                  if (this.positionIncrementsEnabled) {\n                    termNode.setPositionIncrement(position);\n                  } else {\n                    termNode.setPositionIncrement(termGroupCount);\n                  }\n  \n                  mpq.add(termNode);\n  \n                }\n  \n                // Only increment once for each \"group\" of\n                // terms that were in the same position:\n                termGroupCount++;\n  \n                multiTerms.clear();\n  \n              }\n  \n              position += positionIncrement;\n              multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n  \n            }\n  \n            for (FieldQueryNode termNode : multiTerms) {\n  \n              if (this.positionIncrementsEnabled) {\n                termNode.setPositionIncrement(position);\n  \n              } else {\n                termNode.setPositionIncrement(termGroupCount);\n              }\n  \n              mpq.add(termNode);\n  \n            }\n  \n            return mpq;\n  \n          }\n  \n        } else {\n  \n          TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n  \n          int position = -1;\n  \n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n  \n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n  \n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n  \n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n  \n            FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n  \n            if (this.positionIncrementsEnabled) {\n              position += positionIncrement;\n              newFieldNode.setPositionIncrement(position);\n  \n            } else {\n              newFieldNode.setPositionIncrement(i);\n            }\n  \n            pq.add(newFieldNode);\n  \n          }\n  \n          return pq;\n  \n        }\n      } finally {\n        if (buffer != null) {\n          try {\n            buffer.close();\n          } catch (IOException e) {\n            // safe to ignore\n          }\n        }\n      }\n    }\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor#postProcessNode(QueryNode).mjava","sourceNew":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      CachingTokenFilter buffer = null;\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n      \n      try {\n        try (TokenStream source = this.analyzer.tokenStream(field, text)) {\n          buffer = new CachingTokenFilter(source);\n          buffer.reset();\n\n          if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n            posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n          }\n  \n          try {\n  \n            while (buffer.incrementToken()) {\n              numTokens++;\n              int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n                  .getPositionIncrement() : 1;\n              if (positionIncrement != 0) {\n                positionCount += positionIncrement;\n  \n              } else {\n                severalTokensAtSamePosition = true;\n              }\n  \n            }\n  \n          } catch (IOException e) {\n            // ignore\n          }\n\n          // rewind the buffer stream\n          buffer.reset();//will never through on subsequent reset calls\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        if (!buffer.hasAttribute(CharTermAttribute.class)) {\n          return new NoTokenFoundQueryNode();\n        }\n  \n        CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n  \n        if (numTokens == 0) {\n          return new NoTokenFoundQueryNode();\n  \n        } else if (numTokens == 1) {\n          String term = null;\n          try {\n            boolean hasNext;\n            hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n  \n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n  \n          fieldNode.setText(term);\n  \n          return fieldNode;\n  \n        } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n          if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n            // no phrase query:\n            \n            if (positionCount == 1) {\n              // simple case: only one position, with synonyms\n              LinkedList<QueryNode> children = new LinkedList<>();\n              \n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                  \n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                \n                children.add(new FieldQueryNode(field, term, -1, -1));\n                \n              }\n              return new GroupQueryNode(\n                  new SynonymQueryNode(children));\n            } else {\n              // multiple positions\n              QueryNode q = new BooleanQueryNode(Collections.<QueryNode>emptyList());\n              QueryNode currentQuery = null;\n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                  if (!(currentQuery instanceof BooleanQueryNode)) {\n                    QueryNode t = currentQuery;\n                    currentQuery = new SynonymQueryNode(Collections.<QueryNode>emptyList());\n                    ((BooleanQueryNode)currentQuery).add(t);\n                  }\n                  ((BooleanQueryNode)currentQuery).add(new FieldQueryNode(field, term, -1, -1));\n                } else {\n                  if (currentQuery != null) {\n                    if (this.defaultOperator == Operator.OR) {\n                      q.add(currentQuery);\n                    } else {\n                      q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n                    }\n                  }\n                  currentQuery = new FieldQueryNode(field, term, -1, -1);\n                }\n              }\n              if (this.defaultOperator == Operator.OR) {\n                q.add(currentQuery);\n              } else {\n                q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n              }\n              \n              if (q instanceof BooleanQueryNode) {\n                q = new GroupQueryNode(q);\n              }\n              return q;\n            }\n          } else {\n            // phrase query:\n            MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n  \n            List<FieldQueryNode> multiTerms = new ArrayList<>();\n            int position = -1;\n            int i = 0;\n            int termGroupCount = 0;\n            for (; i < numTokens; i++) {\n              String term = null;\n              int positionIncrement = 1;\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                term = termAtt.toString();\n                if (posIncrAtt != null) {\n                  positionIncrement = posIncrAtt.getPositionIncrement();\n                }\n  \n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n  \n              if (positionIncrement > 0 && multiTerms.size() > 0) {\n  \n                for (FieldQueryNode termNode : multiTerms) {\n  \n                  if (this.positionIncrementsEnabled) {\n                    termNode.setPositionIncrement(position);\n                  } else {\n                    termNode.setPositionIncrement(termGroupCount);\n                  }\n  \n                  mpq.add(termNode);\n  \n                }\n  \n                // Only increment once for each \"group\" of\n                // terms that were in the same position:\n                termGroupCount++;\n  \n                multiTerms.clear();\n  \n              }\n  \n              position += positionIncrement;\n              multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n  \n            }\n  \n            for (FieldQueryNode termNode : multiTerms) {\n  \n              if (this.positionIncrementsEnabled) {\n                termNode.setPositionIncrement(position);\n  \n              } else {\n                termNode.setPositionIncrement(termGroupCount);\n              }\n  \n              mpq.add(termNode);\n  \n            }\n  \n            return mpq;\n  \n          }\n  \n        } else {\n  \n          TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n  \n          int position = -1;\n  \n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n  \n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n  \n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n  \n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n  \n            FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n  \n            if (this.positionIncrementsEnabled) {\n              position += positionIncrement;\n              newFieldNode.setPositionIncrement(position);\n  \n            } else {\n              newFieldNode.setPositionIncrement(i);\n            }\n  \n            pq.add(newFieldNode);\n  \n          }\n  \n          return pq;\n  \n        }\n      } finally {\n        if (buffer != null) {\n          try {\n            buffer.close();\n          } catch (IOException e) {\n            // safe to ignore\n          }\n        }\n      }\n    }\n\n    return node;\n  }\n\n","sourceOld":"  @Override\n  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {\n\n    if (node instanceof TextableQueryNode\n        && !(node instanceof WildcardQueryNode)\n        && !(node instanceof FuzzyQueryNode)\n        && !(node instanceof RegexpQueryNode)\n        && !(node.getParent() instanceof RangeQueryNode)) {\n\n      FieldQueryNode fieldNode = ((FieldQueryNode) node);\n      String text = fieldNode.getTextAsString();\n      String field = fieldNode.getFieldAsString();\n\n      CachingTokenFilter buffer = null;\n      PositionIncrementAttribute posIncrAtt = null;\n      int numTokens = 0;\n      int positionCount = 0;\n      boolean severalTokensAtSamePosition = false;\n      \n      try {\n        try (TokenStream source = this.analyzer.tokenStream(field, text)) {\n          buffer = new CachingTokenFilter(source);\n          buffer.reset();\n\n          if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n            posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n          }\n  \n          try {\n  \n            while (buffer.incrementToken()) {\n              numTokens++;\n              int positionIncrement = (posIncrAtt != null) ? posIncrAtt\n                  .getPositionIncrement() : 1;\n              if (positionIncrement != 0) {\n                positionCount += positionIncrement;\n  \n              } else {\n                severalTokensAtSamePosition = true;\n              }\n  \n            }\n  \n          } catch (IOException e) {\n            // ignore\n          }\n\n          // rewind the buffer stream\n          buffer.reset();//will never through on subsequent reset calls\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        if (!buffer.hasAttribute(CharTermAttribute.class)) {\n          return new NoTokenFoundQueryNode();\n        }\n  \n        CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);\n  \n        if (numTokens == 0) {\n          return new NoTokenFoundQueryNode();\n  \n        } else if (numTokens == 1) {\n          String term = null;\n          try {\n            boolean hasNext;\n            hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.toString();\n  \n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n  \n          fieldNode.setText(term);\n  \n          return fieldNode;\n  \n        } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {\n          if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {\n            // no phrase query:\n            \n            if (positionCount == 1) {\n              // simple case: only one position, with synonyms\n              LinkedList<QueryNode> children = new LinkedList<>();\n              \n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                  \n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                \n                children.add(new FieldQueryNode(field, term, -1, -1));\n                \n              }\n              return new GroupQueryNode(\n                  new StandardBooleanQueryNode(children, positionCount==1));\n            } else {\n              // multiple positions\n              QueryNode q = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(),false);\n              QueryNode currentQuery = null;\n              for (int i = 0; i < numTokens; i++) {\n                String term = null;\n                try {\n                  boolean hasNext = buffer.incrementToken();\n                  assert hasNext == true;\n                  term = termAtt.toString();\n                } catch (IOException e) {\n                  // safe to ignore, because we know the number of tokens\n                }\n                if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {\n                  if (!(currentQuery instanceof BooleanQueryNode)) {\n                    QueryNode t = currentQuery;\n                    currentQuery = new StandardBooleanQueryNode(Collections.<QueryNode>emptyList(), true);\n                    ((BooleanQueryNode)currentQuery).add(t);\n                  }\n                  ((BooleanQueryNode)currentQuery).add(new FieldQueryNode(field, term, -1, -1));\n                } else {\n                  if (currentQuery != null) {\n                    if (this.defaultOperator == Operator.OR) {\n                      q.add(currentQuery);\n                    } else {\n                      q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n                    }\n                  }\n                  currentQuery = new FieldQueryNode(field, term, -1, -1);\n                }\n              }\n              if (this.defaultOperator == Operator.OR) {\n                q.add(currentQuery);\n              } else {\n                q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));\n              }\n              \n              if (q instanceof BooleanQueryNode) {\n                q = new GroupQueryNode(q);\n              }\n              return q;\n            }\n          } else {\n            // phrase query:\n            MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();\n  \n            List<FieldQueryNode> multiTerms = new ArrayList<>();\n            int position = -1;\n            int i = 0;\n            int termGroupCount = 0;\n            for (; i < numTokens; i++) {\n              String term = null;\n              int positionIncrement = 1;\n              try {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                term = termAtt.toString();\n                if (posIncrAtt != null) {\n                  positionIncrement = posIncrAtt.getPositionIncrement();\n                }\n  \n              } catch (IOException e) {\n                // safe to ignore, because we know the number of tokens\n              }\n  \n              if (positionIncrement > 0 && multiTerms.size() > 0) {\n  \n                for (FieldQueryNode termNode : multiTerms) {\n  \n                  if (this.positionIncrementsEnabled) {\n                    termNode.setPositionIncrement(position);\n                  } else {\n                    termNode.setPositionIncrement(termGroupCount);\n                  }\n  \n                  mpq.add(termNode);\n  \n                }\n  \n                // Only increment once for each \"group\" of\n                // terms that were in the same position:\n                termGroupCount++;\n  \n                multiTerms.clear();\n  \n              }\n  \n              position += positionIncrement;\n              multiTerms.add(new FieldQueryNode(field, term, -1, -1));\n  \n            }\n  \n            for (FieldQueryNode termNode : multiTerms) {\n  \n              if (this.positionIncrementsEnabled) {\n                termNode.setPositionIncrement(position);\n  \n              } else {\n                termNode.setPositionIncrement(termGroupCount);\n              }\n  \n              mpq.add(termNode);\n  \n            }\n  \n            return mpq;\n  \n          }\n  \n        } else {\n  \n          TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();\n  \n          int position = -1;\n  \n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n  \n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.toString();\n  \n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n  \n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n  \n            FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);\n  \n            if (this.positionIncrementsEnabled) {\n              position += positionIncrement;\n              newFieldNode.setPositionIncrement(position);\n  \n            } else {\n              newFieldNode.setPositionIncrement(i);\n            }\n  \n            pq.add(newFieldNode);\n  \n          }\n  \n          return pq;\n  \n        }\n      } finally {\n        if (buffer != null) {\n          try {\n            buffer.close();\n          } catch (IOException e) {\n            // safe to ignore\n          }\n        }\n      }\n    }\n\n    return node;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["caaf8f27a34037f65ab81e92835f18a303d8d2f1"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["cb09d349a44ec933e41f1cfa536d5efb2c207752","c83d6c4335f31cae14f625a222bc842f20073dcd"],"c83d6c4335f31cae14f625a222bc842f20073dcd":["cb09d349a44ec933e41f1cfa536d5efb2c207752"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cb09d349a44ec933e41f1cfa536d5efb2c207752":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"c8a0e442f7b61f811680273b25da95994a724466":["55244759f906151d96839f8451dee793acb06e75"],"782ed6a4b4ba50ec19734fc8db4e570ee193d627":["c83d6c4335f31cae14f625a222bc842f20073dcd"],"55244759f906151d96839f8451dee793acb06e75":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"caaf8f27a34037f65ab81e92835f18a303d8d2f1":["782ed6a4b4ba50ec19734fc8db4e570ee193d627"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["55244759f906151d96839f8451dee793acb06e75","c8a0e442f7b61f811680273b25da95994a724466"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c8a0e442f7b61f811680273b25da95994a724466"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["55244759f906151d96839f8451dee793acb06e75"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cb09d349a44ec933e41f1cfa536d5efb2c207752"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"c83d6c4335f31cae14f625a222bc842f20073dcd":["37a0f60745e53927c4c876cfe5b5a58170f0646c","782ed6a4b4ba50ec19734fc8db4e570ee193d627"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cb09d349a44ec933e41f1cfa536d5efb2c207752":["37a0f60745e53927c4c876cfe5b5a58170f0646c","c83d6c4335f31cae14f625a222bc842f20073dcd"],"c8a0e442f7b61f811680273b25da95994a724466":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"782ed6a4b4ba50ec19734fc8db4e570ee193d627":["caaf8f27a34037f65ab81e92835f18a303d8d2f1"],"55244759f906151d96839f8451dee793acb06e75":["c8a0e442f7b61f811680273b25da95994a724466","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"caaf8f27a34037f65ab81e92835f18a303d8d2f1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}