{"path":"lucene/test-framework/src/java/org/apache/lucene/index/BaseDocValuesFormatTestCase#testVariouslyCompressibleBinaryValues().mjava","commits":[{"id":"5fcfc028fca127dc2779630e53a9c2ec208ee7a0","date":1582034562,"type":0,"author":"markharwood","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseDocValuesFormatTestCase#testVariouslyCompressibleBinaryValues().mjava","pathOld":"/dev/null","sourceNew":"  public void testVariouslyCompressibleBinaryValues() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter iwriter = new RandomIndexWriter(random(), directory);\n    int numDocs = 1 + random().nextInt(100);\n\n    HashMap<Integer,BytesRef> writtenValues = new HashMap<>(numDocs);\n    \n    // Small vocabulary ranges will be highly compressible \n    int vocabRange = random().nextInt(Byte.MAX_VALUE);\n\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      \n      // Generate random-sized byte array with random choice of bytes in vocab range\n      byte[] value = new byte[500 + random().nextInt(1024)];\n      for (int j = 0; j < value.length; j++) {\n        value[j] = (byte) random().nextInt(vocabRange);\n      }\n      BytesRef bytesRef = new BytesRef(value);\n      writtenValues.put(i, bytesRef);\n      doc.add(newTextField(\"id\", Integer.toString(i), Field.Store.YES));\n      doc.add(new BinaryDocValuesField(\"dv1\", bytesRef));\n      iwriter.addDocument(doc);\n    }\n    iwriter.forceMerge(1);\n    iwriter.close();\n\n    // Now search the index:\n    IndexReader ireader = DirectoryReader.open(directory); // read-only=true\n    IndexSearcher isearcher = new IndexSearcher(ireader);\n\n    for (int i = 0; i < numDocs; i++) {\n      String id = Integer.toString(i);\n      Query query = new TermQuery(new Term(\"id\", id));\n      TopDocs hits = isearcher.search(query, 1);\n      assertEquals(1, hits.totalHits.value);\n      // Iterate through the results:\n      int hitDocID = hits.scoreDocs[0].doc;\n      Document hitDoc = isearcher.doc(hitDocID);\n      assertEquals(id, hitDoc.get(\"id\"));\n      assert ireader.leaves().size() == 1;\n      BinaryDocValues dv = ireader.leaves().get(0).reader().getBinaryDocValues(\"dv1\");\n      assertEquals(hitDocID, dv.advance(hitDocID));\n      BytesRef scratch = dv.binaryValue();\n      assertEquals(writtenValues.get(i), scratch);\n    }\n\n    ireader.close();\n    directory.close();\n  }  \n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22eee05930ccf0c0b77dac380d4a0cbb73e60158","date":1582103654,"type":3,"author":"markharwood","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseDocValuesFormatTestCase#testVariouslyCompressibleBinaryValues().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseDocValuesFormatTestCase#testVariouslyCompressibleBinaryValues().mjava","sourceNew":"  public void testVariouslyCompressibleBinaryValues() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter iwriter = new RandomIndexWriter(random(), directory);\n    int numDocs = 1 + random().nextInt(100);\n\n    HashMap<Integer,BytesRef> writtenValues = new HashMap<>(numDocs);\n    \n    // Small vocabulary ranges will be highly compressible \n    int vocabRange = 1 + random().nextInt(Byte.MAX_VALUE - 1);\n\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      \n      // Generate random-sized byte array with random choice of bytes in vocab range\n      byte[] value = new byte[500 + random().nextInt(1024)];\n      for (int j = 0; j < value.length; j++) {\n        value[j] = (byte) random().nextInt(vocabRange);\n      }\n      BytesRef bytesRef = new BytesRef(value);\n      writtenValues.put(i, bytesRef);\n      doc.add(newTextField(\"id\", Integer.toString(i), Field.Store.YES));\n      doc.add(new BinaryDocValuesField(\"dv1\", bytesRef));\n      iwriter.addDocument(doc);\n    }\n    iwriter.forceMerge(1);\n    iwriter.close();\n\n    // Now search the index:\n    IndexReader ireader = DirectoryReader.open(directory); // read-only=true\n    IndexSearcher isearcher = new IndexSearcher(ireader);\n\n    for (int i = 0; i < numDocs; i++) {\n      String id = Integer.toString(i);\n      Query query = new TermQuery(new Term(\"id\", id));\n      TopDocs hits = isearcher.search(query, 1);\n      assertEquals(1, hits.totalHits.value);\n      // Iterate through the results:\n      int hitDocID = hits.scoreDocs[0].doc;\n      Document hitDoc = isearcher.doc(hitDocID);\n      assertEquals(id, hitDoc.get(\"id\"));\n      assert ireader.leaves().size() == 1;\n      BinaryDocValues dv = ireader.leaves().get(0).reader().getBinaryDocValues(\"dv1\");\n      assertEquals(hitDocID, dv.advance(hitDocID));\n      BytesRef scratch = dv.binaryValue();\n      assertEquals(writtenValues.get(i), scratch);\n    }\n\n    ireader.close();\n    directory.close();\n  }  \n\n","sourceOld":"  public void testVariouslyCompressibleBinaryValues() throws IOException {\n    Directory directory = newDirectory();\n    RandomIndexWriter iwriter = new RandomIndexWriter(random(), directory);\n    int numDocs = 1 + random().nextInt(100);\n\n    HashMap<Integer,BytesRef> writtenValues = new HashMap<>(numDocs);\n    \n    // Small vocabulary ranges will be highly compressible \n    int vocabRange = random().nextInt(Byte.MAX_VALUE);\n\n    for (int i = 0; i < numDocs; i++) {\n      Document doc = new Document();\n      \n      // Generate random-sized byte array with random choice of bytes in vocab range\n      byte[] value = new byte[500 + random().nextInt(1024)];\n      for (int j = 0; j < value.length; j++) {\n        value[j] = (byte) random().nextInt(vocabRange);\n      }\n      BytesRef bytesRef = new BytesRef(value);\n      writtenValues.put(i, bytesRef);\n      doc.add(newTextField(\"id\", Integer.toString(i), Field.Store.YES));\n      doc.add(new BinaryDocValuesField(\"dv1\", bytesRef));\n      iwriter.addDocument(doc);\n    }\n    iwriter.forceMerge(1);\n    iwriter.close();\n\n    // Now search the index:\n    IndexReader ireader = DirectoryReader.open(directory); // read-only=true\n    IndexSearcher isearcher = new IndexSearcher(ireader);\n\n    for (int i = 0; i < numDocs; i++) {\n      String id = Integer.toString(i);\n      Query query = new TermQuery(new Term(\"id\", id));\n      TopDocs hits = isearcher.search(query, 1);\n      assertEquals(1, hits.totalHits.value);\n      // Iterate through the results:\n      int hitDocID = hits.scoreDocs[0].doc;\n      Document hitDoc = isearcher.doc(hitDocID);\n      assertEquals(id, hitDoc.get(\"id\"));\n      assert ireader.leaves().size() == 1;\n      BinaryDocValues dv = ireader.leaves().get(0).reader().getBinaryDocValues(\"dv1\");\n      assertEquals(hitDocID, dv.advance(hitDocID));\n      BytesRef scratch = dv.binaryValue();\n      assertEquals(writtenValues.get(i), scratch);\n    }\n\n    ireader.close();\n    directory.close();\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"22eee05930ccf0c0b77dac380d4a0cbb73e60158":["5fcfc028fca127dc2779630e53a9c2ec208ee7a0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5fcfc028fca127dc2779630e53a9c2ec208ee7a0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["22eee05930ccf0c0b77dac380d4a0cbb73e60158"]},"commit2Childs":{"22eee05930ccf0c0b77dac380d4a0cbb73e60158":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5fcfc028fca127dc2779630e53a9c2ec208ee7a0"],"5fcfc028fca127dc2779630e53a9c2ec208ee7a0":["22eee05930ccf0c0b77dac380d4a0cbb73e60158"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}