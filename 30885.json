{"path":"lucene/src/java/org/apache/lucene/store/FSDirectory.FSIndexOutput#copyBytes(DataInput,long).mjava","commits":[{"id":"462dfb1d8690f192817503773f5b8b94a702246a","date":1280128992,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/FSDirectory.FSIndexOutput#copyBytes(DataInput,long).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void copyBytes(DataInput input, long numBytes) throws IOException {\n      // Optimized copy only if the number of bytes to copy is larger than the\n      // buffer size, and the given IndexInput supports FileChannel copying ..\n      // NOTE: the below check relies on NIOIndexInput extending Simple. If that\n      // changes in the future, we should change the check as well.\n      if (numBytes > BUFFER_SIZE && input instanceof SimpleFSIndexInput) {\n        // flush any bytes in the buffer\n        flush();\n        // do the optimized copy\n        FileChannel in = ((SimpleFSIndexInput) input).file.getChannel();\n        FileChannel out = file.getChannel();\n        copy(in, out, numBytes);\n        // corrects the position in super (BufferedIndexOutput), so that calls\n        // to getFilePointer will return the correct pointer.\n        // Perhaps a specific method is better?\n        super.seek(out.position());\n      } else {\n        super.copyBytes(input, numBytes);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/store/FSDirectory.FSIndexOutput#copyBytes(DataInput,long).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void copyBytes(DataInput input, long numBytes) throws IOException {\n      // Optimized copy only if the number of bytes to copy is larger than the\n      // buffer size, and the given IndexInput supports FileChannel copying ..\n      // NOTE: the below check relies on NIOIndexInput extending Simple. If that\n      // changes in the future, we should change the check as well.\n      if (numBytes > BUFFER_SIZE && input instanceof SimpleFSIndexInput) {\n        // flush any bytes in the buffer\n        flush();\n        // do the optimized copy\n        FileChannel in = ((SimpleFSIndexInput) input).file.getChannel();\n        FileChannel out = file.getChannel();\n        copy(in, out, numBytes);\n        // corrects the position in super (BufferedIndexOutput), so that calls\n        // to getFilePointer will return the correct pointer.\n        // Perhaps a specific method is better?\n        super.seek(out.position());\n      } else {\n        super.copyBytes(input, numBytes);\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d05b801583d7568b68b06c67b22136d2a3b3e3bb","date":1280470393,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/FSDirectory.FSIndexOutput#copyBytes(DataInput,long).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/FSDirectory.FSIndexOutput#copyBytes(DataInput,long).mjava","sourceNew":"    @Override\n    public void copyBytes(DataInput input, long numBytes) throws IOException {\n      // Optimized copy only if the number of bytes to copy is larger than the\n      // buffer size, and the given IndexInput supports FileChannel copying.\n      // NOTE: the below check relies on NIOIndexInput extending Simple. If that\n      // changes in the future, we should change the check as well.\n      if (numBytes <= BUFFER_SIZE || !(input instanceof SimpleFSIndexInput)) {\n        super.copyBytes(input, numBytes);\n        return;\n      }\n\n      SimpleFSIndexInput fsInput = (SimpleFSIndexInput) input;\n\n      // flush any bytes in the buffer\n      flush();\n      \n      // flush any bytes in the input's buffer.\n      numBytes -= fsInput.flushBuffer(this, numBytes);\n      \n      // do the optimized copy\n      FileChannel in = fsInput.file.getChannel();\n      FileChannel out = file.getChannel();\n      long pos = out.position();\n      long writeTo = numBytes + pos;\n      while (pos < writeTo) {\n        pos += out.transferFrom(in, pos, Math.min(CHANNEL_CHUNK_SIZE, writeTo - pos));\n      }\n      // transferFrom does not change the position of the channel. Need to change it manually\n      out.position(pos);\n      \n      // corrects the position in super (BufferedIndexOutput), so that calls\n      // to getFilePointer will return the correct pointer.\n      // Perhaps a specific method is better?\n      super.seek(out.position());\n    }\n\n","sourceOld":"    @Override\n    public void copyBytes(DataInput input, long numBytes) throws IOException {\n      // Optimized copy only if the number of bytes to copy is larger than the\n      // buffer size, and the given IndexInput supports FileChannel copying ..\n      // NOTE: the below check relies on NIOIndexInput extending Simple. If that\n      // changes in the future, we should change the check as well.\n      if (numBytes > BUFFER_SIZE && input instanceof SimpleFSIndexInput) {\n        // flush any bytes in the buffer\n        flush();\n        // do the optimized copy\n        FileChannel in = ((SimpleFSIndexInput) input).file.getChannel();\n        FileChannel out = file.getChannel();\n        copy(in, out, numBytes);\n        // corrects the position in super (BufferedIndexOutput), so that calls\n        // to getFilePointer will return the correct pointer.\n        // Perhaps a specific method is better?\n        super.seek(out.position());\n      } else {\n        super.copyBytes(input, numBytes);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc59f76ab05132dcb816d613956c236017659fbe","date":1280776850,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/FSDirectory.FSIndexOutput#copyBytes(DataInput,long).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/FSDirectory.FSIndexOutput#copyBytes(DataInput,long).mjava","sourceNew":"    @Override\n    public void copyBytes(DataInput input, long numBytes) throws IOException {\n      // Optimized copy only if the number of bytes to copy is larger than the\n      // buffer size, and the given IndexInput supports FileChannel copying.\n      // NOTE: the below check relies on NIOIndexInput extending Simple. If that\n      // changes in the future, we should change the check as well.\n      if (numBytes <= BUFFER_SIZE || !(input instanceof SimpleFSIndexInput)) {\n        super.copyBytes(input, numBytes);\n        return;\n      }\n\n      SimpleFSIndexInput fsInput = (SimpleFSIndexInput) input;\n\n      // flush any bytes in the buffer\n      flush();\n      \n      // flush any bytes in the input's buffer.\n      numBytes -= fsInput.flushBuffer(this, numBytes);\n      \n      // do the optimized copy\n      FileChannel in = fsInput.file.getChannel();\n\n      // Necessary because BufferedIndexInput does lazy seeking:\n      in.position(fsInput.getFilePointer());\n\n      FileChannel out = file.getChannel();\n      long pos = out.position();\n      long writeTo = numBytes + pos;\n      while (pos < writeTo) {\n        pos += out.transferFrom(in, pos, Math.min(CHANNEL_CHUNK_SIZE, writeTo - pos));\n      }\n      // transferFrom does not change the position of the channel. Need to change it manually\n      out.position(pos);\n      \n      // corrects the position in super (BufferedIndexOutput), so that calls\n      // to getFilePointer will return the correct pointer.\n      // Perhaps a specific method is better?\n      super.seek(out.position());\n    }\n\n","sourceOld":"    @Override\n    public void copyBytes(DataInput input, long numBytes) throws IOException {\n      // Optimized copy only if the number of bytes to copy is larger than the\n      // buffer size, and the given IndexInput supports FileChannel copying.\n      // NOTE: the below check relies on NIOIndexInput extending Simple. If that\n      // changes in the future, we should change the check as well.\n      if (numBytes <= BUFFER_SIZE || !(input instanceof SimpleFSIndexInput)) {\n        super.copyBytes(input, numBytes);\n        return;\n      }\n\n      SimpleFSIndexInput fsInput = (SimpleFSIndexInput) input;\n\n      // flush any bytes in the buffer\n      flush();\n      \n      // flush any bytes in the input's buffer.\n      numBytes -= fsInput.flushBuffer(this, numBytes);\n      \n      // do the optimized copy\n      FileChannel in = fsInput.file.getChannel();\n      FileChannel out = file.getChannel();\n      long pos = out.position();\n      long writeTo = numBytes + pos;\n      while (pos < writeTo) {\n        pos += out.transferFrom(in, pos, Math.min(CHANNEL_CHUNK_SIZE, writeTo - pos));\n      }\n      // transferFrom does not change the position of the channel. Need to change it manually\n      out.position(pos);\n      \n      // corrects the position in super (BufferedIndexOutput), so that calls\n      // to getFilePointer will return the correct pointer.\n      // Perhaps a specific method is better?\n      super.seek(out.position());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90276262a0c6ca51695ab04d9a591d2c8eb0d7f4","date":1280840637,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/FSDirectory.FSIndexOutput#copyBytes(DataInput,long).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/FSDirectory.FSIndexOutput#copyBytes(DataInput,long).mjava","sourceNew":"    @Override\n    public void copyBytes(DataInput input, long numBytes) throws IOException {\n      // Optimized copy only if the number of bytes to copy is larger than the\n      // buffer size, and the given IndexInput supports FileChannel copying.\n      // NOTE: the below check relies on NIOIndexInput extending Simple. If that\n      // changes in the future, we should change the check as well.\n      if (true || numBytes <= BUFFER_SIZE || !(input instanceof SimpleFSIndexInput)) {\n        super.copyBytes(input, numBytes);\n        return;\n      }\n\n      SimpleFSIndexInput fsInput = (SimpleFSIndexInput) input;\n\n      // flush any bytes in the buffer\n      flush();\n      \n      // flush any bytes in the input's buffer.\n      numBytes -= fsInput.flushBuffer(this, numBytes);\n      \n      // do the optimized copy\n      FileChannel in = fsInput.file.getChannel();\n\n      // Necessary because BufferedIndexInput does lazy seeking:\n      in.position(fsInput.getFilePointer());\n\n      FileChannel out = file.getChannel();\n      long pos = out.position();\n      long writeTo = numBytes + pos;\n      while (pos < writeTo) {\n        pos += out.transferFrom(in, pos, Math.min(CHANNEL_CHUNK_SIZE, writeTo - pos));\n      }\n      // transferFrom does not change the position of the channel. Need to change it manually\n      out.position(pos);\n      \n      // corrects the position in super (BufferedIndexOutput), so that calls\n      // to getFilePointer will return the correct pointer.\n      // Perhaps a specific method is better?\n      super.seek(out.position());\n    }\n\n","sourceOld":"    @Override\n    public void copyBytes(DataInput input, long numBytes) throws IOException {\n      // Optimized copy only if the number of bytes to copy is larger than the\n      // buffer size, and the given IndexInput supports FileChannel copying.\n      // NOTE: the below check relies on NIOIndexInput extending Simple. If that\n      // changes in the future, we should change the check as well.\n      if (numBytes <= BUFFER_SIZE || !(input instanceof SimpleFSIndexInput)) {\n        super.copyBytes(input, numBytes);\n        return;\n      }\n\n      SimpleFSIndexInput fsInput = (SimpleFSIndexInput) input;\n\n      // flush any bytes in the buffer\n      flush();\n      \n      // flush any bytes in the input's buffer.\n      numBytes -= fsInput.flushBuffer(this, numBytes);\n      \n      // do the optimized copy\n      FileChannel in = fsInput.file.getChannel();\n\n      // Necessary because BufferedIndexInput does lazy seeking:\n      in.position(fsInput.getFilePointer());\n\n      FileChannel out = file.getChannel();\n      long pos = out.position();\n      long writeTo = numBytes + pos;\n      while (pos < writeTo) {\n        pos += out.transferFrom(in, pos, Math.min(CHANNEL_CHUNK_SIZE, writeTo - pos));\n      }\n      // transferFrom does not change the position of the channel. Need to change it manually\n      out.position(pos);\n      \n      // corrects the position in super (BufferedIndexOutput), so that calls\n      // to getFilePointer will return the correct pointer.\n      // Perhaps a specific method is better?\n      super.seek(out.position());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57d5dad190acf63cb17e05df3882de97b1105c1c","date":1280877729,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/FSDirectory.FSIndexOutput#copyBytes(DataInput,long).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/FSDirectory.FSIndexOutput#copyBytes(DataInput,long).mjava","sourceNew":"    @Override\n    public void copyBytes(DataInput input, long numBytes) throws IOException {\n      // Optimized copy only if the number of bytes to copy is larger than the\n      // buffer size, and the given IndexInput supports FileChannel copying.\n      // NOTE: the below check relies on NIOIndexInput extending Simple. If that\n      // changes in the future, we should change the check as well.\n      if (numBytes <= BUFFER_SIZE || !(input instanceof SimpleFSIndexInput)) {\n        super.copyBytes(input, numBytes);\n        return;\n      }\n\n      SimpleFSIndexInput fsInput = (SimpleFSIndexInput) input;\n\n      // flush any bytes in the input's buffer.\n      numBytes -= fsInput.flushBuffer(this, numBytes);\n      \n      // flush any bytes in the buffer\n      flush();\n      \n      // do the optimized copy\n      FileChannel in = fsInput.file.getChannel();\n\n      // Necessary because BufferedIndexInput does lazy seeking:\n      in.position(fsInput.getFilePointer());\n\n      FileChannel out = file.getChannel();\n      long pos = out.position();\n      long writeTo = numBytes + pos;\n      while (pos < writeTo) {\n        pos += out.transferFrom(in, pos, Math.min(CHANNEL_CHUNK_SIZE, writeTo - pos));\n      }\n      // transferFrom does not change the position of the channel. Need to change it manually\n      out.position(pos);\n      \n      // corrects the position in super (BufferedIndexOutput), so that calls\n      // to getFilePointer will return the correct pointer.\n      // Perhaps a specific method is better?\n      super.seek(out.position());\n    }\n\n","sourceOld":"    @Override\n    public void copyBytes(DataInput input, long numBytes) throws IOException {\n      // Optimized copy only if the number of bytes to copy is larger than the\n      // buffer size, and the given IndexInput supports FileChannel copying.\n      // NOTE: the below check relies on NIOIndexInput extending Simple. If that\n      // changes in the future, we should change the check as well.\n      if (true || numBytes <= BUFFER_SIZE || !(input instanceof SimpleFSIndexInput)) {\n        super.copyBytes(input, numBytes);\n        return;\n      }\n\n      SimpleFSIndexInput fsInput = (SimpleFSIndexInput) input;\n\n      // flush any bytes in the buffer\n      flush();\n      \n      // flush any bytes in the input's buffer.\n      numBytes -= fsInput.flushBuffer(this, numBytes);\n      \n      // do the optimized copy\n      FileChannel in = fsInput.file.getChannel();\n\n      // Necessary because BufferedIndexInput does lazy seeking:\n      in.position(fsInput.getFilePointer());\n\n      FileChannel out = file.getChannel();\n      long pos = out.position();\n      long writeTo = numBytes + pos;\n      while (pos < writeTo) {\n        pos += out.transferFrom(in, pos, Math.min(CHANNEL_CHUNK_SIZE, writeTo - pos));\n      }\n      // transferFrom does not change the position of the channel. Need to change it manually\n      out.position(pos);\n      \n      // corrects the position in super (BufferedIndexOutput), so that calls\n      // to getFilePointer will return the correct pointer.\n      // Perhaps a specific method is better?\n      super.seek(out.position());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1ff72a5dbafa0f42676070a2f46223b2d0e122c8","date":1284029415,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/store/FSDirectory.FSIndexOutput#copyBytes(DataInput,long).mjava","sourceNew":null,"sourceOld":"    @Override\n    public void copyBytes(DataInput input, long numBytes) throws IOException {\n      // Optimized copy only if the number of bytes to copy is larger than the\n      // buffer size, and the given IndexInput supports FileChannel copying.\n      // NOTE: the below check relies on NIOIndexInput extending Simple. If that\n      // changes in the future, we should change the check as well.\n      if (numBytes <= BUFFER_SIZE || !(input instanceof SimpleFSIndexInput)) {\n        super.copyBytes(input, numBytes);\n        return;\n      }\n\n      SimpleFSIndexInput fsInput = (SimpleFSIndexInput) input;\n\n      // flush any bytes in the input's buffer.\n      numBytes -= fsInput.flushBuffer(this, numBytes);\n      \n      // flush any bytes in the buffer\n      flush();\n      \n      // do the optimized copy\n      FileChannel in = fsInput.file.getChannel();\n\n      // Necessary because BufferedIndexInput does lazy seeking:\n      in.position(fsInput.getFilePointer());\n\n      FileChannel out = file.getChannel();\n      long pos = out.position();\n      long writeTo = numBytes + pos;\n      while (pos < writeTo) {\n        pos += out.transferFrom(in, pos, Math.min(CHANNEL_CHUNK_SIZE, writeTo - pos));\n      }\n      // transferFrom does not change the position of the channel. Need to change it manually\n      out.position(pos);\n      \n      // corrects the position in super (BufferedIndexOutput), so that calls\n      // to getFilePointer will return the correct pointer.\n      // Perhaps a specific method is better?\n      super.seek(out.position());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":4,"author":"Michael Busch","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/store/FSDirectory.FSIndexOutput#copyBytes(DataInput,long).mjava","sourceNew":null,"sourceOld":"    @Override\n    public void copyBytes(DataInput input, long numBytes) throws IOException {\n      // Optimized copy only if the number of bytes to copy is larger than the\n      // buffer size, and the given IndexInput supports FileChannel copying ..\n      // NOTE: the below check relies on NIOIndexInput extending Simple. If that\n      // changes in the future, we should change the check as well.\n      if (numBytes > BUFFER_SIZE && input instanceof SimpleFSIndexInput) {\n        // flush any bytes in the buffer\n        flush();\n        // do the optimized copy\n        FileChannel in = ((SimpleFSIndexInput) input).file.getChannel();\n        FileChannel out = file.getChannel();\n        copy(in, out, numBytes);\n        // corrects the position in super (BufferedIndexOutput), so that calls\n        // to getFilePointer will return the correct pointer.\n        // Perhaps a specific method is better?\n        super.seek(out.position());\n      } else {\n        super.copyBytes(input, numBytes);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"462dfb1d8690f192817503773f5b8b94a702246a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","462dfb1d8690f192817503773f5b8b94a702246a"],"90276262a0c6ca51695ab04d9a591d2c8eb0d7f4":["fc59f76ab05132dcb816d613956c236017659fbe"],"d05b801583d7568b68b06c67b22136d2a3b3e3bb":["462dfb1d8690f192817503773f5b8b94a702246a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"57d5dad190acf63cb17e05df3882de97b1105c1c":["90276262a0c6ca51695ab04d9a591d2c8eb0d7f4"],"fc59f76ab05132dcb816d613956c236017659fbe":["d05b801583d7568b68b06c67b22136d2a3b3e3bb"],"1ff72a5dbafa0f42676070a2f46223b2d0e122c8":["57d5dad190acf63cb17e05df3882de97b1105c1c"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["3242a09f703274d3b9283f2064a1a33064b53a1b","1ff72a5dbafa0f42676070a2f46223b2d0e122c8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1ff72a5dbafa0f42676070a2f46223b2d0e122c8"]},"commit2Childs":{"462dfb1d8690f192817503773f5b8b94a702246a":["3242a09f703274d3b9283f2064a1a33064b53a1b","d05b801583d7568b68b06c67b22136d2a3b3e3bb"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"90276262a0c6ca51695ab04d9a591d2c8eb0d7f4":["57d5dad190acf63cb17e05df3882de97b1105c1c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["462dfb1d8690f192817503773f5b8b94a702246a","3242a09f703274d3b9283f2064a1a33064b53a1b"],"d05b801583d7568b68b06c67b22136d2a3b3e3bb":["fc59f76ab05132dcb816d613956c236017659fbe"],"fc59f76ab05132dcb816d613956c236017659fbe":["90276262a0c6ca51695ab04d9a591d2c8eb0d7f4"],"57d5dad190acf63cb17e05df3882de97b1105c1c":["1ff72a5dbafa0f42676070a2f46223b2d0e122c8"],"1ff72a5dbafa0f42676070a2f46223b2d0e122c8":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}