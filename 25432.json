{"path":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"/dev/null","sourceNew":"  protected final float phraseFreq() throws IOException {\n    pq.clear();\n    int end = 0;\n    for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n      pp.firstPosition();\n      if (pp.position > end)\n\tend = pp.position;\n      pq.put(pp);\t\t\t\t  // build pq from list\n    }\n\n    float freq = 0.0f;\n    boolean done = false;\n    do {\n      PhrasePositions pp = (PhrasePositions)pq.pop();\n      int start = pp.position;\n      int next = ((PhrasePositions)pq.top()).position;\n      for (int pos = start; pos <= next; pos = pp.position) {\n\tstart = pos;\t\t\t\t  // advance pp to min window\n\tif (!pp.nextPosition()) {\n\t  done = true;\t\t\t\t  // ran out of a term -- done\n\t  break;\n\t}\n      }\n\n      int matchLength = end - start;\n      if (matchLength <= slop)\n\tfreq += 1.0 / (matchLength + 1);\t  // penalize longer matches\n\n      if (pp.position > end)\n\tend = pp.position;\n      pq.put(pp);\t\t\t\t  // restore pq\n    } while (!done);\n    \n    return freq;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f5efa46fb27648cd98137d9898d819e115911bc","date":1036690287,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"  protected final float phraseFreq() throws IOException {\n    pq.clear();\n    int end = 0;\n    for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n      pp.firstPosition();\n      if (pp.position > end)\n\tend = pp.position;\n      pq.put(pp);\t\t\t\t  // build pq from list\n    }\n\n    float freq = 0.0f;\n    boolean done = false;\n    do {\n      PhrasePositions pp = (PhrasePositions)pq.pop();\n      int start = pp.position;\n      int next = ((PhrasePositions)pq.top()).position;\n      for (int pos = start; pos <= next; pos = pp.position) {\n\tstart = pos;\t\t\t\t  // advance pp to min window\n\tif (!pp.nextPosition()) {\n\t  done = true;\t\t\t\t  // ran out of a term -- done\n\t  break;\n\t}\n      }\n\n      int matchLength = end - start;\n      if (matchLength <= slop)\n\tfreq += getSimilarity().sloppyFreq(matchLength); // score match\n\n      if (pp.position > end)\n\tend = pp.position;\n      pq.put(pp);\t\t\t\t  // restore pq\n    } while (!done);\n    \n    return freq;\n  }\n\n","sourceOld":"  protected final float phraseFreq() throws IOException {\n    pq.clear();\n    int end = 0;\n    for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n      pp.firstPosition();\n      if (pp.position > end)\n\tend = pp.position;\n      pq.put(pp);\t\t\t\t  // build pq from list\n    }\n\n    float freq = 0.0f;\n    boolean done = false;\n    do {\n      PhrasePositions pp = (PhrasePositions)pq.pop();\n      int start = pp.position;\n      int next = ((PhrasePositions)pq.top()).position;\n      for (int pos = start; pos <= next; pos = pp.position) {\n\tstart = pos;\t\t\t\t  // advance pp to min window\n\tif (!pp.nextPosition()) {\n\t  done = true;\t\t\t\t  // ran out of a term -- done\n\t  break;\n\t}\n      }\n\n      int matchLength = end - start;\n      if (matchLength <= slop)\n\tfreq += 1.0 / (matchLength + 1);\t  // penalize longer matches\n\n      if (pp.position > end)\n\tend = pp.position;\n      pq.put(pp);\t\t\t\t  // restore pq\n    } while (!done);\n    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9d9dc36efcf84dcc613e66f8eeef578481dfc8d","date":1063243547,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    protected final float phraseFreq() throws IOException {\n        pq.clear();\n        int end = 0;\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            pp.firstPosition();\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);\t\t\t\t  // build pq from list\n        }\n\n        float freq = 0.0f;\n        boolean done = false;\n        do {\n            PhrasePositions pp = (PhrasePositions) pq.pop();\n            int start = pp.position;\n            int next = ((PhrasePositions) pq.top()).position;\n            for (int pos = start; pos <= next; pos = pp.position) {\n                start = pos;\t\t\t\t  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;\t\t\t\t  // ran out of a term -- done\n                    break;\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);\t\t\t\t  // restore pq\n        } while (!done);\n\n        return freq;\n    }\n\n","sourceOld":"  protected final float phraseFreq() throws IOException {\n    pq.clear();\n    int end = 0;\n    for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n      pp.firstPosition();\n      if (pp.position > end)\n\tend = pp.position;\n      pq.put(pp);\t\t\t\t  // build pq from list\n    }\n\n    float freq = 0.0f;\n    boolean done = false;\n    do {\n      PhrasePositions pp = (PhrasePositions)pq.pop();\n      int start = pp.position;\n      int next = ((PhrasePositions)pq.top()).position;\n      for (int pos = start; pos <= next; pos = pp.position) {\n\tstart = pos;\t\t\t\t  // advance pp to min window\n\tif (!pp.nextPosition()) {\n\t  done = true;\t\t\t\t  // ran out of a term -- done\n\t  break;\n\t}\n      }\n\n      int matchLength = end - start;\n      if (matchLength <= slop)\n\tfreq += getSimilarity().sloppyFreq(matchLength); // score match\n\n      if (pp.position > end)\n\tend = pp.position;\n      pq.put(pp);\t\t\t\t  // restore pq\n    } while (!done);\n    \n    return freq;\n  }\n\n","bugFix":null,"bugIntro":["3b2ceed5f2320db5cc371e0dd95622cda9a9a56a","b3e493496c35fb4f17315b8827d1ba1ae1585554","c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3e493496c35fb4f17315b8827d1ba1ae1585554","date":1177392767,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Pssibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = (PhrasePositions) pq.pop();\n            int start = pp.position;\n            int next = ((PhrasePositions) pq.top()).position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;\t\t\t\t  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                tpsDiffer = !pp.repeats || termPositionsDiffer(pp);\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);\t\t\t\t  // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    protected final float phraseFreq() throws IOException {\n        pq.clear();\n        int end = 0;\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            pp.firstPosition();\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);\t\t\t\t  // build pq from list\n        }\n\n        float freq = 0.0f;\n        boolean done = false;\n        do {\n            PhrasePositions pp = (PhrasePositions) pq.pop();\n            int start = pp.position;\n            int next = ((PhrasePositions) pq.top()).position;\n            for (int pos = start; pos <= next; pos = pp.position) {\n                start = pos;\t\t\t\t  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;\t\t\t\t  // ran out of a term -- done\n                    break;\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);\t\t\t\t  // restore pq\n        } while (!done);\n\n        return freq;\n    }\n\n","bugFix":["e9d9dc36efcf84dcc613e66f8eeef578481dfc8d"],"bugIntro":["3b2ceed5f2320db5cc371e0dd95622cda9a9a56a","c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b2ceed5f2320db5cc371e0dd95622cda9a9a56a","date":1217778014,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Pssibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = (PhrasePositions) pq.pop();\n            int start = pp.position;\n            int next = ((PhrasePositions) pq.top()).position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Pssibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = (PhrasePositions) pq.pop();\n            int start = pp.position;\n            int next = ((PhrasePositions) pq.top()).position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;\t\t\t\t  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                tpsDiffer = !pp.repeats || termPositionsDiffer(pp);\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);\t\t\t\t  // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":["e9d9dc36efcf84dcc613e66f8eeef578481dfc8d","b3e493496c35fb4f17315b8827d1ba1ae1585554"],"bugIntro":["76bdd2a0d65c8a40e657fbefccfc915026e4902b","c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"12716999e1e8b79bca2fa1f6ec4511c4bfbf6736","date":1250520301,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = (PhrasePositions) pq.pop();\n            int start = pp.position;\n            int next = ((PhrasePositions) pq.top()).position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Pssibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = (PhrasePositions) pq.pop();\n            int start = pp.position;\n            int next = ((PhrasePositions) pq.top()).position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":null,"bugIntro":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0731e137bcbb58121034de6ddaa67332fbe6e5d1","date":1255233265,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = (PhrasePositions) pq.pop();\n            int start = pp.position;\n            int next = ((PhrasePositions) pq.top()).position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = (PhrasePositions) pq.pop();\n            int start = pp.position;\n            int next = ((PhrasePositions) pq.top()).position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.put(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":null,"bugIntro":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"20645c714ca2a7b7707c2707d58ee9fa384c7362","date":1256074979,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = (PhrasePositions) pq.pop();\n            int start = pp.position;\n            int next = ((PhrasePositions) pq.top()).position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":null,"bugIntro":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8a9e385641d717e641408d8fbbc62be8fc766357","date":1256746606,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":null,"bugIntro":["c9ff635e6838a2facda02727dec5b77d9e64dc4c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","pathOld":"src/java/org/apache/lucene/search/SloppyPhraseScorer#phraseFreq().mjava","sourceNew":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","sourceOld":"    /**\n     * Score a candidate doc for all slop-valid position-combinations (matches) \n     * encountered while traversing/hopping the PhrasePositions.\n     * <br> The score contribution of a match depends on the distance: \n     * <br> - highest score for distance=0 (exact match).\n     * <br> - score gets lower as distance gets higher.\n     * <br>Example: for query \"a b\"~2, a document \"x a b a y\" can be scored twice: \n     * once for \"a b\" (distance=0), and once for \"b a\" (distance=2).\n     * <br>Possibly not all valid combinations are encountered, because for efficiency  \n     * we always propagate the least PhrasePosition. This allows to base on \n     * PriorityQueue and move forward faster. \n     * As result, for example, document \"a b c b a\"\n     * would score differently for queries \"a b c\"~4 and \"c b a\"~4, although \n     * they really are equivalent. \n     * Similarly, for doc \"a b c b a f g\", query \"c b\"~2 \n     * would get same score as \"g f\"~2, although \"c b\"~2 could be matched twice.\n     * We may want to fix this in the future (currently not, for performance reasons).\n     */\n    @Override\n    protected final float phraseFreq() throws IOException {\n        int end = initPhrasePositions();\n        \n        float freq = 0.0f;\n        boolean done = (end<0);\n        while (!done) {\n            PhrasePositions pp = pq.pop();\n            int start = pp.position;\n            int next = pq.top().position;\n\n            boolean tpsDiffer = true;\n            for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {\n                if (pos<=next && tpsDiffer)\n                    start = pos;                  // advance pp to min window\n                if (!pp.nextPosition()) {\n                    done = true;          // ran out of a term -- done\n                    break;\n                }\n                PhrasePositions pp2 = null;\n                tpsDiffer = !pp.repeats || (pp2 = termPositionsDiffer(pp))==null;\n                if (pp2!=null && pp2!=pp) {\n                  pp = flip(pp,pp2); // flip pp to pp2\n                }\n            }\n\n            int matchLength = end - start;\n            if (matchLength <= slop)\n                freq += getSimilarity().sloppyFreq(matchLength); // score match\n\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);               // restore pq\n        }\n\n        return freq;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3b2ceed5f2320db5cc371e0dd95622cda9a9a56a":["b3e493496c35fb4f17315b8827d1ba1ae1585554"],"b3e493496c35fb4f17315b8827d1ba1ae1585554":["e9d9dc36efcf84dcc613e66f8eeef578481dfc8d"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8a9e385641d717e641408d8fbbc62be8fc766357":["20645c714ca2a7b7707c2707d58ee9fa384c7362"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0731e137bcbb58121034de6ddaa67332fbe6e5d1":["12716999e1e8b79bca2fa1f6ec4511c4bfbf6736"],"20645c714ca2a7b7707c2707d58ee9fa384c7362":["0731e137bcbb58121034de6ddaa67332fbe6e5d1"],"12716999e1e8b79bca2fa1f6ec4511c4bfbf6736":["3b2ceed5f2320db5cc371e0dd95622cda9a9a56a"],"e9d9dc36efcf84dcc613e66f8eeef578481dfc8d":["6f5efa46fb27648cd98137d9898d819e115911bc"],"6f5efa46fb27648cd98137d9898d819e115911bc":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["8a9e385641d717e641408d8fbbc62be8fc766357"]},"commit2Childs":{"3b2ceed5f2320db5cc371e0dd95622cda9a9a56a":["12716999e1e8b79bca2fa1f6ec4511c4bfbf6736"],"b3e493496c35fb4f17315b8827d1ba1ae1585554":["3b2ceed5f2320db5cc371e0dd95622cda9a9a56a"],"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["6f5efa46fb27648cd98137d9898d819e115911bc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"8a9e385641d717e641408d8fbbc62be8fc766357":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"0731e137bcbb58121034de6ddaa67332fbe6e5d1":["20645c714ca2a7b7707c2707d58ee9fa384c7362"],"20645c714ca2a7b7707c2707d58ee9fa384c7362":["8a9e385641d717e641408d8fbbc62be8fc766357"],"12716999e1e8b79bca2fa1f6ec4511c4bfbf6736":["0731e137bcbb58121034de6ddaa67332fbe6e5d1"],"e9d9dc36efcf84dcc613e66f8eeef578481dfc8d":["b3e493496c35fb4f17315b8827d1ba1ae1585554"],"6f5efa46fb27648cd98137d9898d819e115911bc":["e9d9dc36efcf84dcc613e66f8eeef578481dfc8d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}