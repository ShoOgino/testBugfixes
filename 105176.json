{"path":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","commits":[{"id":"b213cb4b7b825687d73e7ec995c615eb0cf68305","date":1510236177,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,int,int).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions, DocValuesType docValues,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, -1, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"165c905a42bedc7c7d1acb37b177498306b7e866","date":1518704038,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eeba0a4d0845889a402dd225793d62f009d029c9","date":1527938093,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes, boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab548c8f96022b4780f7500a30b19b4f4a5feeb6","date":1527940044,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,boolean).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes, boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7e4ca6dc9612ff741d8713743e2bccfae5eadac","date":1528093718,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes, boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":5,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes, boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":5,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/FieldInfos.Builder#addOrUpdateInternal(String,int,boolean,boolean,boolean,IndexOptions,DocValuesType,long,int,int).mjava","sourceNew":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes, boolean isSoftDeletesField) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes, isSoftDeletesField);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","sourceOld":"    private FieldInfo addOrUpdateInternal(String name, int preferredFieldNumber,\n                                          boolean storeTermVector,\n                                          boolean omitNorms, boolean storePayloads, IndexOptions indexOptions,\n                                          DocValuesType docValues, long dvGen,\n                                          int dimensionCount, int dimensionNumBytes) {\n      assert assertNotFinished();\n      if (docValues == null) {\n        throw new NullPointerException(\"DocValuesType must not be null\");\n      }\n      FieldInfo fi = fieldInfo(name);\n      if (fi == null) {\n        // This field wasn't yet added to this in-RAM\n        // segment's FieldInfo, so now we get a global\n        // number for this field.  If the field was seen\n        // before then we'll get the same name and number,\n        // else we'll allocate a new one:\n        final int fieldNumber = globalFieldNumbers.addOrGet(name, preferredFieldNumber, indexOptions, docValues, dimensionCount, dimensionNumBytes);\n        fi = new FieldInfo(name, fieldNumber, storeTermVector, omitNorms, storePayloads, indexOptions, docValues, dvGen, new HashMap<>(), dimensionCount, dimensionNumBytes);\n        assert !byName.containsKey(fi.name);\n        globalFieldNumbers.verifyConsistent(Integer.valueOf(fi.number), fi.name, fi.getDocValuesType());\n        byName.put(fi.name, fi);\n      } else {\n        fi.update(storeTermVector, omitNorms, storePayloads, indexOptions, dimensionCount, dimensionNumBytes);\n\n        if (docValues != DocValuesType.NONE) {\n          // Only pay the synchronization cost if fi does not already have a DVType\n          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NONE;\n          if (updateGlobal) {\n            // Must also update docValuesType map so it's\n            // aware of this field's DocValuesType.  This will throw IllegalArgumentException if\n            // an illegal type change was attempted.\n            globalFieldNumbers.setDocValuesType(fi.number, name, docValues);\n          }\n\n          fi.setDocValuesType(docValues); // this will also perform the consistency check.\n          fi.setDocValuesGen(dvGen);\n        }\n      }\n      return fi;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"165c905a42bedc7c7d1acb37b177498306b7e866":["b213cb4b7b825687d73e7ec995c615eb0cf68305"],"b213cb4b7b825687d73e7ec995c615eb0cf68305":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ab548c8f96022b4780f7500a30b19b4f4a5feeb6":["eeba0a4d0845889a402dd225793d62f009d029c9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["165c905a42bedc7c7d1acb37b177498306b7e866","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6"],"eeba0a4d0845889a402dd225793d62f009d029c9":["165c905a42bedc7c7d1acb37b177498306b7e866"],"f592209545c71895260367152601e9200399776d":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6","b7e4ca6dc9612ff741d8713743e2bccfae5eadac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac"]},"commit2Childs":{"165c905a42bedc7c7d1acb37b177498306b7e866":["b70042a8a492f7054d480ccdd2be9796510d4327","eeba0a4d0845889a402dd225793d62f009d029c9"],"b213cb4b7b825687d73e7ec995c615eb0cf68305":["165c905a42bedc7c7d1acb37b177498306b7e866"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b213cb4b7b825687d73e7ec995c615eb0cf68305"],"ab548c8f96022b4780f7500a30b19b4f4a5feeb6":["b7e4ca6dc9612ff741d8713743e2bccfae5eadac","f592209545c71895260367152601e9200399776d"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"eeba0a4d0845889a402dd225793d62f009d029c9":["ab548c8f96022b4780f7500a30b19b4f4a5feeb6"],"b7e4ca6dc9612ff741d8713743e2bccfae5eadac":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f592209545c71895260367152601e9200399776d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}