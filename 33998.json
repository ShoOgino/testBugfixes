{"path":"solr/core/src/test/org/apache/solr/request/TestUnInvertedFieldException#testConcurrentInit().mjava","commits":[{"id":"f0b850f06b1db39c994c6386cbbaa486651f490b","date":1523385145,"type":0,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestUnInvertedFieldException#testConcurrentInit().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testConcurrentInit() throws Exception {\n    final SolrQueryRequest req = req(\"*:*\");\n\n    List<Callable<UnInvertedField>> initCallables = new ArrayList<>();\n    for (int i=0;i< TestUtil.nextInt(random(), 10, 30);i++) {\n      initCallables.add(()-> UnInvertedField.getUnInvertedField(proto.field(), req.getSearcher()));\n    }\n\n    final ThreadPoolExecutor pool  = new MDCAwareThreadPoolExecutor(3, \n        TestUtil.nextInt(random(), 3, 6), 10, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory(getClass().getSimpleName()));\n\n    try {\n      TestInjection.uifOutOfMemoryError = true;\n      if (assertsAreEnabled) { // if they aren't, we check that injection is disabled in live\n        List<Future<UnInvertedField>> futures = initCallables.stream().map((c) -> pool.submit(c))\n            .collect(Collectors.toList());\n        for (Future<UnInvertedField> uifuture : futures) {\n          try {\n            final UnInvertedField uif = uifuture.get();\n          } catch (ExecutionException injection) {\n            SolrException solrException = (SolrException) injection.getCause();\n            assertEquals(ErrorCode.SERVER_ERROR.code, solrException.code());\n            assertSame(solrException.getCause().getClass(), OutOfMemoryError.class);\n          }\n          assertNull(UnInvertedField.checkUnInvertedField(proto.field(), req.getSearcher()));\n        }\n        TestInjection.uifOutOfMemoryError = false;\n      }\n      UnInvertedField prev = null;\n      List<Future<UnInvertedField>> futures = initCallables.stream().map((c) -> pool.submit(c))\n          .collect(Collectors.toList());\n      for (Future<UnInvertedField> uifuture : futures) {\n        final UnInvertedField uif = uifuture.get();\n        assertNotNull(uif);\n        assertSame(uif, UnInvertedField.checkUnInvertedField(proto.field(), req.getSearcher()));\n        if (prev != null) {\n          assertSame(prev, uif);\n        }\n        assertEquals(numTerms, uif.numTerms());\n        prev = uif;\n      }\n    } finally {\n      pool.shutdownNow();\n      req.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["833902bf626ef0c2f8aca54539b3c642d084d809"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"833902bf626ef0c2f8aca54539b3c642d084d809","date":1524052669,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestUnInvertedFieldException#testConcurrentInit().mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestUnInvertedFieldException#testConcurrentInit().mjava","sourceNew":"  @Test\n  public void testConcurrentInit() throws Exception {\n    final SolrQueryRequest req = req(\"*:*\");\n    final SolrIndexSearcher searcher = req.getSearcher();\n\n    List<Callable<UnInvertedField>> initCallables = new ArrayList<>();\n    for (int i=0;i< TestUtil.nextInt(random(), 10, 30);i++) {\n      initCallables.add(()-> UnInvertedField.getUnInvertedField(proto.field(), searcher));\n    }\n\n    final ThreadPoolExecutor pool  = new MDCAwareThreadPoolExecutor(3, \n        TestUtil.nextInt(random(), 3, 6), 10, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory(getClass().getSimpleName()));\n\n    try {\n      TestInjection.uifOutOfMemoryError = true;\n      if (assertsAreEnabled) { // if they aren't, we check that injection is disabled in live\n        List<Future<UnInvertedField>> futures = initCallables.stream().map((c) -> pool.submit(c))\n            .collect(Collectors.toList());\n        for (Future<UnInvertedField> uifuture : futures) {\n          try {\n            final UnInvertedField uif = uifuture.get();\n          } catch (ExecutionException injection) {\n            SolrException solrException = (SolrException) injection.getCause();\n            assertEquals(ErrorCode.SERVER_ERROR.code, solrException.code());\n            assertSame(solrException.getCause().getClass(), OutOfMemoryError.class);\n          }\n          assertNull(UnInvertedField.checkUnInvertedField(proto.field(), searcher));\n        }\n        TestInjection.uifOutOfMemoryError = false;\n      }\n      UnInvertedField prev = null;\n      List<Future<UnInvertedField>> futures = initCallables.stream().map((c) -> pool.submit(c))\n          .collect(Collectors.toList());\n      for (Future<UnInvertedField> uifuture : futures) {\n        final UnInvertedField uif = uifuture.get();\n        assertNotNull(uif);\n        assertSame(uif, UnInvertedField.checkUnInvertedField(proto.field(), searcher));\n        if (prev != null) {\n          assertSame(prev, uif);\n        }\n        assertEquals(numTerms, uif.numTerms());\n        prev = uif;\n      }\n    } finally {\n      pool.shutdownNow();\n      req.close();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testConcurrentInit() throws Exception {\n    final SolrQueryRequest req = req(\"*:*\");\n\n    List<Callable<UnInvertedField>> initCallables = new ArrayList<>();\n    for (int i=0;i< TestUtil.nextInt(random(), 10, 30);i++) {\n      initCallables.add(()-> UnInvertedField.getUnInvertedField(proto.field(), req.getSearcher()));\n    }\n\n    final ThreadPoolExecutor pool  = new MDCAwareThreadPoolExecutor(3, \n        TestUtil.nextInt(random(), 3, 6), 10, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(), new NamedThreadFactory(getClass().getSimpleName()));\n\n    try {\n      TestInjection.uifOutOfMemoryError = true;\n      if (assertsAreEnabled) { // if they aren't, we check that injection is disabled in live\n        List<Future<UnInvertedField>> futures = initCallables.stream().map((c) -> pool.submit(c))\n            .collect(Collectors.toList());\n        for (Future<UnInvertedField> uifuture : futures) {\n          try {\n            final UnInvertedField uif = uifuture.get();\n          } catch (ExecutionException injection) {\n            SolrException solrException = (SolrException) injection.getCause();\n            assertEquals(ErrorCode.SERVER_ERROR.code, solrException.code());\n            assertSame(solrException.getCause().getClass(), OutOfMemoryError.class);\n          }\n          assertNull(UnInvertedField.checkUnInvertedField(proto.field(), req.getSearcher()));\n        }\n        TestInjection.uifOutOfMemoryError = false;\n      }\n      UnInvertedField prev = null;\n      List<Future<UnInvertedField>> futures = initCallables.stream().map((c) -> pool.submit(c))\n          .collect(Collectors.toList());\n      for (Future<UnInvertedField> uifuture : futures) {\n        final UnInvertedField uif = uifuture.get();\n        assertNotNull(uif);\n        assertSame(uif, UnInvertedField.checkUnInvertedField(proto.field(), req.getSearcher()));\n        if (prev != null) {\n          assertSame(prev, uif);\n        }\n        assertEquals(numTerms, uif.numTerms());\n        prev = uif;\n      }\n    } finally {\n      pool.shutdownNow();\n      req.close();\n    }\n  }\n\n","bugFix":["f0b850f06b1db39c994c6386cbbaa486651f490b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"833902bf626ef0c2f8aca54539b3c642d084d809":["f0b850f06b1db39c994c6386cbbaa486651f490b"],"f0b850f06b1db39c994c6386cbbaa486651f490b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["833902bf626ef0c2f8aca54539b3c642d084d809"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f0b850f06b1db39c994c6386cbbaa486651f490b"],"833902bf626ef0c2f8aca54539b3c642d084d809":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f0b850f06b1db39c994c6386cbbaa486651f490b":["833902bf626ef0c2f8aca54539b3c642d084d809"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}