{"path":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet,IndexReader.CacheHelper).mjava","commits":[{"id":"d211216c83f01894810543d1c107160a9ae3650b","date":1488289605,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet,IndexReader.CacheHelper).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet).mjava","sourceNew":"  void putIfAbsent(Query query, LeafReaderContext context, DocIdSet set, IndexReader.CacheHelper cacheHelper) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(singleton, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + ramBytesUsed(query));\n      } else {\n        query = singleton;\n      }\n      final IndexReader.CacheKey key = cacheHelper.getKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(key, leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        cacheHelper.addClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  void putIfAbsent(Query query, LeafReaderContext context, DocIdSet set) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(singleton, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + ramBytesUsed(query));\n      } else {\n        query = singleton;\n      }\n      final Object key = context.reader().getCoreCacheKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(context.reader().getCoreCacheKey(), leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        context.reader().addCoreClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"393f9042b18c4281cb212ceb8dc71c31a2220f46","date":1494510970,"type":3,"author":"ChristophKaser","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet,IndexReader.CacheHelper).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet,IndexReader.CacheHelper).mjava","sourceNew":"  void putIfAbsent(Query query, LeafReaderContext context, DocIdSet set, IndexReader.CacheHelper cacheHelper) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(query, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + ramBytesUsed(query));\n      } else {\n        query = singleton;\n      }\n      final IndexReader.CacheKey key = cacheHelper.getKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(key, leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        cacheHelper.addClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  void putIfAbsent(Query query, LeafReaderContext context, DocIdSet set, IndexReader.CacheHelper cacheHelper) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(singleton, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + ramBytesUsed(query));\n      } else {\n        query = singleton;\n      }\n      final IndexReader.CacheKey key = cacheHelper.getKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(key, leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        cacheHelper.addClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":["aa7f878dadf2afe37eaf26f3f2906ec2dd0aacaa"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"360b3962efc30aa8b2c39c3087aa36069674bbe7","date":1494557674,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet,IndexReader.CacheHelper).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet,IndexReader.CacheHelper).mjava","sourceNew":"  void putIfAbsent(Query query, LeafReaderContext context, DocIdSet set, IndexReader.CacheHelper cacheHelper) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(query, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + ramBytesUsed(query));\n      } else {\n        query = singleton;\n      }\n      final IndexReader.CacheKey key = cacheHelper.getKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(key, leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        cacheHelper.addClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  void putIfAbsent(Query query, LeafReaderContext context, DocIdSet set, IndexReader.CacheHelper cacheHelper) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(singleton, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + ramBytesUsed(query));\n      } else {\n        query = singleton;\n      }\n      final IndexReader.CacheKey key = cacheHelper.getKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(key, leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        cacheHelper.addClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet,IndexReader.CacheHelper).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet,IndexReader.CacheHelper).mjava","sourceNew":"  void putIfAbsent(Query query, LeafReaderContext context, DocIdSet set, IndexReader.CacheHelper cacheHelper) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(query, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + ramBytesUsed(query));\n      } else {\n        query = singleton;\n      }\n      final IndexReader.CacheKey key = cacheHelper.getKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(key, leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        cacheHelper.addClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  void putIfAbsent(Query query, LeafReaderContext context, DocIdSet set, IndexReader.CacheHelper cacheHelper) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(singleton, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + ramBytesUsed(query));\n      } else {\n        query = singleton;\n      }\n      final IndexReader.CacheKey key = cacheHelper.getKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(key, leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        cacheHelper.addClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b31781f87f2e572b5c28caf2f83400abe6c05fe7","date":1511944192,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet,IndexReader.CacheHelper).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet,IndexReader.CacheHelper).mjava","sourceNew":"  void putIfAbsent(Query query, LeafReaderContext context, DocIdSet set, IndexReader.CacheHelper cacheHelper) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(query, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + QUERY_DEFAULT_RAM_BYTES_USED);\n      } else {\n        query = singleton;\n      }\n      final IndexReader.CacheKey key = cacheHelper.getKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(key, leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        cacheHelper.addClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  void putIfAbsent(Query query, LeafReaderContext context, DocIdSet set, IndexReader.CacheHelper cacheHelper) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(query, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + ramBytesUsed(query));\n      } else {\n        query = singleton;\n      }\n      final IndexReader.CacheKey key = cacheHelper.getKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(key, leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        cacheHelper.addClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet,IndexReader.CacheHelper).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet,IndexReader.CacheHelper).mjava","sourceNew":"  void putIfAbsent(Query query, LeafReaderContext context, DocIdSet set, IndexReader.CacheHelper cacheHelper) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(query, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + QUERY_DEFAULT_RAM_BYTES_USED);\n      } else {\n        query = singleton;\n      }\n      final IndexReader.CacheKey key = cacheHelper.getKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(key, leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        cacheHelper.addClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  void putIfAbsent(Query query, LeafReaderContext context, DocIdSet set, IndexReader.CacheHelper cacheHelper) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(query, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + ramBytesUsed(query));\n      } else {\n        query = singleton;\n      }\n      final IndexReader.CacheKey key = cacheHelper.getKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(key, leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        cacheHelper.addClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4e703a107dabba92e897b4405f4a69f135565a2","date":1567669029,"type":5,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,DocIdSet,IndexReader.CacheHelper).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache#putIfAbsent(Query,LeafReaderContext,DocIdSet,IndexReader.CacheHelper).mjava","sourceNew":"  private void putIfAbsent(Query query, DocIdSet set, IndexReader.CacheHelper cacheHelper) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(query, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + QUERY_DEFAULT_RAM_BYTES_USED);\n      } else {\n        query = singleton;\n      }\n      final IndexReader.CacheKey key = cacheHelper.getKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(key, leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        cacheHelper.addClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","sourceOld":"  void putIfAbsent(Query query, LeafReaderContext context, DocIdSet set, IndexReader.CacheHelper cacheHelper) {\n    assert query instanceof BoostQuery == false;\n    assert query instanceof ConstantScoreQuery == false;\n    // under a lock to make sure that mostRecentlyUsedQueries and cache remain sync'ed\n    lock.lock();\n    try {\n      Query singleton = uniqueQueries.putIfAbsent(query, query);\n      if (singleton == null) {\n        onQueryCache(query, LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY + QUERY_DEFAULT_RAM_BYTES_USED);\n      } else {\n        query = singleton;\n      }\n      final IndexReader.CacheKey key = cacheHelper.getKey();\n      LeafCache leafCache = cache.get(key);\n      if (leafCache == null) {\n        leafCache = new LeafCache(key);\n        final LeafCache previous = cache.put(key, leafCache);\n        ramBytesUsed += HASHTABLE_RAM_BYTES_PER_ENTRY;\n        assert previous == null;\n        // we just created a new leaf cache, need to register a close listener\n        cacheHelper.addClosedListener(this::clearCoreCacheKey);\n      }\n      leafCache.putIfAbsent(query, set);\n      evictIfNecessary();\n    } finally {\n      lock.unlock();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1aad05eeff7818b0833c02ac6b743aa72054963b":["360b3962efc30aa8b2c39c3087aa36069674bbe7","b31781f87f2e572b5c28caf2f83400abe6c05fe7"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["d211216c83f01894810543d1c107160a9ae3650b","360b3962efc30aa8b2c39c3087aa36069674bbe7"],"b31781f87f2e572b5c28caf2f83400abe6c05fe7":["360b3962efc30aa8b2c39c3087aa36069674bbe7"],"360b3962efc30aa8b2c39c3087aa36069674bbe7":["d211216c83f01894810543d1c107160a9ae3650b","393f9042b18c4281cb212ceb8dc71c31a2220f46"],"d4e703a107dabba92e897b4405f4a69f135565a2":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"d211216c83f01894810543d1c107160a9ae3650b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"393f9042b18c4281cb212ceb8dc71c31a2220f46":["d211216c83f01894810543d1c107160a9ae3650b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4e703a107dabba92e897b4405f4a69f135565a2"]},"commit2Childs":{"1aad05eeff7818b0833c02ac6b743aa72054963b":["d4e703a107dabba92e897b4405f4a69f135565a2"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"b31781f87f2e572b5c28caf2f83400abe6c05fe7":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"360b3962efc30aa8b2c39c3087aa36069674bbe7":["1aad05eeff7818b0833c02ac6b743aa72054963b","e9017cf144952056066919f1ebc7897ff9bd71b1","b31781f87f2e572b5c28caf2f83400abe6c05fe7"],"d211216c83f01894810543d1c107160a9ae3650b":["e9017cf144952056066919f1ebc7897ff9bd71b1","360b3962efc30aa8b2c39c3087aa36069674bbe7","393f9042b18c4281cb212ceb8dc71c31a2220f46"],"d4e703a107dabba92e897b4405f4a69f135565a2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d211216c83f01894810543d1c107160a9ae3650b"],"393f9042b18c4281cb212ceb8dc71c31a2220f46":["360b3962efc30aa8b2c39c3087aa36069674bbe7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}