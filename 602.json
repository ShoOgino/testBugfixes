{"path":"solr/core/src/test/org/apache/solr/cloud/TestAuthenticationFramework#collectionCreateSearchDelete(MiniSolrCloudCluster).mjava","commits":[{"id":"5ae827abc0676fd634796da7b0a0726ebac813b8","date":1467296417,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestAuthenticationFramework#collectionCreateSearchDelete(MiniSolrCloudCluster).mjava","pathOld":"/dev/null","sourceNew":"  public void collectionCreateSearchDelete(MiniSolrCloudCluster miniCluster) throws Exception {\n\n    final String collectionName = \"testcollection\";\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // create collection\n    log.info(\"#### Creating a collection\");\n    final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId);\n    if (asyncId != null) {\n      final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n          cloudSolrClient);\n      assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n    }\n\n    ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // modify/query collection\n    log.info(\"#### updating a querying collection\");\n    cloudSolrClient.setDefaultCollection(collectionName);\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.setField(\"id\", \"1\");\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    SolrQuery query = new SolrQuery();\n    query.setQuery(\"*:*\");\n    QueryResponse rsp = cloudSolrClient.query(query);\n    assertEquals(1, rsp.getResults().getNumFound());\n\n    // delete the collection we created earlier\n    miniCluster.deleteCollection(collectionName);\n    AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n\n    // create it again\n    String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId2);\n    if (asyncId2 != null) {\n      final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId2, 330,\n          cloudSolrClient);\n      assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n    }\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // check that there's no left-over state\n    assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56ae3539e829325e80cc0e8d65df4d724cc762d1","date":1467374872,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestAuthenticationFramework#collectionCreateSearchDelete(MiniSolrCloudCluster).mjava","pathOld":"/dev/null","sourceNew":"  public void collectionCreateSearchDelete(MiniSolrCloudCluster miniCluster) throws Exception {\n\n    final String collectionName = \"testcollection\";\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // create collection\n    log.info(\"#### Creating a collection\");\n    final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId);\n    if (asyncId != null) {\n      final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n          cloudSolrClient);\n      assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n    }\n\n    ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // modify/query collection\n    log.info(\"#### updating a querying collection\");\n    cloudSolrClient.setDefaultCollection(collectionName);\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.setField(\"id\", \"1\");\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    SolrQuery query = new SolrQuery();\n    query.setQuery(\"*:*\");\n    QueryResponse rsp = cloudSolrClient.query(query);\n    assertEquals(1, rsp.getResults().getNumFound());\n\n    // delete the collection we created earlier\n    miniCluster.deleteCollection(collectionName);\n    AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n\n    // create it again\n    String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId2);\n    if (asyncId2 != null) {\n      final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId2, 330,\n          cloudSolrClient);\n      assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n    }\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // check that there's no left-over state\n    assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e89a32cc825033ebae8bb9e1c6877c2d9d76749e","date":1476790453,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestAuthenticationFramework#collectionCreateSearchDelete(MiniSolrCloudCluster).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestAuthenticationFramework#collectionCreateSearchDelete(MiniSolrCloudCluster).mjava","sourceNew":"  public void collectionCreateSearchDelete(MiniSolrCloudCluster miniCluster) throws Exception {\n\n    final String collectionName = \"testcollection\";\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // create collection\n    log.info(\"#### Creating a collection\");\n    final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId);\n\n    ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // modify/query collection\n    log.info(\"#### updating a querying collection\");\n    cloudSolrClient.setDefaultCollection(collectionName);\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.setField(\"id\", \"1\");\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    SolrQuery query = new SolrQuery();\n    query.setQuery(\"*:*\");\n    QueryResponse rsp = cloudSolrClient.query(query);\n    assertEquals(1, rsp.getResults().getNumFound());\n\n    // delete the collection we created earlier\n    CollectionAdminRequest.deleteCollection(collectionName).process(miniCluster.getSolrClient());\n\n    // create it again\n    String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId2);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // check that there's no left-over state\n    assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":"  public void collectionCreateSearchDelete(MiniSolrCloudCluster miniCluster) throws Exception {\n\n    final String collectionName = \"testcollection\";\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // create collection\n    log.info(\"#### Creating a collection\");\n    final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId);\n    if (asyncId != null) {\n      final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330,\n          cloudSolrClient);\n      assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n    }\n\n    ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // modify/query collection\n    log.info(\"#### updating a querying collection\");\n    cloudSolrClient.setDefaultCollection(collectionName);\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.setField(\"id\", \"1\");\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    SolrQuery query = new SolrQuery();\n    query.setQuery(\"*:*\");\n    QueryResponse rsp = cloudSolrClient.query(query);\n    assertEquals(1, rsp.getResults().getNumFound());\n\n    // delete the collection we created earlier\n    miniCluster.deleteCollection(collectionName);\n    AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n\n    // create it again\n    String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId2);\n    if (asyncId2 != null) {\n      final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId2, 330,\n          cloudSolrClient);\n      assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n    }\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // check that there's no left-over state\n    assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestAuthenticationFramework#collectionCreateSearchDelete(MiniSolrCloudCluster).mjava","pathOld":"/dev/null","sourceNew":"  public void collectionCreateSearchDelete(MiniSolrCloudCluster miniCluster) throws Exception {\n\n    final String collectionName = \"testcollection\";\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // create collection\n    log.info(\"#### Creating a collection\");\n    final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId);\n\n    ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // modify/query collection\n    log.info(\"#### updating a querying collection\");\n    cloudSolrClient.setDefaultCollection(collectionName);\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.setField(\"id\", \"1\");\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    SolrQuery query = new SolrQuery();\n    query.setQuery(\"*:*\");\n    QueryResponse rsp = cloudSolrClient.query(query);\n    assertEquals(1, rsp.getResults().getNumFound());\n\n    // delete the collection we created earlier\n    CollectionAdminRequest.deleteCollection(collectionName).process(miniCluster.getSolrClient());\n\n    // create it again\n    String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId2);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // check that there's no left-over state\n    assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5719bfb2650ba43855e20564d39873bbbdc7f02c","date":1500676092,"type":4,"author":"Steve Rowe","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestAuthenticationFramework#collectionCreateSearchDelete(MiniSolrCloudCluster).mjava","sourceNew":null,"sourceOld":"  public void collectionCreateSearchDelete(MiniSolrCloudCluster miniCluster) throws Exception {\n\n    final String collectionName = \"testcollection\";\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // create collection\n    log.info(\"#### Creating a collection\");\n    final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId);\n\n    ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // modify/query collection\n    log.info(\"#### updating a querying collection\");\n    cloudSolrClient.setDefaultCollection(collectionName);\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.setField(\"id\", \"1\");\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    SolrQuery query = new SolrQuery();\n    query.setQuery(\"*:*\");\n    QueryResponse rsp = cloudSolrClient.query(query);\n    assertEquals(1, rsp.getResults().getNumFound());\n\n    // delete the collection we created earlier\n    CollectionAdminRequest.deleteCollection(collectionName).process(miniCluster.getSolrClient());\n\n    // create it again\n    String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId2);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // check that there's no left-over state\n    assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":4,"author":"Cao Manh Dat","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestAuthenticationFramework#collectionCreateSearchDelete(MiniSolrCloudCluster).mjava","sourceNew":null,"sourceOld":"  public void collectionCreateSearchDelete(MiniSolrCloudCluster miniCluster) throws Exception {\n\n    final String collectionName = \"testcollection\";\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // create collection\n    log.info(\"#### Creating a collection\");\n    final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId);\n\n    ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // modify/query collection\n    log.info(\"#### updating a querying collection\");\n    cloudSolrClient.setDefaultCollection(collectionName);\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.setField(\"id\", \"1\");\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    SolrQuery query = new SolrQuery();\n    query.setQuery(\"*:*\");\n    QueryResponse rsp = cloudSolrClient.query(query);\n    assertEquals(1, rsp.getResults().getNumFound());\n\n    // delete the collection we created earlier\n    CollectionAdminRequest.deleteCollection(collectionName).process(miniCluster.getSolrClient());\n\n    // create it again\n    String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId2);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // check that there's no left-over state\n    assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a52341299179de5479672f7cf518bf4b173f34b3","date":1501079746,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestAuthenticationFramework#collectionCreateSearchDelete(MiniSolrCloudCluster).mjava","sourceNew":null,"sourceOld":"  public void collectionCreateSearchDelete(MiniSolrCloudCluster miniCluster) throws Exception {\n\n    final String collectionName = \"testcollection\";\n\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n\n    assertNotNull(miniCluster.getZkServer());\n    List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();\n    assertEquals(NUM_SERVERS, jettys.size());\n    for (JettySolrRunner jetty : jettys) {\n      assertTrue(jetty.isRunning());\n    }\n\n    // create collection\n    log.info(\"#### Creating a collection\");\n    final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId);\n\n    ZkStateReader zkStateReader = miniCluster.getSolrClient().getZkStateReader();\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // modify/query collection\n    log.info(\"#### updating a querying collection\");\n    cloudSolrClient.setDefaultCollection(collectionName);\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.setField(\"id\", \"1\");\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    SolrQuery query = new SolrQuery();\n    query.setQuery(\"*:*\");\n    QueryResponse rsp = cloudSolrClient.query(query);\n    assertEquals(1, rsp.getResults().getNumFound());\n\n    // delete the collection we created earlier\n    CollectionAdminRequest.deleteCollection(collectionName).process(miniCluster.getSolrClient());\n\n    // create it again\n    String asyncId2 = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n    createCollection(miniCluster, collectionName, asyncId2);\n    AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n    // check that there's no left-over state\n    assertEquals(0, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    cloudSolrClient.add(doc);\n    cloudSolrClient.commit();\n    assertEquals(1, cloudSolrClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"56ae3539e829325e80cc0e8d65df4d724cc762d1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5ae827abc0676fd634796da7b0a0726ebac813b8"],"a52341299179de5479672f7cf518bf4b173f34b3":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e","5719bfb2650ba43855e20564d39873bbbdc7f02c"],"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["56ae3539e829325e80cc0e8d65df4d724cc762d1"],"5ae827abc0676fd634796da7b0a0726ebac813b8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"936cdd5882761db3b844afd6f84ab81cbb011a75":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e","5719bfb2650ba43855e20564d39873bbbdc7f02c"],"5719bfb2650ba43855e20564d39873bbbdc7f02c":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a52341299179de5479672f7cf518bf4b173f34b3"]},"commit2Childs":{"56ae3539e829325e80cc0e8d65df4d724cc762d1":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"a52341299179de5479672f7cf518bf4b173f34b3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5ae827abc0676fd634796da7b0a0726ebac813b8":["56ae3539e829325e80cc0e8d65df4d724cc762d1"],"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["a52341299179de5479672f7cf518bf4b173f34b3","936cdd5882761db3b844afd6f84ab81cbb011a75","5719bfb2650ba43855e20564d39873bbbdc7f02c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["56ae3539e829325e80cc0e8d65df4d724cc762d1","5ae827abc0676fd634796da7b0a0726ebac813b8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"936cdd5882761db3b844afd6f84ab81cbb011a75":[],"5719bfb2650ba43855e20564d39873bbbdc7f02c":["a52341299179de5479672f7cf518bf4b173f34b3","936cdd5882761db3b844afd6f84ab81cbb011a75"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["936cdd5882761db3b844afd6f84ab81cbb011a75","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}