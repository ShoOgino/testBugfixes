{"path":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","commits":[{"id":"791c4fb1ff970967cf1802cf4d4875ba12c2eb01","date":1446659977,"type":0,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getInQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing query against path=\" + path);\n    HttpSolrClient client = new HttpSolrClient(path);\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    client.query(new SolrQuery(\"*:*\"));\n    client.close();\n\n    //Test to see if the query got forwarded to the active replica or not.\n    for (JettySolrRunner jetty : jettys) {\n      CoreContainer container = ((SolrDispatchFilter) jetty.getDispatchFilter().getFilter()).getCores();\n      for (SolrCore core : container.getCores()) {\n        if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          SolrRequestHandler select = core.getRequestHandler(\"\");\n          long c = (long) select.getStatistics().get(\"requests\");\n          assertEquals(core.getName() + \" should have got 1 request\", 1, c);\n          break;\n        }\n      }\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["344b0840364d990b29b97467bfcc766ff8325d11","5a64d7356125ada6ba003de26604826588561d24"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1088b72b3b4cc45316b7595bd09023c859cd2327","date":1447150009,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getInQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing query against path=\" + path);\n    HttpSolrClient client = new HttpSolrClient(path);\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    client.query(new SolrQuery(\"*:*\"));\n    client.close();\n\n    //Test to see if the query got forwarded to the active replica or not.\n    for (JettySolrRunner jetty : jettys) {\n      CoreContainer container = jetty.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          SolrRequestHandler select = core.getRequestHandler(\"\");\n          long c = (long) select.getStatistics().get(\"requests\");\n          assertEquals(core.getName() + \" should have got 1 request\", 1, c);\n          break;\n        }\n      }\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getInQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing query against path=\" + path);\n    HttpSolrClient client = new HttpSolrClient(path);\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    client.query(new SolrQuery(\"*:*\"));\n    client.close();\n\n    //Test to see if the query got forwarded to the active replica or not.\n    for (JettySolrRunner jetty : jettys) {\n      CoreContainer container = ((SolrDispatchFilter) jetty.getDispatchFilter().getFilter()).getCores();\n      for (SolrCore core : container.getCores()) {\n        if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          SolrRequestHandler select = core.getRequestHandler(\"\");\n          long c = (long) select.getStatistics().get(\"requests\");\n          assertEquals(core.getName() + \" should have got 1 request\", 1, c);\n          break;\n        }\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5a64d7356125ada6ba003de26604826588561d24","date":1447985851,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getInQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    HttpSolrClient client = new HttpSolrClient(path);\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    SolrCore leaderCore = null;\n    for (JettySolrRunner jetty : jettys) {\n      CoreContainer container = jetty.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          leaderCore = core;\n          break;\n        }\n      }\n    }\n    assertNotNull(leaderCore);\n\n    //All queries should be served by the active replica\n    //To make sure that's true we keep querying the down replica\n    //If queries are getting processed by the down replica then the cluster state hasn't updated for that replica locally\n    //So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n    long count = 0;\n    while (true) {\n      count++;\n      client.query(new SolrQuery(\"*:*\"));\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      if (c == 1) {\n        break;  //cluster state has got update locally\n      } else {\n        Thread.sleep(100);\n      }\n\n      if (count > 10000) {\n        fail(\"After 10k queries we still see all requests being processed by the down replica\");\n      }\n    }\n\n    //Now we fire a few additional queries and make sure ALL of them\n    //are served by the active replica\n    int moreQueries = TestUtil.nextInt(random(), 4, 10);\n    count = 1; //Since 1 query has already hit the leader\n    for (int i=0; i<moreQueries; i++) {\n      client.query(new SolrQuery(\"*:*\"));\n      count++;\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      assertEquals(\"Query wasn't served by leader\", count, c);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getInQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing query against path=\" + path);\n    HttpSolrClient client = new HttpSolrClient(path);\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    client.query(new SolrQuery(\"*:*\"));\n    client.close();\n\n    //Test to see if the query got forwarded to the active replica or not.\n    for (JettySolrRunner jetty : jettys) {\n      CoreContainer container = jetty.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          SolrRequestHandler select = core.getRequestHandler(\"\");\n          long c = (long) select.getStatistics().get(\"requests\");\n          assertEquals(core.getName() + \" should have got 1 request\", 1, c);\n          break;\n        }\n      }\n    }\n\n  }\n\n","bugFix":["791c4fb1ff970967cf1802cf4d4875ba12c2eb01"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19498030e0adab22f604f935cae3c03dcf0952a6","date":1456558851,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    HttpSolrClient client = new HttpSolrClient(path);\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    SolrCore leaderCore = null;\n    for (JettySolrRunner jetty : jettys) {\n      CoreContainer container = jetty.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          leaderCore = core;\n          break;\n        }\n      }\n    }\n    assertNotNull(leaderCore);\n\n    //All queries should be served by the active replica\n    //To make sure that's true we keep querying the down replica\n    //If queries are getting processed by the down replica then the cluster state hasn't updated for that replica locally\n    //So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n    long count = 0;\n    while (true) {\n      count++;\n      client.query(new SolrQuery(\"*:*\"));\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      if (c == 1) {\n        break;  //cluster state has got update locally\n      } else {\n        Thread.sleep(100);\n      }\n\n      if (count > 10000) {\n        fail(\"After 10k queries we still see all requests being processed by the down replica\");\n      }\n    }\n\n    //Now we fire a few additional queries and make sure ALL of them\n    //are served by the active replica\n    int moreQueries = TestUtil.nextInt(random(), 4, 10);\n    count = 1; //Since 1 query has already hit the leader\n    for (int i=0; i<moreQueries; i++) {\n      client.query(new SolrQuery(\"*:*\"));\n      count++;\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      assertEquals(\"Query wasn't served by leader\", count, c);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getInQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    HttpSolrClient client = new HttpSolrClient(path);\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    SolrCore leaderCore = null;\n    for (JettySolrRunner jetty : jettys) {\n      CoreContainer container = jetty.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          leaderCore = core;\n          break;\n        }\n      }\n    }\n    assertNotNull(leaderCore);\n\n    //All queries should be served by the active replica\n    //To make sure that's true we keep querying the down replica\n    //If queries are getting processed by the down replica then the cluster state hasn't updated for that replica locally\n    //So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n    long count = 0;\n    while (true) {\n      count++;\n      client.query(new SolrQuery(\"*:*\"));\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      if (c == 1) {\n        break;  //cluster state has got update locally\n      } else {\n        Thread.sleep(100);\n      }\n\n      if (count > 10000) {\n        fail(\"After 10k queries we still see all requests being processed by the down replica\");\n      }\n    }\n\n    //Now we fire a few additional queries and make sure ALL of them\n    //are served by the active replica\n    int moreQueries = TestUtil.nextInt(random(), 4, 10);\n    count = 1; //Since 1 query has already hit the leader\n    for (int i=0; i<moreQueries; i++) {\n      client.query(new SolrQuery(\"*:*\"));\n      count++;\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      assertEquals(\"Query wasn't served by leader\", count, c);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    HttpSolrClient client = new HttpSolrClient(path);\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    SolrCore leaderCore = null;\n    for (JettySolrRunner jetty : jettys) {\n      CoreContainer container = jetty.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          leaderCore = core;\n          break;\n        }\n      }\n    }\n    assertNotNull(leaderCore);\n\n    //All queries should be served by the active replica\n    //To make sure that's true we keep querying the down replica\n    //If queries are getting processed by the down replica then the cluster state hasn't updated for that replica locally\n    //So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n    long count = 0;\n    while (true) {\n      count++;\n      client.query(new SolrQuery(\"*:*\"));\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      if (c == 1) {\n        break;  //cluster state has got update locally\n      } else {\n        Thread.sleep(100);\n      }\n\n      if (count > 10000) {\n        fail(\"After 10k queries we still see all requests being processed by the down replica\");\n      }\n    }\n\n    //Now we fire a few additional queries and make sure ALL of them\n    //are served by the active replica\n    int moreQueries = TestUtil.nextInt(random(), 4, 10);\n    count = 1; //Since 1 query has already hit the leader\n    for (int i=0; i<moreQueries; i++) {\n      client.query(new SolrQuery(\"*:*\"));\n      count++;\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      assertEquals(\"Query wasn't served by leader\", count, c);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getInQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    HttpSolrClient client = new HttpSolrClient(path);\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    SolrCore leaderCore = null;\n    for (JettySolrRunner jetty : jettys) {\n      CoreContainer container = jetty.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          leaderCore = core;\n          break;\n        }\n      }\n    }\n    assertNotNull(leaderCore);\n\n    //All queries should be served by the active replica\n    //To make sure that's true we keep querying the down replica\n    //If queries are getting processed by the down replica then the cluster state hasn't updated for that replica locally\n    //So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n    long count = 0;\n    while (true) {\n      count++;\n      client.query(new SolrQuery(\"*:*\"));\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      if (c == 1) {\n        break;  //cluster state has got update locally\n      } else {\n        Thread.sleep(100);\n      }\n\n      if (count > 10000) {\n        fail(\"After 10k queries we still see all requests being processed by the down replica\");\n      }\n    }\n\n    //Now we fire a few additional queries and make sure ALL of them\n    //are served by the active replica\n    int moreQueries = TestUtil.nextInt(random(), 4, 10);\n    count = 1; //Since 1 query has already hit the leader\n    for (int i=0; i<moreQueries; i++) {\n      client.query(new SolrQuery(\"*:*\"));\n      count++;\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      assertEquals(\"Query wasn't served by leader\", count, c);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    HttpSolrClient client = new HttpSolrClient(path);\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    SolrCore leaderCore = null;\n    for (JettySolrRunner jetty : jettys) {\n      CoreContainer container = jetty.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          leaderCore = core;\n          break;\n        }\n      }\n    }\n    assertNotNull(leaderCore);\n\n    //All queries should be served by the active replica\n    //To make sure that's true we keep querying the down replica\n    //If queries are getting processed by the down replica then the cluster state hasn't updated for that replica locally\n    //So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n    long count = 0;\n    while (true) {\n      count++;\n      client.query(new SolrQuery(\"*:*\"));\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      if (c == 1) {\n        break;  //cluster state has got update locally\n      } else {\n        Thread.sleep(100);\n      }\n\n      if (count > 10000) {\n        fail(\"After 10k queries we still see all requests being processed by the down replica\");\n      }\n    }\n\n    //Now we fire a few additional queries and make sure ALL of them\n    //are served by the active replica\n    int moreQueries = TestUtil.nextInt(random(), 4, 10);\n    count = 1; //Since 1 query has already hit the leader\n    for (int i=0; i<moreQueries; i++) {\n      client.query(new SolrQuery(\"*:*\"));\n      count++;\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      assertEquals(\"Query wasn't served by leader\", count, c);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().updateClusterState();\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    HttpSolrClient client = new HttpSolrClient(path);\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    SolrCore leaderCore = null;\n    for (JettySolrRunner jetty : jettys) {\n      CoreContainer container = jetty.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          leaderCore = core;\n          break;\n        }\n      }\n    }\n    assertNotNull(leaderCore);\n\n    //All queries should be served by the active replica\n    //To make sure that's true we keep querying the down replica\n    //If queries are getting processed by the down replica then the cluster state hasn't updated for that replica locally\n    //So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n    long count = 0;\n    while (true) {\n      count++;\n      client.query(new SolrQuery(\"*:*\"));\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      if (c == 1) {\n        break;  //cluster state has got update locally\n      } else {\n        Thread.sleep(100);\n      }\n\n      if (count > 10000) {\n        fail(\"After 10k queries we still see all requests being processed by the down replica\");\n      }\n    }\n\n    //Now we fire a few additional queries and make sure ALL of them\n    //are served by the active replica\n    int moreQueries = TestUtil.nextInt(random(), 4, 10);\n    count = 1; //Since 1 query has already hit the leader\n    for (int i=0; i<moreQueries; i++) {\n      client.query(new SolrQuery(\"*:*\"));\n      count++;\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      assertEquals(\"Query wasn't served by leader\", count, c);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"859081acf00749f5dd462772c571d611d4a4d2db","date":1459527719,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = new HttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    HttpSolrClient client = new HttpSolrClient(path);\n    client.setSoTimeout(5000);\n    client.setConnectionTimeout(2000);\n\n    SolrCore leaderCore = null;\n    for (JettySolrRunner jetty : jettys) {\n      CoreContainer container = jetty.getCoreContainer();\n      for (SolrCore core : container.getCores()) {\n        if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n          leaderCore = core;\n          break;\n        }\n      }\n    }\n    assertNotNull(leaderCore);\n\n    //All queries should be served by the active replica\n    //To make sure that's true we keep querying the down replica\n    //If queries are getting processed by the down replica then the cluster state hasn't updated for that replica locally\n    //So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n    long count = 0;\n    while (true) {\n      count++;\n      client.query(new SolrQuery(\"*:*\"));\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      if (c == 1) {\n        break;  //cluster state has got update locally\n      } else {\n        Thread.sleep(100);\n      }\n\n      if (count > 10000) {\n        fail(\"After 10k queries we still see all requests being processed by the down replica\");\n      }\n    }\n\n    //Now we fire a few additional queries and make sure ALL of them\n    //are served by the active replica\n    int moreQueries = TestUtil.nextInt(random(), 4, 10);\n    count = 1; //Since 1 query has already hit the leader\n    for (int i=0; i<moreQueries; i++) {\n      client.query(new SolrQuery(\"*:*\"));\n      count++;\n\n      SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n      long c = (long) select.getStatistics().get(\"requests\");\n\n      assertEquals(\"Query wasn't served by leader\", count, c);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = new HttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = new HttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz Krasiski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active reploca\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"816521ebaad5add9cb96bb88c577394e2938c40b","date":1491931343,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreDescriptor().getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreDescriptor().getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        SolrRequestHandler select = leaderCore.getRequestHandler(\"\");\n        long c = (long) select.getStatistics().get(\"requests\");\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac97ea104d893f16aab430d9904473bc1f233f3c","date":1496249396,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3217321f3e1d7922898c6c633d17acfa840d6875","date":1496257480,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f","date":1496281877,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    new CollectionAdminRequest.Create()\n        .setCollectionName(\"football\")\n        .setNumShards(1)\n        .setReplicationFactor(2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"197bbedf08450ade98a11f4a0001448059666bec","date":1498534625,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","date":1498540685,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ff704ef91e9ae30ca59babb23ece85720701b60","date":1498684964,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\",1,2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY.standard\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43d1e498704edd2bba13548a189eed4dfccff11b","date":1499143458,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ea161f828a3a7a6eb9410a431aecda6d7ab1065","date":1499213384,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path)) {\n      client.setSoTimeout(5000);\n      client.setConnectionTimeout(2000);\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getCollection(\"football\").getSlice(\"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":["791c4fb1ff970967cf1802cf4d4875ba12c2eb01"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getCollection(\"football\").getSlice(\"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getSlice(\"football\", \"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e","date":1505888025,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getCollection(\"football\").getSlice(\"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    ZkDistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getCollection(\"football\").getSlice(\"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getCollection(\"football\").getSlice(\"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    ZkDistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getCollection(\"football\").getSlice(\"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    DistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getCollection(\"football\").getSlice(\"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    ZkDistributedQueue q = jettys.get(0).getCoreContainer().getZkController().getOverseer().getStateUpdateQueue();\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getCollection(\"football\").getSlice(\"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    ZkDistributedQueue q = Overseer.getStateUpdateQueue(cloudClient.getZkStateReader().getZkClient());\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":["89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestRandomRequestDistribution#testQueryAgainstDownReplica().mjava","sourceNew":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getCollection(\"football\").getSlice(\"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    }\n    ZkDistributedQueue q = jettys.get(0).getCoreContainer().getZkController().getOverseer().getStateUpdateQueue();\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path={}\", path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Asserts that requests against a collection are only served by a 'active' local replica\n   */\n  private void testQueryAgainstDownReplica() throws Exception {\n\n    log.info(\"Creating collection 'football' with 1 shard and 2 replicas\");\n    CollectionAdminRequest.createCollection(\"football\", \"conf1\", 1, 2)\n        .setCreateNodeSet(nodeNames.get(0) + ',' + nodeNames.get(1))\n        .process(cloudClient);\n\n    waitForRecoveriesToFinish(\"football\", true);\n\n    cloudClient.getZkStateReader().forceUpdateCollection(\"football\");\n\n    Replica leader = null;\n    Replica notLeader = null;\n\n    Collection<Replica> replicas = cloudClient.getZkStateReader().getClusterState().getCollection(\"football\").getSlice(\"shard1\").getReplicas();\n    for (Replica replica : replicas) {\n      if (replica.getStr(ZkStateReader.LEADER_PROP) != null) {\n        leader = replica;\n      } else {\n        notLeader = replica;\n      }\n    }\n\n    //Simulate a replica being in down state.\n    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.STATE.toLower(),\n        ZkStateReader.BASE_URL_PROP, notLeader.getStr(ZkStateReader.BASE_URL_PROP),\n        ZkStateReader.NODE_NAME_PROP, notLeader.getStr(ZkStateReader.NODE_NAME_PROP),\n        ZkStateReader.COLLECTION_PROP, \"football\",\n        ZkStateReader.SHARD_ID_PROP, \"shard1\",\n        ZkStateReader.CORE_NAME_PROP, notLeader.getStr(ZkStateReader.CORE_NAME_PROP),\n        ZkStateReader.ROLES_PROP, \"\",\n        ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());\n\n    log.info(\"Forcing {} to go into 'down' state\", notLeader.getStr(ZkStateReader.CORE_NAME_PROP));\n    ZkDistributedQueue q = jettys.get(0).getCoreContainer().getZkController().getOverseer().getStateUpdateQueue();\n    q.offer(Utils.toJSON(m));\n\n    verifyReplicaStatus(cloudClient.getZkStateReader(), \"football\", \"shard1\", notLeader.getName(), Replica.State.DOWN);\n\n    //Query against the node which hosts the down replica\n\n    String baseUrl = notLeader.getStr(ZkStateReader.BASE_URL_PROP);\n    if (!baseUrl.endsWith(\"/\")) baseUrl += \"/\";\n    String path = baseUrl + \"football\";\n    log.info(\"Firing queries against path=\" + path);\n    try (HttpSolrClient client = getHttpSolrClient(path, 2000, 5000)) {\n\n      SolrCore leaderCore = null;\n      for (JettySolrRunner jetty : jettys) {\n        CoreContainer container = jetty.getCoreContainer();\n        for (SolrCore core : container.getCores()) {\n          if (core.getName().equals(leader.getStr(ZkStateReader.CORE_NAME_PROP))) {\n            leaderCore = core;\n            break;\n          }\n        }\n      }\n      assertNotNull(leaderCore);\n\n      SolrMetricManager leaderMetricManager = leaderCore.getCoreContainer().getMetricManager();\n      String leaderRegistry = leaderCore.getCoreMetricManager().getRegistryName();\n      Counter cnt = leaderMetricManager.counter(null, leaderRegistry, \"requests\", \"QUERY./select\");\n\n      // All queries should be served by the active replica\n      // To make sure that's true we keep querying the down replica\n      // If queries are getting processed by the down replica then the cluster state hasn't updated for that replica\n      // locally\n      // So we keep trying till it has updated and then verify if ALL queries go to the active replica\n      long count = 0;\n      while (true) {\n        count++;\n        client.query(new SolrQuery(\"*:*\"));\n\n        long c = cnt.getCount();\n\n        if (c == 1) {\n          break; // cluster state has got update locally\n        } else {\n          Thread.sleep(100);\n        }\n\n        if (count > 10000) {\n          fail(\"After 10k queries we still see all requests being processed by the down replica\");\n        }\n      }\n\n      // Now we fire a few additional queries and make sure ALL of them\n      // are served by the active replica\n      int moreQueries = TestUtil.nextInt(random(), 4, 10);\n      count = 1; // Since 1 query has already hit the leader\n      for (int i = 0; i < moreQueries; i++) {\n        client.query(new SolrQuery(\"*:*\"));\n        count++;\n\n        long c = cnt.getCount();\n\n        assertEquals(\"Query wasn't served by leader\", count, c);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"af2638813028b254a88b418ebeafb541afb49653":["5a64d7356125ada6ba003de26604826588561d24","19498030e0adab22f604f935cae3c03dcf0952a6"],"197bbedf08450ade98a11f4a0001448059666bec":["42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"344b0840364d990b29b97467bfcc766ff8325d11":["43d1e498704edd2bba13548a189eed4dfccff11b"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["859081acf00749f5dd462772c571d611d4a4d2db"],"791c4fb1ff970967cf1802cf4d4875ba12c2eb01":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["af2638813028b254a88b418ebeafb541afb49653"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","0158ced21948b6626f733c1c42c1e18d94449789"],"43d1e498704edd2bba13548a189eed4dfccff11b":["28288370235ed02234a64753cdbf0c6ec096304a"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["30c8e5574b55d57947e989443dfde611646530ee","43d1e498704edd2bba13548a189eed4dfccff11b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4":["e9017cf144952056066919f1ebc7897ff9bd71b1","197bbedf08450ade98a11f4a0001448059666bec"],"ac97ea104d893f16aab430d9904473bc1f233f3c":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"30c8e5574b55d57947e989443dfde611646530ee":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","28288370235ed02234a64753cdbf0c6ec096304a"],"3217321f3e1d7922898c6c633d17acfa840d6875":["729cb470f975115d4c60517b2cb7c42e37a7a2e1","ac97ea104d893f16aab430d9904473bc1f233f3c"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["816521ebaad5add9cb96bb88c577394e2938c40b"],"816521ebaad5add9cb96bb88c577394e2938c40b":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"28288370235ed02234a64753cdbf0c6ec096304a":["3217321f3e1d7922898c6c633d17acfa840d6875","5ff704ef91e9ae30ca59babb23ece85720701b60"],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["729cb470f975115d4c60517b2cb7c42e37a7a2e1","3217321f3e1d7922898c6c633d17acfa840d6875"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","d470c8182e92b264680e34081b75e70a9f2b3c89"],"19498030e0adab22f604f935cae3c03dcf0952a6":["5a64d7356125ada6ba003de26604826588561d24"],"859081acf00749f5dd462772c571d611d4a4d2db":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065","344b0840364d990b29b97467bfcc766ff8325d11"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"1088b72b3b4cc45316b7595bd09023c859cd2327":["791c4fb1ff970967cf1802cf4d4875ba12c2eb01"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["859081acf00749f5dd462772c571d611d4a4d2db","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e":["344b0840364d990b29b97467bfcc766ff8325d11"],"5a64d7356125ada6ba003de26604826588561d24":["1088b72b3b4cc45316b7595bd09023c859cd2327"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"0158ced21948b6626f733c1c42c1e18d94449789":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"5ff704ef91e9ae30ca59babb23ece85720701b60":["197bbedf08450ade98a11f4a0001448059666bec"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"af2638813028b254a88b418ebeafb541afb49653":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"197bbedf08450ade98a11f4a0001448059666bec":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","5ff704ef91e9ae30ca59babb23ece85720701b60"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"344b0840364d990b29b97467bfcc766ff8325d11":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","89c102d671c256ef8dd67b3ecb3ab96fe7a8006e"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"791c4fb1ff970967cf1802cf4d4875ba12c2eb01":["1088b72b3b4cc45316b7595bd09023c859cd2327"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["859081acf00749f5dd462772c571d611d4a4d2db"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","816521ebaad5add9cb96bb88c577394e2938c40b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"43d1e498704edd2bba13548a189eed4dfccff11b":["344b0840364d990b29b97467bfcc766ff8325d11","2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["791c4fb1ff970967cf1802cf4d4875ba12c2eb01"],"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4":["30c8e5574b55d57947e989443dfde611646530ee"],"ac97ea104d893f16aab430d9904473bc1f233f3c":["3217321f3e1d7922898c6c633d17acfa840d6875"],"30c8e5574b55d57947e989443dfde611646530ee":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"3217321f3e1d7922898c6c633d17acfa840d6875":["28288370235ed02234a64753cdbf0c6ec096304a","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["197bbedf08450ade98a11f4a0001448059666bec","e9017cf144952056066919f1ebc7897ff9bd71b1"],"28288370235ed02234a64753cdbf0c6ec096304a":["43d1e498704edd2bba13548a189eed4dfccff11b","30c8e5574b55d57947e989443dfde611646530ee"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["ac97ea104d893f16aab430d9904473bc1f233f3c","3217321f3e1d7922898c6c633d17acfa840d6875","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"816521ebaad5add9cb96bb88c577394e2938c40b":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"19498030e0adab22f604f935cae3c03dcf0952a6":["af2638813028b254a88b418ebeafb541afb49653"],"859081acf00749f5dd462772c571d611d4a4d2db":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["6240b74b884c5587f2a4062dd27d6c32bf228889"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"1088b72b3b4cc45316b7595bd09023c859cd2327":["5a64d7356125ada6ba003de26604826588561d24"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["d470c8182e92b264680e34081b75e70a9f2b3c89","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0158ced21948b6626f733c1c42c1e18d94449789"],"89c102d671c256ef8dd67b3ecb3ab96fe7a8006e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","6240b74b884c5587f2a4062dd27d6c32bf228889"],"5a64d7356125ada6ba003de26604826588561d24":["af2638813028b254a88b418ebeafb541afb49653","19498030e0adab22f604f935cae3c03dcf0952a6"],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"5ff704ef91e9ae30ca59babb23ece85720701b60":["28288370235ed02234a64753cdbf0c6ec096304a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}