{"path":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","commits":[{"id":"bdac0dff04219451c7511d62225080a93a0181ea","date":1451212020,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc    A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid  The lucene docid of the document to be populated\n   * @param fields The list of docValues fields to be decorated\n   */\n  @SuppressWarnings(\"deprecation\")\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid,\n                                     Set<String> fields) throws IOException {\n    for (String fieldName : fields) {\n      SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: {}, schemaField: {}\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        SortedSetDocValues values = getLeafReader().getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0 &&\n            DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n          values.setDocument(docid);\n          List<Object> outValues = new LinkedList<Object>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            if (schemaField.getType() instanceof TrieIntField) {\n              outValues.add(LegacyNumericUtils.prefixCodedToInt(values.lookupOrd(ord)));\n            } else if (schemaField.getType() instanceof TrieLongField) {\n              outValues.add(LegacyNumericUtils.prefixCodedToLong(values.lookupOrd(ord)));\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              outValues.add(LegacyNumericUtils.sortableIntToFloat(LegacyNumericUtils.prefixCodedToInt(values.lookupOrd(ord))));\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              outValues.add(LegacyNumericUtils.sortableLongToDouble(LegacyNumericUtils.prefixCodedToLong(values.lookupOrd(ord))));\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              outValues.add(new Date(LegacyNumericUtils.prefixCodedToLong(values.lookupOrd(ord))));\n            } else if (schemaField.getType() instanceof EnumField) {\n              outValues.add(((EnumField) schemaField.getType()).intValueToStringValue(\n                  LegacyNumericUtils.prefixCodedToInt(values.lookupOrd(ord))));\n            } else if (schemaField.getType() instanceof StrField) {\n              outValues.add(values.lookupOrd(ord).utf8ToString());\n            }\n          }\n          if (outValues.size() > 0)\n            doc.addField(fieldName, outValues);\n        }\n      } else {\n        DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            if (DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n              NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n              Object val = ndv.get(docid);\n              if (schemaField.getType() instanceof TrieIntField) {\n                val = ((Long) val).intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                val = NumericUtils.sortableIntToFloat(((Long) val).intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                val = NumericUtils.sortableLongToDouble((long) val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                val = new Date((long) val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                val = ((EnumField) schemaField.getType()).intValueToStringValue(((Long) val).intValue());\n              }\n              doc.addField(fieldName, val);\n            }\n            break;\n          case BINARY:\n            if (DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n              BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n              doc.addField(fieldName, bdv.get(docid));\n            }\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv.getOrd(docid) >= 0) {\n              doc.addField(fieldName, sdv.get(docid).utf8ToString());\n            }\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac9de183adbc9483681f275ac1e2d92ed19f52e1","date":1452414626,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final LeafReader reader = getLeafReader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (!DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = reader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          values.setDocument(docid);\n          final List<Object> outValues = new LinkedList<Object>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            final BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          if (outValues.size() > 0) doc.addField(fieldName, outValues);\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            Long val = ndv.get(docid);\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = NumericUtils.sortableIntToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = NumericUtils.sortableLongToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            doc.addField(fieldName, bdv.get(docid));\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv.getOrd(docid) >= 0) {\n              doc.addField(fieldName, sdv.get(docid).utf8ToString());\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            // Shouldn't happen since we check that the document has a DocValues field.\n            throw new AssertionError(\"Document does not have a DocValues field with the name '\" + fieldName + \"'!\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc    A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid  The lucene docid of the document to be populated\n   * @param fields The list of docValues fields to be decorated\n   */\n  @SuppressWarnings(\"deprecation\")\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid,\n                                     Set<String> fields) throws IOException {\n    for (String fieldName : fields) {\n      SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: {}, schemaField: {}\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        SortedSetDocValues values = getLeafReader().getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0 &&\n            DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n          values.setDocument(docid);\n          List<Object> outValues = new LinkedList<Object>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            if (schemaField.getType() instanceof TrieIntField) {\n              outValues.add(LegacyNumericUtils.prefixCodedToInt(values.lookupOrd(ord)));\n            } else if (schemaField.getType() instanceof TrieLongField) {\n              outValues.add(LegacyNumericUtils.prefixCodedToLong(values.lookupOrd(ord)));\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              outValues.add(LegacyNumericUtils.sortableIntToFloat(LegacyNumericUtils.prefixCodedToInt(values.lookupOrd(ord))));\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              outValues.add(LegacyNumericUtils.sortableLongToDouble(LegacyNumericUtils.prefixCodedToLong(values.lookupOrd(ord))));\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              outValues.add(new Date(LegacyNumericUtils.prefixCodedToLong(values.lookupOrd(ord))));\n            } else if (schemaField.getType() instanceof EnumField) {\n              outValues.add(((EnumField) schemaField.getType()).intValueToStringValue(\n                  LegacyNumericUtils.prefixCodedToInt(values.lookupOrd(ord))));\n            } else if (schemaField.getType() instanceof StrField) {\n              outValues.add(values.lookupOrd(ord).utf8ToString());\n            }\n          }\n          if (outValues.size() > 0)\n            doc.addField(fieldName, outValues);\n        }\n      } else {\n        DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            if (DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n              NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n              Object val = ndv.get(docid);\n              if (schemaField.getType() instanceof TrieIntField) {\n                val = ((Long) val).intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                val = NumericUtils.sortableIntToFloat(((Long) val).intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                val = NumericUtils.sortableLongToDouble((long) val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                val = new Date((long) val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                val = ((EnumField) schemaField.getType()).intValueToStringValue(((Long) val).intValue());\n              }\n              doc.addField(fieldName, val);\n            }\n            break;\n          case BINARY:\n            if (DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n              BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n              doc.addField(fieldName, bdv.get(docid));\n            }\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv.getOrd(docid) >= 0) {\n              doc.addField(fieldName, sdv.get(docid).utf8ToString());\n            }\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a83d6857d62b422f79747a834cfbfdc1610fd515","date":1458168983,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final LeafReader reader = getLeafReader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (!DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = reader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          values.setDocument(docid);\n          final List<Object> outValues = new LinkedList<Object>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            final BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          if (outValues.size() > 0) doc.addField(fieldName, outValues);\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            Long val = ndv.get(docid);\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            doc.addField(fieldName, bdv.get(docid));\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv.getOrd(docid) >= 0) {\n              doc.addField(fieldName, sdv.get(docid).utf8ToString());\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            // Shouldn't happen since we check that the document has a DocValues field.\n            throw new AssertionError(\"Document does not have a DocValues field with the name '\" + fieldName + \"'!\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final LeafReader reader = getLeafReader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (!DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = reader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          values.setDocument(docid);\n          final List<Object> outValues = new LinkedList<Object>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            final BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          if (outValues.size() > 0) doc.addField(fieldName, outValues);\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            Long val = ndv.get(docid);\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = NumericUtils.sortableIntToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = NumericUtils.sortableLongToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            doc.addField(fieldName, bdv.get(docid));\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv.getOrd(docid) >= 0) {\n              doc.addField(fieldName, sdv.get(docid).utf8ToString());\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            // Shouldn't happen since we check that the document has a DocValues field.\n            throw new AssertionError(\"Document does not have a DocValues field with the name '\" + fieldName + \"'!\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5","date":1465691899,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final LeafReader reader = getLeafReader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (!DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = reader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          values.setDocument(docid);\n          final List<Object> outValues = new LinkedList<Object>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            final BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          if (outValues.size() > 0) doc.addField(fieldName, outValues);\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            Long val = ndv.get(docid);\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            doc.addField(fieldName, bdv.get(docid));\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            int ord = sdv.getOrd(docid);\n            if (ord >= 0) {\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                final BytesRef bRef = sdv.lookupOrd(ord);\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, sdv.get(docid).utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            // Shouldn't happen since we check that the document has a DocValues field.\n            throw new AssertionError(\"Document does not have a DocValues field with the name '\" + fieldName + \"'!\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final LeafReader reader = getLeafReader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (!DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = reader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          values.setDocument(docid);\n          final List<Object> outValues = new LinkedList<Object>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            final BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          if (outValues.size() > 0) doc.addField(fieldName, outValues);\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            Long val = ndv.get(docid);\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            doc.addField(fieldName, bdv.get(docid));\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv.getOrd(docid) >= 0) {\n              doc.addField(fieldName, sdv.get(docid).utf8ToString());\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            // Shouldn't happen since we check that the document has a DocValues field.\n            throw new AssertionError(\"Document does not have a DocValues field with the name '\" + fieldName + \"'!\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final LeafReader reader = getLeafReader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = reader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(docid) == docid) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            Long val;\n            if (ndv.advance(docid) == docid) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            BytesRef value;\n            if (bdv.advance(docid) == docid) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv.advance(docid) == docid) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final LeafReader reader = getLeafReader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (!DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = reader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          values.setDocument(docid);\n          final List<Object> outValues = new LinkedList<Object>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            final BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          if (outValues.size() > 0) doc.addField(fieldName, outValues);\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            Long val = ndv.get(docid);\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            doc.addField(fieldName, bdv.get(docid));\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            int ord = sdv.getOrd(docid);\n            if (ord >= 0) {\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                final BytesRef bRef = sdv.lookupOrd(ord);\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, sdv.get(docid).utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            // Shouldn't happen since we check that the document has a DocValues field.\n            throw new AssertionError(\"Document does not have a DocValues field with the name '\" + fieldName + \"'!\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final LeafReader reader = getLeafReader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = reader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(docid) == docid) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            Long val;\n            if (ndv.advance(docid) == docid) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            BytesRef value;\n            if (bdv.advance(docid) == docid) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv.advance(docid) == docid) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final LeafReader reader = getLeafReader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (!DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = reader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          values.setDocument(docid);\n          final List<Object> outValues = new LinkedList<Object>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            final BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          if (outValues.size() > 0) doc.addField(fieldName, outValues);\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            Long val = ndv.get(docid);\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            doc.addField(fieldName, bdv.get(docid));\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            int ord = sdv.getOrd(docid);\n            if (ord >= 0) {\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                final BytesRef bRef = sdv.lookupOrd(ord);\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, sdv.get(docid).utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            // Shouldn't happen since we check that the document has a DocValues field.\n            throw new AssertionError(\"Document does not have a DocValues field with the name '\" + fieldName + \"'!\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e07c409cff8701e4dc3d45934b021a949a5a8822","date":1475694629,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advance(localId) == localId) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advance(localId) == localId) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advance(localId) == localId) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final LeafReader reader = getLeafReader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = reader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(docid) == docid) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            Long val;\n            if (ndv.advance(docid) == docid) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            BytesRef value;\n            if (bdv.advance(docid) == docid) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv.advance(docid) == docid) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advance(localId) == localId) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advance(localId) == localId) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advance(localId) == localId) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final LeafReader reader = getLeafReader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (!DocValues.getDocsWithField(leafReader, fieldName).get(docid)) {\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = reader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          values.setDocument(docid);\n          final List<Object> outValues = new LinkedList<Object>();\n          for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n            final BytesRef value = values.lookupOrd(ord);\n            outValues.add(schemaField.getType().toObject(schemaField, value));\n          }\n          if (outValues.size() > 0) doc.addField(fieldName, outValues);\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            Long val = ndv.get(docid);\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            doc.addField(fieldName, bdv.get(docid));\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv.getOrd(docid) >= 0) {\n              doc.addField(fieldName, sdv.get(docid).utf8ToString());\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            // Shouldn't happen since we check that the document has a DocValues field.\n            throw new AssertionError(\"Document does not have a DocValues field with the name '\" + fieldName + \"'!\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11134e449dabe11d6d0ff6a564d84b82cbe93722","date":1477299083,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advance(localId) == localId) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advance(localId) == localId) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advance(localId) == localId) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2714c85633b642b29871cf5ff8d17d3ba7bfd76","date":1477307753,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advance(localId) == localId) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advance(localId) == localId) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advance(localId) == localId) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advance(localId) == localId) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advance(localId) == localId) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advance(localId) == localId) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46dc9ac8b3e748407baaef82453138ff3974480c","date":1484789241,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              PointField.PointTypes type = ((PointField)schemaField.getType()).getType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cdd24a5b48ffd59f921ccc4f5199fc029f65797","date":1485039431,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              NumericFieldType.NumberType type = ((PointField)schemaField.getType()).getType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              PointField.PointTypes type = ((PointField)schemaField.getType()).getType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              NumericFieldType.NumberType type = ((PointField)schemaField.getType()).getType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n        if (fi == null) {\n          continue; // Searcher doesn't have info about this field, hence ignore it.\n        }\n        final DocValuesType dvType = fi.getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              NumericFieldType.NumberType type = ((PointField)schemaField.getType()).getType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              NumericFieldType.NumberType type = ((PointField)schemaField.getType()).getType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n        if (fi == null) {\n          continue; // Searcher doesn't have info about this field, hence ignore it.\n        }\n        final DocValuesType dvType = fi.getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              NumericFieldType.NumberType type = ((PointField)schemaField.getType()).getType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              NumericFieldType.NumberType type = ((PointField)schemaField.getType()).getType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d81baa64023bbb9b43f6d929ee168b105940d30","date":1486492702,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n        if (fi == null) {\n          continue; // Searcher doesn't have info about this field, hence ignore it.\n        }\n        final DocValuesType dvType = fi.getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              NumberType type = schemaField.getType().getNumberType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n        if (fi == null) {\n          continue; // Searcher doesn't have info about this field, hence ignore it.\n        }\n        final DocValuesType dvType = fi.getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              NumericFieldType.NumberType type = ((PointField)schemaField.getType()).getType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"744b111b17d15d490a648eb021bfa240e7f11556","date":1487008069,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    newVal = new Date(number);\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n        if (fi == null) {\n          continue; // Searcher doesn't have info about this field, hence ignore it.\n        }\n        final DocValuesType dvType = fi.getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              NumberType type = schemaField.getType().getNumberType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"022a4de90e0479b604264ca9c2e134c996454ab3","date":1487118265,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    newVal = new Date(number);\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n        if (fi == null) {\n          continue; // Searcher doesn't have info about this field, hence ignore it.\n        }\n        final DocValuesType dvType = fi.getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              NumberType type = schemaField.getType().getNumberType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96","date":1487122334,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n        if (fi == null) {\n          continue; // Searcher doesn't have info about this field, hence ignore it.\n        }\n        final DocValuesType dvType = fi.getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              NumberType type = schemaField.getType().getNumberType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    newVal = new Date(number);\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"897b06b1364bd1f658a8be7591e43f0851458e7f","date":1487123008,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    newVal = new Date(number);\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n\n      if (schemaField.multiValued()) {\n        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n        if (values != null && values.getValueCount() > 0) {\n          if (values.advance(localId) == localId) {\n            final List<Object> outValues = new LinkedList<Object>();\n            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n              final BytesRef value = values.lookupOrd(ord);\n              outValues.add(schemaField.getType().toObject(schemaField, value));\n            }\n            assert outValues.size() > 0;\n            doc.addField(fieldName, outValues);\n          }\n        }\n      } else {\n        FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n        if (fi == null) {\n          continue; // Searcher doesn't have info about this field, hence ignore it.\n        }\n        final DocValuesType dvType = fi.getDocValuesType();\n        switch (dvType) {\n          case NUMERIC:\n            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n            if (ndv == null) {\n              continue;\n            }\n            Long val;\n            if (ndv.advanceExact(localId)) {\n              val = ndv.longValue();\n            } else {\n              continue;\n            }\n            Object newVal = val;\n            if (schemaField.getType().isPointField()) {\n              NumberType type = schemaField.getType().getNumberType(); \n              switch (type) {\n                case INTEGER:\n                  newVal = val.intValue();\n                  break;\n                case LONG:\n                  newVal = val.longValue();\n                  break;\n                case FLOAT:\n                  newVal = Float.intBitsToFloat(val.intValue());\n                  break;\n                case DOUBLE:\n                  newVal = Double.longBitsToDouble(val);\n                  break;\n                case DATE:\n                  newVal = new Date(val);\n                  break;\n                default:\n                  throw new AssertionError(\"Unexpected PointType: \" + type);\n              }\n            } else {\n              if (schemaField.getType() instanceof TrieIntField) {\n                newVal = val.intValue();\n              } else if (schemaField.getType() instanceof TrieFloatField) {\n                newVal = Float.intBitsToFloat(val.intValue());\n              } else if (schemaField.getType() instanceof TrieDoubleField) {\n                newVal = Double.longBitsToDouble(val);\n              } else if (schemaField.getType() instanceof TrieDateField) {\n                newVal = new Date(val);\n              } else if (schemaField.getType() instanceof EnumField) {\n                newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n              }\n            }\n            doc.addField(fieldName, newVal);\n            break;\n          case BINARY:\n            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n            if (bdv == null) {\n              continue;\n            }\n            BytesRef value;\n            if (bdv.advanceExact(localId)) {\n              value = BytesRef.deepCopyOf(bdv.binaryValue());\n            } else {\n              continue;\n            }\n            doc.addField(fieldName, value);\n            break;\n          case SORTED:\n            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n            if (sdv == null) {\n              continue;\n            }\n            if (sdv.advanceExact(localId)) {\n              final BytesRef bRef = sdv.binaryValue();\n              // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n              if (schemaField.getType() instanceof BoolField) {\n                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n              } else {\n                doc.addField(fieldName, bRef.utf8ToString());\n              }\n            }\n            break;\n          case SORTED_NUMERIC:\n            throw new AssertionError(\"SORTED_NUMERIC not supported yet!\");\n          case SORTED_SET:\n            throw new AssertionError(\"SORTED_SET fields should be multi-valued!\");\n          case NONE:\n            break;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"daa9f76a48e97bb2d40fc67ecdaad33d166d596e","date":1488856307,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    newVal = new Date(number);\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4958642f967bfbd6f083ddf50f141bcde89b9ec1","date":1489572234,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val;\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bca83a747f8e297ee4412c0d18bdd3a98c09df3b","date":1489651910,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val;\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val;\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"63a9344cff6a72bc4c1ef080c69e10ad0635b811","date":1490410892,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val;\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de548de3ce5405595899f548152d4b93ac9eb9cc","date":1490594650,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrDocumentFetcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#decorateDocValueFields(SolrDocumentBase,int,Set[String]).mjava","sourceNew":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final List<LeafReaderContext> leafContexts = searcher.getLeafContexts();\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = searcher.getSchema().getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = searcher.getFieldInfos().fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val.longValue();\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument\n   *\n   * @param doc\n   *          A SolrDocument or SolrInputDocument instance where docValues will be added\n   * @param docid\n   *          The lucene docid of the document to be populated\n   * @param fields\n   *          The list of docValues fields to be decorated\n   */\n  public void decorateDocValueFields(@SuppressWarnings(\"rawtypes\") SolrDocumentBase doc, int docid, Set<String> fields)\n      throws IOException {\n    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);\n    final int localId = docid - leafContexts.get(subIndex).docBase;\n    final LeafReader leafReader = leafContexts.get(subIndex).reader();\n    for (String fieldName : fields) {\n      final SchemaField schemaField = schema.getFieldOrNull(fieldName);\n      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {\n        log.warn(\"Couldn't decorate docValues for field: [{}], schemaField: [{}]\", fieldName, schemaField);\n        continue;\n      }\n      FieldInfo fi = fieldInfos.fieldInfo(fieldName);\n      if (fi == null) {\n        continue; // Searcher doesn't have info about this field, hence ignore it.\n      }\n      final DocValuesType dvType = fi.getDocValuesType();\n      switch (dvType) {\n        case NUMERIC:\n          final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);\n          if (ndv == null) {\n            continue;\n          }\n          Long val;\n          if (ndv.advanceExact(localId)) {\n            val = ndv.longValue();\n          } else {\n            continue;\n          }\n          Object newVal = val;\n          if (schemaField.getType().isPointField()) {\n            // TODO: Maybe merge PointField with TrieFields here\n            NumberType type = schemaField.getType().getNumberType();\n            switch (type) {\n              case INTEGER:\n                newVal = val.intValue();\n                break;\n              case LONG:\n                newVal = val;\n                break;\n              case FLOAT:\n                newVal = Float.intBitsToFloat(val.intValue());\n                break;\n              case DOUBLE:\n                newVal = Double.longBitsToDouble(val);\n                break;\n              case DATE:\n                newVal = new Date(val);\n                break;\n              default:\n                throw new AssertionError(\"Unexpected PointType: \" + type);\n            }\n          } else {\n            if (schemaField.getType() instanceof TrieIntField) {\n              newVal = val.intValue();\n            } else if (schemaField.getType() instanceof TrieFloatField) {\n              newVal = Float.intBitsToFloat(val.intValue());\n            } else if (schemaField.getType() instanceof TrieDoubleField) {\n              newVal = Double.longBitsToDouble(val);\n            } else if (schemaField.getType() instanceof TrieDateField) {\n              newVal = new Date(val);\n            } else if (schemaField.getType() instanceof EnumField) {\n              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());\n            }\n          }\n          doc.addField(fieldName, newVal);\n          break;\n        case BINARY:\n          BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);\n          if (bdv == null) {\n            continue;\n          }\n          BytesRef value;\n          if (bdv.advanceExact(localId)) {\n            value = BytesRef.deepCopyOf(bdv.binaryValue());\n          } else {\n            continue;\n          }\n          doc.addField(fieldName, value);\n          break;\n        case SORTED:\n          SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);\n          if (sdv == null) {\n            continue;\n          }\n          if (sdv.advanceExact(localId)) {\n            final BytesRef bRef = sdv.binaryValue();\n            // Special handling for Boolean fields since they're stored as 'T' and 'F'.\n            if (schemaField.getType() instanceof BoolField) {\n              doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));\n            } else {\n              doc.addField(fieldName, bRef.utf8ToString());\n            }\n          }\n          break;\n        case SORTED_NUMERIC:\n          final SortedNumericDocValues numericDv = leafReader.getSortedNumericDocValues(fieldName);\n          NumberType type = schemaField.getType().getNumberType();\n          if (numericDv != null) {\n            if (numericDv.advance(localId) == localId) {\n              final List<Object> outValues = new ArrayList<Object>(numericDv.docValueCount());\n              for (int i = 0; i < numericDv.docValueCount(); i++) {\n                long number = numericDv.nextValue();\n                switch (type) {\n                  case INTEGER:\n                    outValues.add((int)number);\n                    break;\n                  case LONG:\n                    outValues.add(number);\n                    break;\n                  case FLOAT:\n                    outValues.add(NumericUtils.sortableIntToFloat((int)number));\n                    break;\n                  case DOUBLE:\n                    outValues.add(NumericUtils.sortableLongToDouble(number));\n                    break;\n                  case DATE:\n                    outValues.add(new Date(number));\n                    break;\n                  default:\n                    throw new AssertionError(\"Unexpected PointType: \" + type);\n                }\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case SORTED_SET:\n          final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);\n          if (values != null && values.getValueCount() > 0) {\n            if (values.advance(localId) == localId) {\n              final List<Object> outValues = new LinkedList<Object>();\n              for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {\n                value = values.lookupOrd(ord);\n                outValues.add(schemaField.getType().toObject(schemaField, value));\n              }\n              assert outValues.size() > 0;\n              doc.addField(fieldName, outValues);\n            }\n          }\n        case NONE:\n          break;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"598b5d23aa7c9732bf473c21a9cd309c44599394":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","415bbbe7da8065dd3c477bdc3c703c6425622998"],"a83d6857d62b422f79747a834cfbfdc1610fd515":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"63a9344cff6a72bc4c1ef080c69e10ad0635b811":["4958642f967bfbd6f083ddf50f141bcde89b9ec1"],"7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5":["a83d6857d62b422f79747a834cfbfdc1610fd515"],"bdac0dff04219451c7511d62225080a93a0181ea":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"022a4de90e0479b604264ca9c2e134c996454ab3":["3d81baa64023bbb9b43f6d929ee168b105940d30","744b111b17d15d490a648eb021bfa240e7f11556"],"daa9f76a48e97bb2d40fc67ecdaad33d166d596e":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"bca83a747f8e297ee4412c0d18bdd3a98c09df3b":["daa9f76a48e97bb2d40fc67ecdaad33d166d596e"],"ab68488225b6a6c357dda72ed11dedca9914a192":["daa9f76a48e97bb2d40fc67ecdaad33d166d596e","bca83a747f8e297ee4412c0d18bdd3a98c09df3b"],"415bbbe7da8065dd3c477bdc3c703c6425622998":["3cdd24a5b48ffd59f921ccc4f5199fc029f65797"],"3cdd24a5b48ffd59f921ccc4f5199fc029f65797":["46dc9ac8b3e748407baaef82453138ff3974480c"],"4958642f967bfbd6f083ddf50f141bcde89b9ec1":["daa9f76a48e97bb2d40fc67ecdaad33d166d596e"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"de548de3ce5405595899f548152d4b93ac9eb9cc":["ab68488225b6a6c357dda72ed11dedca9914a192"],"46dc9ac8b3e748407baaef82453138ff3974480c":["d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"e07c409cff8701e4dc3d45934b021a949a5a8822":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["bdac0dff04219451c7511d62225080a93a0181ea"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a83d6857d62b422f79747a834cfbfdc1610fd515","e07c409cff8701e4dc3d45934b021a949a5a8822"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","3cdd24a5b48ffd59f921ccc4f5199fc029f65797"],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["022a4de90e0479b604264ca9c2e134c996454ab3"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"11134e449dabe11d6d0ff6a564d84b82cbe93722":["e07c409cff8701e4dc3d45934b021a949a5a8822"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"744b111b17d15d490a648eb021bfa240e7f11556":["3d81baa64023bbb9b43f6d929ee168b105940d30"],"d2714c85633b642b29871cf5ff8d17d3ba7bfd76":["e07c409cff8701e4dc3d45934b021a949a5a8822","11134e449dabe11d6d0ff6a564d84b82cbe93722"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["63a9344cff6a72bc4c1ef080c69e10ad0635b811"]},"commit2Childs":{"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"a83d6857d62b422f79747a834cfbfdc1610fd515":["7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"63a9344cff6a72bc4c1ef080c69e10ad0635b811":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7f1f5e4b31ec44927335e2ad6eebc4c1f8c0abf5":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"bdac0dff04219451c7511d62225080a93a0181ea":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"022a4de90e0479b604264ca9c2e134c996454ab3":["b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96"],"daa9f76a48e97bb2d40fc67ecdaad33d166d596e":["bca83a747f8e297ee4412c0d18bdd3a98c09df3b","ab68488225b6a6c357dda72ed11dedca9914a192","4958642f967bfbd6f083ddf50f141bcde89b9ec1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bdac0dff04219451c7511d62225080a93a0181ea"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["e07c409cff8701e4dc3d45934b021a949a5a8822"],"bca83a747f8e297ee4412c0d18bdd3a98c09df3b":["ab68488225b6a6c357dda72ed11dedca9914a192"],"ab68488225b6a6c357dda72ed11dedca9914a192":["de548de3ce5405595899f548152d4b93ac9eb9cc"],"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","3d81baa64023bbb9b43f6d929ee168b105940d30"],"3cdd24a5b48ffd59f921ccc4f5199fc029f65797":["415bbbe7da8065dd3c477bdc3c703c6425622998","90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"4958642f967bfbd6f083ddf50f141bcde89b9ec1":["63a9344cff6a72bc4c1ef080c69e10ad0635b811"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["daa9f76a48e97bb2d40fc67ecdaad33d166d596e"],"de548de3ce5405595899f548152d4b93ac9eb9cc":[],"46dc9ac8b3e748407baaef82453138ff3974480c":["3cdd24a5b48ffd59f921ccc4f5199fc029f65797"],"e07c409cff8701e4dc3d45934b021a949a5a8822":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","11134e449dabe11d6d0ff6a564d84b82cbe93722","d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["a83d6857d62b422f79747a834cfbfdc1610fd515"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["598b5d23aa7c9732bf473c21a9cd309c44599394"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"b49c0eb9ef7bc25609a89e7986ce7e6eeb9c9d96":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["022a4de90e0479b604264ca9c2e134c996454ab3","744b111b17d15d490a648eb021bfa240e7f11556"],"11134e449dabe11d6d0ff6a564d84b82cbe93722":["d2714c85633b642b29871cf5ff8d17d3ba7bfd76"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"744b111b17d15d490a648eb021bfa240e7f11556":["022a4de90e0479b604264ca9c2e134c996454ab3"],"d2714c85633b642b29871cf5ff8d17d3ba7bfd76":["46dc9ac8b3e748407baaef82453138ff3974480c","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","de548de3ce5405595899f548152d4b93ac9eb9cc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}