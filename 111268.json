{"path":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","commits":[{"id":"43b04c27924fe393e38e9f0986e32c634f261859","date":1284399440,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods())\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            m.getParameterTypes().length == 0 &&\n            m.getGenericReturnType() == Void.TYPE)\n          testMethods.add(new FrameworkMethod(m));\n      return testMethods;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9e89d520e3ed13b1c01bc576d841c2e8f6d66601","date":1284401513,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods())\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            (m.getModifiers() & (Modifier.STATIC|Modifier.ABSTRACT)) == 0 &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n          testMethods.add(new FrameworkMethod(m));\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods())\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            m.getParameterTypes().length == 0 &&\n            m.getGenericReturnType() == Void.TYPE)\n          testMethods.add(new FrameworkMethod(m));\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24bbea3efc4507c483f922462353c5994867de42","date":1284405081,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods())\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            (m.getModifiers() & (Modifier.STATIC|Modifier.ABSTRACT)) == 0 &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n          testMethods.add(new FrameworkMethod(m));\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87f526c8b71404bbf1d37be79633aa9ce2c3540b","date":1287162759,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      // check if the current test's class has methods annotated with @Ignore\n      final Class<?> clazz = getTestClass().getJavaClass();\n      for (Method m : clazz.getMethods()) {\n        Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"' \" + ignored.value());\n        }\n      }\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e42b97f2dcf8cca9bf6437e7d0dd3e8711f7413f","date":1287243791,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      // check if the current test's class has methods annotated with @Ignore\n      final Class<?> clazz = getTestClass().getJavaClass();\n      for (Method m : clazz.getMethods()) {\n        Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"' \" + ignored.value());\n        }\n      }\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74637427311cf2dd084ed0cf383acdb039c1823f","date":1287326839,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"274d6ef4fd75d246651078be2ff7ed3620a85221","date":1290009535,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eb7d492f3e2d5a27d05802bdf01781cbbb8d111","date":1291982465,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = getTestClass().getAnnotatedMethods(Test.class);\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getName().startsWith(\"test\") &&\n            m.getAnnotation(Test.class) == null &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE)\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n\n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n\n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce","date":1297021734,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n      \n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n      \n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":5,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test-framework/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/LuceneTestCase.LuceneTestCaseRunner#computeTestMethods().mjava","sourceNew":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n\n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n\n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","sourceOld":"    @Override\n    protected List<FrameworkMethod> computeTestMethods() {\n      if (testMethods != null)\n        return testMethods;\n      testClassesRun.add(getTestClass().getJavaClass().getSimpleName());\n      testMethods = new ArrayList<FrameworkMethod>();\n      for (Method m : getTestClass().getJavaClass().getMethods()) {\n        // check if the current test's class has methods annotated with @Ignore\n        final Ignore ignored = m.getAnnotation(Ignore.class);\n        if (ignored != null && !m.getName().equals(\"alwaysIgnoredTestMethod\")) {\n          System.err.println(\"NOTE: Ignoring test method '\" + m.getName() + \"': \" + ignored.value());\n        }\n        // add methods starting with \"test\"\n        final int mod = m.getModifiers();\n        if (m.getAnnotation(Test.class) != null ||\n            (m.getName().startsWith(\"test\") &&\n            !Modifier.isAbstract(mod) &&\n            m.getParameterTypes().length == 0 &&\n            m.getReturnType() == Void.TYPE))\n        {\n          if (Modifier.isStatic(mod))\n            throw new RuntimeException(\"Test methods must not be static.\");\n          testMethods.add(new FrameworkMethod(m));\n        }\n      }\n\n      if (testMethods.isEmpty()) {\n        throw new RuntimeException(\"No runnable methods!\");\n      }\n\n      if (TEST_NIGHTLY == false) {\n        if (getTestClass().getJavaClass().isAnnotationPresent(Nightly.class)) {\n          /* the test class is annotated with nightly, remove all methods */\n          String className = getTestClass().getJavaClass().getSimpleName();\n          System.err.println(\"NOTE: Ignoring nightly-only test class '\" + className + \"'\");\n          testMethods.clear();\n        } else {\n          /* remove all nightly-only methods */\n          for (int i = 0; i < testMethods.size(); i++) {\n            final FrameworkMethod m = testMethods.get(i);\n            if (m.getAnnotation(Nightly.class) != null) {\n              System.err.println(\"NOTE: Ignoring nightly-only test method '\" + m.getName() + \"'\");\n              testMethods.remove(i--);\n            }\n          }\n        }\n        /* dodge a possible \"no-runnable methods\" exception by adding a fake ignored test */\n        if (testMethods.isEmpty()) {\n          try {\n            testMethods.add(new FrameworkMethod(LuceneTestCase.class.getMethod(\"alwaysIgnoredTestMethod\")));\n          } catch (Exception e) { throw new RuntimeException(e); }\n        }\n      }\n      return testMethods;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"87f526c8b71404bbf1d37be79633aa9ce2c3540b":["24bbea3efc4507c483f922462353c5994867de42"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["3bb13258feba31ab676502787ab2e1779f129b7a","1eb7d492f3e2d5a27d05802bdf01781cbbb8d111"],"74637427311cf2dd084ed0cf383acdb039c1823f":["e42b97f2dcf8cca9bf6437e7d0dd3e8711f7413f"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1eb7d492f3e2d5a27d05802bdf01781cbbb8d111"],"43b04c27924fe393e38e9f0986e32c634f261859":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["1eb7d492f3e2d5a27d05802bdf01781cbbb8d111"],"24bbea3efc4507c483f922462353c5994867de42":["9e89d520e3ed13b1c01bc576d841c2e8f6d66601"],"9e89d520e3ed13b1c01bc576d841c2e8f6d66601":["43b04c27924fe393e38e9f0986e32c634f261859"],"1eb7d492f3e2d5a27d05802bdf01781cbbb8d111":["274d6ef4fd75d246651078be2ff7ed3620a85221"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"274d6ef4fd75d246651078be2ff7ed3620a85221":["74637427311cf2dd084ed0cf383acdb039c1823f"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["24bbea3efc4507c483f922462353c5994867de42","74637427311cf2dd084ed0cf383acdb039c1823f"],"e42b97f2dcf8cca9bf6437e7d0dd3e8711f7413f":["87f526c8b71404bbf1d37be79633aa9ce2c3540b"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"3bb13258feba31ab676502787ab2e1779f129b7a":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","274d6ef4fd75d246651078be2ff7ed3620a85221"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"]},"commit2Childs":{"87f526c8b71404bbf1d37be79633aa9ce2c3540b":["e42b97f2dcf8cca9bf6437e7d0dd3e8711f7413f"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"74637427311cf2dd084ed0cf383acdb039c1823f":["274d6ef4fd75d246651078be2ff7ed3620a85221","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"43b04c27924fe393e38e9f0986e32c634f261859":["9e89d520e3ed13b1c01bc576d841c2e8f6d66601"],"f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"24bbea3efc4507c483f922462353c5994867de42":["87f526c8b71404bbf1d37be79633aa9ce2c3540b","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"9e89d520e3ed13b1c01bc576d841c2e8f6d66601":["24bbea3efc4507c483f922462353c5994867de42"],"1eb7d492f3e2d5a27d05802bdf01781cbbb8d111":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","f0b9dc55f42953d6740cddbc92cb0d19fe1ba0ce"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","43b04c27924fe393e38e9f0986e32c634f261859"],"274d6ef4fd75d246651078be2ff7ed3620a85221":["1eb7d492f3e2d5a27d05802bdf01781cbbb8d111","3bb13258feba31ab676502787ab2e1779f129b7a"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["3bb13258feba31ab676502787ab2e1779f129b7a"],"e42b97f2dcf8cca9bf6437e7d0dd3e8711f7413f":["74637427311cf2dd084ed0cf383acdb039c1823f"],"3bb13258feba31ab676502787ab2e1779f129b7a":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}