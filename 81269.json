{"path":"solr/core/src/test/org/apache/solr/update/VersionInfoTest#testMaxVersionLogic(SolrQueryRequest).mjava","commits":[{"id":"773a737806859660d4756f710adc0ad53e05f9d5","date":1432140757,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/VersionInfoTest#testMaxVersionLogic(SolrQueryRequest).mjava","pathOld":"/dev/null","sourceNew":"  protected void testMaxVersionLogic(SolrQueryRequest req) throws Exception {\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    ulog.init(uhandler, req.getCore());\n\n    clearIndex();\n    assertU(commit());\n\n    // index the first doc\n    String docId = Integer.toString(1);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    // max from index should not be 0 or null\n    Long maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    // version from index should be less than or equal the version of the first doc indexed\n    VersionInfo vInfo = ulog.getVersionInfo();\n    Long version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than or equal to the version of first doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex <= version);\n\n    BytesRef idBytes = new BytesRef(docId);\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    VersionBucket bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    // send 2nd doc ...\n    docId = Integer.toString(2);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    Long versionFromTLog = ulog.lookupVersion(idBytes);\n    Long versionFromIndex = vInfo.getVersionFromIndex(idBytes);\n    assertEquals(\"version from tlog and version from index should be the same\",\n        versionFromTLog, versionFromIndex);\n\n    // reload the core, which should reset the max\n    CoreContainer coreContainer = req.getCore().getCoreDescriptor().getCoreContainer();\n    coreContainer.reload(req.getCore().getName());\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertEquals(\"max version from index should be equal to version of last doc added after reload\",\n        maxVersionFromIndex, version);\n\n    // one more doc after reload\n    docId = Integer.toString(3);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n        (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1248476067f7f652e875bd77a9a3faeecde50430"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/VersionInfoTest#testMaxVersionLogic(SolrQueryRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/update/VersionInfoTest#testMaxVersionLogic(SolrQueryRequest).mjava","sourceNew":"  protected void testMaxVersionLogic(SolrQueryRequest req) throws Exception {\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    ulog.init(uhandler, req.getCore());\n\n    clearIndex();\n    assertU(commit());\n\n    // index the first doc\n    String docId = Integer.toString(1);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    // max from index should not be 0 or null\n    Long maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    // version from index should be less than or equal the version of the first doc indexed\n    VersionInfo vInfo = ulog.getVersionInfo();\n    Long version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than or equal to the version of first doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex <= version);\n\n    BytesRef idBytes = new BytesRef(docId);\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    VersionBucket bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    // send 2nd doc ...\n    docId = Integer.toString(2);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    Long versionFromTLog = ulog.lookupVersion(idBytes);\n    Long versionFromIndex = vInfo.getVersionFromIndex(idBytes);\n    assertEquals(\"version from tlog and version from index should be the same\",\n        versionFromTLog, versionFromIndex);\n\n    // reload the core, which should reset the max\n    CoreContainer coreContainer = req.getCore().getCoreContainer();\n    coreContainer.reload(req.getCore().getName());\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertEquals(\"max version from index should be equal to version of last doc added after reload\",\n        maxVersionFromIndex, version);\n\n    // one more doc after reload\n    docId = Integer.toString(3);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n        (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n  }\n\n","sourceOld":"  protected void testMaxVersionLogic(SolrQueryRequest req) throws Exception {\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    ulog.init(uhandler, req.getCore());\n\n    clearIndex();\n    assertU(commit());\n\n    // index the first doc\n    String docId = Integer.toString(1);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    // max from index should not be 0 or null\n    Long maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    // version from index should be less than or equal the version of the first doc indexed\n    VersionInfo vInfo = ulog.getVersionInfo();\n    Long version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than or equal to the version of first doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex <= version);\n\n    BytesRef idBytes = new BytesRef(docId);\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    VersionBucket bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    // send 2nd doc ...\n    docId = Integer.toString(2);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    Long versionFromTLog = ulog.lookupVersion(idBytes);\n    Long versionFromIndex = vInfo.getVersionFromIndex(idBytes);\n    assertEquals(\"version from tlog and version from index should be the same\",\n        versionFromTLog, versionFromIndex);\n\n    // reload the core, which should reset the max\n    CoreContainer coreContainer = req.getCore().getCoreDescriptor().getCoreContainer();\n    coreContainer.reload(req.getCore().getName());\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertEquals(\"max version from index should be equal to version of last doc added after reload\",\n        maxVersionFromIndex, version);\n\n    // one more doc after reload\n    docId = Integer.toString(3);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n        (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/VersionInfoTest#testMaxVersionLogic(SolrQueryRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/update/VersionInfoTest#testMaxVersionLogic(SolrQueryRequest).mjava","sourceNew":"  protected void testMaxVersionLogic(SolrQueryRequest req) throws Exception {\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    ulog.init(uhandler, req.getCore());\n\n    clearIndex();\n    assertU(commit());\n\n    // index the first doc\n    String docId = Integer.toString(1);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    // max from index should not be 0 or null\n    Long maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    // version from index should be less than or equal the version of the first doc indexed\n    VersionInfo vInfo = ulog.getVersionInfo();\n    Long version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than or equal to the version of first doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex <= version);\n\n    BytesRef idBytes = new BytesRef(docId);\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    VersionBucket bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    // send 2nd doc ...\n    docId = Integer.toString(2);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    Long versionFromTLog = ulog.lookupVersion(idBytes);\n    Long versionFromIndex = vInfo.getVersionFromIndex(idBytes);\n    assertEquals(\"version from tlog and version from index should be the same\",\n        versionFromTLog, versionFromIndex);\n\n    // reload the core, which should reset the max\n    CoreContainer coreContainer = req.getCore().getCoreContainer();\n    coreContainer.reload(req.getCore().getName());\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertEquals(\"max version from index should be equal to version of last doc added after reload\",\n        maxVersionFromIndex, version);\n\n    // one more doc after reload\n    docId = Integer.toString(3);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n        (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n  }\n\n","sourceOld":"  protected void testMaxVersionLogic(SolrQueryRequest req) throws Exception {\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    ulog.init(uhandler, req.getCore());\n\n    clearIndex();\n    assertU(commit());\n\n    // index the first doc\n    String docId = Integer.toString(1);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    // max from index should not be 0 or null\n    Long maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    // version from index should be less than or equal the version of the first doc indexed\n    VersionInfo vInfo = ulog.getVersionInfo();\n    Long version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than or equal to the version of first doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex <= version);\n\n    BytesRef idBytes = new BytesRef(docId);\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    VersionBucket bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    // send 2nd doc ...\n    docId = Integer.toString(2);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    Long versionFromTLog = ulog.lookupVersion(idBytes);\n    Long versionFromIndex = vInfo.getVersionFromIndex(idBytes);\n    assertEquals(\"version from tlog and version from index should be the same\",\n        versionFromTLog, versionFromIndex);\n\n    // reload the core, which should reset the max\n    CoreContainer coreContainer = req.getCore().getCoreDescriptor().getCoreContainer();\n    coreContainer.reload(req.getCore().getName());\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertEquals(\"max version from index should be equal to version of last doc added after reload\",\n        maxVersionFromIndex, version);\n\n    // one more doc after reload\n    docId = Integer.toString(3);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n        (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1248476067f7f652e875bd77a9a3faeecde50430","date":1497567228,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/VersionInfoTest#testMaxVersionLogic(SolrQueryRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/update/VersionInfoTest#testMaxVersionLogic(SolrQueryRequest).mjava","sourceNew":"  protected void testMaxVersionLogic(SolrQueryRequest req) throws Exception {\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    ulog.init(uhandler, req.getCore());\n\n    clearIndex();\n    assertU(commit());\n\n    // index the first doc\n    String docId = Integer.toString(1);\n    BytesRef idBytes = new BytesRef(docId);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    // max from the ulog should not be 0 or null\n    Long maxVersionFromUlog = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromUlog);\n    assertTrue(maxVersionFromUlog != 0L);\n\n    VersionInfo vInfo = ulog.getVersionInfo();\n    try (SolrQueryRequest newReq = req()) {\n      // max version direct from the index should not be null, and should match what ulog reports\n      // (since doc is committed)\n      Long vInfoMax = vInfo.getMaxVersionFromIndex(newReq.getSearcher());\n      assertNotNull(vInfoMax);\n      assertEquals(maxVersionFromUlog, vInfoMax);\n    }\n    \n    // max version from ulog (and index) should be exactly the same as our single committed doc\n    Long version = vInfo.getVersionFromIndex(idBytes);\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertEquals(maxVersionFromUlog, version);\n\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    VersionBucket bucket = vInfo.bucket(bucketHash);\n    assertEquals(bucket.highest, version.longValue());\n\n    // send 2nd doc ... BUT DO NOT COMMIT\n    docId = Integer.toString(2);\n    idBytes = new BytesRef(docId);\n    assertU(adoc(\"id\", docId));\n    \n    try (SolrQueryRequest newReq = req()) {\n      // max version direct from the index should not be null, and should still match what ulog\n      // previously reported (since new doc is un-committed)\n      Long vInfoMax = vInfo.getMaxVersionFromIndex(newReq.getSearcher());\n      assertNotNull(vInfoMax);\n      assertEquals(maxVersionFromUlog, vInfoMax);\n    }\n    \n    maxVersionFromUlog = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromUlog);\n    assertTrue(\"max version in ulog should have increased since our last committed doc: \" +\n               version + \" ?< \" + maxVersionFromUlog,\n               version < maxVersionFromUlog.longValue());\n\n    version = vInfo.getVersionFromIndex(idBytes);\n    assertNull(\"version info should be null for uncommited test doc: \"+docId, version);\n\n    Long versionFromTLog = ulog.lookupVersion(idBytes);\n    assertNotNull(\"version from tlog should be non-null for uncommited test doc: \"+docId, versionFromTLog);\n\n    // now commit that 2nd doc\n    assertU(commit());\n    try (SolrQueryRequest newReq = req()) {\n      // max version direct from the index should match the new doc we just committed\n      Long vInfoMax = vInfo.getMaxVersionFromIndex(newReq.getSearcher());\n      assertEquals(versionFromTLog, vInfoMax);\n    }\n    assertEquals(\"committing doc should not have changed version from ulog\",\n                 versionFromTLog, ulog.lookupVersion(idBytes));\n    Long versionFromIndex = version = vInfo.getVersionFromIndex(idBytes);\n    assertNotNull(\"version from index should be non-null for commited test doc: \"+docId, versionFromIndex);\n    assertEquals(\"version from tlog and version from index should be the same\",\n                 versionFromTLog, versionFromIndex);\n    \n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertEquals(bucket.highest, version.longValue());\n\n    // reload the core, which should reset the max\n    CoreContainer coreContainer = req.getCore().getCoreContainer();\n    coreContainer.reload(req.getCore().getName());\n    maxVersionFromUlog = ulog.getMaxVersionFromIndex();\n    assertEquals(\"after reload, max version from ulog should be equal to version of last doc added\",\n                 maxVersionFromUlog, versionFromIndex);\n\n    // one more doc after reload\n    docId = Integer.toString(3);\n    idBytes = new BytesRef(docId);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromUlog = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromUlog);\n    assertTrue(maxVersionFromUlog != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    try (SolrQueryRequest newReq = req()) {\n      // max version direct from the index should not be null, and should match what ulog reports\n      // (since doc is committed)\n      Long vInfoMax = vInfo.getMaxVersionFromIndex(newReq.getSearcher());\n      assertNotNull(vInfoMax);\n      assertEquals(maxVersionFromUlog, vInfoMax);\n    }\n    version = vInfo.getVersionFromIndex(idBytes);\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertEquals(maxVersionFromUlog, version);\n\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertEquals(bucket.highest, version.longValue());\n  }\n\n","sourceOld":"  protected void testMaxVersionLogic(SolrQueryRequest req) throws Exception {\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    ulog.init(uhandler, req.getCore());\n\n    clearIndex();\n    assertU(commit());\n\n    // index the first doc\n    String docId = Integer.toString(1);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    // max from index should not be 0 or null\n    Long maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    // version from index should be less than or equal the version of the first doc indexed\n    VersionInfo vInfo = ulog.getVersionInfo();\n    Long version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than or equal to the version of first doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex <= version);\n\n    BytesRef idBytes = new BytesRef(docId);\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    VersionBucket bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    // send 2nd doc ...\n    docId = Integer.toString(2);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    Long versionFromTLog = ulog.lookupVersion(idBytes);\n    Long versionFromIndex = vInfo.getVersionFromIndex(idBytes);\n    assertEquals(\"version from tlog and version from index should be the same\",\n        versionFromTLog, versionFromIndex);\n\n    // reload the core, which should reset the max\n    CoreContainer coreContainer = req.getCore().getCoreContainer();\n    coreContainer.reload(req.getCore().getName());\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertEquals(\"max version from index should be equal to version of last doc added after reload\",\n        maxVersionFromIndex, version);\n\n    // one more doc after reload\n    docId = Integer.toString(3);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n        (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n  }\n\n","bugFix":["773a737806859660d4756f710adc0ad53e05f9d5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/VersionInfoTest#testMaxVersionLogic(SolrQueryRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/update/VersionInfoTest#testMaxVersionLogic(SolrQueryRequest).mjava","sourceNew":"  protected void testMaxVersionLogic(SolrQueryRequest req) throws Exception {\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    ulog.init(uhandler, req.getCore());\n\n    clearIndex();\n    assertU(commit());\n\n    // index the first doc\n    String docId = Integer.toString(1);\n    BytesRef idBytes = new BytesRef(docId);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    // max from the ulog should not be 0 or null\n    Long maxVersionFromUlog = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromUlog);\n    assertTrue(maxVersionFromUlog != 0L);\n\n    VersionInfo vInfo = ulog.getVersionInfo();\n    try (SolrQueryRequest newReq = req()) {\n      // max version direct from the index should not be null, and should match what ulog reports\n      // (since doc is committed)\n      Long vInfoMax = vInfo.getMaxVersionFromIndex(newReq.getSearcher());\n      assertNotNull(vInfoMax);\n      assertEquals(maxVersionFromUlog, vInfoMax);\n    }\n    \n    // max version from ulog (and index) should be exactly the same as our single committed doc\n    Long version = vInfo.getVersionFromIndex(idBytes);\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertEquals(maxVersionFromUlog, version);\n\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    VersionBucket bucket = vInfo.bucket(bucketHash);\n    assertEquals(bucket.highest, version.longValue());\n\n    // send 2nd doc ... BUT DO NOT COMMIT\n    docId = Integer.toString(2);\n    idBytes = new BytesRef(docId);\n    assertU(adoc(\"id\", docId));\n    \n    try (SolrQueryRequest newReq = req()) {\n      // max version direct from the index should not be null, and should still match what ulog\n      // previously reported (since new doc is un-committed)\n      Long vInfoMax = vInfo.getMaxVersionFromIndex(newReq.getSearcher());\n      assertNotNull(vInfoMax);\n      assertEquals(maxVersionFromUlog, vInfoMax);\n    }\n    \n    maxVersionFromUlog = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromUlog);\n    assertTrue(\"max version in ulog should have increased since our last committed doc: \" +\n               version + \" ?< \" + maxVersionFromUlog,\n               version < maxVersionFromUlog.longValue());\n\n    version = vInfo.getVersionFromIndex(idBytes);\n    assertNull(\"version info should be null for uncommited test doc: \"+docId, version);\n\n    Long versionFromTLog = ulog.lookupVersion(idBytes);\n    assertNotNull(\"version from tlog should be non-null for uncommited test doc: \"+docId, versionFromTLog);\n\n    // now commit that 2nd doc\n    assertU(commit());\n    try (SolrQueryRequest newReq = req()) {\n      // max version direct from the index should match the new doc we just committed\n      Long vInfoMax = vInfo.getMaxVersionFromIndex(newReq.getSearcher());\n      assertEquals(versionFromTLog, vInfoMax);\n    }\n    assertEquals(\"committing doc should not have changed version from ulog\",\n                 versionFromTLog, ulog.lookupVersion(idBytes));\n    Long versionFromIndex = version = vInfo.getVersionFromIndex(idBytes);\n    assertNotNull(\"version from index should be non-null for commited test doc: \"+docId, versionFromIndex);\n    assertEquals(\"version from tlog and version from index should be the same\",\n                 versionFromTLog, versionFromIndex);\n    \n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertEquals(bucket.highest, version.longValue());\n\n    // reload the core, which should reset the max\n    CoreContainer coreContainer = req.getCore().getCoreContainer();\n    coreContainer.reload(req.getCore().getName());\n    maxVersionFromUlog = ulog.getMaxVersionFromIndex();\n    assertEquals(\"after reload, max version from ulog should be equal to version of last doc added\",\n                 maxVersionFromUlog, versionFromIndex);\n\n    // one more doc after reload\n    docId = Integer.toString(3);\n    idBytes = new BytesRef(docId);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromUlog = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromUlog);\n    assertTrue(maxVersionFromUlog != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    try (SolrQueryRequest newReq = req()) {\n      // max version direct from the index should not be null, and should match what ulog reports\n      // (since doc is committed)\n      Long vInfoMax = vInfo.getMaxVersionFromIndex(newReq.getSearcher());\n      assertNotNull(vInfoMax);\n      assertEquals(maxVersionFromUlog, vInfoMax);\n    }\n    version = vInfo.getVersionFromIndex(idBytes);\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertEquals(maxVersionFromUlog, version);\n\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertEquals(bucket.highest, version.longValue());\n  }\n\n","sourceOld":"  protected void testMaxVersionLogic(SolrQueryRequest req) throws Exception {\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    ulog.init(uhandler, req.getCore());\n\n    clearIndex();\n    assertU(commit());\n\n    // index the first doc\n    String docId = Integer.toString(1);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    // max from index should not be 0 or null\n    Long maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    // version from index should be less than or equal the version of the first doc indexed\n    VersionInfo vInfo = ulog.getVersionInfo();\n    Long version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than or equal to the version of first doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex <= version);\n\n    BytesRef idBytes = new BytesRef(docId);\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    VersionBucket bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    // send 2nd doc ...\n    docId = Integer.toString(2);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    Long versionFromTLog = ulog.lookupVersion(idBytes);\n    Long versionFromIndex = vInfo.getVersionFromIndex(idBytes);\n    assertEquals(\"version from tlog and version from index should be the same\",\n        versionFromTLog, versionFromIndex);\n\n    // reload the core, which should reset the max\n    CoreContainer coreContainer = req.getCore().getCoreContainer();\n    coreContainer.reload(req.getCore().getName());\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertEquals(\"max version from index should be equal to version of last doc added after reload\",\n        maxVersionFromIndex, version);\n\n    // one more doc after reload\n    docId = Integer.toString(3);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n        (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/VersionInfoTest#testMaxVersionLogic(SolrQueryRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/update/VersionInfoTest#testMaxVersionLogic(SolrQueryRequest).mjava","sourceNew":"  protected void testMaxVersionLogic(SolrQueryRequest req) throws Exception {\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    ulog.init(uhandler, req.getCore());\n\n    clearIndex();\n    assertU(commit());\n\n    // index the first doc\n    String docId = Integer.toString(1);\n    BytesRef idBytes = new BytesRef(docId);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    // max from the ulog should not be 0 or null\n    Long maxVersionFromUlog = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromUlog);\n    assertTrue(maxVersionFromUlog != 0L);\n\n    VersionInfo vInfo = ulog.getVersionInfo();\n    try (SolrQueryRequest newReq = req()) {\n      // max version direct from the index should not be null, and should match what ulog reports\n      // (since doc is committed)\n      Long vInfoMax = vInfo.getMaxVersionFromIndex(newReq.getSearcher());\n      assertNotNull(vInfoMax);\n      assertEquals(maxVersionFromUlog, vInfoMax);\n    }\n    \n    // max version from ulog (and index) should be exactly the same as our single committed doc\n    Long version = vInfo.getVersionFromIndex(idBytes);\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertEquals(maxVersionFromUlog, version);\n\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    VersionBucket bucket = vInfo.bucket(bucketHash);\n    assertEquals(bucket.highest, version.longValue());\n\n    // send 2nd doc ... BUT DO NOT COMMIT\n    docId = Integer.toString(2);\n    idBytes = new BytesRef(docId);\n    assertU(adoc(\"id\", docId));\n    \n    try (SolrQueryRequest newReq = req()) {\n      // max version direct from the index should not be null, and should still match what ulog\n      // previously reported (since new doc is un-committed)\n      Long vInfoMax = vInfo.getMaxVersionFromIndex(newReq.getSearcher());\n      assertNotNull(vInfoMax);\n      assertEquals(maxVersionFromUlog, vInfoMax);\n    }\n    \n    maxVersionFromUlog = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromUlog);\n    assertTrue(\"max version in ulog should have increased since our last committed doc: \" +\n               version + \" ?< \" + maxVersionFromUlog,\n               version < maxVersionFromUlog.longValue());\n\n    version = vInfo.getVersionFromIndex(idBytes);\n    assertNull(\"version info should be null for uncommited test doc: \"+docId, version);\n\n    Long versionFromTLog = ulog.lookupVersion(idBytes);\n    assertNotNull(\"version from tlog should be non-null for uncommited test doc: \"+docId, versionFromTLog);\n\n    // now commit that 2nd doc\n    assertU(commit());\n    try (SolrQueryRequest newReq = req()) {\n      // max version direct from the index should match the new doc we just committed\n      Long vInfoMax = vInfo.getMaxVersionFromIndex(newReq.getSearcher());\n      assertEquals(versionFromTLog, vInfoMax);\n    }\n    assertEquals(\"committing doc should not have changed version from ulog\",\n                 versionFromTLog, ulog.lookupVersion(idBytes));\n    Long versionFromIndex = version = vInfo.getVersionFromIndex(idBytes);\n    assertNotNull(\"version from index should be non-null for commited test doc: \"+docId, versionFromIndex);\n    assertEquals(\"version from tlog and version from index should be the same\",\n                 versionFromTLog, versionFromIndex);\n    \n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertEquals(bucket.highest, version.longValue());\n\n    // reload the core, which should reset the max\n    CoreContainer coreContainer = req.getCore().getCoreContainer();\n    coreContainer.reload(req.getCore().getName());\n    maxVersionFromUlog = ulog.getMaxVersionFromIndex();\n    assertEquals(\"after reload, max version from ulog should be equal to version of last doc added\",\n                 maxVersionFromUlog, versionFromIndex);\n\n    // one more doc after reload\n    docId = Integer.toString(3);\n    idBytes = new BytesRef(docId);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromUlog = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromUlog);\n    assertTrue(maxVersionFromUlog != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    try (SolrQueryRequest newReq = req()) {\n      // max version direct from the index should not be null, and should match what ulog reports\n      // (since doc is committed)\n      Long vInfoMax = vInfo.getMaxVersionFromIndex(newReq.getSearcher());\n      assertNotNull(vInfoMax);\n      assertEquals(maxVersionFromUlog, vInfoMax);\n    }\n    version = vInfo.getVersionFromIndex(idBytes);\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertEquals(maxVersionFromUlog, version);\n\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertEquals(bucket.highest, version.longValue());\n  }\n\n","sourceOld":"  protected void testMaxVersionLogic(SolrQueryRequest req) throws Exception {\n    UpdateHandler uhandler = req.getCore().getUpdateHandler();\n    UpdateLog ulog = uhandler.getUpdateLog();\n    ulog.init(uhandler, req.getCore());\n\n    clearIndex();\n    assertU(commit());\n\n    // index the first doc\n    String docId = Integer.toString(1);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    // max from index should not be 0 or null\n    Long maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    // version from index should be less than or equal the version of the first doc indexed\n    VersionInfo vInfo = ulog.getVersionInfo();\n    Long version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than or equal to the version of first doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex <= version);\n\n    BytesRef idBytes = new BytesRef(docId);\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    VersionBucket bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    // send 2nd doc ...\n    docId = Integer.toString(2);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n            (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n\n    Long versionFromTLog = ulog.lookupVersion(idBytes);\n    Long versionFromIndex = vInfo.getVersionFromIndex(idBytes);\n    assertEquals(\"version from tlog and version from index should be the same\",\n        versionFromTLog, versionFromIndex);\n\n    // reload the core, which should reset the max\n    CoreContainer coreContainer = req.getCore().getCoreContainer();\n    coreContainer.reload(req.getCore().getName());\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertEquals(\"max version from index should be equal to version of last doc added after reload\",\n        maxVersionFromIndex, version);\n\n    // one more doc after reload\n    docId = Integer.toString(3);\n    assertU(adoc(\"id\", docId));\n    assertU(commit());\n\n    maxVersionFromIndex = ulog.getMaxVersionFromIndex();\n    assertNotNull(maxVersionFromIndex);\n    assertTrue(maxVersionFromIndex != 0L);\n\n    vInfo = ulog.getVersionInfo();\n    version = vInfo.getVersionFromIndex(new BytesRef(docId));\n    assertNotNull(\"version info should not be null for test doc: \"+docId, version);\n    assertTrue(\"max version from index should be less than version of last doc added, diff: \"+\n        (version - maxVersionFromIndex), maxVersionFromIndex < version);\n\n    idBytes = new BytesRef(docId);\n    bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n    bucket = vInfo.bucket(bucketHash);\n    assertTrue(bucket.highest == version.longValue());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["773a737806859660d4756f710adc0ad53e05f9d5"],"1248476067f7f652e875bd77a9a3faeecde50430":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"773a737806859660d4756f710adc0ad53e05f9d5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["773a737806859660d4756f710adc0ad53e05f9d5"],"28288370235ed02234a64753cdbf0c6ec096304a":["729cb470f975115d4c60517b2cb7c42e37a7a2e1","1248476067f7f652e875bd77a9a3faeecde50430"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","1248476067f7f652e875bd77a9a3faeecde50430"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"1248476067f7f652e875bd77a9a3faeecde50430":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"773a737806859660d4756f710adc0ad53e05f9d5":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["773a737806859660d4756f710adc0ad53e05f9d5"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["1248476067f7f652e875bd77a9a3faeecde50430","28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}