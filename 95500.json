{"path":"lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","pathOld":"lucene/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","sourceNew":"  private int phraseFreq() throws IOException {\n\n    freq = 0;\n\n    // init chunks\n    for(int i=0;i<chunkStates.length;i++) {\n      final ChunkState cs = chunkStates[i];\n      cs.posLimit = cs.posEnum.freq();\n      cs.pos = cs.offset + cs.posEnum.nextPosition();\n      cs.posUpto = 1;\n      cs.lastPos = -1;\n    }\n\n    int chunkStart = 0;\n    int chunkEnd = CHUNK;\n\n    // process chunk by chunk\n    boolean end = false;\n\n    // TODO: we could fold in chunkStart into offset and\n    // save one subtract per pos incr\n\n    while(!end) {\n\n      gen++;\n\n      if (gen == 0) {\n        // wraparound\n        Arrays.fill(gens, 0);\n        gen++;\n      }\n\n      // first term\n      {\n        final ChunkState cs = chunkStates[0];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            counts[posIndex] = 1;\n            assert gens[posIndex] != gen;\n            gens[posIndex] = gen;\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      // middle terms\n      boolean any = true;\n      for(int t=1;t<endMinus1;t++) {\n        final ChunkState cs = chunkStates[t];\n        any = false;\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == t) {\n              // viable\n              counts[posIndex]++;\n              any = true;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n\n        if (!any) {\n          break;\n        }\n      }\n\n      if (!any) {\n        // petered out for this chunk\n        chunkStart += CHUNK;\n        chunkEnd += CHUNK;\n        continue;\n      }\n\n      // last term\n\n      {\n        final ChunkState cs = chunkStates[endMinus1];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == endMinus1) {\n              freq++;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      chunkStart += CHUNK;\n      chunkEnd += CHUNK;\n    }\n\n    return freq;\n  }\n\n","sourceOld":"  private int phraseFreq() throws IOException {\n\n    freq = 0;\n\n    // init chunks\n    for(int i=0;i<chunkStates.length;i++) {\n      final ChunkState cs = chunkStates[i];\n      cs.posLimit = cs.posEnum.freq();\n      cs.pos = cs.offset + cs.posEnum.nextPosition();\n      cs.posUpto = 1;\n      cs.lastPos = -1;\n    }\n\n    int chunkStart = 0;\n    int chunkEnd = CHUNK;\n\n    // process chunk by chunk\n    boolean end = false;\n\n    // TODO: we could fold in chunkStart into offset and\n    // save one subtract per pos incr\n\n    while(!end) {\n\n      gen++;\n\n      if (gen == 0) {\n        // wraparound\n        Arrays.fill(gens, 0);\n        gen++;\n      }\n\n      // first term\n      {\n        final ChunkState cs = chunkStates[0];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            counts[posIndex] = 1;\n            assert gens[posIndex] != gen;\n            gens[posIndex] = gen;\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      // middle terms\n      boolean any = true;\n      for(int t=1;t<endMinus1;t++) {\n        final ChunkState cs = chunkStates[t];\n        any = false;\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == t) {\n              // viable\n              counts[posIndex]++;\n              any = true;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n\n        if (!any) {\n          break;\n        }\n      }\n\n      if (!any) {\n        // petered out for this chunk\n        chunkStart += CHUNK;\n        chunkEnd += CHUNK;\n        continue;\n      }\n\n      // last term\n\n      {\n        final ChunkState cs = chunkStates[endMinus1];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == endMinus1) {\n              freq++;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      chunkStart += CHUNK;\n      chunkEnd += CHUNK;\n    }\n\n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"781239fc84d36be12b84e4d3e2618f5f07a182e3","date":1423139668,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","sourceNew":"  private int phraseFreq() throws IOException {\n\n    freq = 0;\n\n    // init chunks\n    for(int i=0;i<chunkStates.length;i++) {\n      final ChunkState cs = chunkStates[i];\n      cs.posLimit = cs.posEnum.freq();\n      cs.pos = cs.offset + cs.posEnum.nextPosition();\n      cs.posUpto = 1;\n      cs.lastPos = -1;\n    }\n\n    int chunkStart = 0;\n    int chunkEnd = CHUNK;\n\n    // process chunk by chunk\n    boolean end = false;\n\n    // TODO: we could fold in chunkStart into offset and\n    // save one subtract per pos incr\n\n    while(!end) {\n\n      gen++;\n\n      if (gen == 0) {\n        // wraparound\n        Arrays.fill(gens, 0);\n        gen++;\n      }\n\n      // first term\n      {\n        final ChunkState cs = chunkStates[0];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            counts[posIndex] = 1;\n            assert gens[posIndex] != gen;\n            gens[posIndex] = gen;\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      // middle terms\n      boolean any = true;\n      for(int t=1;t<endMinus1;t++) {\n        final ChunkState cs = chunkStates[t];\n        any = false;\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == t) {\n              // viable\n              counts[posIndex]++;\n              any = true;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n\n        if (!any) {\n          break;\n        }\n      }\n\n      if (!any) {\n        // petered out for this chunk\n        chunkStart += CHUNK;\n        chunkEnd += CHUNK;\n        continue;\n      }\n\n      // last term\n\n      {\n        final ChunkState cs = chunkStates[endMinus1];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == endMinus1) {\n              freq++;\n              if (!needsScores) {\n                return freq; // we determined there was a match.\n              }\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      chunkStart += CHUNK;\n      chunkEnd += CHUNK;\n    }\n\n    return freq;\n  }\n\n","sourceOld":"  private int phraseFreq() throws IOException {\n\n    freq = 0;\n\n    // init chunks\n    for(int i=0;i<chunkStates.length;i++) {\n      final ChunkState cs = chunkStates[i];\n      cs.posLimit = cs.posEnum.freq();\n      cs.pos = cs.offset + cs.posEnum.nextPosition();\n      cs.posUpto = 1;\n      cs.lastPos = -1;\n    }\n\n    int chunkStart = 0;\n    int chunkEnd = CHUNK;\n\n    // process chunk by chunk\n    boolean end = false;\n\n    // TODO: we could fold in chunkStart into offset and\n    // save one subtract per pos incr\n\n    while(!end) {\n\n      gen++;\n\n      if (gen == 0) {\n        // wraparound\n        Arrays.fill(gens, 0);\n        gen++;\n      }\n\n      // first term\n      {\n        final ChunkState cs = chunkStates[0];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            counts[posIndex] = 1;\n            assert gens[posIndex] != gen;\n            gens[posIndex] = gen;\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      // middle terms\n      boolean any = true;\n      for(int t=1;t<endMinus1;t++) {\n        final ChunkState cs = chunkStates[t];\n        any = false;\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == t) {\n              // viable\n              counts[posIndex]++;\n              any = true;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n\n        if (!any) {\n          break;\n        }\n      }\n\n      if (!any) {\n        // petered out for this chunk\n        chunkStart += CHUNK;\n        chunkEnd += CHUNK;\n        continue;\n      }\n\n      // last term\n\n      {\n        final ChunkState cs = chunkStates[endMinus1];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == endMinus1) {\n              freq++;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      chunkStart += CHUNK;\n      chunkEnd += CHUNK;\n    }\n\n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a24a7a6d0e69e0595c8813443018f1cea18e6433","date":1424446886,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","sourceNew":"  private int phraseFreq() throws IOException {\n    // reset state\n    final PostingsAndPosition[] postings = this.postings;\n    for (PostingsAndPosition posting : postings) {\n      posting.freq = posting.postings.freq();\n      posting.pos = posting.postings.nextPosition();\n      posting.upTo = 1;\n    }\n\n    int freq = 0;\n    final PostingsAndPosition lead = postings[0];\n\n    advanceHead:\n    while (true) {\n      final int phrasePos = lead.pos - lead.offset;\n      for (int j = 1; j < postings.length; ++j) {\n        final PostingsAndPosition posting = postings[j];\n        final int expectedPos = phrasePos + posting.offset;\n\n        // advance up to the same position as the lead\n        if (advancePosition(posting, expectedPos) == false) {\n          break advanceHead;\n        }\n\n        if (posting.pos != expectedPos) { // we advanced too far\n          if (advancePosition(lead, posting.pos - posting.offset + lead.offset)) {\n            continue advanceHead;\n          } else {\n            break advanceHead;\n          }\n        }\n      }\n\n      freq += 1;\n      if (needsScores == false) {\n        break;\n      }\n\n      if (lead.upTo == lead.freq) {\n        break;\n      }\n      lead.pos = lead.postings.nextPosition();\n      lead.upTo += 1;\n    }\n\n    return this.freq = freq;\n  }\n\n","sourceOld":"  private int phraseFreq() throws IOException {\n\n    freq = 0;\n\n    // init chunks\n    for(int i=0;i<chunkStates.length;i++) {\n      final ChunkState cs = chunkStates[i];\n      cs.posLimit = cs.posEnum.freq();\n      cs.pos = cs.offset + cs.posEnum.nextPosition();\n      cs.posUpto = 1;\n      cs.lastPos = -1;\n    }\n\n    int chunkStart = 0;\n    int chunkEnd = CHUNK;\n\n    // process chunk by chunk\n    boolean end = false;\n\n    // TODO: we could fold in chunkStart into offset and\n    // save one subtract per pos incr\n\n    while(!end) {\n\n      gen++;\n\n      if (gen == 0) {\n        // wraparound\n        Arrays.fill(gens, 0);\n        gen++;\n      }\n\n      // first term\n      {\n        final ChunkState cs = chunkStates[0];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            counts[posIndex] = 1;\n            assert gens[posIndex] != gen;\n            gens[posIndex] = gen;\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      // middle terms\n      boolean any = true;\n      for(int t=1;t<endMinus1;t++) {\n        final ChunkState cs = chunkStates[t];\n        any = false;\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == t) {\n              // viable\n              counts[posIndex]++;\n              any = true;\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n\n        if (!any) {\n          break;\n        }\n      }\n\n      if (!any) {\n        // petered out for this chunk\n        chunkStart += CHUNK;\n        chunkEnd += CHUNK;\n        continue;\n      }\n\n      // last term\n\n      {\n        final ChunkState cs = chunkStates[endMinus1];\n        while(cs.pos < chunkEnd) {\n          if (cs.pos > cs.lastPos) {\n            cs.lastPos = cs.pos;\n            final int posIndex = cs.pos - chunkStart;\n            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == endMinus1) {\n              freq++;\n              if (!needsScores) {\n                return freq; // we determined there was a match.\n              }\n            }\n          }\n\n          if (cs.posUpto == cs.posLimit) {\n            end = true;\n            break;\n          }\n          cs.posUpto++;\n          cs.pos = cs.offset + cs.posEnum.nextPosition();\n        }\n      }\n\n      chunkStart += CHUNK;\n      chunkEnd += CHUNK;\n    }\n\n    return freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b11b9d5eaf9707760ca5151530830a825197023","date":1525941319,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/ExactPhraseMatcher#nextMatch().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer#phraseFreq().mjava","sourceNew":"  @Override\n  public boolean nextMatch() throws IOException {\n    final PostingsAndPosition lead = postings[0];\n    if (lead.upTo < lead.freq) {\n      lead.pos = lead.postings.nextPosition();\n      lead.upTo += 1;\n    }\n    else {\n      return false;\n    }\n    advanceHead:\n    while (true) {\n      final int phrasePos = lead.pos - lead.offset;\n      for (int j = 1; j < postings.length; ++j) {\n        final PostingsAndPosition posting = postings[j];\n        final int expectedPos = phrasePos + posting.offset;\n\n        // advance up to the same position as the lead\n        if (advancePosition(posting, expectedPos) == false) {\n          break advanceHead;\n        }\n\n        if (posting.pos != expectedPos) { // we advanced too far\n          if (advancePosition(lead, posting.pos - posting.offset + lead.offset)) {\n            continue advanceHead;\n          } else {\n            break advanceHead;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n","sourceOld":"  private int phraseFreq() throws IOException {\n    // reset state\n    final PostingsAndPosition[] postings = this.postings;\n    for (PostingsAndPosition posting : postings) {\n      posting.freq = posting.postings.freq();\n      posting.pos = posting.postings.nextPosition();\n      posting.upTo = 1;\n    }\n\n    int freq = 0;\n    final PostingsAndPosition lead = postings[0];\n\n    advanceHead:\n    while (true) {\n      final int phrasePos = lead.pos - lead.offset;\n      for (int j = 1; j < postings.length; ++j) {\n        final PostingsAndPosition posting = postings[j];\n        final int expectedPos = phrasePos + posting.offset;\n\n        // advance up to the same position as the lead\n        if (advancePosition(posting, expectedPos) == false) {\n          break advanceHead;\n        }\n\n        if (posting.pos != expectedPos) { // we advanced too far\n          if (advancePosition(lead, posting.pos - posting.offset + lead.offset)) {\n            continue advanceHead;\n          } else {\n            break advanceHead;\n          }\n        }\n      }\n\n      freq += 1;\n      if (needsScores == false) {\n        break;\n      }\n\n      if (lead.upTo == lead.freq) {\n        break;\n      }\n      lead.pos = lead.postings.nextPosition();\n      lead.upTo += 1;\n    }\n\n    return this.freq = freq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3b11b9d5eaf9707760ca5151530830a825197023":["a24a7a6d0e69e0595c8813443018f1cea18e6433"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"a24a7a6d0e69e0595c8813443018f1cea18e6433":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3b11b9d5eaf9707760ca5151530830a825197023"]},"commit2Childs":{"3b11b9d5eaf9707760ca5151530830a825197023":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["a24a7a6d0e69e0595c8813443018f1cea18e6433"],"a24a7a6d0e69e0595c8813443018f1cea18e6433":["3b11b9d5eaf9707760ca5151530830a825197023"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}