{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/bloom/FuzzySet#downsize(float).mjava","commits":[{"id":"3f1361ca6e7d39bfd5cf15485d8843ea798bdd30","date":1346918556,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/bloom/FuzzySet#downsize(float).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/FuzzySet#downsize(float).mjava","sourceNew":"  /**\n   * \n   * @param targetMaxSaturation A number between 0 and 1 describing the % of bits that would ideally be set in the \n   * result. Lower values have better qccuracy but require more space.\n   * @return a smaller FuzzySet or null if the current set is already over-saturated\n   */\n  public FuzzySet downsize(float targetMaxSaturation)\n  {\n    int numBitsSet = filter.cardinality();\n    FixedBitSet rightSizedBitSet = filter;\n    int rightSizedBitSetSize = bloomSize;\n    //Hopefully find a smaller size bitset into which we can project accumulated values while maintaining desired saturation level\n    for (int i = 0; i < usableBitSetSizes.length; i++) {\n      int candidateBitsetSize = usableBitSetSizes[i];\n      float candidateSaturation = (float) numBitsSet\n          / (float) candidateBitsetSize;\n      if (candidateSaturation <= targetMaxSaturation) {\n        rightSizedBitSetSize = candidateBitsetSize;\n        break;\n      }\n    }\n    // Re-project the numbers to a smaller space if necessary\n    if (rightSizedBitSetSize < bloomSize) {\n      // Reset the choice of bitset to the smaller version\n      rightSizedBitSet = new FixedBitSet(rightSizedBitSetSize + 1);\n      // Map across the bits from the large set to the smaller one\n      int bitIndex = 0;\n      do {\n        bitIndex = filter.nextSetBit(bitIndex);\n        if (bitIndex >= 0) {\n          // Project the larger number into a smaller one effectively\n          // modulo-ing by using the target bitset size as a mask\n          int downSizedBitIndex = bitIndex & rightSizedBitSetSize;\n          rightSizedBitSet.set(downSizedBitIndex);\n          bitIndex++;\n        }\n      } while ( (bitIndex >= 0)&&(bitIndex<=bloomSize));\n    } else {\n      return null;\n    }\n    return new FuzzySet(rightSizedBitSet,rightSizedBitSetSize, hashFunction);\n  }\n\n","sourceOld":"  /**\n   * \n   * @param targetMaxSaturation A number between 0 and 1 describing the % of bits that would ideally be set in the \n   * result. Lower values have better qccuracy but require more space.\n   * @return a smaller FuzzySet or null if the current set is already over-saturated\n   */\n  public FuzzySet downsize(float targetMaxSaturation)\n  {\n    int numBitsSet = filter.cardinality();\n    FixedBitSet rightSizedBitSet = filter;\n    int rightSizedBitSetSize = bloomSize;\n    //Hopefully find a smaller size bitset into which we can project accumulated values while maintaining desired saturation level\n    for (int i = 0; i < usableBitSetSizes.length; i++) {\n      int candidateBitsetSize = usableBitSetSizes[i];\n      float candidateSaturation = (float) numBitsSet\n          / (float) candidateBitsetSize;\n      if (candidateSaturation <= targetMaxSaturation) {\n        rightSizedBitSetSize = candidateBitsetSize;\n        break;\n      }\n    }\n    // Re-project the numbers to a smaller space if necessary\n    if (rightSizedBitSetSize < bloomSize) {\n      // Reset the choice of bitset to the smaller version\n      rightSizedBitSet = new FixedBitSet(rightSizedBitSetSize + 1);\n      // Map across the bits from the large set to the smaller one\n      int bitIndex = 0;\n      do {\n        bitIndex = filter.nextSetBit(bitIndex);\n        if (bitIndex >= 0) {\n          // Project the larger number into a smaller one effectively\n          // modulo-ing by using the target bitset size as a mask\n          int downSizedBitIndex = bitIndex & rightSizedBitSetSize;\n          rightSizedBitSet.set(downSizedBitIndex);\n          bitIndex++;\n        }\n      } while ( (bitIndex >= 0)&&(bitIndex<=bloomSize));\n    } else {\n      return null;\n    }\n    return new FuzzySet(rightSizedBitSet,rightSizedBitSetSize, hashFunction);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7602e63987582091a0e432f8d8f7619d2206fab7","date":1361393626,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/bloom/FuzzySet#downsize(float).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/bloom/FuzzySet#downsize(float).mjava","sourceNew":"  /**\n   * \n   * @param targetMaxSaturation A number between 0 and 1 describing the % of bits that would ideally be set in the \n   * result. Lower values have better accuracy but require more space.\n   * @return a smaller FuzzySet or null if the current set is already over-saturated\n   */\n  public FuzzySet downsize(float targetMaxSaturation)\n  {\n    int numBitsSet = filter.cardinality();\n    FixedBitSet rightSizedBitSet = filter;\n    int rightSizedBitSetSize = bloomSize;\n    //Hopefully find a smaller size bitset into which we can project accumulated values while maintaining desired saturation level\n    for (int i = 0; i < usableBitSetSizes.length; i++) {\n      int candidateBitsetSize = usableBitSetSizes[i];\n      float candidateSaturation = (float) numBitsSet\n          / (float) candidateBitsetSize;\n      if (candidateSaturation <= targetMaxSaturation) {\n        rightSizedBitSetSize = candidateBitsetSize;\n        break;\n      }\n    }\n    // Re-project the numbers to a smaller space if necessary\n    if (rightSizedBitSetSize < bloomSize) {\n      // Reset the choice of bitset to the smaller version\n      rightSizedBitSet = new FixedBitSet(rightSizedBitSetSize + 1);\n      // Map across the bits from the large set to the smaller one\n      int bitIndex = 0;\n      do {\n        bitIndex = filter.nextSetBit(bitIndex);\n        if (bitIndex >= 0) {\n          // Project the larger number into a smaller one effectively\n          // modulo-ing by using the target bitset size as a mask\n          int downSizedBitIndex = bitIndex & rightSizedBitSetSize;\n          rightSizedBitSet.set(downSizedBitIndex);\n          bitIndex++;\n        }\n      } while ( (bitIndex >= 0)&&(bitIndex<=bloomSize));\n    } else {\n      return null;\n    }\n    return new FuzzySet(rightSizedBitSet,rightSizedBitSetSize, hashFunction);\n  }\n\n","sourceOld":"  /**\n   * \n   * @param targetMaxSaturation A number between 0 and 1 describing the % of bits that would ideally be set in the \n   * result. Lower values have better qccuracy but require more space.\n   * @return a smaller FuzzySet or null if the current set is already over-saturated\n   */\n  public FuzzySet downsize(float targetMaxSaturation)\n  {\n    int numBitsSet = filter.cardinality();\n    FixedBitSet rightSizedBitSet = filter;\n    int rightSizedBitSetSize = bloomSize;\n    //Hopefully find a smaller size bitset into which we can project accumulated values while maintaining desired saturation level\n    for (int i = 0; i < usableBitSetSizes.length; i++) {\n      int candidateBitsetSize = usableBitSetSizes[i];\n      float candidateSaturation = (float) numBitsSet\n          / (float) candidateBitsetSize;\n      if (candidateSaturation <= targetMaxSaturation) {\n        rightSizedBitSetSize = candidateBitsetSize;\n        break;\n      }\n    }\n    // Re-project the numbers to a smaller space if necessary\n    if (rightSizedBitSetSize < bloomSize) {\n      // Reset the choice of bitset to the smaller version\n      rightSizedBitSet = new FixedBitSet(rightSizedBitSetSize + 1);\n      // Map across the bits from the large set to the smaller one\n      int bitIndex = 0;\n      do {\n        bitIndex = filter.nextSetBit(bitIndex);\n        if (bitIndex >= 0) {\n          // Project the larger number into a smaller one effectively\n          // modulo-ing by using the target bitset size as a mask\n          int downSizedBitIndex = bitIndex & rightSizedBitSetSize;\n          rightSizedBitSet.set(downSizedBitIndex);\n          bitIndex++;\n        }\n      } while ( (bitIndex >= 0)&&(bitIndex<=bloomSize));\n    } else {\n      return null;\n    }\n    return new FuzzySet(rightSizedBitSet,rightSizedBitSetSize, hashFunction);\n  }\n\n","bugFix":["0274c27988a26cb0cda3a0d15b282221b1b453f0"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e","date":1414135939,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/bloom/FuzzySet#downsize(float).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/bloom/FuzzySet#downsize(float).mjava","sourceNew":"  /**\n   * \n   * @param targetMaxSaturation A number between 0 and 1 describing the % of bits that would ideally be set in the \n   * result. Lower values have better accuracy but require more space.\n   * @return a smaller FuzzySet or null if the current set is already over-saturated\n   */\n  public FuzzySet downsize(float targetMaxSaturation)\n  {\n    int numBitsSet = filter.cardinality();\n    FixedBitSet rightSizedBitSet = filter;\n    int rightSizedBitSetSize = bloomSize;\n    //Hopefully find a smaller size bitset into which we can project accumulated values while maintaining desired saturation level\n    for (int i = 0; i < usableBitSetSizes.length; i++) {\n      int candidateBitsetSize = usableBitSetSizes[i];\n      float candidateSaturation = (float) numBitsSet\n          / (float) candidateBitsetSize;\n      if (candidateSaturation <= targetMaxSaturation) {\n        rightSizedBitSetSize = candidateBitsetSize;\n        break;\n      }\n    }\n    // Re-project the numbers to a smaller space if necessary\n    if (rightSizedBitSetSize < bloomSize) {\n      // Reset the choice of bitset to the smaller version\n      rightSizedBitSet = new FixedBitSet(rightSizedBitSetSize + 1);\n      // Map across the bits from the large set to the smaller one\n      int bitIndex = 0;\n      do {\n        bitIndex = filter.nextSetBit(bitIndex);\n        if (bitIndex != DocIdSetIterator.NO_MORE_DOCS) {\n          // Project the larger number into a smaller one effectively\n          // modulo-ing by using the target bitset size as a mask\n          int downSizedBitIndex = bitIndex & rightSizedBitSetSize;\n          rightSizedBitSet.set(downSizedBitIndex);\n          bitIndex++;\n        }\n      } while ( (bitIndex >= 0)&&(bitIndex<=bloomSize));\n    } else {\n      return null;\n    }\n    return new FuzzySet(rightSizedBitSet,rightSizedBitSetSize, hashFunction);\n  }\n\n","sourceOld":"  /**\n   * \n   * @param targetMaxSaturation A number between 0 and 1 describing the % of bits that would ideally be set in the \n   * result. Lower values have better accuracy but require more space.\n   * @return a smaller FuzzySet or null if the current set is already over-saturated\n   */\n  public FuzzySet downsize(float targetMaxSaturation)\n  {\n    int numBitsSet = filter.cardinality();\n    FixedBitSet rightSizedBitSet = filter;\n    int rightSizedBitSetSize = bloomSize;\n    //Hopefully find a smaller size bitset into which we can project accumulated values while maintaining desired saturation level\n    for (int i = 0; i < usableBitSetSizes.length; i++) {\n      int candidateBitsetSize = usableBitSetSizes[i];\n      float candidateSaturation = (float) numBitsSet\n          / (float) candidateBitsetSize;\n      if (candidateSaturation <= targetMaxSaturation) {\n        rightSizedBitSetSize = candidateBitsetSize;\n        break;\n      }\n    }\n    // Re-project the numbers to a smaller space if necessary\n    if (rightSizedBitSetSize < bloomSize) {\n      // Reset the choice of bitset to the smaller version\n      rightSizedBitSet = new FixedBitSet(rightSizedBitSetSize + 1);\n      // Map across the bits from the large set to the smaller one\n      int bitIndex = 0;\n      do {\n        bitIndex = filter.nextSetBit(bitIndex);\n        if (bitIndex >= 0) {\n          // Project the larger number into a smaller one effectively\n          // modulo-ing by using the target bitset size as a mask\n          int downSizedBitIndex = bitIndex & rightSizedBitSetSize;\n          rightSizedBitSet.set(downSizedBitIndex);\n          bitIndex++;\n        }\n      } while ( (bitIndex >= 0)&&(bitIndex<=bloomSize));\n    } else {\n      return null;\n    }\n    return new FuzzySet(rightSizedBitSet,rightSizedBitSetSize, hashFunction);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f1361ca6e7d39bfd5cf15485d8843ea798bdd30":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["7602e63987582091a0e432f8d8f7619d2206fab7"],"7602e63987582091a0e432f8d8f7619d2206fab7":["3f1361ca6e7d39bfd5cf15485d8843ea798bdd30"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"]},"commit2Childs":{"3f1361ca6e7d39bfd5cf15485d8843ea798bdd30":["7602e63987582091a0e432f8d8f7619d2206fab7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3f1361ca6e7d39bfd5cf15485d8843ea798bdd30"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7602e63987582091a0e432f8d8f7619d2206fab7":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}