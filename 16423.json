{"path":"lucene/backwards/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","pathOld":"backwards/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap<PhrasePositions, Object> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap<PhrasePositions, Object>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","sourceOld":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap<PhrasePositions, Object> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap<PhrasePositions, Object>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6","date":1272983566,"type":4,"author":"Uwe Schindler","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/backwards/src/java/org/apache/lucene/search/SloppyPhraseScorer#initPhrasePositions().mjava","sourceNew":null,"sourceOld":"    /**\n     * Init PhrasePositions in place.\n     * There is a one time initialization for this scorer:\n     * <br>- Put in repeats[] each pp that has another pp with same position in the doc.\n     * <br>- Also mark each such pp by pp.repeats = true.\n     * <br>Later can consult with repeats[] in termPositionsDiffer(pp), making that check efficient.\n     * In particular, this allows to score queries with no repetitions with no overhead due to this computation.\n     * <br>- Example 1 - query with no repetitions: \"ho my\"~2\n     * <br>- Example 2 - query with repetitions: \"ho my my\"~2\n     * <br>- Example 3 - query with repetitions: \"my ho my\"~2\n     * <br>Init per doc w/repeats in query, includes propagating some repeating pp's to avoid false phrase detection.  \n     * @return end (max position), or -1 if any term ran out (i.e. done) \n     * @throws IOException \n     */\n    private int initPhrasePositions() throws IOException {\n        int end = 0;\n        \n        // no repeats at all (most common case is also the simplest one)\n        if (checkedRepeats && repeats==null) {\n            // build queue from list\n            pq.clear();\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                pp.firstPosition();\n                if (pp.position > end)\n                    end = pp.position;\n                pq.add(pp);         // build pq from list\n            }\n            return end;\n        }\n        \n        // position the pp's\n        for (PhrasePositions pp = first; pp != null; pp = pp.next)\n            pp.firstPosition();\n        \n        // one time initializatin for this scorer\n        if (!checkedRepeats) {\n            checkedRepeats = true;\n            // check for repeats\n            HashMap<PhrasePositions, Object> m = null;\n            for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n                int tpPos = pp.position + pp.offset;\n                for (PhrasePositions pp2 = pp.next; pp2 != null; pp2 = pp2.next) {\n                    int tpPos2 = pp2.position + pp2.offset;\n                    if (tpPos2 == tpPos) { \n                        if (m == null)\n                            m = new HashMap<PhrasePositions, Object>();\n                        pp.repeats = true;\n                        pp2.repeats = true;\n                        m.put(pp,null);\n                        m.put(pp2,null);\n                    }\n                }\n            }\n            if (m!=null)\n                repeats = m.keySet().toArray(new PhrasePositions[0]);\n        }\n        \n        // with repeats must advance some repeating pp's so they all start with differing tp's       \n        if (repeats!=null) {\n            for (int i = 0; i < repeats.length; i++) {\n                PhrasePositions pp = repeats[i];\n                PhrasePositions pp2;\n                while ((pp2 = termPositionsDiffer(pp)) != null) {\n                  if (!pp2.nextPosition())  // out of pps that do not differ, advance the pp with higher offset \n                      return -1;           // ran out of a term -- done  \n                } \n            }\n        }\n      \n        // build queue from list\n        pq.clear();\n        for (PhrasePositions pp = first; pp != null; pp = pp.next) {\n            if (pp.position > end)\n                end = pp.position;\n            pq.add(pp);         // build pq from list\n        }\n\n        if (repeats!=null) {\n          tmpPos = new PhrasePositions[pq.size()];\n        }\n        return end;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["90eca6fcb6635ca73ea4fdbe2f57d2033b66d3b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}