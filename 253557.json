{"path":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testAllVersionsTested().mjava","commits":[{"id":"5a0b6886e871521dbc3495e30ea752689de9023d","date":1410451802,"type":0,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testAllVersionsTested().mjava","pathOld":"/dev/null","sourceNew":"  public void testAllVersionsTested() throws Exception {\n    Pattern constantPattern = Pattern.compile(\"LUCENE_(\\\\d+)_(\\\\d+)_(\\\\d+)(_ALPHA|_BETA)?\");\n    // find the unique versions according to Version.java\n    List<String> expectedVersions = new ArrayList<>();\n    int lastPrevMinorIndex = -1;\n    Version lastPrevMajorVersion = null;\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        if (v.equals(Version.LATEST)) continue;\n\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n\n        if (v.major == Version.LATEST.major - 1 &&\n            (lastPrevMajorVersion == null || v.onOrAfter(lastPrevMajorVersion))) {\n          lastPrevMajorVersion = v;\n          lastPrevMinorIndex = expectedVersions.size();\n        }\n\n        String major = constant.group(1);\n        String minor = constant.group(2);\n        String bugfix = constant.group(3);\n        if (bugfix.equals(\"0\")) {\n          bugfix = \"\";\n        }\n        String prerelease = constant.group(4);\n        if (prerelease != null) {\n          if (prerelease.equals(\"_ALPHA\")) {\n            prerelease = \"a\";\n          } else { // _BETA\n            prerelease = \"b\";\n          }\n        } else {\n          prerelease = \"\";\n        }\n        expectedVersions.add(major + minor + bugfix + prerelease + \".cfs\");\n      }\n    }\n    if (Version.LATEST.minor == 0 && Version.LATEST.bugfix == 0 && Version.LATEST.prerelease == 0) {\n      // we are on trunk (latest is a first major release) so the last minor index\n      // for the previous major version is also not yet tested\n      assertNotNull(lastPrevMajorVersion);\n      expectedVersions.remove(lastPrevMinorIndex);\n    }\n    Collections.sort(expectedVersions);\n\n    // find what versions we are testing\n    List<String> testedVersions = new ArrayList<>();\n    for (String testedVersion : oldNames) {\n      if (testedVersion.endsWith(\".cfs\") == false) continue;\n      testedVersions.add(testedVersion);\n    }\n    Collections.sort(testedVersions);\n\n\n    int i = 0;\n    int j = 0;\n    List<String> missingFiles = new ArrayList<>();\n    List<String> extraFiles = new ArrayList<>();\n    while (i < expectedVersions.size() && j < testedVersions.size()) {\n      String expectedVersion = expectedVersions.get(i);\n      String testedVersion = testedVersions.get(j);\n      int compare = expectedVersion.compareTo(testedVersion);\n      if (compare == 0) { // equal, we can move on\n        ++i;\n        ++j;\n      } else if (compare < 0) { // didn't find test for version constant\n        missingFiles.add(expectedVersion);\n        ++i;\n      } else { // extra test file\n        extraFiles.add(testedVersion);\n        ++j;\n      }\n    }\n    while (i < expectedVersions.size()) {\n      missingFiles.add(expectedVersions.get(i));\n      ++i;\n    }\n    while (j < testedVersions.size()) {\n      missingFiles.add(testedVersions.get(j));\n      ++j;\n    }\n\n    if (missingFiles.isEmpty() && extraFiles.isEmpty()) {\n      // success\n      return;\n    }\n\n    StringBuffer msg = new StringBuffer();\n    if (missingFiles.isEmpty() == false) {\n      msg.append(\"Missing backcompat test files:\\n\");\n      for (String missingFile : missingFiles) {\n        msg.append(\"  \" + missingFile + \"\\n\");\n      }\n    }\n    if (extraFiles.isEmpty() == false) {\n      msg.append(\"Extra backcompat test files:\\n\");\n      for (String extraFile : extraFiles) {\n        msg.append(\"  \" + extraFile + \"\\n\");\n      }\n    }\n    fail(msg.toString());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"882d14638c19fc8b274bb94935b35e3061acd86e","date":1411143315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testAllVersionsTested().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testAllVersionsTested().mjava","sourceNew":"  public void testAllVersionsTested() throws Exception {\n    Pattern constantPattern = Pattern.compile(\"LUCENE_(\\\\d+)_(\\\\d+)_(\\\\d+)(_ALPHA|_BETA)?\");\n    // find the unique versions according to Version.java\n    List<String> expectedVersions = new ArrayList<>();\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        if (v.equals(Version.LATEST)) continue;\n\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n\n        expectedVersions.add(cfsFilename(v));\n      }\n    }\n\n    // BEGIN TRUNK ONLY BLOCK\n    // on trunk, the last release of the prev major release is also untested\n    Version lastPrevMajorVersion = null;\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n        if (v.major == Version.LATEST.major - 1 &&\n            (lastPrevMajorVersion == null || v.onOrAfter(lastPrevMajorVersion))) {\n          lastPrevMajorVersion = v;\n        }\n      }\n    }\n    assertNotNull(lastPrevMajorVersion);\n    expectedVersions.remove(cfsFilename(lastPrevMajorVersion));\n    // END TRUNK ONLY BLOCK\n\n    Collections.sort(expectedVersions);\n\n    // find what versions we are testing\n    List<String> testedVersions = new ArrayList<>();\n    for (String testedVersion : oldNames) {\n      if (testedVersion.endsWith(\".cfs\") == false) continue;\n      testedVersions.add(testedVersion);\n    }\n    Collections.sort(testedVersions);\n\n\n    int i = 0;\n    int j = 0;\n    List<String> missingFiles = new ArrayList<>();\n    List<String> extraFiles = new ArrayList<>();\n    while (i < expectedVersions.size() && j < testedVersions.size()) {\n      String expectedVersion = expectedVersions.get(i);\n      String testedVersion = testedVersions.get(j);\n      int compare = expectedVersion.compareTo(testedVersion);\n      if (compare == 0) { // equal, we can move on\n        ++i;\n        ++j;\n      } else if (compare < 0) { // didn't find test for version constant\n        missingFiles.add(expectedVersion);\n        ++i;\n      } else { // extra test file\n        extraFiles.add(testedVersion);\n        ++j;\n      }\n    }\n    while (i < expectedVersions.size()) {\n      missingFiles.add(expectedVersions.get(i));\n      ++i;\n    }\n    while (j < testedVersions.size()) {\n      missingFiles.add(testedVersions.get(j));\n      ++j;\n    }\n\n    if (missingFiles.isEmpty() && extraFiles.isEmpty()) {\n      // success\n      return;\n    }\n\n    StringBuffer msg = new StringBuffer();\n    if (missingFiles.isEmpty() == false) {\n      msg.append(\"Missing backcompat test files:\\n\");\n      for (String missingFile : missingFiles) {\n        msg.append(\"  \" + missingFile + \"\\n\");\n      }\n    }\n    if (extraFiles.isEmpty() == false) {\n      msg.append(\"Extra backcompat test files:\\n\");\n      for (String extraFile : extraFiles) {\n        msg.append(\"  \" + extraFile + \"\\n\");\n      }\n    }\n    fail(msg.toString());\n  }\n\n","sourceOld":"  public void testAllVersionsTested() throws Exception {\n    Pattern constantPattern = Pattern.compile(\"LUCENE_(\\\\d+)_(\\\\d+)_(\\\\d+)(_ALPHA|_BETA)?\");\n    // find the unique versions according to Version.java\n    List<String> expectedVersions = new ArrayList<>();\n    int lastPrevMinorIndex = -1;\n    Version lastPrevMajorVersion = null;\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        if (v.equals(Version.LATEST)) continue;\n\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n\n        if (v.major == Version.LATEST.major - 1 &&\n            (lastPrevMajorVersion == null || v.onOrAfter(lastPrevMajorVersion))) {\n          lastPrevMajorVersion = v;\n          lastPrevMinorIndex = expectedVersions.size();\n        }\n\n        String major = constant.group(1);\n        String minor = constant.group(2);\n        String bugfix = constant.group(3);\n        if (bugfix.equals(\"0\")) {\n          bugfix = \"\";\n        }\n        String prerelease = constant.group(4);\n        if (prerelease != null) {\n          if (prerelease.equals(\"_ALPHA\")) {\n            prerelease = \"a\";\n          } else { // _BETA\n            prerelease = \"b\";\n          }\n        } else {\n          prerelease = \"\";\n        }\n        expectedVersions.add(major + minor + bugfix + prerelease + \".cfs\");\n      }\n    }\n    if (Version.LATEST.minor == 0 && Version.LATEST.bugfix == 0 && Version.LATEST.prerelease == 0) {\n      // we are on trunk (latest is a first major release) so the last minor index\n      // for the previous major version is also not yet tested\n      assertNotNull(lastPrevMajorVersion);\n      expectedVersions.remove(lastPrevMinorIndex);\n    }\n    Collections.sort(expectedVersions);\n\n    // find what versions we are testing\n    List<String> testedVersions = new ArrayList<>();\n    for (String testedVersion : oldNames) {\n      if (testedVersion.endsWith(\".cfs\") == false) continue;\n      testedVersions.add(testedVersion);\n    }\n    Collections.sort(testedVersions);\n\n\n    int i = 0;\n    int j = 0;\n    List<String> missingFiles = new ArrayList<>();\n    List<String> extraFiles = new ArrayList<>();\n    while (i < expectedVersions.size() && j < testedVersions.size()) {\n      String expectedVersion = expectedVersions.get(i);\n      String testedVersion = testedVersions.get(j);\n      int compare = expectedVersion.compareTo(testedVersion);\n      if (compare == 0) { // equal, we can move on\n        ++i;\n        ++j;\n      } else if (compare < 0) { // didn't find test for version constant\n        missingFiles.add(expectedVersion);\n        ++i;\n      } else { // extra test file\n        extraFiles.add(testedVersion);\n        ++j;\n      }\n    }\n    while (i < expectedVersions.size()) {\n      missingFiles.add(expectedVersions.get(i));\n      ++i;\n    }\n    while (j < testedVersions.size()) {\n      missingFiles.add(testedVersions.get(j));\n      ++j;\n    }\n\n    if (missingFiles.isEmpty() && extraFiles.isEmpty()) {\n      // success\n      return;\n    }\n\n    StringBuffer msg = new StringBuffer();\n    if (missingFiles.isEmpty() == false) {\n      msg.append(\"Missing backcompat test files:\\n\");\n      for (String missingFile : missingFiles) {\n        msg.append(\"  \" + missingFile + \"\\n\");\n      }\n    }\n    if (extraFiles.isEmpty() == false) {\n      msg.append(\"Extra backcompat test files:\\n\");\n      for (String extraFile : extraFiles) {\n        msg.append(\"  \" + extraFile + \"\\n\");\n      }\n    }\n    fail(msg.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec8882143e40fbd4aaa2cc02fc4abb1217eb24c7","date":1411591737,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testAllVersionsTested().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testAllVersionsTested().mjava","sourceNew":"  public void testAllVersionsTested() throws Exception {\n    Pattern constantPattern = Pattern.compile(\"LUCENE_(\\\\d+)_(\\\\d+)_(\\\\d+)(_ALPHA|_BETA)?\");\n    // find the unique versions according to Version.java\n    List<String> expectedVersions = new ArrayList<>();\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        if (v.equals(Version.LATEST)) continue;\n\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n\n        expectedVersions.add(v.toString() + \"-cfs\");\n      }\n    }\n\n    // BEGIN TRUNK ONLY BLOCK\n    // on trunk, the last release of the prev major release is also untested\n    Version lastPrevMajorVersion = null;\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n        if (v.major == Version.LATEST.major - 1 &&\n            (lastPrevMajorVersion == null || v.onOrAfter(lastPrevMajorVersion))) {\n          lastPrevMajorVersion = v;\n        }\n      }\n    }\n    assertNotNull(lastPrevMajorVersion);\n    expectedVersions.remove(lastPrevMajorVersion.toString() + \"-cfs\");\n    // END TRUNK ONLY BLOCK\n\n    Collections.sort(expectedVersions);\n\n    // find what versions we are testing\n    List<String> testedVersions = new ArrayList<>();\n    for (String testedVersion : oldNames) {\n      if (testedVersion.endsWith(\"-cfs\") == false) continue;\n      testedVersions.add(testedVersion);\n    }\n    Collections.sort(testedVersions);\n\n\n    int i = 0;\n    int j = 0;\n    List<String> missingFiles = new ArrayList<>();\n    List<String> extraFiles = new ArrayList<>();\n    while (i < expectedVersions.size() && j < testedVersions.size()) {\n      String expectedVersion = expectedVersions.get(i);\n      String testedVersion = testedVersions.get(j);\n      int compare = expectedVersion.compareTo(testedVersion);\n      if (compare == 0) { // equal, we can move on\n        ++i;\n        ++j;\n      } else if (compare < 0) { // didn't find test for version constant\n        missingFiles.add(expectedVersion);\n        ++i;\n      } else { // extra test file\n        extraFiles.add(testedVersion);\n        ++j;\n      }\n    }\n    while (i < expectedVersions.size()) {\n      missingFiles.add(expectedVersions.get(i));\n      ++i;\n    }\n    while (j < testedVersions.size()) {\n      missingFiles.add(testedVersions.get(j));\n      ++j;\n    }\n\n    // we could be missing up to 1 file, which may be due to a release that is in progress\n    if (missingFiles.size() <= 1 && extraFiles.isEmpty()) {\n      // success\n      return;\n    }\n\n    StringBuffer msg = new StringBuffer();\n    if (missingFiles.size() > 1) {\n      msg.append(\"Missing backcompat test files:\\n\");\n      for (String missingFile : missingFiles) {\n        msg.append(\"  \" + missingFile + \"\\n\");\n      }\n    }\n    if (extraFiles.isEmpty() == false) {\n      msg.append(\"Extra backcompat test files:\\n\");\n      for (String extraFile : extraFiles) {\n        msg.append(\"  \" + extraFile + \"\\n\");\n      }\n    }\n    fail(msg.toString());\n  }\n\n","sourceOld":"  public void testAllVersionsTested() throws Exception {\n    Pattern constantPattern = Pattern.compile(\"LUCENE_(\\\\d+)_(\\\\d+)_(\\\\d+)(_ALPHA|_BETA)?\");\n    // find the unique versions according to Version.java\n    List<String> expectedVersions = new ArrayList<>();\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        if (v.equals(Version.LATEST)) continue;\n\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n\n        expectedVersions.add(cfsFilename(v));\n      }\n    }\n\n    // BEGIN TRUNK ONLY BLOCK\n    // on trunk, the last release of the prev major release is also untested\n    Version lastPrevMajorVersion = null;\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n        if (v.major == Version.LATEST.major - 1 &&\n            (lastPrevMajorVersion == null || v.onOrAfter(lastPrevMajorVersion))) {\n          lastPrevMajorVersion = v;\n        }\n      }\n    }\n    assertNotNull(lastPrevMajorVersion);\n    expectedVersions.remove(cfsFilename(lastPrevMajorVersion));\n    // END TRUNK ONLY BLOCK\n\n    Collections.sort(expectedVersions);\n\n    // find what versions we are testing\n    List<String> testedVersions = new ArrayList<>();\n    for (String testedVersion : oldNames) {\n      if (testedVersion.endsWith(\".cfs\") == false) continue;\n      testedVersions.add(testedVersion);\n    }\n    Collections.sort(testedVersions);\n\n\n    int i = 0;\n    int j = 0;\n    List<String> missingFiles = new ArrayList<>();\n    List<String> extraFiles = new ArrayList<>();\n    while (i < expectedVersions.size() && j < testedVersions.size()) {\n      String expectedVersion = expectedVersions.get(i);\n      String testedVersion = testedVersions.get(j);\n      int compare = expectedVersion.compareTo(testedVersion);\n      if (compare == 0) { // equal, we can move on\n        ++i;\n        ++j;\n      } else if (compare < 0) { // didn't find test for version constant\n        missingFiles.add(expectedVersion);\n        ++i;\n      } else { // extra test file\n        extraFiles.add(testedVersion);\n        ++j;\n      }\n    }\n    while (i < expectedVersions.size()) {\n      missingFiles.add(expectedVersions.get(i));\n      ++i;\n    }\n    while (j < testedVersions.size()) {\n      missingFiles.add(testedVersions.get(j));\n      ++j;\n    }\n\n    if (missingFiles.isEmpty() && extraFiles.isEmpty()) {\n      // success\n      return;\n    }\n\n    StringBuffer msg = new StringBuffer();\n    if (missingFiles.isEmpty() == false) {\n      msg.append(\"Missing backcompat test files:\\n\");\n      for (String missingFile : missingFiles) {\n        msg.append(\"  \" + missingFile + \"\\n\");\n      }\n    }\n    if (extraFiles.isEmpty() == false) {\n      msg.append(\"Extra backcompat test files:\\n\");\n      for (String extraFile : extraFiles) {\n        msg.append(\"  \" + extraFile + \"\\n\");\n      }\n    }\n    fail(msg.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"98c87780d12c9a7445efb0e3edc4208e0546f140","date":1456917407,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testAllVersionsTested().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testAllVersionsTested().mjava","sourceNew":"  public void testAllVersionsTested() throws Exception {\n    Pattern constantPattern = Pattern.compile(\"LUCENE_(\\\\d+)_(\\\\d+)_(\\\\d+)(_ALPHA|_BETA)?\");\n    // find the unique versions according to Version.java\n    List<String> expectedVersions = new ArrayList<>();\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        if (v.equals(Version.LATEST)) {\n          continue;\n        }\n\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) {\n          continue;\n        }\n\n        expectedVersions.add(v.toString() + \"-cfs\");\n      }\n    }\n\n    // BEGIN TRUNK ONLY BLOCK\n    // on trunk, the last release of the prev major release is also untested\n    Version lastPrevMajorVersion = null;\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n        if (v.major == Version.LATEST.major - 1 &&\n            (lastPrevMajorVersion == null || v.onOrAfter(lastPrevMajorVersion))) {\n          lastPrevMajorVersion = v;\n        }\n      }\n    }\n    assertNotNull(lastPrevMajorVersion);\n    expectedVersions.remove(lastPrevMajorVersion.toString() + \"-cfs\");\n    // END TRUNK ONLY BLOCK\n\n    Collections.sort(expectedVersions);\n\n    // find what versions we are testing\n    List<String> testedVersions = new ArrayList<>();\n    for (String testedVersion : oldNames) {\n      if (testedVersion.endsWith(\"-cfs\") == false) {\n        continue;\n      }\n      testedVersions.add(testedVersion);\n    }\n    Collections.sort(testedVersions);\n\n\n    int i = 0;\n    int j = 0;\n    List<String> missingFiles = new ArrayList<>();\n    List<String> extraFiles = new ArrayList<>();\n    while (i < expectedVersions.size() && j < testedVersions.size()) {\n      String expectedVersion = expectedVersions.get(i);\n      String testedVersion = testedVersions.get(j);\n      int compare = expectedVersion.compareTo(testedVersion);\n      if (compare == 0) { // equal, we can move on\n        ++i;\n        ++j;\n      } else if (compare < 0) { // didn't find test for version constant\n        missingFiles.add(expectedVersion);\n        ++i;\n      } else { // extra test file\n        extraFiles.add(testedVersion);\n        ++j;\n      }\n    }\n    while (i < expectedVersions.size()) {\n      missingFiles.add(expectedVersions.get(i));\n      ++i;\n    }\n    while (j < testedVersions.size()) {\n      missingFiles.add(testedVersions.get(j));\n      ++j;\n    }\n\n    // we could be missing up to 1 file, which may be due to a release that is in progress\n    if (missingFiles.size() <= 1 && extraFiles.isEmpty()) {\n      // success\n      return;\n    }\n\n    StringBuffer msg = new StringBuffer();\n    if (missingFiles.size() > 1) {\n      msg.append(\"Missing backcompat test files:\\n\");\n      for (String missingFile : missingFiles) {\n        msg.append(\"  \" + missingFile + \"\\n\");\n      }\n    }\n    if (extraFiles.isEmpty() == false) {\n      msg.append(\"Extra backcompat test files:\\n\");\n      for (String extraFile : extraFiles) {\n        msg.append(\"  \" + extraFile + \"\\n\");\n      }\n    }\n    fail(msg.toString());\n  }\n\n","sourceOld":"  public void testAllVersionsTested() throws Exception {\n    Pattern constantPattern = Pattern.compile(\"LUCENE_(\\\\d+)_(\\\\d+)_(\\\\d+)(_ALPHA|_BETA)?\");\n    // find the unique versions according to Version.java\n    List<String> expectedVersions = new ArrayList<>();\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        if (v.equals(Version.LATEST)) continue;\n\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n\n        expectedVersions.add(v.toString() + \"-cfs\");\n      }\n    }\n\n    // BEGIN TRUNK ONLY BLOCK\n    // on trunk, the last release of the prev major release is also untested\n    Version lastPrevMajorVersion = null;\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n        if (v.major == Version.LATEST.major - 1 &&\n            (lastPrevMajorVersion == null || v.onOrAfter(lastPrevMajorVersion))) {\n          lastPrevMajorVersion = v;\n        }\n      }\n    }\n    assertNotNull(lastPrevMajorVersion);\n    expectedVersions.remove(lastPrevMajorVersion.toString() + \"-cfs\");\n    // END TRUNK ONLY BLOCK\n\n    Collections.sort(expectedVersions);\n\n    // find what versions we are testing\n    List<String> testedVersions = new ArrayList<>();\n    for (String testedVersion : oldNames) {\n      if (testedVersion.endsWith(\"-cfs\") == false) continue;\n      testedVersions.add(testedVersion);\n    }\n    Collections.sort(testedVersions);\n\n\n    int i = 0;\n    int j = 0;\n    List<String> missingFiles = new ArrayList<>();\n    List<String> extraFiles = new ArrayList<>();\n    while (i < expectedVersions.size() && j < testedVersions.size()) {\n      String expectedVersion = expectedVersions.get(i);\n      String testedVersion = testedVersions.get(j);\n      int compare = expectedVersion.compareTo(testedVersion);\n      if (compare == 0) { // equal, we can move on\n        ++i;\n        ++j;\n      } else if (compare < 0) { // didn't find test for version constant\n        missingFiles.add(expectedVersion);\n        ++i;\n      } else { // extra test file\n        extraFiles.add(testedVersion);\n        ++j;\n      }\n    }\n    while (i < expectedVersions.size()) {\n      missingFiles.add(expectedVersions.get(i));\n      ++i;\n    }\n    while (j < testedVersions.size()) {\n      missingFiles.add(testedVersions.get(j));\n      ++j;\n    }\n\n    // we could be missing up to 1 file, which may be due to a release that is in progress\n    if (missingFiles.size() <= 1 && extraFiles.isEmpty()) {\n      // success\n      return;\n    }\n\n    StringBuffer msg = new StringBuffer();\n    if (missingFiles.size() > 1) {\n      msg.append(\"Missing backcompat test files:\\n\");\n      for (String missingFile : missingFiles) {\n        msg.append(\"  \" + missingFile + \"\\n\");\n      }\n    }\n    if (extraFiles.isEmpty() == false) {\n      msg.append(\"Extra backcompat test files:\\n\");\n      for (String extraFile : extraFiles) {\n        msg.append(\"  \" + extraFile + \"\\n\");\n      }\n    }\n    fail(msg.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testAllVersionsTested().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testAllVersionsTested().mjava","sourceNew":"  public void testAllVersionsTested() throws Exception {\n    Pattern constantPattern = Pattern.compile(\"LUCENE_(\\\\d+)_(\\\\d+)_(\\\\d+)(_ALPHA|_BETA)?\");\n    // find the unique versions according to Version.java\n    List<String> expectedVersions = new ArrayList<>();\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        if (v.equals(Version.LATEST)) {\n          continue;\n        }\n\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) {\n          continue;\n        }\n\n        expectedVersions.add(v.toString() + \"-cfs\");\n      }\n    }\n\n    // BEGIN TRUNK ONLY BLOCK\n    // on trunk, the last release of the prev major release is also untested\n    Version lastPrevMajorVersion = null;\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n        if (v.major == Version.LATEST.major - 1 &&\n            (lastPrevMajorVersion == null || v.onOrAfter(lastPrevMajorVersion))) {\n          lastPrevMajorVersion = v;\n        }\n      }\n    }\n    assertNotNull(lastPrevMajorVersion);\n    expectedVersions.remove(lastPrevMajorVersion.toString() + \"-cfs\");\n    // END TRUNK ONLY BLOCK\n\n    Collections.sort(expectedVersions);\n\n    // find what versions we are testing\n    List<String> testedVersions = new ArrayList<>();\n    for (String testedVersion : oldNames) {\n      if (testedVersion.endsWith(\"-cfs\") == false) {\n        continue;\n      }\n      testedVersions.add(testedVersion);\n    }\n    Collections.sort(testedVersions);\n\n\n    int i = 0;\n    int j = 0;\n    List<String> missingFiles = new ArrayList<>();\n    List<String> extraFiles = new ArrayList<>();\n    while (i < expectedVersions.size() && j < testedVersions.size()) {\n      String expectedVersion = expectedVersions.get(i);\n      String testedVersion = testedVersions.get(j);\n      int compare = expectedVersion.compareTo(testedVersion);\n      if (compare == 0) { // equal, we can move on\n        ++i;\n        ++j;\n      } else if (compare < 0) { // didn't find test for version constant\n        missingFiles.add(expectedVersion);\n        ++i;\n      } else { // extra test file\n        extraFiles.add(testedVersion);\n        ++j;\n      }\n    }\n    while (i < expectedVersions.size()) {\n      missingFiles.add(expectedVersions.get(i));\n      ++i;\n    }\n    while (j < testedVersions.size()) {\n      missingFiles.add(testedVersions.get(j));\n      ++j;\n    }\n\n    // we could be missing up to 1 file, which may be due to a release that is in progress\n    if (missingFiles.size() <= 1 && extraFiles.isEmpty()) {\n      // success\n      return;\n    }\n\n    StringBuffer msg = new StringBuffer();\n    if (missingFiles.size() > 1) {\n      msg.append(\"Missing backcompat test files:\\n\");\n      for (String missingFile : missingFiles) {\n        msg.append(\"  \" + missingFile + \"\\n\");\n      }\n    }\n    if (extraFiles.isEmpty() == false) {\n      msg.append(\"Extra backcompat test files:\\n\");\n      for (String extraFile : extraFiles) {\n        msg.append(\"  \" + extraFile + \"\\n\");\n      }\n    }\n    fail(msg.toString());\n  }\n\n","sourceOld":"  public void testAllVersionsTested() throws Exception {\n    Pattern constantPattern = Pattern.compile(\"LUCENE_(\\\\d+)_(\\\\d+)_(\\\\d+)(_ALPHA|_BETA)?\");\n    // find the unique versions according to Version.java\n    List<String> expectedVersions = new ArrayList<>();\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        if (v.equals(Version.LATEST)) continue;\n\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n\n        expectedVersions.add(v.toString() + \"-cfs\");\n      }\n    }\n\n    // BEGIN TRUNK ONLY BLOCK\n    // on trunk, the last release of the prev major release is also untested\n    Version lastPrevMajorVersion = null;\n    for (java.lang.reflect.Field field : Version.class.getDeclaredFields()) {\n      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {\n        Version v = (Version)field.get(Version.class);\n        Matcher constant = constantPattern.matcher(field.getName());\n        if (constant.matches() == false) continue;\n        if (v.major == Version.LATEST.major - 1 &&\n            (lastPrevMajorVersion == null || v.onOrAfter(lastPrevMajorVersion))) {\n          lastPrevMajorVersion = v;\n        }\n      }\n    }\n    assertNotNull(lastPrevMajorVersion);\n    expectedVersions.remove(lastPrevMajorVersion.toString() + \"-cfs\");\n    // END TRUNK ONLY BLOCK\n\n    Collections.sort(expectedVersions);\n\n    // find what versions we are testing\n    List<String> testedVersions = new ArrayList<>();\n    for (String testedVersion : oldNames) {\n      if (testedVersion.endsWith(\"-cfs\") == false) continue;\n      testedVersions.add(testedVersion);\n    }\n    Collections.sort(testedVersions);\n\n\n    int i = 0;\n    int j = 0;\n    List<String> missingFiles = new ArrayList<>();\n    List<String> extraFiles = new ArrayList<>();\n    while (i < expectedVersions.size() && j < testedVersions.size()) {\n      String expectedVersion = expectedVersions.get(i);\n      String testedVersion = testedVersions.get(j);\n      int compare = expectedVersion.compareTo(testedVersion);\n      if (compare == 0) { // equal, we can move on\n        ++i;\n        ++j;\n      } else if (compare < 0) { // didn't find test for version constant\n        missingFiles.add(expectedVersion);\n        ++i;\n      } else { // extra test file\n        extraFiles.add(testedVersion);\n        ++j;\n      }\n    }\n    while (i < expectedVersions.size()) {\n      missingFiles.add(expectedVersions.get(i));\n      ++i;\n    }\n    while (j < testedVersions.size()) {\n      missingFiles.add(testedVersions.get(j));\n      ++j;\n    }\n\n    // we could be missing up to 1 file, which may be due to a release that is in progress\n    if (missingFiles.size() <= 1 && extraFiles.isEmpty()) {\n      // success\n      return;\n    }\n\n    StringBuffer msg = new StringBuffer();\n    if (missingFiles.size() > 1) {\n      msg.append(\"Missing backcompat test files:\\n\");\n      for (String missingFile : missingFiles) {\n        msg.append(\"  \" + missingFile + \"\\n\");\n      }\n    }\n    if (extraFiles.isEmpty() == false) {\n      msg.append(\"Extra backcompat test files:\\n\");\n      for (String extraFile : extraFiles) {\n        msg.append(\"  \" + extraFile + \"\\n\");\n      }\n    }\n    fail(msg.toString());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"882d14638c19fc8b274bb94935b35e3061acd86e":["5a0b6886e871521dbc3495e30ea752689de9023d"],"98c87780d12c9a7445efb0e3edc4208e0546f140":["ec8882143e40fbd4aaa2cc02fc4abb1217eb24c7"],"5a0b6886e871521dbc3495e30ea752689de9023d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ec8882143e40fbd4aaa2cc02fc4abb1217eb24c7":["882d14638c19fc8b274bb94935b35e3061acd86e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["ec8882143e40fbd4aaa2cc02fc4abb1217eb24c7","98c87780d12c9a7445efb0e3edc4208e0546f140"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"]},"commit2Childs":{"882d14638c19fc8b274bb94935b35e3061acd86e":["ec8882143e40fbd4aaa2cc02fc4abb1217eb24c7"],"98c87780d12c9a7445efb0e3edc4208e0546f140":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"5a0b6886e871521dbc3495e30ea752689de9023d":["882d14638c19fc8b274bb94935b35e3061acd86e"],"ec8882143e40fbd4aaa2cc02fc4abb1217eb24c7":["98c87780d12c9a7445efb0e3edc4208e0546f140","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5a0b6886e871521dbc3495e30ea752689de9023d"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}