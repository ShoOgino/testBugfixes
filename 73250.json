{"path":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newField(random(), \"id\", id, TextField.TYPE_STORED));\n      document.add(newField(random(), \"value\", value, TextField.TYPE_STORED));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      RandomDoc doc = new RandomDoc(id, numberOfLinkValues, value);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        doc.linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(doc);\n          context.randomValueFromDocs.get(value).add(doc);\n          document.add(newField(random(), \"from\", linkValue, TextField.TYPE_STORED));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(doc);\n          context.randomValueToDocs.get(value).add(doc);\n          document.add(newField(random(), \"to\", linkValue, TextField.TYPE_STORED));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + i + \"]: \" + document);\n      }\n    }\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newField(random(), \"id\", id, TextField.TYPE_STORED));\n      document.add(newField(random(), \"value\", value, TextField.TYPE_STORED));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      RandomDoc doc = new RandomDoc(id, numberOfLinkValues, value);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        doc.linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(doc);\n          context.randomValueFromDocs.get(value).add(doc);\n          document.add(newField(random(), \"from\", linkValue, TextField.TYPE_STORED));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(doc);\n          context.randomValueToDocs.get(value).add(doc);\n          document.add(newField(random(), \"to\", linkValue, TextField.TYPE_STORED));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + i + \"]: \" + document);\n      }\n    }\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"77855215e331ce146763531cb9b0c050726f6ae5","date":1338323851,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newField(random(), \"id\", id, TextField.TYPE_UNSTORED));\n      document.add(newField(random(), \"value\", value, TextField.TYPE_UNSTORED));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newField(random(), \"from\", linkValue, TextField.TYPE_UNSTORED));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newField(random(), \"to\", linkValue, TextField.TYPE_UNSTORED));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n          private int docBase;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) throws IOException {}\n        });\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) throws IOException {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newField(random(), \"id\", id, TextField.TYPE_STORED));\n      document.add(newField(random(), \"value\", value, TextField.TYPE_STORED));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      RandomDoc doc = new RandomDoc(id, numberOfLinkValues, value);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        doc.linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(doc);\n          context.randomValueFromDocs.get(value).add(doc);\n          document.add(newField(random(), \"from\", linkValue, TextField.TYPE_STORED));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(doc);\n          context.randomValueToDocs.get(value).add(doc);\n          document.add(newField(random(), \"to\", linkValue, TextField.TYPE_STORED));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + i + \"]: \" + document);\n      }\n    }\n    return context;\n  }\n\n","bugFix":null,"bugIntro":["d4d69c535930b5cce125cff868d40f6373dc27d4","d4d69c535930b5cce125cff868d40f6373dc27d4","d4d69c535930b5cce125cff868d40f6373dc27d4","d4d69c535930b5cce125cff868d40f6373dc27d4","d4d69c535930b5cce125cff868d40f6373dc27d4","87d6f9603307ae2ad642fb01deedf031320fd0c3","87d6f9603307ae2ad642fb01deedf031320fd0c3","87d6f9603307ae2ad642fb01deedf031320fd0c3","87d6f9603307ae2ad642fb01deedf031320fd0c3","87d6f9603307ae2ad642fb01deedf031320fd0c3","04f07771a2a7dd3a395700665ed839c3dae2def2","04f07771a2a7dd3a395700665ed839c3dae2def2","4d3e8520fd031bab31fd0e4d480e55958bc45efe","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n          private int docBase;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) throws IOException {}\n        });\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) throws IOException {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newField(random(), \"id\", id, TextField.TYPE_UNSTORED));\n      document.add(newField(random(), \"value\", value, TextField.TYPE_UNSTORED));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newField(random(), \"from\", linkValue, TextField.TYPE_UNSTORED));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newField(random(), \"to\", linkValue, TextField.TYPE_UNSTORED));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n          private int docBase;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) throws IOException {}\n        });\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) throws IOException {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":["77855215e331ce146763531cb9b0c050726f6ae5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n          private int docBase;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n          private int docBase;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) throws IOException {}\n        });\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) throws IOException {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":["77855215e331ce146763531cb9b0c050726f6ae5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n          private int docBase;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n          private int docBase;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) throws IOException {}\n        });\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) throws IOException {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b64a4420c88dd81303e7f7959057baf9f3b45f94","date":1346077333,"type":5,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          AtomicReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<BytesRef>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue, true)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, 0);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n            private DocTermOrds docTermOrds;\n            private TermsEnum docTermsEnum;\n            private DocTermOrds.TermOrdsIterator reuse;\n            private int docBase;\n\n            public void collect(int doc) throws IOException {\n              if (docTermOrds.isEmpty()) {\n                return;\n              }\n\n              reuse = docTermOrds.lookup(doc, reuse);\n              int[] buffer = new int[5];\n\n              int chunk;\n              do {\n                chunk = reuse.read(buffer);\n                if (chunk == 0) {\n                  return;\n                }\n\n                for (int idx = 0; idx < chunk; idx++) {\n                  int key = buffer[idx];\n                  docTermsEnum.seekExact((long) key);\n                  JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                  if (joinScore == null) {\n                    continue;\n                  }\n                  Integer basedDoc = docBase + doc;\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(basedDoc)) {\n                    docToJoinScore.put(basedDoc, joinScore);\n                  }\n                }\n              } while (chunk >= buffer.length);\n            }\n\n            public void setNextReader(AtomicReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n              docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n              reuse = null;\n            }\n\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n          private int docBase;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":null,"sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<String>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = _TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<BytesRef, JoinScore>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                BytesRef joinValue = docTermsEnum.term();\n                if (joinValue == null) {\n                  continue;\n                }\n\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n                }\n                joinScore.addScore(scorer.score());\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), fromField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new Collector() {\n\n          private Scorer scorer;\n          private FieldCache.DocTerms terms;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) throws IOException {\n            BytesRef joinValue = terms.getTerm(doc, spare);\n            if (joinValue == null) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), fromField);\n          }\n\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<Integer, JoinScore>();\n      if (multipleValuesPerDocument) {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private DocTermOrds docTermOrds;\n          private TermsEnum docTermsEnum;\n          private DocTermOrds.TermOrdsIterator reuse;\n          private int docBase;\n\n          public void collect(int doc) throws IOException {\n            if (docTermOrds.isEmpty()) {\n              return;\n            }\n\n            reuse = docTermOrds.lookup(doc, reuse);\n            int[] buffer = new int[5];\n\n            int chunk;\n            do {\n              chunk = reuse.read(buffer);\n              if (chunk == 0) {\n                return;\n              }\n\n              for (int idx = 0; idx < chunk; idx++) {\n                int key = buffer[idx];\n                docTermsEnum.seekExact((long) key);\n                JoinScore joinScore = joinValueToJoinScores.get(docTermsEnum.term());\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            } while (chunk >= buffer.length);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n            docTermOrds = FieldCache.DEFAULT.getDocTermOrds(context.reader(), toField);\n            docTermsEnum = docTermOrds.getOrdTermsEnum(context.reader());\n            reuse = null;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new Collector() {\n\n          private FieldCache.DocTerms terms;\n          private int docBase;\n          private final BytesRef spare = new BytesRef();\n\n          public void collect(int doc) {\n            JoinScore joinScore = joinValueToJoinScores.get(terms.getTerm(doc, spare));\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            terms = FieldCache.DEFAULT.getTerms(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          DocsEnum docsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean scoreDocsInOrder) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        if (scoreDocsInOrder) {\n          LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n          Terms terms = slowCompositeReader.terms(toField);\n          if (terms != null) {\n            DocsEnum docsEnum = null;\n            TermsEnum termsEnum = null;\n            SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n            joinValues.addAll(joinValueToJoinScores.keySet());\n            for (BytesRef joinValue : joinValues) {\n              termsEnum = terms.iterator(termsEnum);\n              if (termsEnum.seekExact(joinValue)) {\n                docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n                for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                  // First encountered join value determines the score.\n                  // Something to keep in mind for many-to-many relations.\n                  if (!docToJoinScore.containsKey(doc)) {\n                    docToJoinScore.put(doc, joinScore);\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n            private SortedSetDocValues docTermOrds;\n            private int docBase;\n\n            @Override\n            public void collect(int doc) throws IOException {\n              docTermOrds.setDocument(doc);\n              long ord;\n              while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n                final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n                JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n                if (joinScore == null) {\n                  continue;\n                }\n                Integer basedDoc = docBase + doc;\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(basedDoc)) {\n                  docToJoinScore.put(basedDoc, joinScore);\n                }\n              }\n            }\n\n            @Override\n            protected void doSetNextReader(LeafReaderContext context) throws IOException {\n              docBase = context.docBase;\n              docTermOrds = DocValues.getSortedSet(context.reader(), toField);\n            }\n\n            @Override\n            public boolean acceptsDocsOutOfOrder() {return false;}\n            @Override\n            public void setScorer(Scorer scorer) {}\n          });\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {return false;}\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"781239fc84d36be12b84e4d3e2618f5f07a182e3","date":1423139668,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          DocsEnum docsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          DocsEnum docsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.FLAG_NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          DocsEnum docsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              docsEnum = termsEnum.docs(slowCompositeReader.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e73063b92d958076ef4ae8beb5f493e8ccdcecb4","date":1424177215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.FLAG_NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9359ad4a5596673c3154ffa1133458f00e124234","date":1428012026,"type":5,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","date":1428091986,"type":5,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean,boolean).mjava","pathOld":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#createContext(int,RandomIndexWriter,RandomIndexWriter,boolean).mjava","sourceNew":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument, boolean globalOrdinalJoin) throws IOException {\n    if (globalOrdinalJoin) {\n      assertFalse(\"ordinal join doesn't support multiple join values per document\", multipleValuesPerDocument);\n    }\n\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n//        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n        uniqueRandomValue = TestUtil.randomSimpleString(random());\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      if (globalOrdinalJoin) {\n        document.add(newStringField(\"type\", from ? \"from\" : \"to\", Field.Store.NO));\n      }\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n          if (globalOrdinalJoin) {\n            document.add(new SortedDocValuesField(\"join_field\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            if (VERBOSE) {\n              System.out.println(\"expected val=\" + joinValue.utf8ToString() + \" expected score=\" + scorer.score());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","sourceOld":"  private IndexIterationContext createContext(int nDocs, RandomIndexWriter fromWriter, RandomIndexWriter toWriter, boolean multipleValuesPerDocument) throws IOException {\n    IndexIterationContext context = new IndexIterationContext();\n    int numRandomValues = nDocs / 2;\n    context.randomUniqueValues = new String[numRandomValues];\n    Set<String> trackSet = new HashSet<>();\n    context.randomFrom = new boolean[numRandomValues];\n    for (int i = 0; i < numRandomValues; i++) {\n      String uniqueRandomValue;\n      do {\n        uniqueRandomValue = TestUtil.randomRealisticUnicodeString(random());\n//        uniqueRandomValue = _TestUtil.randomSimpleString(random);\n      } while (\"\".equals(uniqueRandomValue) || trackSet.contains(uniqueRandomValue));\n      // Generate unique values and empty strings aren't allowed.\n      trackSet.add(uniqueRandomValue);\n      context.randomFrom[i] = random().nextBoolean();\n      context.randomUniqueValues[i] = uniqueRandomValue;\n    }\n\n    RandomDoc[] docs = new RandomDoc[nDocs];\n    for (int i = 0; i < nDocs; i++) {\n      String id = Integer.toString(i);\n      int randomI = random().nextInt(context.randomUniqueValues.length);\n      String value = context.randomUniqueValues[randomI];\n      Document document = new Document();\n      document.add(newTextField(random(), \"id\", id, Field.Store.NO));\n      document.add(newTextField(random(), \"value\", value, Field.Store.NO));\n\n      boolean from = context.randomFrom[randomI];\n      int numberOfLinkValues = multipleValuesPerDocument ? 2 + random().nextInt(10) : 1;\n      docs[i] = new RandomDoc(id, numberOfLinkValues, value, from);\n      for (int j = 0; j < numberOfLinkValues; j++) {\n        String linkValue = context.randomUniqueValues[random().nextInt(context.randomUniqueValues.length)];\n        docs[i].linkValues.add(linkValue);\n        if (from) {\n          if (!context.fromDocuments.containsKey(linkValue)) {\n            context.fromDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueFromDocs.containsKey(value)) {\n            context.randomValueFromDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.fromDocuments.get(linkValue).add(docs[i]);\n          context.randomValueFromDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"from\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"from\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"from\", new BytesRef(linkValue)));\n          }\n        } else {\n          if (!context.toDocuments.containsKey(linkValue)) {\n            context.toDocuments.put(linkValue, new ArrayList<RandomDoc>());\n          }\n          if (!context.randomValueToDocs.containsKey(value)) {\n            context.randomValueToDocs.put(value, new ArrayList<RandomDoc>());\n          }\n\n          context.toDocuments.get(linkValue).add(docs[i]);\n          context.randomValueToDocs.get(value).add(docs[i]);\n          document.add(newTextField(random(), \"to\", linkValue, Field.Store.NO));\n          if (multipleValuesPerDocument) {\n            document.add(new SortedSetDocValuesField(\"to\", new BytesRef(linkValue)));\n          } else {\n            document.add(new SortedDocValuesField(\"to\", new BytesRef(linkValue)));\n          }\n        }\n      }\n\n      final RandomIndexWriter w;\n      if (from) {\n        w = fromWriter;\n      } else {\n        w = toWriter;\n      }\n\n      w.addDocument(document);\n      if (random().nextInt(10) == 4) {\n        w.commit();\n      }\n      if (VERBOSE) {\n        System.out.println(\"Added document[\" + docs[i].id + \"]: \" + document);\n      }\n    }\n\n    // Pre-compute all possible hits for all unique random values. On top of this also compute all possible score for\n    // any ScoreMode.\n    IndexSearcher fromSearcher = newSearcher(fromWriter.getReader());\n    IndexSearcher toSearcher = newSearcher(toWriter.getReader());\n    for (int i = 0; i < context.randomUniqueValues.length; i++) {\n      String uniqueRandomValue = context.randomUniqueValues[i];\n      final String fromField;\n      final String toField;\n      final Map<String, Map<Integer, JoinScore>> queryVals;\n      if (context.randomFrom[i]) {\n        fromField = \"from\";\n        toField = \"to\";\n        queryVals = context.fromHitsToJoinScore;\n      } else {\n        fromField = \"to\";\n        toField = \"from\";\n        queryVals = context.toHitsToJoinScore;\n      }\n      final Map<BytesRef, JoinScore> joinValueToJoinScores = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private SortedSetDocValues docTermOrds;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            docTermOrds.setDocument(doc);\n            long ord;\n            while ((ord = docTermOrds.nextOrd()) != SortedSetDocValues.NO_MORE_ORDS) {\n              final BytesRef joinValue = docTermOrds.lookupOrd(ord);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n              if (joinScore == null) {\n                joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n              }\n              joinScore.addScore(scorer.score());\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            docTermOrds = DocValues.getSortedSet(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      } else {\n        fromSearcher.search(new TermQuery(new Term(\"value\", uniqueRandomValue)), new SimpleCollector() {\n\n          private Scorer scorer;\n          private BinaryDocValues terms;\n          private Bits docsWithField;\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final BytesRef joinValue = terms.get(doc);\n            if (joinValue.length == 0 && !docsWithField.get(doc)) {\n              return;\n            }\n\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              joinValueToJoinScores.put(BytesRef.deepCopyOf(joinValue), joinScore = new JoinScore());\n            }\n            joinScore.addScore(scorer.score());\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), fromField);\n            docsWithField = DocValues.getDocsWithField(context.reader(), fromField);\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        });\n      }\n\n      final Map<Integer, JoinScore> docToJoinScore = new HashMap<>();\n      if (multipleValuesPerDocument) {\n        LeafReader slowCompositeReader = SlowCompositeReaderWrapper.wrap(toSearcher.getIndexReader());\n        Terms terms = slowCompositeReader.terms(toField);\n        if (terms != null) {\n          PostingsEnum postingsEnum = null;\n          TermsEnum termsEnum = null;\n          SortedSet<BytesRef> joinValues = new TreeSet<>(BytesRef.getUTF8SortedAsUnicodeComparator());\n          joinValues.addAll(joinValueToJoinScores.keySet());\n          for (BytesRef joinValue : joinValues) {\n            termsEnum = terms.iterator(termsEnum);\n            if (termsEnum.seekExact(joinValue)) {\n              postingsEnum = termsEnum.postings(slowCompositeReader.getLiveDocs(), postingsEnum, PostingsEnum.NONE);\n              JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n\n              for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n                // First encountered join value determines the score.\n                // Something to keep in mind for many-to-many relations.\n                if (!docToJoinScore.containsKey(doc)) {\n                  docToJoinScore.put(doc, joinScore);\n                }\n              }\n            }\n          }\n        }\n      } else {\n        toSearcher.search(new MatchAllDocsQuery(), new SimpleCollector() {\n\n          private BinaryDocValues terms;\n          private int docBase;\n\n          @Override\n          public void collect(int doc) {\n            final BytesRef joinValue = terms.get(doc);\n            JoinScore joinScore = joinValueToJoinScores.get(joinValue);\n            if (joinScore == null) {\n              return;\n            }\n            docToJoinScore.put(docBase + doc, joinScore);\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            terms = DocValues.getBinary(context.reader(), toField);\n            docBase = context.docBase;\n          }\n\n          @Override\n          public void setScorer(Scorer scorer) {}\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        });\n      }\n      queryVals.put(uniqueRandomValue, docToJoinScore);\n    }\n\n    fromSearcher.getIndexReader().close();\n    toSearcher.getIndexReader().close();\n\n    return context;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9359ad4a5596673c3154ffa1133458f00e124234":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","b64a4420c88dd81303e7f7959057baf9f3b45f94"],"51f5280f31484820499077f41fcdfe92d527d9dc":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"b64a4420c88dd81303e7f7959057baf9f3b45f94":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["77855215e331ce146763531cb9b0c050726f6ae5"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["51f5280f31484820499077f41fcdfe92d527d9dc"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["b64a4420c88dd81303e7f7959057baf9f3b45f94"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["04f07771a2a7dd3a395700665ed839c3dae2def2","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4","9359ad4a5596673c3154ffa1133458f00e124234"],"77855215e331ce146763531cb9b0c050726f6ae5":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9359ad4a5596673c3154ffa1133458f00e124234"]},"commit2Childs":{"9359ad4a5596673c3154ffa1133458f00e124234":["6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["51f5280f31484820499077f41fcdfe92d527d9dc"],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"51f5280f31484820499077f41fcdfe92d527d9dc":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"b64a4420c88dd81303e7f7959057baf9f3b45f94":["05a14b2611ead08655a2b2bdc61632eb31316e57","f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"04f07771a2a7dd3a395700665ed839c3dae2def2":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["9359ad4a5596673c3154ffa1133458f00e124234","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["77855215e331ce146763531cb9b0c050726f6ae5"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c":[],"77855215e331ce146763531cb9b0c050726f6ae5":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["05a14b2611ead08655a2b2bdc61632eb31316e57","b64a4420c88dd81303e7f7959057baf9f3b45f94","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["05a14b2611ead08655a2b2bdc61632eb31316e57","fe33227f6805edab2036cbb80645cc4e2d1fa424","6c757ac42dd1f3f893db5c4d89c61cbe1a9fab6c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}