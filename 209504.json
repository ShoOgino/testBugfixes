{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#mergeStats(Map[String,StatsValues],NamedList[NamedList[NamedList[#]]],StatsInfo).mjava","commits":[{"id":"4c18a95e9168a30be855f5d5e7d61a863186fdc5","date":1415142581,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#mergeStats(Map[String,StatsValues],NamedList[NamedList[NamedList[#]]],StatsInfo).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given a mapping of keys to {@link StatsValues} representing the currently \n   * known \"merged\" stats (which may be null if none exist yet), and a \n   * {@link NamedList} containing the \"stats\" response block returned by an individual \n   * shard, this method accumulates the stasts for each {@link StatsField} found in \n   * the shard response with the existing mergeStats\n   *\n   * @return the original <code>merged</code> Map after modifying, or a new Map if the <code>merged</code> param was originally null.\n   * @see StatsInfo#getStatsField\n   * @see StatsValuesFactory#createStatsValues\n   * @see StatsValues#accumulate(NamedList)\n   */\n  public static Map<String,StatsValues> mergeStats\n    (Map<String,StatsValues> merged, \n     NamedList<NamedList<NamedList<?>>> remoteWrapper, \n     StatsInfo statsInfo) {\n\n    if (null == merged) merged = new LinkedHashMap<String,StatsValues>();\n\n    NamedList<NamedList<?>> remoteStats = StatsComponent.unwrapStats(remoteWrapper);\n\n    for (Entry<String,NamedList<?>> entry : remoteStats) {\n      StatsValues receivingStatsValues = merged.get(entry.getKey());\n      if (receivingStatsValues == null) {\n        StatsField recievingStatsField = statsInfo.getStatsField(entry.getKey());\n        if (null == recievingStatsField) {\n          throw new SolrException(ErrorCode.SERVER_ERROR , \"No stats.field found corrisponding to pivot stats recieved from shard: \"+entry.getKey());\n        }\n        receivingStatsValues = StatsValuesFactory.createStatsValues(recievingStatsField);\n        merged.put(entry.getKey(), receivingStatsValues);\n      }\n      receivingStatsValues.accumulate(entry.getValue());\n    }\n    return merged;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c169312e8f621502de0661c48a43e492983cd28a","date":1423728604,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#mergeStats(Map[String,StatsValues],NamedList[NamedList[NamedList[#]]],StatsInfo).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetHelper#mergeStats(Map[String,StatsValues],NamedList[NamedList[NamedList[#]]],StatsInfo).mjava","sourceNew":"  /**\n   * Given a mapping of keys to {@link StatsValues} representing the currently \n   * known \"merged\" stats (which may be null if none exist yet), and a \n   * {@link NamedList} containing the \"stats\" response block returned by an individual \n   * shard, this method accumulates the stats for each {@link StatsField} found in\n   * the shard response with the existing mergeStats\n   *\n   * @return the original <code>merged</code> Map after modifying, or a new Map if the <code>merged</code> param was originally null.\n   * @see StatsInfo#getStatsField\n   * @see StatsValuesFactory#createStatsValues\n   * @see StatsValues#accumulate(NamedList)\n   */\n  public static Map<String,StatsValues> mergeStats\n    (Map<String,StatsValues> merged, \n     NamedList<NamedList<NamedList<?>>> remoteWrapper, \n     StatsInfo statsInfo) {\n\n    if (null == merged) merged = new LinkedHashMap<>();\n\n    NamedList<NamedList<?>> remoteStats = StatsComponent.unwrapStats(remoteWrapper);\n\n    for (Entry<String,NamedList<?>> entry : remoteStats) {\n      StatsValues receivingStatsValues = merged.get(entry.getKey());\n      if (receivingStatsValues == null) {\n        StatsField receivingStatsField = statsInfo.getStatsField(entry.getKey());\n        if (null == receivingStatsField) {\n          throw new SolrException(ErrorCode.SERVER_ERROR , \"No stats.field found corresponding to pivot stats received from shard: \"+entry.getKey());\n        }\n        receivingStatsValues = StatsValuesFactory.createStatsValues(receivingStatsField);\n        merged.put(entry.getKey(), receivingStatsValues);\n      }\n      receivingStatsValues.accumulate(entry.getValue());\n    }\n    return merged;\n  }\n\n","sourceOld":"  /**\n   * Given a mapping of keys to {@link StatsValues} representing the currently \n   * known \"merged\" stats (which may be null if none exist yet), and a \n   * {@link NamedList} containing the \"stats\" response block returned by an individual \n   * shard, this method accumulates the stasts for each {@link StatsField} found in \n   * the shard response with the existing mergeStats\n   *\n   * @return the original <code>merged</code> Map after modifying, or a new Map if the <code>merged</code> param was originally null.\n   * @see StatsInfo#getStatsField\n   * @see StatsValuesFactory#createStatsValues\n   * @see StatsValues#accumulate(NamedList)\n   */\n  public static Map<String,StatsValues> mergeStats\n    (Map<String,StatsValues> merged, \n     NamedList<NamedList<NamedList<?>>> remoteWrapper, \n     StatsInfo statsInfo) {\n\n    if (null == merged) merged = new LinkedHashMap<String,StatsValues>();\n\n    NamedList<NamedList<?>> remoteStats = StatsComponent.unwrapStats(remoteWrapper);\n\n    for (Entry<String,NamedList<?>> entry : remoteStats) {\n      StatsValues receivingStatsValues = merged.get(entry.getKey());\n      if (receivingStatsValues == null) {\n        StatsField recievingStatsField = statsInfo.getStatsField(entry.getKey());\n        if (null == recievingStatsField) {\n          throw new SolrException(ErrorCode.SERVER_ERROR , \"No stats.field found corrisponding to pivot stats recieved from shard: \"+entry.getKey());\n        }\n        receivingStatsValues = StatsValuesFactory.createStatsValues(recievingStatsField);\n        merged.put(entry.getKey(), receivingStatsValues);\n      }\n      receivingStatsValues.accumulate(entry.getValue());\n    }\n    return merged;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c169312e8f621502de0661c48a43e492983cd28a":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c169312e8f621502de0661c48a43e492983cd28a"]},"commit2Childs":{"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["c169312e8f621502de0661c48a43e492983cd28a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"c169312e8f621502de0661c48a43e492983cd28a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}