{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String,boolean).mjava","sourceNew":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   * Optionally count transpositions as a primitive edit.\n   */\n  public LevenshteinAutomata(String input, boolean withTranspositions) {\n    this.input = input;\n    int length = Character.codePointCount(input, 0, input.length());\n    word = new int[length];\n    for (int i = 0, j = 0, cp = 0; i < input.length(); i += Character.charCount(cp)) {\n      word[j++] = cp = input.codePointAt(i);\n    }\n    \n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= Character.MAX_CODE_POINT) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = Character.MAX_CODE_POINT;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   * Optionally count transpositions as a primitive edit.\n   */\n  public LevenshteinAutomata(String input, boolean withTranspositions) {\n    this.input = input;\n    int length = Character.codePointCount(input, 0, input.length());\n    word = new int[length];\n    for (int i = 0, j = 0, cp = 0; i < input.length(); i += Character.charCount(cp)) {\n      word[j++] = cp = input.codePointAt(i);\n    }\n    \n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= Character.MAX_CODE_POINT) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = Character.MAX_CODE_POINT;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc41b743423981e7ec17a024ce7e107096e472fe","date":1349975327,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String,boolean).mjava","sourceNew":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   * Optionally count transpositions as a primitive edit.\n   */\n  public LevenshteinAutomata(String input, boolean withTranspositions) {\n    this(codePoints(input), Character.MAX_CODE_POINT, withTranspositions);\n  }\n\n","sourceOld":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   * Optionally count transpositions as a primitive edit.\n   */\n  public LevenshteinAutomata(String input, boolean withTranspositions) {\n    this.input = input;\n    int length = Character.codePointCount(input, 0, input.length());\n    word = new int[length];\n    for (int i = 0, j = 0, cp = 0; i < input.length(); i += Character.charCount(cp)) {\n      word[j++] = cp = input.codePointAt(i);\n    }\n    \n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= Character.MAX_CODE_POINT) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = Character.MAX_CODE_POINT;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","date":1351615637,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/LevenshteinAutomata#LevenshteinAutomata(String,boolean).mjava","sourceNew":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   * Optionally count transpositions as a primitive edit.\n   */\n  public LevenshteinAutomata(String input, boolean withTranspositions) {\n    this(codePoints(input), Character.MAX_CODE_POINT, withTranspositions);\n  }\n\n","sourceOld":"  /**\n   * Create a new LevenshteinAutomata for some input String.\n   * Optionally count transpositions as a primitive edit.\n   */\n  public LevenshteinAutomata(String input, boolean withTranspositions) {\n    this.input = input;\n    int length = Character.codePointCount(input, 0, input.length());\n    word = new int[length];\n    for (int i = 0, j = 0, cp = 0; i < input.length(); i += Character.charCount(cp)) {\n      word[j++] = cp = input.codePointAt(i);\n    }\n    \n    // calculate the alphabet\n    SortedSet<Integer> set = new TreeSet<Integer>();\n    for (int i = 0; i < word.length; i++)\n      set.add(word[i]);\n    alphabet = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    for (int i = 0; i < alphabet.length; i++)\n      alphabet[i] = iterator.next();\n      \n    rangeLower = new int[alphabet.length + 2];\n    rangeUpper = new int[alphabet.length + 2];\n    // calculate the unicode range intervals that exclude the alphabet\n    // these are the ranges for all unicode characters not in the alphabet\n    int lower = 0;\n    for (int i = 0; i < alphabet.length; i++) {\n      int higher = alphabet[i];\n      if (higher > lower) {\n        rangeLower[numRanges] = lower;\n        rangeUpper[numRanges] = higher - 1;\n        numRanges++;\n      }\n      lower = higher + 1;\n    }\n    /* add the final endpoint */\n    if (lower <= Character.MAX_CODE_POINT) {\n      rangeLower[numRanges] = lower;\n      rangeUpper[numRanges] = Character.MAX_CODE_POINT;\n      numRanges++;\n    }\n\n    descriptions = new ParametricDescription[] {\n        null, /* for n=0, we do not need to go through the trouble */\n        withTranspositions ? new Lev1TParametricDescription(word.length) : new Lev1ParametricDescription(word.length),\n        withTranspositions ? new Lev2TParametricDescription(word.length) : new Lev2ParametricDescription(word.length),\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","cc41b743423981e7ec17a024ce7e107096e472fe"],"cc41b743423981e7ec17a024ce7e107096e472fe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"]},"commit2Childs":{"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cc41b743423981e7ec17a024ce7e107096e472fe":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","cc41b743423981e7ec17a024ce7e107096e472fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}