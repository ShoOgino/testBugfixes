{"path":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) throws IOException {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) throws IOException {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) throws IOException {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) throws IOException {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) throws IOException {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) throws IOException {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) throws IOException {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) throws IOException {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) throws IOException {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) throws IOException {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) throws IOException {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) throws IOException {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) throws IOException {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) throws IOException {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) throws IOException {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) throws IOException {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) throws IOException {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) throws IOException {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb02351ae2b114dd41585916d1e35fb2cff98fb0","date":1337171337,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) throws IOException {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) throws IOException {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) throws IOException {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) throws IOException {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) throws IOException {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) throws IOException {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) throws IOException {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef0d8a69209261514c5739c770bba706c2308450","date":1337607597,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) throws IOException {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) throws IOException {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) throws IOException {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) throws IOException {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) throws IOException {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) throws IOException {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) throws IOException {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) throws IOException {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) throws IOException {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) throws IOException {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) throws IOException {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","bugFix":["c7e70cecc56c33998f8f16cd1fbbc5a58de17f28","fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) throws IOException {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) throws IOException {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) throws IOException {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) throws IOException {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29f7cc7c185412da66c1d0089d9e75da01329a00","date":1353364851,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d7e5f3aa5935964617824d1f9b2599ddb334464","date":1353762831,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         idIndex.lookupOrd(ord, tempBR);\n         Integer prio = priority.get(tempBR);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         idIndex.lookupOrd(ord, tempBR);\n         Integer prio = priority.get(tempBR);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     FieldCache.DocTermsIndex idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == 0) {\n         return 0;\n       } else {\n         BytesRef id = idIndex.lookup(ord, tempBR);\n         Integer prio = priority.get(id);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","bugFix":["be20f9fed1d3edcb1c84abcc39df87a90fab22df"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7615b855702e008d91a95a2578bf05d27372f599","date":1389802891,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         idIndex.lookupOrd(ord, tempBR);\n         Integer prio = priority.get(tempBR);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareTop(int doc) {\n       throw new UnsupportedOperationException();\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         idIndex.lookupOrd(ord, tempBR);\n         Integer prio = priority.get(tempBR);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27ab7b234eab0cbc020836989b96ed430e1065bb","date":1389894025,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         idIndex.lookupOrd(ord, tempBR);\n         Integer prio = priority.get(tempBR);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareTop(int doc) {\n       throw new UnsupportedOperationException();\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         idIndex.lookupOrd(ord, tempBR);\n         Integer prio = priority.get(tempBR);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareDocToValue(int doc, Integer valueObj) {\n       final int value = valueObj.intValue();\n       final int docValue = docVal(doc);\n       // values will be small enough that there is no overflow concern\n       return value - docValue;\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","date":1399816179,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         idIndex.lookupOrd(ord, tempBR);\n         Integer prio = priority.get(tempBR);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = DocValues.getSorted(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareTop(int doc) {\n       throw new UnsupportedOperationException();\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         idIndex.lookupOrd(ord, tempBR);\n         Integer prio = priority.get(tempBR);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareTop(int doc) {\n       throw new UnsupportedOperationException();\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93dd449115a9247533e44bab47e8429e5dccbc6d","date":1400258396,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         idIndex.lookupOrd(ord, tempBR);\n         Integer prio = priority.get(tempBR);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = DocValues.getSorted(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareTop(int doc) {\n       throw new UnsupportedOperationException();\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         idIndex.lookupOrd(ord, tempBR);\n         Integer prio = priority.get(tempBR);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareTop(int doc) {\n       throw new UnsupportedOperationException();\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         idIndex.lookupOrd(ord, tempBR);\n         Integer prio = priority.get(tempBR);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = DocValues.getSorted(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareTop(int doc) {\n       throw new UnsupportedOperationException();\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         idIndex.lookupOrd(ord, tempBR);\n         Integer prio = priority.get(tempBR);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = FieldCache.DEFAULT.getTermsIndex(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareTop(int doc) {\n       throw new UnsupportedOperationException();\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf","date":1401983689,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         final BytesRef term = idIndex.lookupOrd(ord);\n         Integer prio = priority.get(term);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = DocValues.getSorted(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareTop(int doc) {\n       throw new UnsupportedOperationException();\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     private final BytesRef tempBR = new BytesRef();\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         idIndex.lookupOrd(ord, tempBR);\n         Integer prio = priority.get(tempBR);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = DocValues.getSorted(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareTop(int doc) {\n       throw new UnsupportedOperationException();\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         final BytesRef term = idIndex.lookupOrd(ord);\n         Integer prio = priority.get(term);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n       idIndex = DocValues.getSorted(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareTop(int doc) {\n       throw new UnsupportedOperationException();\n     }\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         final BytesRef term = idIndex.lookupOrd(ord);\n         Integer prio = priority.get(term);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(AtomicReaderContext context) throws IOException {\n       idIndex = DocValues.getSorted(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareTop(int doc) {\n       throw new UnsupportedOperationException();\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"901e951cec2e6af4e503209a6721c8834db23279","date":1420556599,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n    public LeafFieldComparator getLeafComparator(LeafReaderContext context)\n        throws IOException {\n      final SortedDocValues idIndex = DocValues.getSorted(context.reader(), fieldname);\n      return new LeafFieldComparator() {\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          throw new UnsupportedOperationException();\n        }\n\n        private int docVal(int doc) {\n          int ord = idIndex.getOrd(doc);\n          if (ord == -1) {\n            return 0;\n          } else {\n            final BytesRef term = idIndex.lookupOrd(ord);\n            Integer prio = priority.get(term);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) {\n          return docVal(doc) - bottomVal;\n        }\n\n        @Override\n        public void copy(int slot, int doc) {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {}\n      };\n    }\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     SortedDocValues idIndex;\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setBottom(int slot) {\n       bottomVal = values[slot];\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     private int docVal(int doc) {\n       int ord = idIndex.getOrd(doc);\n       if (ord == -1) {\n         return 0;\n       } else {\n         final BytesRef term = idIndex.lookupOrd(ord);\n         Integer prio = priority.get(term);\n         return prio == null ? 0 : prio.intValue();\n       }\n     }\n\n     @Override\n     public int compareBottom(int doc) {\n       return docVal(doc) - bottomVal;\n     }\n\n     @Override\n     public void copy(int slot, int doc) {\n       values[slot] = docVal(doc);\n     }\n\n     @Override\n     public FieldComparator<Integer> setNextReader(LeafReaderContext context) throws IOException {\n       idIndex = DocValues.getSorted(context.reader(), fieldname);\n       return this;\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n     @Override\n     public int compareTop(int doc) {\n       throw new UnsupportedOperationException();\n     }\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n     public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n      return new LeafFieldComparator() {\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          throw new UnsupportedOperationException();\n        }\n\n        private int docVal(int doc) throws IOException {\n          SortedDocValues idIndex = DocValues.getSorted(context.reader(), fieldname);\n          if (idIndex.advance(doc) == doc) {\n            final BytesRef term = idIndex.binaryValue();\n            Integer prio = priority.get(term);\n            return prio == null ? 0 : prio.intValue();\n          } else {\n            return 0;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) throws IOException {\n          return docVal(doc) - bottomVal;\n        }\n\n        @Override\n        public void copy(int slot, int doc) throws IOException {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {}\n      };\n    }\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n    public LeafFieldComparator getLeafComparator(LeafReaderContext context)\n        throws IOException {\n      final SortedDocValues idIndex = DocValues.getSorted(context.reader(), fieldname);\n      return new LeafFieldComparator() {\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          throw new UnsupportedOperationException();\n        }\n\n        private int docVal(int doc) {\n          int ord = idIndex.getOrd(doc);\n          if (ord == -1) {\n            return 0;\n          } else {\n            final BytesRef term = idIndex.lookupOrd(ord);\n            Integer prio = priority.get(term);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) {\n          return docVal(doc) - bottomVal;\n        }\n\n        @Override\n        public void copy(int slot, int doc) {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {}\n      };\n    }\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n     public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n      return new LeafFieldComparator() {\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          throw new UnsupportedOperationException();\n        }\n\n        private int docVal(int doc) throws IOException {\n          SortedDocValues idIndex = DocValues.getSorted(context.reader(), fieldname);\n          if (idIndex.advance(doc) == doc) {\n            final BytesRef term = idIndex.binaryValue();\n            Integer prio = priority.get(term);\n            return prio == null ? 0 : prio.intValue();\n          } else {\n            return 0;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) throws IOException {\n          return docVal(doc) - bottomVal;\n        }\n\n        @Override\n        public void copy(int slot, int doc) throws IOException {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {}\n      };\n    }\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n    public LeafFieldComparator getLeafComparator(LeafReaderContext context)\n        throws IOException {\n      final SortedDocValues idIndex = DocValues.getSorted(context.reader(), fieldname);\n      return new LeafFieldComparator() {\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          throw new UnsupportedOperationException();\n        }\n\n        private int docVal(int doc) {\n          int ord = idIndex.getOrd(doc);\n          if (ord == -1) {\n            return 0;\n          } else {\n            final BytesRef term = idIndex.lookupOrd(ord);\n            Integer prio = priority.get(term);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) {\n          return docVal(doc) - bottomVal;\n        }\n\n        @Override\n        public void copy(int slot, int doc) {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {}\n      };\n    }\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n     public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n      return new LeafFieldComparator() {\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          throw new UnsupportedOperationException();\n        }\n\n        private int docVal(int doc) throws IOException {\n          SortedDocValues idIndex = DocValues.getSorted(context.reader(), fieldname);\n          if (idIndex.advance(doc) == doc) {\n            final BytesRef term = idIndex.binaryValue();\n            Integer prio = priority.get(term);\n            return prio == null ? 0 : prio.intValue();\n          } else {\n            return 0;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) throws IOException {\n          return docVal(doc) - bottomVal;\n        }\n\n        @Override\n        public void copy(int slot, int doc) throws IOException {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {}\n      };\n    }\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n    public LeafFieldComparator getLeafComparator(LeafReaderContext context)\n        throws IOException {\n      final SortedDocValues idIndex = DocValues.getSorted(context.reader(), fieldname);\n      return new LeafFieldComparator() {\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          throw new UnsupportedOperationException();\n        }\n\n        private int docVal(int doc) {\n          int ord = idIndex.getOrd(doc);\n          if (ord == -1) {\n            return 0;\n          } else {\n            final BytesRef term = idIndex.lookupOrd(ord);\n            Integer prio = priority.get(term);\n            return prio == null ? 0 : prio.intValue();\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) {\n          return docVal(doc) - bottomVal;\n        }\n\n        @Override\n        public void copy(int slot, int doc) {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {}\n      };\n    }\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03e38c6374c23083c93e212a9498ff0a9c255476","date":1484767039,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) {\n   return new FieldComparator<Integer>() {\n\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n     public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n      return new LeafFieldComparator() {\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          throw new UnsupportedOperationException();\n        }\n\n        private int docVal(int doc) throws IOException {\n          SortedDocValues idIndex = DocValues.getSorted(context.reader(), fieldname);\n          if (idIndex.advance(doc) == doc) {\n            final BytesRef term = idIndex.binaryValue();\n            Integer prio = priority.get(term);\n            return prio == null ? 0 : prio.intValue();\n          } else {\n            return 0;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) throws IOException {\n          return docVal(doc) - bottomVal;\n        }\n\n        @Override\n        public void copy(int slot, int doc) throws IOException {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {}\n      };\n    }\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n     public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n      return new LeafFieldComparator() {\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          throw new UnsupportedOperationException();\n        }\n\n        private int docVal(int doc) throws IOException {\n          SortedDocValues idIndex = DocValues.getSorted(context.reader(), fieldname);\n          if (idIndex.advance(doc) == doc) {\n            final BytesRef term = idIndex.binaryValue();\n            Integer prio = priority.get(term);\n            return prio == null ? 0 : prio.intValue();\n          } else {\n            return 0;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) throws IOException {\n          return docVal(doc) - bottomVal;\n        }\n\n        @Override\n        public void copy(int slot, int doc) throws IOException {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {}\n      };\n    }\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"90a682dc1bfd188ef61cc28373c7f5d700b4ac75","date":1485186128,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) {\n   return new FieldComparator<Integer>() {\n\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n     public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n      return new LeafFieldComparator() {\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          throw new UnsupportedOperationException();\n        }\n\n        private int docVal(int doc) throws IOException {\n          SortedDocValues idIndex = DocValues.getSorted(context.reader(), fieldname);\n          if (idIndex.advance(doc) == doc) {\n            final BytesRef term = idIndex.binaryValue();\n            Integer prio = priority.get(term);\n            return prio == null ? 0 : prio.intValue();\n          } else {\n            return 0;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) throws IOException {\n          return docVal(doc) - bottomVal;\n        }\n\n        @Override\n        public void copy(int slot, int doc) throws IOException {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {}\n      };\n    }\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {\n   return new FieldComparator<Integer>() {\n\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n     public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n      return new LeafFieldComparator() {\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          throw new UnsupportedOperationException();\n        }\n\n        private int docVal(int doc) throws IOException {\n          SortedDocValues idIndex = DocValues.getSorted(context.reader(), fieldname);\n          if (idIndex.advance(doc) == doc) {\n            final BytesRef term = idIndex.binaryValue();\n            Integer prio = priority.get(term);\n            return prio == null ? 0 : prio.intValue();\n          } else {\n            return 0;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) throws IOException {\n          return docVal(doc) - bottomVal;\n        }\n\n        @Override\n        public void copy(int slot, int doc) throws IOException {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {}\n      };\n    }\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285244982ce6aa163d1e60a707f0e6e121736ce5","date":1536055304,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/ElevationComparatorSource[TestElevationComparator]#newComparator(String,int,int,boolean).mjava","sourceNew":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) {\n   return new FieldComparator<Integer>() {\n\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n     public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n      return new LeafFieldComparator() {\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          throw new UnsupportedOperationException();\n        }\n\n        private int docVal(int doc) throws IOException {\n          SortedDocValues idIndex = DocValues.getSorted(context.reader(), fieldname);\n          if (idIndex.advance(doc) == doc) {\n            final BytesRef term = idIndex.binaryValue();\n            Integer prio = priority.get(term);\n            return prio == null ? 0 : prio.intValue();\n          } else {\n            return 0;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) throws IOException {\n          return docVal(doc) - bottomVal;\n        }\n\n        @Override\n        public void copy(int slot, int doc) throws IOException {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public void setScorer(Scorable scorer) {}\n      };\n    }\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n\n   };\n }\n\n","sourceOld":"  @Override\n  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) {\n   return new FieldComparator<Integer>() {\n\n     private final int[] values = new int[numHits];\n     int bottomVal;\n\n     @Override\n     public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n      return new LeafFieldComparator() {\n\n        @Override\n        public void setBottom(int slot) {\n          bottomVal = values[slot];\n        }\n\n        @Override\n        public int compareTop(int doc) {\n          throw new UnsupportedOperationException();\n        }\n\n        private int docVal(int doc) throws IOException {\n          SortedDocValues idIndex = DocValues.getSorted(context.reader(), fieldname);\n          if (idIndex.advance(doc) == doc) {\n            final BytesRef term = idIndex.binaryValue();\n            Integer prio = priority.get(term);\n            return prio == null ? 0 : prio.intValue();\n          } else {\n            return 0;\n          }\n        }\n\n        @Override\n        public int compareBottom(int doc) throws IOException {\n          return docVal(doc) - bottomVal;\n        }\n\n        @Override\n        public void copy(int slot, int doc) throws IOException {\n          values[slot] = docVal(doc);\n        }\n\n        @Override\n        public void setScorer(Scorer scorer) {}\n      };\n    }\n\n     @Override\n     public int compare(int slot1, int slot2) {\n       return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern\n     }\n\n     @Override\n     public void setTopValue(Integer value) {\n       throw new UnsupportedOperationException();\n     }\n\n     @Override\n     public Integer value(int slot) {\n       return Integer.valueOf(values[slot]);\n     }\n\n\n   };\n }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"29f7cc7c185412da66c1d0089d9e75da01329a00":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["d4d69c535930b5cce125cff868d40f6373dc27d4","7615b855702e008d91a95a2578bf05d27372f599"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"56572ec06f1407c066d6b7399413178b33176cd8":["27ab7b234eab0cbc020836989b96ed430e1065bb","93dd449115a9247533e44bab47e8429e5dccbc6d"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["901e951cec2e6af4e503209a6721c8834db23279","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"9d7e5f3aa5935964617824d1f9b2599ddb334464":["29f7cc7c185412da66c1d0089d9e75da01329a00"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"ef0d8a69209261514c5739c770bba706c2308450":["f08557cdb6c60ac7b88a9342c983a20cd236e74f","fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"901e951cec2e6af4e503209a6721c8834db23279":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["901e951cec2e6af4e503209a6721c8834db23279","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","03e38c6374c23083c93e212a9498ff0a9c255476"],"fb02351ae2b114dd41585916d1e35fb2cff98fb0":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","9d7e5f3aa5935964617824d1f9b2599ddb334464"],"03e38c6374c23083c93e212a9498ff0a9c255476":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["27ab7b234eab0cbc020836989b96ed430e1065bb","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["03e38c6374c23083c93e212a9498ff0a9c255476"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["fb02351ae2b114dd41585916d1e35fb2cff98fb0","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["901e951cec2e6af4e503209a6721c8834db23279"],"7615b855702e008d91a95a2578bf05d27372f599":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["285244982ce6aa163d1e60a707f0e6e121736ce5"]},"commit2Childs":{"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"29f7cc7c185412da66c1d0089d9e75da01329a00":["9d7e5f3aa5935964617824d1f9b2599ddb334464"],"27ab7b234eab0cbc020836989b96ed430e1065bb":["56572ec06f1407c066d6b7399413178b33176cd8","b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c","93dd449115a9247533e44bab47e8429e5dccbc6d"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"56572ec06f1407c066d6b7399413178b33176cd8":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["901e951cec2e6af4e503209a6721c8834db23279"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","03e38c6374c23083c93e212a9498ff0a9c255476"],"9d7e5f3aa5935964617824d1f9b2599ddb334464":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["29f7cc7c185412da66c1d0089d9e75da01329a00","d4d69c535930b5cce125cff868d40f6373dc27d4","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"ef0d8a69209261514c5739c770bba706c2308450":[],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","ef0d8a69209261514c5739c770bba706c2308450","fb02351ae2b114dd41585916d1e35fb2cff98fb0"],"53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"b70a13d2b73512ad6b204e9ad8fe09ffeeda3c2c":["93dd449115a9247533e44bab47e8429e5dccbc6d"],"901e951cec2e6af4e503209a6721c8834db23279":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75"],"90a682dc1bfd188ef61cc28373c7f5d700b4ac75":[],"fb02351ae2b114dd41585916d1e35fb2cff98fb0":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","ef0d8a69209261514c5739c770bba706c2308450","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["27ab7b234eab0cbc020836989b96ed430e1065bb","7615b855702e008d91a95a2578bf05d27372f599"],"93dd449115a9247533e44bab47e8429e5dccbc6d":["56572ec06f1407c066d6b7399413178b33176cd8","53fc2f4c5ce4f2053be3d5f5d14d79129ebb4bbf"],"03e38c6374c23083c93e212a9498ff0a9c255476":["90a682dc1bfd188ef61cc28373c7f5d700b4ac75","285244982ce6aa163d1e60a707f0e6e121736ce5"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"7615b855702e008d91a95a2578bf05d27372f599":["27ab7b234eab0cbc020836989b96ed430e1065bb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","56572ec06f1407c066d6b7399413178b33176cd8","ef0d8a69209261514c5739c770bba706c2308450","90a682dc1bfd188ef61cc28373c7f5d700b4ac75","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}