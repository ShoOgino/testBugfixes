{"path":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"modules/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<SpanQuery>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<SpanQuery>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e2eb9920ac302f8d2a4cd14e42eba6935f84fe0d","date":1394988844,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":["0107b7f49bcfde8f333685f53b37608815ca889b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f68d01cf19df971dcdcb05e30247f4ad7ec9747","date":1434611645,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2e0b693f44c4d48acb66e289f04ec7309118a1a","date":1437989791,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = new IndexSearcher(reader).rewrite(qc);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2dfdf766e55e943d942055d7de53c7ad6bc45283","date":1441632886,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = new IndexSearcher(reader).rewrite(qc);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        while (qc instanceof BoostQuery) {\n          qc = ((BoostQuery) qc).getQuery();\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = new IndexSearcher(reader).rewrite(qc);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8b3f2faaf05547a6ed4e2769b664522af9514b3","date":1466522779,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = new IndexSearcher(reader).rewrite(qc);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        while (qc instanceof BoostQuery) {\n          qc = ((BoostQuery) qc).getQuery();\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else if (qc instanceof MatchNoDocsQuery) {\n          // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n          // there were no \"Smithe*\" terms - need to\n          // prevent match on just \"Fred\".\n          allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                                                         \"Dummy clause because no terms found - must match nothing\"));\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = new IndexSearcher(reader).rewrite(qc);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        while (qc instanceof BoostQuery) {\n          qc = ((BoostQuery) qc).getQuery();\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = new IndexSearcher(reader).rewrite(qc);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        while (qc instanceof BoostQuery) {\n          qc = ((BoostQuery) qc).getQuery();\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else if (qc instanceof MatchNoDocsQuery) {\n          // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n          // there were no \"Smithe*\" terms - need to\n          // prevent match on just \"Fred\".\n          allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                                                         \"Dummy clause because no terms found - must match nothing\"));\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = new IndexSearcher(reader).rewrite(qc);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        while (qc instanceof BoostQuery) {\n          qc = ((BoostQuery) qc).getQuery();\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"72adbc0c89de5fae07a4c2dbf2798821b037f37d","date":1483738924,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery \n          || contents instanceof MultiTermQuery\n          ) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = new IndexSearcher(reader).rewrite(qc);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        while (qc instanceof BoostQuery) {\n          qc = ((BoostQuery) qc).getQuery();\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else if (qc instanceof MatchNoDocsQuery) {\n          // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n          // there were no \"Smithe*\" terms - need to\n          // prevent match on just \"Fred\".\n          allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                                                         \"Dummy clause because no terms found - must match nothing\"));\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = new IndexSearcher(reader).rewrite(qc);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        while (qc instanceof BoostQuery) {\n          qc = ((BoostQuery) qc).getQuery();\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else if (qc instanceof MatchNoDocsQuery) {\n          // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n          // there were no \"Smithe*\" terms - need to\n          // prevent match on just \"Fred\".\n          allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                                                         \"Dummy clause because no terms found - must match nothing\"));\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery \n          || contents instanceof MultiTermQuery\n          ) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = new IndexSearcher(reader).rewrite(qc);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        while (qc instanceof BoostQuery) {\n          qc = ((BoostQuery) qc).getQuery();\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else if (qc instanceof MatchNoDocsQuery) {\n          // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n          // there were no \"Smithe*\" terms - need to\n          // prevent match on just \"Fred\".\n          allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                                                         \"Dummy clause because no terms found - must match nothing\"));\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = new IndexSearcher(reader).rewrite(qc);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        while (qc instanceof BoostQuery) {\n          qc = ((BoostQuery) qc).getQuery();\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else if (qc instanceof MatchNoDocsQuery) {\n          // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n          // there were no \"Smithe*\" terms - need to\n          // prevent match on just \"Fred\".\n          allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                                                         \"Dummy clause because no terms found - must match nothing\"));\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"de299b6017d29ce89b72c3ef9cfb99ca50d433cf","date":1488961235,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery \n          || contents instanceof MultiTermQuery\n          || contents instanceof SynonymQuery\n          ) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = new IndexSearcher(reader).rewrite(qc);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        while (qc instanceof BoostQuery) {\n          qc = ((BoostQuery) qc).getQuery();\n        }\n\n        if (qc instanceof BooleanQuery || qc instanceof SynonymQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          BooleanQuery booleanCaluse = qc instanceof BooleanQuery ?\n              (BooleanQuery) qc : convert((SynonymQuery) qc);\n          addComplexPhraseClause(sc, booleanCaluse);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else if (qc instanceof MatchNoDocsQuery) {\n          // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n          // there were no \"Smithe*\" terms - need to\n          // prevent match on just \"Fred\".\n          allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                                                         \"Dummy clause because no terms found - must match nothing\"));\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n            } else { \n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n        }\n\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    @Override\n    public Query rewrite(IndexReader reader) throws IOException {\n      final Query contents = this.contents[0];\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery \n          || contents instanceof MultiTermQuery\n          ) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      SpanQuery[] allSpanClauses = new SpanQuery[bq.clauses().size()];\n      // For all clauses e.g. one* two~\n      int i = 0;\n      for (BooleanClause clause : bq) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = clause.getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = new IndexSearcher(reader).rewrite(qc);\n        if (clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        while (qc instanceof BoostQuery) {\n          qc = ((BoostQuery) qc).getQuery();\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList<SpanQuery> sc = new ArrayList<>();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else if (qc instanceof MatchNoDocsQuery) {\n          // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n          // there were no \"Smithe*\" terms - need to\n          // prevent match on just \"Fred\".\n          allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                                                         \"Dummy clause because no terms found - must match nothing\"));\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n        i += 1;\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, inOrder);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList<SpanQuery> positiveClauses = new ArrayList<>();\n      i = 0;\n      for (BooleanClause clause : bq) {\n        if (!clause.getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[i]);\n        }\n        i += 1;\n      }\n\n      SpanQuery[] includeClauses = positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            inOrder);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          inOrder);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":["0107b7f49bcfde8f333685f53b37608815ca889b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["f2e0b693f44c4d48acb66e289f04ec7309118a1a"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","72adbc0c89de5fae07a4c2dbf2798821b037f37d"],"de299b6017d29ce89b72c3ef9cfb99ca50d433cf":["72adbc0c89de5fae07a4c2dbf2798821b037f37d"],"f2e0b693f44c4d48acb66e289f04ec7309118a1a":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"72adbc0c89de5fae07a4c2dbf2798821b037f37d":["d8b3f2faaf05547a6ed4e2769b664522af9514b3"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["2dfdf766e55e943d942055d7de53c7ad6bc45283","d8b3f2faaf05547a6ed4e2769b664522af9514b3"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["e2eb9920ac302f8d2a4cd14e42eba6935f84fe0d"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e2eb9920ac302f8d2a4cd14e42eba6935f84fe0d":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"d8b3f2faaf05547a6ed4e2769b664522af9514b3":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["de299b6017d29ce89b72c3ef9cfb99ca50d433cf"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["e2eb9920ac302f8d2a4cd14e42eba6935f84fe0d"],"2dfdf766e55e943d942055d7de53c7ad6bc45283":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d8b3f2faaf05547a6ed4e2769b664522af9514b3"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"f2e0b693f44c4d48acb66e289f04ec7309118a1a":["2dfdf766e55e943d942055d7de53c7ad6bc45283"],"de299b6017d29ce89b72c3ef9cfb99ca50d433cf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"72adbc0c89de5fae07a4c2dbf2798821b037f37d":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","de299b6017d29ce89b72c3ef9cfb99ca50d433cf"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"3f68d01cf19df971dcdcb05e30247f4ad7ec9747":["f2e0b693f44c4d48acb66e289f04ec7309118a1a"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"e2eb9920ac302f8d2a4cd14e42eba6935f84fe0d":["3f68d01cf19df971dcdcb05e30247f4ad7ec9747"],"d8b3f2faaf05547a6ed4e2769b664522af9514b3":["72adbc0c89de5fae07a4c2dbf2798821b037f37d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}