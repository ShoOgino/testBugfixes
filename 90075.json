{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","commits":[{"id":"294167f39e911e101e57b68cfeaf13cb05810e75","date":1421350806,"type":1,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","sourceNew":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        final boolean hasIndexedLeaves = !strategy.isPointsOnly();\n\n        return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            while (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            return (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","sourceOld":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        final boolean hasIndexedLeaves = !strategy.isPointsOnly();\n\n        return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            while (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            return (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c77e2fbb736fd950ca537ce7c8e1c895eda4cdc4","date":1422887461,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","sourceNew":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel,\n        !strategy.isPointsOnly()) {\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            while (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            return (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","sourceOld":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        final boolean hasIndexedLeaves = !strategy.isPointsOnly();\n\n        return new VisitorTemplate(context, acceptDocs, hasIndexedLeaves) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            while (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            return (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","sourceNew":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel,\n        !strategy.isPointsOnly()) {\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.FLAG_NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.FLAG_NONE);\n            return (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","sourceOld":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel,\n        !strategy.isPointsOnly()) {\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            while (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n            return (docsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6","date":1424027250,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","sourceNew":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel,\n        !strategy.isPointsOnly()) {\n      \n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeFilter\";\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.FLAG_NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.FLAG_NONE);\n            return (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","sourceOld":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel,\n        !strategy.isPointsOnly()) {\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.FLAG_NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.FLAG_NONE);\n            return (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e73063b92d958076ef4ae8beb5f493e8ccdcecb4","date":1424177215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","sourceNew":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel,\n        !strategy.isPointsOnly()) {\n      \n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeFilter\";\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n            return (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","sourceOld":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel,\n        !strategy.isPointsOnly()) {\n      \n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeFilter\";\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.FLAG_NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.FLAG_NONE);\n            return (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0","date":1426015524,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","sourceNew":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n      \n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeFilter\";\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visitPrefix(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n            return (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","sourceOld":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel,\n        !strategy.isPointsOnly()) {\n      \n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeFilter\";\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n            return (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","sourceNew":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n      \n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeFilter\";\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visitPrefix(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n            return (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","sourceOld":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel,\n        !strategy.isPointsOnly()) {\n      \n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeFilter\";\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visit(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n            return (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","sourceNew":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n      \n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeFilter\";\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visitPrefix(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              if (acceptDocs != null && acceptDocs.get(postingsEnum.docID()) == false) {\n                continue;\n              }\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int nextDoc = postingsEnum.nextDoc();\n            while (nextDoc != DocIdSetIterator.NO_MORE_DOCS && acceptDocs.get(nextDoc) == false) {\n              nextDoc = postingsEnum.nextDoc();\n            }\n            return nextDoc != DocIdSetIterator.NO_MORE_DOCS;\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","sourceOld":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n      \n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeFilter\";\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visitPrefix(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n            return (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"672b198fc3dce868916c727917cae58c2906763d","date":1443669960,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","sourceNew":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeQuery(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n      \n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeQuery\";//un-used\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext contexts) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visitPrefix(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              if (acceptDocs.get(postingsEnum.docID()) == false) {\n                continue;\n              }\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int nextDoc = postingsEnum.nextDoc();\n            while (nextDoc != DocIdSetIterator.NO_MORE_DOCS && acceptDocs.get(nextDoc) == false) {\n              nextDoc = postingsEnum.nextDoc();\n            }\n            return nextDoc != DocIdSetIterator.NO_MORE_DOCS;\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context);\n  }\n\n","sourceOld":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeFilter(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n      \n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeFilter\";\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context, acceptDocs) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visitPrefix(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              if (acceptDocs != null && acceptDocs.get(postingsEnum.docID()) == false) {\n                continue;\n              }\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int nextDoc = postingsEnum.nextDoc();\n            while (nextDoc != DocIdSetIterator.NO_MORE_DOCS && acceptDocs.get(nextDoc) == false) {\n              nextDoc = postingsEnum.nextDoc();\n            }\n            return nextDoc != DocIdSetIterator.NO_MORE_DOCS;\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context, acceptDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"112d77ac8d3e10a362516ad834c9a11d35c94234","date":1456784319,"type":5,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","sourceNew":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeQuery(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n\n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeQuery\";//un-used\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext contexts) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visitPrefix(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              if (acceptDocs.get(postingsEnum.docID()) == false) {\n                continue;\n              }\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int nextDoc = postingsEnum.nextDoc();\n            while (nextDoc != DocIdSetIterator.NO_MORE_DOCS && acceptDocs.get(nextDoc) == false) {\n              nextDoc = postingsEnum.nextDoc();\n            }\n            return nextDoc != DocIdSetIterator.NO_MORE_DOCS;\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context);\n  }\n\n","sourceOld":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeQuery(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n      \n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeQuery\";//un-used\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext contexts) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visitPrefix(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              if (acceptDocs.get(postingsEnum.docID()) == false) {\n                continue;\n              }\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int nextDoc = postingsEnum.nextDoc();\n            while (nextDoc != DocIdSetIterator.NO_MORE_DOCS && acceptDocs.get(nextDoc) == false) {\n              nextDoc = postingsEnum.nextDoc();\n            }\n            return nextDoc != DocIdSetIterator.NO_MORE_DOCS;\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeFacetCounter#compute(PrefixTreeStrategy,LeafReaderContext,Bits,Shape,int,FacetVisitor).mjava","sourceNew":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeQuery(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n\n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeQuery\";//un-used\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext contexts) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visitPrefix(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              if (acceptDocs.get(postingsEnum.docID()) == false) {\n                continue;\n              }\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int nextDoc = postingsEnum.nextDoc();\n            while (nextDoc != DocIdSetIterator.NO_MORE_DOCS && acceptDocs.get(nextDoc) == false) {\n              nextDoc = postingsEnum.nextDoc();\n            }\n            return nextDoc != DocIdSetIterator.NO_MORE_DOCS;\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context);\n  }\n\n","sourceOld":"  /** Lower-level per-leaf segment method. */\n  public static void compute(final PrefixTreeStrategy strategy, final LeafReaderContext context, final Bits acceptDocs,\n                             final Shape queryShape, final int facetLevel, final FacetVisitor facetVisitor)\n      throws IOException {\n    if (acceptDocs != null && acceptDocs.length() != context.reader().maxDoc()) {\n      throw new IllegalArgumentException(\n          \"acceptDocs bits length \" + acceptDocs.length() +\" != leaf maxdoc \" + context.reader().maxDoc());\n    }\n    final SpatialPrefixTree tree = strategy.getGrid();\n\n    //scanLevel is an optimization knob of AbstractVisitingPrefixTreeFilter. It's unlikely\n    // another scanLevel would be much faster and it tends to be a risky knob (can help a little, can hurt a ton).\n    // TODO use RPT's configured scan level?  Do we know better here?  Hard to say.\n    final int scanLevel = tree.getMaxLevels();\n    //AbstractVisitingPrefixTreeFilter is a Lucene Filter.  We don't need a filter; we use it for its great prefix-tree\n    // traversal code.  TODO consider refactoring if/when it makes sense (more use cases than this)\n    new AbstractVisitingPrefixTreeQuery(queryShape, strategy.getFieldName(), tree, facetLevel, scanLevel) {\n      \n      @Override\n      public String toString(String field) {\n        return \"anonPrefixTreeQuery\";//un-used\n      }\n\n      @Override\n      public DocIdSet getDocIdSet(LeafReaderContext contexts) throws IOException {\n        assert facetLevel == super.detailLevel;//same thing, FYI. (constant)\n\n        return new VisitorTemplate(context) {\n\n          @Override\n          protected void start() throws IOException {\n            facetVisitor.startOfSegment();\n          }\n\n          @Override\n          protected DocIdSet finish() throws IOException {\n            return null;//unused;\n          }\n\n          @Override\n          protected boolean visitPrefix(Cell cell) throws IOException {\n            // At facetLevel...\n            if (cell.getLevel() == facetLevel) {\n              // Count docs\n              visitLeaf(cell);//we're not a leaf but we treat it as such at facet level\n              return false;//don't descend further; this is enough detail\n            }\n\n            // We optimize for discriminating filters (reflected in acceptDocs) and short-circuit if no\n            // matching docs. We could do this at all levels or never but the closer we get to the facet level, the\n            // higher the probability this is worthwhile. We do when docFreq == 1 because it's a cheap check, especially\n            // due to \"pulsing\" in the codec.\n            //TODO this opt should move to VisitorTemplate (which contains an optimization TODO to this effect)\n            if (cell.getLevel() == facetLevel - 1 || termsEnum.docFreq() == 1) {\n              if (!hasDocsAtThisTerm()) {\n                return false;\n              }\n            }\n            return true;\n          }\n\n          @Override\n          protected void visitLeaf(Cell cell) throws IOException {\n            final int count = countDocsAtThisTerm();\n            if (count > 0) {\n              facetVisitor.visit(cell, count);\n            }\n          }\n\n          private int countDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return termsEnum.docFreq();\n            }\n            int count = 0;\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            while (postingsEnum.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n              if (acceptDocs.get(postingsEnum.docID()) == false) {\n                continue;\n              }\n              count++;\n            }\n            return count;\n          }\n\n          private boolean hasDocsAtThisTerm() throws IOException {\n            if (acceptDocs == null) {\n              return true;\n            }\n            postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n            int nextDoc = postingsEnum.nextDoc();\n            while (nextDoc != DocIdSetIterator.NO_MORE_DOCS && acceptDocs.get(nextDoc) == false) {\n              nextDoc = postingsEnum.nextDoc();\n            }\n            return nextDoc != DocIdSetIterator.NO_MORE_DOCS;\n          }\n\n        }.getDocIdSet();\n      }\n    }.getDocIdSet(context);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"294167f39e911e101e57b68cfeaf13cb05810e75":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"af2638813028b254a88b418ebeafb541afb49653":["672b198fc3dce868916c727917cae58c2906763d","112d77ac8d3e10a362516ad834c9a11d35c94234"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["672b198fc3dce868916c727917cae58c2906763d"],"c77e2fbb736fd950ca537ce7c8e1c895eda4cdc4":["294167f39e911e101e57b68cfeaf13cb05810e75"],"51f5280f31484820499077f41fcdfe92d527d9dc":["c77e2fbb736fd950ca537ce7c8e1c895eda4cdc4"],"fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6":["51f5280f31484820499077f41fcdfe92d527d9dc"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4","11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6"],"672b198fc3dce868916c727917cae58c2906763d":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["af2638813028b254a88b418ebeafb541afb49653"]},"commit2Childs":{"294167f39e911e101e57b68cfeaf13cb05810e75":["c77e2fbb736fd950ca537ce7c8e1c895eda4cdc4"],"af2638813028b254a88b418ebeafb541afb49653":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["af2638813028b254a88b418ebeafb541afb49653"],"c77e2fbb736fd950ca537ce7c8e1c895eda4cdc4":["51f5280f31484820499077f41fcdfe92d527d9dc"],"51f5280f31484820499077f41fcdfe92d527d9dc":["fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6"],"fb58c5f77afb63ba911f6d62f4c1d89f15e56dc6":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["672b198fc3dce868916c727917cae58c2906763d"],"672b198fc3dce868916c727917cae58c2906763d":["af2638813028b254a88b418ebeafb541afb49653","112d77ac8d3e10a362516ad834c9a11d35c94234"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["294167f39e911e101e57b68cfeaf13cb05810e75"],"11ac40ec1cc2f6d61b8c8f0cd9b306dfcef5aaf0":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0f4464508ee83288c8c4585b533f9faaa93aa314"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}