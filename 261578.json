{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","commits":[{"id":"40aa98241c87d86a0077beb8023713d93a0becfe","date":1459784560,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"/dev/null","sourceNew":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  protected static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n    \n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size());\n    final BitSet internalEdges = new BitSet(includedEdges.size()-1);\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      \n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1b71c62c25736a6b959763a1e2450e01ca14aeb2","71165f69aea616f7e533fb3c8bc2ef0d19c6cc47"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"09af2c9610ce53a4b25fd99344299b40318a4a1a","date":1459876565,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"/dev/null","sourceNew":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  protected static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n    \n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size());\n    final BitSet internalEdges = new BitSet(includedEdges.size()-1);\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      \n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5864f13b0b1ae08430bed46d2fcbc5f5c7005195","date":1460068279,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n    \n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size());\n    final BitSet internalEdges = new BitSet(includedEdges.size()-1);\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      \n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  protected static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n    \n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size());\n    final BitSet internalEdges = new BitSet(includedEdges.size()-1);\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      \n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e","date":1460121287,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n    \n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size()+1);\n    final BitSet internalEdges = new BitSet(includedEdges.size());\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      if (includedEdges.size() < 3) {\n        // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it\n        // has no contents, so we've clearly done something wrong, but not sure what.\n        throw new IllegalArgumentException(\"polygon was illegal (degenerate illegal two-edge cyclical polygon encountered in processing)\");\n      }\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      \n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n    \n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size());\n    final BitSet internalEdges = new BitSet(includedEdges.size()-1);\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      \n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"99b0a9e4d18bb364d2546e5230cc61abcd2d366b","date":1461241852,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n      \n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n\n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size()+1);\n    final BitSet internalEdges = new BitSet(includedEdges.size());\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      if (includedEdges.size() < 3) {\n        // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it\n        // has no contents, so we generate no polygon.\n        return false;\n      }\n      \n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      \n      // Look for coplanarity; abort if so\n      for (int i = 0; i < points.size(); i++) {\n        final GeoPoint start = points.get(i);\n        final GeoPoint end = points.get(getLegalIndex(i + 1, points.size()));\n        // We have to find the next point that is not on the plane between start and end.\n        // If there is no such point, it's an error.\n        final Plane planeToFind = new Plane(start, end);\n        int endPointIndex = -1;\n        for (int j = 0; j < points.size(); j++) {\n          final int index = getLegalIndex(j + i + 2, points.size());\n          if (!planeToFind.evaluateIsZero(points.get(index))) {\n            endPointIndex = index;\n            break;\n          }\n        }\n        if (endPointIndex == -1) {\n          return false;\n        }\n      }\n\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      \n      // Look for coplanarity; abort if so\n      for (int i = 0; i < points.size(); i++) {\n        final GeoPoint start = points.get(i);\n        final GeoPoint end = points.get(getLegalIndex(i + 1, points.size()));\n        // We have to find the next point that is not on the plane between start and end.\n        // If there is no such point, it's an error.\n        final Plane planeToFind = new Plane(start, end);\n        int endPointIndex = -1;\n        for (int j = 0; j < points.size(); j++) {\n          final int index = getLegalIndex(j + i + 2, points.size());\n          if (!planeToFind.evaluateIsZero(points.get(index))) {\n            endPointIndex = index;\n            break;\n          }\n        }\n        if (endPointIndex == -1) {\n          return false;\n        }\n      }\n\n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n    \n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size()+1);\n    final BitSet internalEdges = new BitSet(includedEdges.size());\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      if (includedEdges.size() < 3) {\n        // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it\n        // has no contents, so we've clearly done something wrong, but not sure what.\n        throw new IllegalArgumentException(\"polygon was illegal (degenerate illegal two-edge cyclical polygon encountered in processing)\");\n      }\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int i = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(i++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      \n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8","date":1518267216,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newLastEdge.endPoint)) {\n        break;\n      }\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          if (Plane.arePointsCoplanar(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint) ||\n            Plane.arePointsCoplanar(firstEdge.startPoint, newLastEdge.endPoint, newLastEdge.startPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (Plane.arePointsCoplanar(newFirstEdge.startPoint, newFirstEdge.endPoint, firstEdge.endPoint)) {\n        break;\n      }\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          if(Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint) ||\n            Plane.arePointsCoplanar(lastEdge.endPoint, newFirstEdge.startPoint, newFirstEdge.endPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n      \n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n\n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size()+1);\n    final BitSet internalEdges = new BitSet(includedEdges.size());\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      if (includedEdges.size() < 3) {\n        // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it\n        // has no contents, so we generate no polygon.\n        return false;\n      }\n      \n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n      \n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n\n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size()+1);\n    final BitSet internalEdges = new BitSet(includedEdges.size());\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      if (includedEdges.size() < 3) {\n        // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it\n        // has no contents, so we generate no polygon.\n        return false;\n      }\n      \n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      \n      // Look for coplanarity; abort if so\n      for (int i = 0; i < points.size(); i++) {\n        final GeoPoint start = points.get(i);\n        final GeoPoint end = points.get(getLegalIndex(i + 1, points.size()));\n        // We have to find the next point that is not on the plane between start and end.\n        // If there is no such point, it's an error.\n        final Plane planeToFind = new Plane(start, end);\n        int endPointIndex = -1;\n        for (int j = 0; j < points.size(); j++) {\n          final int index = getLegalIndex(j + i + 2, points.size());\n          if (!planeToFind.evaluateIsZero(points.get(index))) {\n            endPointIndex = index;\n            break;\n          }\n        }\n        if (endPointIndex == -1) {\n          return false;\n        }\n      }\n\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      \n      // Look for coplanarity; abort if so\n      for (int i = 0; i < points.size(); i++) {\n        final GeoPoint start = points.get(i);\n        final GeoPoint end = points.get(getLegalIndex(i + 1, points.size()));\n        // We have to find the next point that is not on the plane between start and end.\n        // If there is no such point, it's an error.\n        final Plane planeToFind = new Plane(start, end);\n        int endPointIndex = -1;\n        for (int j = 0; j < points.size(); j++) {\n          final int index = getLegalIndex(j + i + 2, points.size());\n          if (!planeToFind.evaluateIsZero(points.get(index))) {\n            endPointIndex = index;\n            break;\n          }\n        }\n        if (endPointIndex == -1) {\n          return false;\n        }\n      }\n\n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["1b71c62c25736a6b959763a1e2450e01ca14aeb2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"44c3a4ebfa1a780298de8b00afc0722c16233080","date":1522505029,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) throws TileException {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      // Planes that are almost identical cannot be properly handled by the standard polygon logic.  Detect this case and, if found,\n      // give up on the tiling -- we'll need to create a large poly instead.\n      if (lastEdge.plane.isNumericallyIdentical(newLastEdge.plane) /*isNearlyIdentical(lastEdge.plane, newLastEdge.plane) */) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      if (Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newLastEdge.endPoint)) {\n        break;\n      }\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          if (Plane.arePointsCoplanar(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint) ||\n            Plane.arePointsCoplanar(firstEdge.startPoint, newLastEdge.endPoint, newLastEdge.startPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (Plane.arePointsCoplanar(newFirstEdge.startPoint, newFirstEdge.endPoint, firstEdge.endPoint)) {\n        break;\n      }\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          if(Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint) ||\n            Plane.arePointsCoplanar(lastEdge.endPoint, newFirstEdge.startPoint, newFirstEdge.endPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n      \n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n\n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size()+1);\n    final BitSet internalEdges = new BitSet(includedEdges.size());\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      if (includedEdges.size() < 3) {\n        // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it\n        // has no contents, so we generate no polygon.\n        return false;\n      }\n      \n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newLastEdge.endPoint)) {\n        break;\n      }\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          if (Plane.arePointsCoplanar(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint) ||\n            Plane.arePointsCoplanar(firstEdge.startPoint, newLastEdge.endPoint, newLastEdge.startPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (Plane.arePointsCoplanar(newFirstEdge.startPoint, newFirstEdge.endPoint, firstEdge.endPoint)) {\n        break;\n      }\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          if(Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint) ||\n            Plane.arePointsCoplanar(lastEdge.endPoint, newFirstEdge.startPoint, newFirstEdge.endPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n      \n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n\n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size()+1);\n    final BitSet internalEdges = new BitSet(includedEdges.size());\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      if (includedEdges.size() < 3) {\n        // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it\n        // has no contents, so we generate no polygon.\n        return false;\n      }\n      \n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["bc5a9298580a352dd8deee6537b9a544a4af8bae"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc5a9298580a352dd8deee6537b9a544a4af8bae","date":1522510952,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) throws TileException {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      // Planes that are almost identical cannot be properly handled by the standard polygon logic.  Detect this case and, if found,\n      // give up on the tiling -- we'll need to create a large poly instead.\n      if (lastEdge.plane.isFunctionallyIdentical(newLastEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      if (Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newLastEdge.endPoint)) {\n        break;\n      }\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          if (Plane.arePointsCoplanar(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint) ||\n            Plane.arePointsCoplanar(firstEdge.startPoint, newLastEdge.endPoint, newLastEdge.startPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (Plane.arePointsCoplanar(newFirstEdge.startPoint, newFirstEdge.endPoint, firstEdge.endPoint)) {\n        break;\n      }\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          if(Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint) ||\n            Plane.arePointsCoplanar(lastEdge.endPoint, newFirstEdge.startPoint, newFirstEdge.endPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n      \n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n\n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size()+1);\n    final BitSet internalEdges = new BitSet(includedEdges.size());\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      if (includedEdges.size() < 3) {\n        // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it\n        // has no contents, so we generate no polygon.\n        return false;\n      }\n      \n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) throws TileException {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      // Planes that are almost identical cannot be properly handled by the standard polygon logic.  Detect this case and, if found,\n      // give up on the tiling -- we'll need to create a large poly instead.\n      if (lastEdge.plane.isNumericallyIdentical(newLastEdge.plane) /*isNearlyIdentical(lastEdge.plane, newLastEdge.plane) */) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      if (Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newLastEdge.endPoint)) {\n        break;\n      }\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          if (Plane.arePointsCoplanar(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint) ||\n            Plane.arePointsCoplanar(firstEdge.startPoint, newLastEdge.endPoint, newLastEdge.startPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (Plane.arePointsCoplanar(newFirstEdge.startPoint, newFirstEdge.endPoint, firstEdge.endPoint)) {\n        break;\n      }\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          if(Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint) ||\n            Plane.arePointsCoplanar(lastEdge.endPoint, newFirstEdge.startPoint, newFirstEdge.endPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n      \n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n\n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size()+1);\n    final BitSet internalEdges = new BitSet(includedEdges.size());\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      if (includedEdges.size() < 3) {\n        // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it\n        // has no contents, so we generate no polygon.\n        return false;\n      }\n      \n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":["44c3a4ebfa1a780298de8b00afc0722c16233080"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b71c62c25736a6b959763a1e2450e01ca14aeb2","date":1524477121,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) throws TileException {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newLastEdge.endPoint)) {\n        break;\n      }\n      // Planes that are almost identical cannot be properly handled by the standard polygon logic.  Detect this case and, if found,\n      // give up on the tiling -- we'll need to create a large poly instead.\n      if (lastEdge.plane.isFunctionallyIdentical(newLastEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          if (Plane.arePointsCoplanar(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint) ||\n            Plane.arePointsCoplanar(firstEdge.startPoint, newLastEdge.endPoint, newLastEdge.startPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (Plane.arePointsCoplanar(newFirstEdge.startPoint, newFirstEdge.endPoint, firstEdge.endPoint)) {\n        break;\n      }\n      // Planes that are almost identical cannot be properly handled by the standard polygon logic.  Detect this case and, if found,\n      // give up on the tiling -- we'll need to create a large poly instead.\n      if (firstEdge.plane.isFunctionallyIdentical(newFirstEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          if(Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint) ||\n            Plane.arePointsCoplanar(lastEdge.endPoint, newFirstEdge.startPoint, newFirstEdge.endPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n      \n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n\n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size()+1);\n    final BitSet internalEdges = new BitSet(includedEdges.size());\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      if (includedEdges.size() < 3) {\n        // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it\n        // has no contents, so we generate no polygon.\n        return false;\n      }\n\n      if (firstEdge.plane.isFunctionallyIdentical(lastEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      \n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n      if (returnEdge.plane.isFunctionallyIdentical(lastEdge.plane) ||\n          returnEdge.plane.isFunctionallyIdentical(firstEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) throws TileException {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      // Planes that are almost identical cannot be properly handled by the standard polygon logic.  Detect this case and, if found,\n      // give up on the tiling -- we'll need to create a large poly instead.\n      if (lastEdge.plane.isFunctionallyIdentical(newLastEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      if (Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newLastEdge.endPoint)) {\n        break;\n      }\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          if (Plane.arePointsCoplanar(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint) ||\n            Plane.arePointsCoplanar(firstEdge.startPoint, newLastEdge.endPoint, newLastEdge.startPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (Plane.arePointsCoplanar(newFirstEdge.startPoint, newFirstEdge.endPoint, firstEdge.endPoint)) {\n        break;\n      }\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          if(Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint) ||\n            Plane.arePointsCoplanar(lastEdge.endPoint, newFirstEdge.startPoint, newFirstEdge.endPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n      \n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n\n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size()+1);\n    final BitSet internalEdges = new BitSet(includedEdges.size());\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      if (includedEdges.size() < 3) {\n        // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it\n        // has no contents, so we generate no polygon.\n        return false;\n      }\n      \n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":["4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8","40aa98241c87d86a0077beb8023713d93a0becfe"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71165f69aea616f7e533fb3c8bc2ef0d19c6cc47","date":1533985130,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#findConvexPolygon(PlanetModel,Edge,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) throws TileException {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newLastEdge.endPoint)) {\n        break;\n      }\n      // Planes that are almost identical cannot be properly handled by the standard polygon logic.  Detect this case and, if found,\n      // give up on the tiling -- we'll need to create a large poly instead.\n      if (lastEdge.plane.isFunctionallyIdentical(newLastEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          if (Plane.arePointsCoplanar(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint) ||\n            Plane.arePointsCoplanar(firstEdge.startPoint, newLastEdge.endPoint, newLastEdge.startPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (Plane.arePointsCoplanar(newFirstEdge.startPoint, newFirstEdge.endPoint, firstEdge.endPoint)) {\n        break;\n      }\n      // Planes that are almost identical cannot be properly handled by the standard polygon logic.  Detect this case and, if found,\n      // give up on the tiling -- we'll need to create a large poly instead.\n      if (firstEdge.plane.isFunctionallyIdentical(newFirstEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          if(Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint) ||\n            Plane.arePointsCoplanar(lastEdge.endPoint, newFirstEdge.startPoint, newFirstEdge.endPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n      \n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n\n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size()+1);\n    final BitSet internalEdges = new BitSet(includedEdges.size());\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      if (includedEdges.size() < 3) {\n        // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it\n        // has no contents, so we generate no polygon.\n        return false;\n      }\n\n      if (firstEdge.plane.isFunctionallyIdentical(lastEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      \n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n      if (returnEdge.plane.isFunctionallyIdentical(lastEdge.plane) ||\n          returnEdge.plane.isFunctionallyIdentical(firstEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    // Failures in construction mean we have a polygon that is too large (>180 degrees)\n    try {\n      if (testPoint != null && holes != null && holes.size() > 0) {\n        // No holes, for test\n        final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n        if (testPolygon.isWithin(testPoint)) {\n          return null;\n        }\n      }\n      \n      final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n      if (testPoint != null && (holes == null || holes.size() == 0)) {\n        if (realPolygon.isWithin(testPoint)) {\n          return null;\n        }\n      }\n      \n      rval.addShape(realPolygon);\n      return true;\n\n    } catch (IllegalArgumentException e) {\n      throw new TileException(e.getMessage());\n    }\n    \n  }\n\n","sourceOld":"  /** Look for a convex polygon at the specified edge.  If we find it, create one and adjust the edge buffer.\n   * @param planetModel is the planet model.\n   * @param currentEdge is the current edge to use starting the search.\n   * @param rval is the composite polygon to build.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return null if the testPoint is within any polygon detected, otherwise true if a convex polygon was created.\n   */\n  private static Boolean findConvexPolygon(final PlanetModel planetModel,\n    final Edge currentEdge,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) throws TileException {\n    \n    //System.out.println(\"Looking at edge \"+currentEdge+\" with startpoint \"+currentEdge.startPoint+\" endpoint \"+currentEdge.endPoint);\n      \n    // Initialize the structure.\n    // We don't keep track of order here; we just care about membership.\n    // The only exception is the head and tail pointers.\n    final Set<Edge> includedEdges = new HashSet<>();\n    includedEdges.add(currentEdge);\n    Edge firstEdge = currentEdge;\n    Edge lastEdge = currentEdge;\n    \n    // First, walk towards the end until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newLastEdge = edgeBuffer.getNext(lastEdge);\n      if (Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newLastEdge.endPoint)) {\n        break;\n      }\n      // Planes that are almost identical cannot be properly handled by the standard polygon logic.  Detect this case and, if found,\n      // give up on the tiling -- we'll need to create a large poly instead.\n      if (lastEdge.plane.isFunctionallyIdentical(newLastEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      if (isWithin(newLastEdge.endPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to next edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (firstEdge.startPoint != newLastEdge.endPoint) {\n          if (Plane.arePointsCoplanar(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint) ||\n            Plane.arePointsCoplanar(firstEdge.startPoint, newLastEdge.endPoint, newLastEdge.startPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newLastEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != newLastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != firstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newLastEdge);\n          lastEdge = newLastEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n    \n    // Now, walk towards the beginning until we need to stop\n    while (true) {\n      if (firstEdge.startPoint == lastEdge.endPoint) {\n        break;\n      }\n      final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);\n      if (Plane.arePointsCoplanar(newFirstEdge.startPoint, newFirstEdge.endPoint, firstEdge.endPoint)) {\n        break;\n      }\n      // Planes that are almost identical cannot be properly handled by the standard polygon logic.  Detect this case and, if found,\n      // give up on the tiling -- we'll need to create a large poly instead.\n      if (firstEdge.plane.isFunctionallyIdentical(newFirstEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      if (isWithin(newFirstEdge.startPoint, includedEdges)) {\n        //System.out.println(\" maybe can extend to previous edge\");\n        // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon\n        // here will overlap with other remaining points?\n        final SidedPlane returnBoundary;\n        if (newFirstEdge.startPoint != lastEdge.endPoint) {\n          if(Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint) ||\n            Plane.arePointsCoplanar(lastEdge.endPoint, newFirstEdge.startPoint, newFirstEdge.endPoint)) {\n            break;\n          }\n          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);\n        } else {\n          returnBoundary = null;\n        }\n        // The complete set of sided planes for the tentative new polygon include the ones in includedEdges, plus the one from newLastEdge,\n        // plus the new tentative return boundary.  We have to make sure there are no points from elsewhere within the tentative convex polygon.\n        boolean foundPointInside = false;\n        final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n        while (edgeIterator.hasNext()) {\n          final Edge edge = edgeIterator.next();\n          if (!includedEdges.contains(edge) && edge != newFirstEdge) {\n            // This edge has a point to check\n            if (edge.startPoint != lastEdge.endPoint) {\n              // look at edge.startPoint\n              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.startPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n            if (edge.endPoint != newFirstEdge.startPoint) {\n              // look at edge.endPoint\n              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {\n                //System.out.println(\"  nope; point within found: \"+edge.endPoint);\n                foundPointInside = true;\n                break;\n              }\n            }\n          }\n        }\n        \n        if (!foundPointInside) {\n          //System.out.println(\"  extending!\");\n          // Extend the polygon by the new last edge\n          includedEdges.add(newFirstEdge);\n          firstEdge = newFirstEdge;\n          // continue extending in this direction\n          continue;\n        }\n      }\n      // We can't extend any more in this direction, so break from the loop.\n      break;\n    }\n\n    // Ok, figure out what we've accumulated.  If it is enough for a polygon, build it.\n      \n    if (includedEdges.size() < 2) {\n      //System.out.println(\"Done edge \"+currentEdge+\": no poly found\");\n      return false;\n    }\n\n    // It's enough to build a convex polygon\n    //System.out.println(\"Edge \"+currentEdge+\": Found complex poly\");\n    \n    // Create the point list and edge list, starting with the first edge and going to the last.  The return edge will be between\n    // the start point of the first edge and the end point of the last edge.  If the first edge start point is the same as the last edge end point,\n    // it's a degenerate case and we want to just clean out the edge buffer entirely.\n    \n    final List<GeoPoint> points = new ArrayList<GeoPoint>(includedEdges.size()+1);\n    final BitSet internalEdges = new BitSet(includedEdges.size());\n    final boolean returnIsInternal;\n    \n    if (firstEdge.startPoint == lastEdge.endPoint) {\n      // Degenerate case!!  There is no return edge -- or rather, we already have it.\n      if (includedEdges.size() < 3) {\n        // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it\n        // has no contents, so we generate no polygon.\n        return false;\n      }\n\n      if (firstEdge.plane.isFunctionallyIdentical(lastEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      \n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        if (edge == lastEdge) {\n          break;\n        }\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edge = edgeBuffer.getNext(edge);\n      }\n      returnIsInternal = lastEdge.isInternal;\n      edgeBuffer.clear();\n    } else {\n      // Build the return edge (internal, of course)\n      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);\n      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);\n      if (returnEdge.plane.isFunctionallyIdentical(lastEdge.plane) ||\n          returnEdge.plane.isFunctionallyIdentical(firstEdge.plane)) {\n        throw new TileException(\"Two adjacent edge planes are effectively parallel despite filtering; give up on tiling\");\n      }\n      // Build point list and edge list\n      final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());\n      returnIsInternal = true;\n\n      // Now look for completely planar points.  This too is a degeneracy condition that we should\n      // return \"false\" for.\n      Edge edge = firstEdge;\n      points.add(edge.startPoint);\n      int k = 0;\n      while (true) {\n        points.add(edge.endPoint);\n        internalEdges.set(k++, edge.isInternal);\n        edges.add(edge);\n        if (edge == lastEdge) {\n          break;\n        }\n        edge = edgeBuffer.getNext(edge);\n      }\n      // Modify the edge buffer\n      edgeBuffer.replace(edges, returnEdge);\n    }\n    \n    // Now, construct the polygon\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConvexPolygon(planetModel, points, null, internalEdges, returnIsInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConvexPolygon(planetModel, points, holes, internalEdges, returnIsInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return null;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":["40aa98241c87d86a0077beb8023713d93a0becfe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"44c3a4ebfa1a780298de8b00afc0722c16233080":["4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8"],"5864f13b0b1ae08430bed46d2fcbc5f5c7005195":["40aa98241c87d86a0077beb8023713d93a0becfe"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","40aa98241c87d86a0077beb8023713d93a0becfe"],"4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b"],"1b71c62c25736a6b959763a1e2450e01ca14aeb2":["bc5a9298580a352dd8deee6537b9a544a4af8bae"],"bc5a9298580a352dd8deee6537b9a544a4af8bae":["44c3a4ebfa1a780298de8b00afc0722c16233080"],"835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e":["5864f13b0b1ae08430bed46d2fcbc5f5c7005195"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"71165f69aea616f7e533fb3c8bc2ef0d19c6cc47":["1b71c62c25736a6b959763a1e2450e01ca14aeb2"],"40aa98241c87d86a0077beb8023713d93a0becfe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"99b0a9e4d18bb364d2546e5230cc61abcd2d366b":["835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["71165f69aea616f7e533fb3c8bc2ef0d19c6cc47"]},"commit2Childs":{"44c3a4ebfa1a780298de8b00afc0722c16233080":["bc5a9298580a352dd8deee6537b9a544a4af8bae"],"5864f13b0b1ae08430bed46d2fcbc5f5c7005195":["835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e"],"09af2c9610ce53a4b25fd99344299b40318a4a1a":[],"4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8":["44c3a4ebfa1a780298de8b00afc0722c16233080"],"1b71c62c25736a6b959763a1e2450e01ca14aeb2":["71165f69aea616f7e533fb3c8bc2ef0d19c6cc47"],"bc5a9298580a352dd8deee6537b9a544a4af8bae":["1b71c62c25736a6b959763a1e2450e01ca14aeb2"],"835b6983e267a46cbc7d3d7d82b46b2eb9a32d1e":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09af2c9610ce53a4b25fd99344299b40318a4a1a","40aa98241c87d86a0077beb8023713d93a0becfe"],"71165f69aea616f7e533fb3c8bc2ef0d19c6cc47":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"40aa98241c87d86a0077beb8023713d93a0becfe":["5864f13b0b1ae08430bed46d2fcbc5f5c7005195","09af2c9610ce53a4b25fd99344299b40318a4a1a"],"99b0a9e4d18bb364d2546e5230cc61abcd2d366b":["4dcc28ece27acc5c2d8e62029faa7e30e3a1e1e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09af2c9610ce53a4b25fd99344299b40318a4a1a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}