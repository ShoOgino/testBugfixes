{"path":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","sourceNew":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n    \n    destDir.mkdir();\n    LuceneTestCase.registerTempDir(destDir);\n    \n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","sourceOld":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n    \n    destDir.mkdir();\n    LuceneTestCase.registerTempDir(destDir);\n    \n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5da0b42730b6b99b31389ef94cb97384e83b9ede","date":1337107665,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","sourceNew":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n\n    destDir.mkdir();\n    LuceneTestCase.closeAfterSuite(new CloseableFile(destDir));\n\n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","sourceOld":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n    \n    destDir.mkdir();\n    LuceneTestCase.registerTempDir(destDir);\n    \n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"765293980c33173623f760deb48458d0f47dc8c3","date":1345119992,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","sourceNew":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n\n    destDir.mkdir();\n    LuceneTestCase.closeAfterSuite(new CloseableFile(destDir, LuceneTestCase.suiteFailureMarker));\n\n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","sourceOld":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n\n    destDir.mkdir();\n    LuceneTestCase.closeAfterSuite(new CloseableFile(destDir));\n\n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70fa1c0f4d75735ff2e1485e059d9bc5efa50598","date":1345296911,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","sourceNew":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n\n    destDir.mkdir();\n    LuceneTestCase.closeAfterSuite(new CloseableFile(destDir, LuceneTestCase.suiteFailureMarker));\n\n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","sourceOld":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n\n    destDir.mkdir();\n    LuceneTestCase.closeAfterSuite(new CloseableFile(destDir));\n\n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"616c1830142ff5c1ddedec1ed898733b73c8e23b","date":1345368925,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","sourceNew":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n\n    destDir.mkdir();\n    LuceneTestCase.closeAfterSuite(new CloseableFile(destDir, LuceneTestCase.suiteFailureMarker));\n\n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","sourceOld":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n\n    destDir.mkdir();\n    LuceneTestCase.closeAfterSuite(new CloseableFile(destDir));\n\n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":5,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/TestUtil#unzip(File,File).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil#unzip(File,File).mjava","sourceNew":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n\n    destDir.mkdir();\n    LuceneTestCase.closeAfterSuite(new CloseableFile(destDir, LuceneTestCase.suiteFailureMarker));\n\n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","sourceOld":"  /** \n   * Convenience method: Unzip zipName + \".zip\" under destDir, removing destDir first \n   */\n  public static void unzip(File zipName, File destDir) throws IOException {\n    \n    ZipFile zipFile = new ZipFile(zipName);\n    \n    Enumeration<? extends ZipEntry> entries = zipFile.entries();\n    \n    rmDir(destDir);\n\n    destDir.mkdir();\n    LuceneTestCase.closeAfterSuite(new CloseableFile(destDir, LuceneTestCase.suiteFailureMarker));\n\n    while (entries.hasMoreElements()) {\n      ZipEntry entry = entries.nextElement();\n      \n      InputStream in = zipFile.getInputStream(entry);\n      File targetFile = new File(destDir, entry.getName());\n      if (entry.isDirectory()) {\n        // allow unzipping with directory structure\n        targetFile.mkdirs();\n      } else {\n        if (targetFile.getParentFile()!=null) {\n          // be on the safe side: do not rely on that directories are always extracted\n          // before their children (although this makes sense, but is it guaranteed?)\n          targetFile.getParentFile().mkdirs();   \n        }\n        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));\n        \n        byte[] buffer = new byte[8192];\n        int len;\n        while((len = in.read(buffer)) >= 0) {\n          out.write(buffer, 0, len);\n        }\n        \n        in.close();\n        out.close();\n      }\n    }\n    \n    zipFile.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"616c1830142ff5c1ddedec1ed898733b73c8e23b":["5da0b42730b6b99b31389ef94cb97384e83b9ede","765293980c33173623f760deb48458d0f47dc8c3"],"5da0b42730b6b99b31389ef94cb97384e83b9ede":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"6613659748fe4411a7dcf85266e55db1f95f7315":["765293980c33173623f760deb48458d0f47dc8c3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"70fa1c0f4d75735ff2e1485e059d9bc5efa50598":["5da0b42730b6b99b31389ef94cb97384e83b9ede","765293980c33173623f760deb48458d0f47dc8c3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"765293980c33173623f760deb48458d0f47dc8c3":["5da0b42730b6b99b31389ef94cb97384e83b9ede"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6613659748fe4411a7dcf85266e55db1f95f7315"]},"commit2Childs":{"616c1830142ff5c1ddedec1ed898733b73c8e23b":[],"5da0b42730b6b99b31389ef94cb97384e83b9ede":["616c1830142ff5c1ddedec1ed898733b73c8e23b","70fa1c0f4d75735ff2e1485e059d9bc5efa50598","765293980c33173623f760deb48458d0f47dc8c3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5da0b42730b6b99b31389ef94cb97384e83b9ede"],"6613659748fe4411a7dcf85266e55db1f95f7315":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"70fa1c0f4d75735ff2e1485e059d9bc5efa50598":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"765293980c33173623f760deb48458d0f47dc8c3":["616c1830142ff5c1ddedec1ed898733b73c8e23b","6613659748fe4411a7dcf85266e55db1f95f7315","70fa1c0f4d75735ff2e1485e059d9bc5efa50598"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["616c1830142ff5c1ddedec1ed898733b73c8e23b","70fa1c0f4d75735ff2e1485e059d9bc5efa50598","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}