{"path":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","commits":[{"id":"b485ce675d4e8b9dbfafd122ca9b7b33a883be7b","date":1453975275,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","pathOld":"/dev/null","sourceNew":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n          try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n              IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              in.seek(wrongBytes);\n              out.copyBytes(in, victimLength - wrongBytes);\n            }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5bfa8ae748b6814cc58721bbcc5e8723ca1686ca"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8ca66a68d392da80b8f1da46bd3e5e041e40a71d","date":1453998618,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","sourceNew":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","sourceOld":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n          try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n              IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              in.seek(wrongBytes);\n              out.copyBytes(in, victimLength - wrongBytes);\n            }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d15e34266d75e4e8b95da046cd0afc812367b38","date":1454246129,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","pathOld":"/dev/null","sourceNew":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","pathOld":"/dev/null","sourceNew":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aefe9c6efcbd9c785fd98f1379b8ba0b7aefebab","date":1457539417,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","sourceNew":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","sourceOld":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1f21caacfa79b5e587a1395b476d732143bef177","date":1457645644,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","sourceNew":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      if (dirCopy instanceof MockDirectoryWrapper) {\n        // The while(true) loop below, under rarish circumstances, can sometimes double write:\n        ((MockDirectoryWrapper) dirCopy).setPreventDoubleWrite(false);\n      }\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","sourceOld":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11c6df42fb3eba174c3ca0d9a5194eaecd893b77","date":1465931757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","sourceNew":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","sourceOld":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      if (dirCopy instanceof MockDirectoryWrapper) {\n        // The while(true) loop below, under rarish circumstances, can sometimes double write:\n        ((MockDirectoryWrapper) dirCopy).setPreventDoubleWrite(false);\n      }\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","bugFix":["1f21caacfa79b5e587a1395b476d732143bef177"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bfa8ae748b6814cc58721bbcc5e8723ca1686ca","date":1472127653,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","sourceNew":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    // use ramdir explicit, as we do evil things like try to generate broken files, deletes must work.\n    try (BaseDirectoryWrapper dirCopy = new MockDirectoryWrapper(random(), new RAMDirectory())) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n            // we have to try again, delete the first attempt and retry the loop\n            dirCopy.deleteFile(name);\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","sourceOld":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","bugFix":["b485ce675d4e8b9dbfafd122ca9b7b33a883be7b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","date":1472163016,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","sourceNew":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    // use ramdir explicit, as we do evil things like try to generate broken files, deletes must work.\n    try (BaseDirectoryWrapper dirCopy = new MockDirectoryWrapper(random(), new RAMDirectory())) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n            // we have to try again, delete the first attempt and retry the loop\n            dirCopy.deleteFile(name);\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","sourceOld":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","sourceNew":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    // use ramdir explicit, as we do evil things like try to generate broken files, deletes must work.\n    try (BaseDirectoryWrapper dirCopy = new MockDirectoryWrapper(random(), new RAMDirectory())) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n            // we have to try again, delete the first attempt and retry the loop\n            dirCopy.deleteFile(name);\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","sourceOld":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    try (BaseDirectoryWrapper dirCopy = newDirectory()) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      if (dirCopy instanceof MockDirectoryWrapper) {\n        // The while(true) loop below, under rarish circumstances, can sometimes double write:\n        ((MockDirectoryWrapper) dirCopy).setPreventDoubleWrite(false);\n      }\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d77dafd89756a5161d244985903e3487ca109182","date":1548679743,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","sourceNew":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    // use ramdir explicit, as we do evil things like try to generate broken files, deletes must work.\n    try (BaseDirectoryWrapper dirCopy = new MockDirectoryWrapper(random(), new ByteBuffersDirectory())) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n            // we have to try again, delete the first attempt and retry the loop\n            dirCopy.deleteFile(name);\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","sourceOld":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    // use ramdir explicit, as we do evil things like try to generate broken files, deletes must work.\n    try (BaseDirectoryWrapper dirCopy = new MockDirectoryWrapper(random(), new RAMDirectory())) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n            // we have to try again, delete the first attempt and retry the loop\n            dirCopy.deleteFile(name);\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd8a7e622c1138188be79e193b1dc52f3f0889a5","date":1564419078,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","sourceNew":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    // use ramdir explicit, as we do evil things like try to generate broken files, deletes must work.\n    try (BaseDirectoryWrapper dirCopy = new MockDirectoryWrapper(random(), new ByteBuffersDirectory())) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n            // we have to try again, delete the first attempt and retry the loop\n            dirCopy.deleteFile(name);\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n      expectThrowsAnyOf(Arrays.asList(CorruptIndexException.class, EOFException.class, IndexFormatTooOldException.class),\n          () -> DirectoryReader.open(dirCopy).close()\n      );\n\n      // CheckIndex should also fail:\n      expectThrowsAnyOf(Arrays.asList(CorruptIndexException.class, EOFException.class, IndexFormatTooOldException.class),\n          () -> DirectoryReader.open(dirCopy).close()\n      );\n    }\n  }\n\n","sourceOld":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    // use ramdir explicit, as we do evil things like try to generate broken files, deletes must work.\n    try (BaseDirectoryWrapper dirCopy = new MockDirectoryWrapper(random(), new ByteBuffersDirectory())) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n            // we have to try again, delete the first attempt and retry the loop\n            dirCopy.deleteFile(name);\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestAllFilesCheckIndexHeader#checkOneFile(Directory,String).mjava","sourceNew":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    // use ramdir explicit, as we do evil things like try to generate broken files, deletes must work.\n    try (BaseDirectoryWrapper dirCopy = new MockDirectoryWrapper(random(), new ByteBuffersDirectory())) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n            // we have to try again, delete the first attempt and retry the loop\n            dirCopy.deleteFile(name);\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n      expectThrowsAnyOf(Arrays.asList(CorruptIndexException.class, EOFException.class, IndexFormatTooOldException.class),\n          () -> DirectoryReader.open(dirCopy).close()\n      );\n\n      // CheckIndex should also fail:\n      expectThrowsAnyOf(Arrays.asList(CorruptIndexException.class, EOFException.class, IndexFormatTooOldException.class),\n          () -> DirectoryReader.open(dirCopy).close()\n      );\n    }\n  }\n\n","sourceOld":"  private void checkOneFile(Directory dir, String victim) throws IOException {\n    // use ramdir explicit, as we do evil things like try to generate broken files, deletes must work.\n    try (BaseDirectoryWrapper dirCopy = new MockDirectoryWrapper(random(), new ByteBuffersDirectory())) {\n      dirCopy.setCheckIndexOnClose(false);\n\n      long victimLength = dir.fileLength(victim);\n      int wrongBytes = TestUtil.nextInt(random(), 1, (int) Math.min(100, victimLength));\n      assert victimLength > 0;\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now break file \" + victim + \" by randomizing first \" + wrongBytes + \" of \" + victimLength);\n      }\n\n      for(String name : dir.listAll()) {\n        if (name.equals(victim) == false) {\n          dirCopy.copyFrom(dir, name, name, IOContext.DEFAULT);\n        } else {\n\n          // Iterate until our randomly generated bytes are indeed different from the first bytes of the file ... the vast majority of the\n          // time this will only require one iteration!\n          while (true) {\n            try(IndexOutput out = dirCopy.createOutput(name, IOContext.DEFAULT);\n                IndexInput in = dir.openInput(name, IOContext.DEFAULT)) {\n              // keeps same file length, but replaces the first wrongBytes with random bytes:\n              byte[] bytes = new byte[wrongBytes];\n              random().nextBytes(bytes);\n              out.writeBytes(bytes, 0, bytes.length);\n              byte[] bytes2 = new byte[wrongBytes];\n              in.readBytes(bytes2, 0, bytes2.length);\n              if (Arrays.equals(bytes, bytes2) == false) {\n                // We successfully randomly generated bytes that differ from the bytes in the file:\n                out.copyBytes(in, victimLength - wrongBytes);\n                break;\n              }\n            }\n            // we have to try again, delete the first attempt and retry the loop\n            dirCopy.deleteFile(name);\n          }\n        }\n        dirCopy.sync(Collections.singleton(name));\n      }\n\n      try {\n        // NOTE: we .close so that if the test fails (truncation not detected) we don't also get all these confusing errors about open files:\n        DirectoryReader.open(dirCopy).close();\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n\n      // CheckIndex should also fail:\n      try {\n        TestUtil.checkIndex(dirCopy, true, true, null);\n        fail(\"wrong bytes not detected after randomizing first \" + wrongBytes + \" bytes out of \" + victimLength + \" for file \" + victim);\n      } catch (CorruptIndexException | EOFException | IndexFormatTooOldException e) {\n        // expected\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cd8a7e622c1138188be79e193b1dc52f3f0889a5":["d77dafd89756a5161d244985903e3487ca109182"],"8ca66a68d392da80b8f1da46bd3e5e041e40a71d":["b485ce675d4e8b9dbfafd122ca9b7b33a883be7b"],"b485ce675d4e8b9dbfafd122ca9b7b33a883be7b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8d15e34266d75e4e8b95da046cd0afc812367b38"],"d77dafd89756a5161d244985903e3487ca109182":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"11c6df42fb3eba174c3ca0d9a5194eaecd893b77":["1f21caacfa79b5e587a1395b476d732143bef177"],"f8061ddd97f3352007d927dae445884a6f3d857b":["d77dafd89756a5161d244985903e3487ca109182","cd8a7e622c1138188be79e193b1dc52f3f0889a5"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["1f21caacfa79b5e587a1395b476d732143bef177","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"1f21caacfa79b5e587a1395b476d732143bef177":["aefe9c6efcbd9c785fd98f1379b8ba0b7aefebab"],"aefe9c6efcbd9c785fd98f1379b8ba0b7aefebab":["8d15e34266d75e4e8b95da046cd0afc812367b38"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5bfa8ae748b6814cc58721bbcc5e8723ca1686ca":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"8d15e34266d75e4e8b95da046cd0afc812367b38":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8ca66a68d392da80b8f1da46bd3e5e041e40a71d"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77","5bfa8ae748b6814cc58721bbcc5e8723ca1686ca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cd8a7e622c1138188be79e193b1dc52f3f0889a5"]},"commit2Childs":{"cd8a7e622c1138188be79e193b1dc52f3f0889a5":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8ca66a68d392da80b8f1da46bd3e5e041e40a71d":["8d15e34266d75e4e8b95da046cd0afc812367b38"],"b485ce675d4e8b9dbfafd122ca9b7b33a883be7b":["8ca66a68d392da80b8f1da46bd3e5e041e40a71d"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"d77dafd89756a5161d244985903e3487ca109182":["cd8a7e622c1138188be79e193b1dc52f3f0889a5","f8061ddd97f3352007d927dae445884a6f3d857b"],"11c6df42fb3eba174c3ca0d9a5194eaecd893b77":["5bfa8ae748b6814cc58721bbcc5e8723ca1686ca","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"1f21caacfa79b5e587a1395b476d732143bef177":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b485ce675d4e8b9dbfafd122ca9b7b33a883be7b","1e6acbaae7af722f17204ceccf0f7db5753eccf3","8d15e34266d75e4e8b95da046cd0afc812367b38"],"aefe9c6efcbd9c785fd98f1379b8ba0b7aefebab":["1f21caacfa79b5e587a1395b476d732143bef177"],"5bfa8ae748b6814cc58721bbcc5e8723ca1686ca":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"8d15e34266d75e4e8b95da046cd0afc812367b38":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","aefe9c6efcbd9c785fd98f1379b8ba0b7aefebab"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["d77dafd89756a5161d244985903e3487ca109182","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","f8061ddd97f3352007d927dae445884a6f3d857b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}