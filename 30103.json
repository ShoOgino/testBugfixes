{"path":"solr/core/src/test/org/apache/solr/handler/component/DistributedQueryComponentOptimizationTest#queryWithAsserts(String...).mjava","commits":[{"id":"5ebf70dabe6279454c5ff460bdea3f0dc2814a86","date":1463672611,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/DistributedQueryComponentOptimizationTest#queryWithAsserts(String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/DistributedQueryComponentOptimizationTest#queryWithAsserts(Object...).mjava","sourceNew":"  /**\n   * This test now asserts that every distrib.singlePass query:\n   * <ol>\n   * <li>Makes exactly 'numSlices' number of shard requests</li>\n   * <li>Makes no GET_FIELDS requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests all fields that are present in 'fl' param</li>\n   * </ol>\n   * <p>\n   * It also asserts that every regular two phase distribtued search:\n   * <ol>\n   * <li>Makes at most 2 * 'numSlices' number of shard requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests no fields other than id and score in GET_TOP_IDS request</li>\n   * <li>Requests exactly the fields that are present in 'fl' param in GET_FIELDS request and no others</li>\n   * </ol>\n   * <p>\n   * and also asserts that each query which requests id or score or both behaves exactly like a single pass query\n   */\n  private QueryResponse queryWithAsserts(String... q) throws Exception {\n    TrackingShardHandlerFactory.RequestTrackingQueue trackingQueue = new TrackingShardHandlerFactory.RequestTrackingQueue();\n    // the jettys doesn't include the control jetty which is exactly what we need here\n    TrackingShardHandlerFactory.setTrackingQueue(cluster, trackingQueue);\n\n    // let's add debug=track to such requests so we can use DebugComponent responses for assertions\n    QueryResponse response = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"debug\", \"track\", q));\n\n    Map<String, List<TrackingShardHandlerFactory.ShardRequestAndParams>> requests = trackingQueue.getAllRequests();\n    int numRequests = getNumRequests(requests);\n\n    boolean distribSinglePass = false;\n\n    Set<String> fls = new HashSet<>();\n    Set<String> sortFields = new HashSet<>();\n    for (int i = 0; i < q.length; i += 2) {\n      if (ShardParams.DISTRIB_SINGLE_PASS.equals(q[i].toString()) && Boolean.parseBoolean(q[i + 1].toString())) {\n        assertTrue(\"distrib.singlePass=true made more requests than number of shards\",\n            numRequests == sliceCount);\n        distribSinglePass = true;\n      }\n      if (CommonParams.FL.equals(q[i].toString())) {\n        fls.addAll(StrUtils.splitSmart(q[i + 1].toString(), ','));\n      }\n      if (CommonParams.SORT.equals(q[i].toString())) {\n        String val = q[i + 1].toString().trim();\n        // take care of asc/desc decorators\n        sortFields.addAll(StrUtils.splitSmart(StrUtils.splitSmart(val, ' ').get(0), ','));\n      }\n    }\n\n    Set<String> idScoreFields = new HashSet<>(2);\n    idScoreFields.add(\"id\"); // id is always requested in GET_TOP_IDS phase\n    // score is optional, requested only if sorted by score\n    if (fls.contains(\"score\") || sortFields.contains(\"score\")) idScoreFields.add(\"score\");\n\n    if (idScoreFields.containsAll(fls) && !fls.isEmpty()) {\n      // if id and/or score are the only fields being requested then we implicitly turn on distribSinglePass=true\n      distribSinglePass = true;\n    }\n\n    if (distribSinglePass) {\n      Map<String, Object> debugMap = response.getDebugMap();\n      SimpleOrderedMap<Object> track = (SimpleOrderedMap<Object>) debugMap.get(\"track\");\n      assertNotNull(track);\n      assertNotNull(track.get(\"EXECUTE_QUERY\"));\n      assertNull(\"A single pass request should not have a GET_FIELDS phase\", track.get(\"GET_FIELDS\"));\n\n      // all fields should be requested in one go but even if 'id' is not requested by user\n      // it must still be fetched in this phase to merge correctly\n      Set<String> reqAndIdScoreFields = new HashSet<>(fls);\n      reqAndIdScoreFields.addAll(idScoreFields);\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n    } else {\n      // we are assuming there are facet refinement or distributed idf requests here\n      assertTrue(\"distrib.singlePass=false made more requests than 2 * number of shards.\" +\n              \" Actual: \" + numRequests + \" but expected <= \" + sliceCount * 2,\n          numRequests <= sliceCount * 2);\n\n      // only id and/or score should be requested\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n\n      // only originally requested fields must be requested in GET_FIELDS request\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n    }\n\n    return response;\n  }\n\n","sourceOld":"  /**\n   * This test now asserts that every distrib.singlePass query:\n   * <ol>\n   * <li>Makes exactly 'numSlices' number of shard requests</li>\n   * <li>Makes no GET_FIELDS requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests all fields that are present in 'fl' param</li>\n   * </ol>\n   * <p>\n   * It also asserts that every regular two phase distribtued search:\n   * <ol>\n   * <li>Makes at most 2 * 'numSlices' number of shard requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests no fields other than id and score in GET_TOP_IDS request</li>\n   * <li>Requests exactly the fields that are present in 'fl' param in GET_FIELDS request and no others</li>\n   * </ol>\n   * <p>\n   * and also asserts that each query which requests id or score or both behaves exactly like a single pass query\n   */\n  private QueryResponse queryWithAsserts(Object... q) throws Exception {\n    TrackingShardHandlerFactory.RequestTrackingQueue trackingQueue = new TrackingShardHandlerFactory.RequestTrackingQueue();\n    // the jettys doesn't include the control jetty which is exactly what we need here\n    TrackingShardHandlerFactory.setTrackingQueue(jettys, trackingQueue);\n\n    // let's add debug=track to such requests so we can use DebugComponent responses for assertions\n    Object[] qq = new Object[q.length + 2];\n    System.arraycopy(q, 0, qq, 0, q.length);\n    qq[qq.length - 2] = \"debug\";\n    qq[qq.length - 1] = \"track\";\n    handle.put(\"debug\", SKIPVAL);\n    QueryResponse response = query(qq);\n\n    Map<String, List<TrackingShardHandlerFactory.ShardRequestAndParams>> requests = trackingQueue.getAllRequests();\n    int numRequests = getNumRequests(requests);\n\n    boolean distribSinglePass = false;\n\n    Set<String> fls = new HashSet<>();\n    Set<String> sortFields = new HashSet<>();\n    for (int i = 0; i < q.length; i += 2) {\n      if (ShardParams.DISTRIB_SINGLE_PASS.equals(q[i].toString()) && Boolean.parseBoolean(q[i + 1].toString())) {\n        assertTrue(\"distrib.singlePass=true made more requests than number of shards\",\n            numRequests == sliceCount);\n        distribSinglePass = true;\n      }\n      if (CommonParams.FL.equals(q[i].toString())) {\n        fls.addAll(StrUtils.splitSmart(q[i + 1].toString(), ','));\n      }\n      if (CommonParams.SORT.equals(q[i].toString())) {\n        String val = q[i + 1].toString().trim();\n        // take care of asc/desc decorators\n        sortFields.addAll(StrUtils.splitSmart(StrUtils.splitSmart(val, ' ').get(0), ','));\n      }\n    }\n\n    Set<String> idScoreFields = new HashSet<>(2);\n    idScoreFields.add(\"id\"); // id is always requested in GET_TOP_IDS phase\n    // score is optional, requested only if sorted by score\n    if (fls.contains(\"score\") || sortFields.contains(\"score\")) idScoreFields.add(\"score\");\n\n    if (idScoreFields.containsAll(fls) && !fls.isEmpty()) {\n      // if id and/or score are the only fields being requested then we implicitly turn on distribSinglePass=true\n      distribSinglePass = true;\n    }\n\n    if (distribSinglePass) {\n      Map<String, Object> debugMap = response.getDebugMap();\n      SimpleOrderedMap<Object> track = (SimpleOrderedMap<Object>) debugMap.get(\"track\");\n      assertNotNull(track);\n      assertNotNull(track.get(\"EXECUTE_QUERY\"));\n      assertNull(\"A single pass request should not have a GET_FIELDS phase\", track.get(\"GET_FIELDS\"));\n\n      // all fields should be requested in one go but even if 'id' is not requested by user\n      // it must still be fetched in this phase to merge correctly\n      Set<String> reqAndIdScoreFields = new HashSet<>(fls);\n      reqAndIdScoreFields.addAll(idScoreFields);\n      assertParamsEquals(trackingQueue, DEFAULT_COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n      assertParamsEquals(trackingQueue, DEFAULT_COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n    } else {\n      // we are assuming there are facet refinement or distributed idf requests here\n      assertTrue(\"distrib.singlePass=false made more requests than 2 * number of shards.\" +\n              \" Actual: \" + numRequests + \" but expected <= \" + sliceCount * 2,\n          numRequests <= sliceCount * 2);\n\n      // only id and/or score should be requested\n      assertParamsEquals(trackingQueue, DEFAULT_COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n      assertParamsEquals(trackingQueue, DEFAULT_COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n\n      // only originally requested fields must be requested in GET_FIELDS request\n      assertParamsEquals(trackingQueue, DEFAULT_COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n      assertParamsEquals(trackingQueue, DEFAULT_COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n    }\n\n    return response;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/DistributedQueryComponentOptimizationTest#queryWithAsserts(String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/DistributedQueryComponentOptimizationTest#queryWithAsserts(Object...).mjava","sourceNew":"  /**\n   * This test now asserts that every distrib.singlePass query:\n   * <ol>\n   * <li>Makes exactly 'numSlices' number of shard requests</li>\n   * <li>Makes no GET_FIELDS requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests all fields that are present in 'fl' param</li>\n   * </ol>\n   * <p>\n   * It also asserts that every regular two phase distribtued search:\n   * <ol>\n   * <li>Makes at most 2 * 'numSlices' number of shard requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests no fields other than id and score in GET_TOP_IDS request</li>\n   * <li>Requests exactly the fields that are present in 'fl' param in GET_FIELDS request and no others</li>\n   * </ol>\n   * <p>\n   * and also asserts that each query which requests id or score or both behaves exactly like a single pass query\n   */\n  private QueryResponse queryWithAsserts(String... q) throws Exception {\n    TrackingShardHandlerFactory.RequestTrackingQueue trackingQueue = new TrackingShardHandlerFactory.RequestTrackingQueue();\n    // the jettys doesn't include the control jetty which is exactly what we need here\n    TrackingShardHandlerFactory.setTrackingQueue(cluster, trackingQueue);\n\n    // let's add debug=track to such requests so we can use DebugComponent responses for assertions\n    QueryResponse response = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"debug\", \"track\", q));\n\n    Map<String, List<TrackingShardHandlerFactory.ShardRequestAndParams>> requests = trackingQueue.getAllRequests();\n    int numRequests = getNumRequests(requests);\n\n    boolean distribSinglePass = false;\n\n    Set<String> fls = new HashSet<>();\n    Set<String> sortFields = new HashSet<>();\n    for (int i = 0; i < q.length; i += 2) {\n      if (ShardParams.DISTRIB_SINGLE_PASS.equals(q[i].toString()) && Boolean.parseBoolean(q[i + 1].toString())) {\n        assertTrue(\"distrib.singlePass=true made more requests than number of shards\",\n            numRequests == sliceCount);\n        distribSinglePass = true;\n      }\n      if (CommonParams.FL.equals(q[i].toString())) {\n        fls.addAll(StrUtils.splitSmart(q[i + 1].toString(), ','));\n      }\n      if (CommonParams.SORT.equals(q[i].toString())) {\n        String val = q[i + 1].toString().trim();\n        // take care of asc/desc decorators\n        sortFields.addAll(StrUtils.splitSmart(StrUtils.splitSmart(val, ' ').get(0), ','));\n      }\n    }\n\n    Set<String> idScoreFields = new HashSet<>(2);\n    idScoreFields.add(\"id\"); // id is always requested in GET_TOP_IDS phase\n    // score is optional, requested only if sorted by score\n    if (fls.contains(\"score\") || sortFields.contains(\"score\")) idScoreFields.add(\"score\");\n\n    if (idScoreFields.containsAll(fls) && !fls.isEmpty()) {\n      // if id and/or score are the only fields being requested then we implicitly turn on distribSinglePass=true\n      distribSinglePass = true;\n    }\n\n    if (distribSinglePass) {\n      Map<String, Object> debugMap = response.getDebugMap();\n      SimpleOrderedMap<Object> track = (SimpleOrderedMap<Object>) debugMap.get(\"track\");\n      assertNotNull(track);\n      assertNotNull(track.get(\"EXECUTE_QUERY\"));\n      assertNull(\"A single pass request should not have a GET_FIELDS phase\", track.get(\"GET_FIELDS\"));\n\n      // all fields should be requested in one go but even if 'id' is not requested by user\n      // it must still be fetched in this phase to merge correctly\n      Set<String> reqAndIdScoreFields = new HashSet<>(fls);\n      reqAndIdScoreFields.addAll(idScoreFields);\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n    } else {\n      // we are assuming there are facet refinement or distributed idf requests here\n      assertTrue(\"distrib.singlePass=false made more requests than 2 * number of shards.\" +\n              \" Actual: \" + numRequests + \" but expected <= \" + sliceCount * 2,\n          numRequests <= sliceCount * 2);\n\n      // only id and/or score should be requested\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n\n      // only originally requested fields must be requested in GET_FIELDS request\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n    }\n\n    return response;\n  }\n\n","sourceOld":"  /**\n   * This test now asserts that every distrib.singlePass query:\n   * <ol>\n   * <li>Makes exactly 'numSlices' number of shard requests</li>\n   * <li>Makes no GET_FIELDS requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests all fields that are present in 'fl' param</li>\n   * </ol>\n   * <p>\n   * It also asserts that every regular two phase distribtued search:\n   * <ol>\n   * <li>Makes at most 2 * 'numSlices' number of shard requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests no fields other than id and score in GET_TOP_IDS request</li>\n   * <li>Requests exactly the fields that are present in 'fl' param in GET_FIELDS request and no others</li>\n   * </ol>\n   * <p>\n   * and also asserts that each query which requests id or score or both behaves exactly like a single pass query\n   */\n  private QueryResponse queryWithAsserts(Object... q) throws Exception {\n    TrackingShardHandlerFactory.RequestTrackingQueue trackingQueue = new TrackingShardHandlerFactory.RequestTrackingQueue();\n    // the jettys doesn't include the control jetty which is exactly what we need here\n    TrackingShardHandlerFactory.setTrackingQueue(jettys, trackingQueue);\n\n    // let's add debug=track to such requests so we can use DebugComponent responses for assertions\n    Object[] qq = new Object[q.length + 2];\n    System.arraycopy(q, 0, qq, 0, q.length);\n    qq[qq.length - 2] = \"debug\";\n    qq[qq.length - 1] = \"track\";\n    handle.put(\"debug\", SKIPVAL);\n    QueryResponse response = query(qq);\n\n    Map<String, List<TrackingShardHandlerFactory.ShardRequestAndParams>> requests = trackingQueue.getAllRequests();\n    int numRequests = getNumRequests(requests);\n\n    boolean distribSinglePass = false;\n\n    Set<String> fls = new HashSet<>();\n    Set<String> sortFields = new HashSet<>();\n    for (int i = 0; i < q.length; i += 2) {\n      if (ShardParams.DISTRIB_SINGLE_PASS.equals(q[i].toString()) && Boolean.parseBoolean(q[i + 1].toString())) {\n        assertTrue(\"distrib.singlePass=true made more requests than number of shards\",\n            numRequests == sliceCount);\n        distribSinglePass = true;\n      }\n      if (CommonParams.FL.equals(q[i].toString())) {\n        fls.addAll(StrUtils.splitSmart(q[i + 1].toString(), ','));\n      }\n      if (CommonParams.SORT.equals(q[i].toString())) {\n        String val = q[i + 1].toString().trim();\n        // take care of asc/desc decorators\n        sortFields.addAll(StrUtils.splitSmart(StrUtils.splitSmart(val, ' ').get(0), ','));\n      }\n    }\n\n    Set<String> idScoreFields = new HashSet<>(2);\n    idScoreFields.add(\"id\"); // id is always requested in GET_TOP_IDS phase\n    // score is optional, requested only if sorted by score\n    if (fls.contains(\"score\") || sortFields.contains(\"score\")) idScoreFields.add(\"score\");\n\n    if (idScoreFields.containsAll(fls) && !fls.isEmpty()) {\n      // if id and/or score are the only fields being requested then we implicitly turn on distribSinglePass=true\n      distribSinglePass = true;\n    }\n\n    if (distribSinglePass) {\n      Map<String, Object> debugMap = response.getDebugMap();\n      SimpleOrderedMap<Object> track = (SimpleOrderedMap<Object>) debugMap.get(\"track\");\n      assertNotNull(track);\n      assertNotNull(track.get(\"EXECUTE_QUERY\"));\n      assertNull(\"A single pass request should not have a GET_FIELDS phase\", track.get(\"GET_FIELDS\"));\n\n      // all fields should be requested in one go but even if 'id' is not requested by user\n      // it must still be fetched in this phase to merge correctly\n      Set<String> reqAndIdScoreFields = new HashSet<>(fls);\n      reqAndIdScoreFields.addAll(idScoreFields);\n      assertParamsEquals(trackingQueue, DEFAULT_COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n      assertParamsEquals(trackingQueue, DEFAULT_COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n    } else {\n      // we are assuming there are facet refinement or distributed idf requests here\n      assertTrue(\"distrib.singlePass=false made more requests than 2 * number of shards.\" +\n              \" Actual: \" + numRequests + \" but expected <= \" + sliceCount * 2,\n          numRequests <= sliceCount * 2);\n\n      // only id and/or score should be requested\n      assertParamsEquals(trackingQueue, DEFAULT_COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n      assertParamsEquals(trackingQueue, DEFAULT_COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n\n      // only originally requested fields must be requested in GET_FIELDS request\n      assertParamsEquals(trackingQueue, DEFAULT_COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n      assertParamsEquals(trackingQueue, DEFAULT_COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n    }\n\n    return response;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/DistributedQueryComponentOptimizationTest#queryWithAsserts(String...).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * This test now asserts that every distrib.singlePass query:\n   * <ol>\n   * <li>Makes exactly 'numSlices' number of shard requests</li>\n   * <li>Makes no GET_FIELDS requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests all fields that are present in 'fl' param</li>\n   * </ol>\n   * <p>\n   * It also asserts that every regular two phase distribtued search:\n   * <ol>\n   * <li>Makes at most 2 * 'numSlices' number of shard requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests no fields other than id and score in GET_TOP_IDS request</li>\n   * <li>Requests exactly the fields that are present in 'fl' param in GET_FIELDS request and no others</li>\n   * </ol>\n   * <p>\n   * and also asserts that each query which requests id or score or both behaves exactly like a single pass query\n   */\n  private QueryResponse queryWithAsserts(String... q) throws Exception {\n    TrackingShardHandlerFactory.RequestTrackingQueue trackingQueue = new TrackingShardHandlerFactory.RequestTrackingQueue();\n    // the jettys doesn't include the control jetty which is exactly what we need here\n    TrackingShardHandlerFactory.setTrackingQueue(cluster, trackingQueue);\n\n    // let's add debug=track to such requests so we can use DebugComponent responses for assertions\n    QueryResponse response = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"debug\", \"track\", q));\n\n    Map<String, List<TrackingShardHandlerFactory.ShardRequestAndParams>> requests = trackingQueue.getAllRequests();\n    int numRequests = getNumRequests(requests);\n\n    boolean distribSinglePass = false;\n\n    Set<String> fls = new HashSet<>();\n    Set<String> sortFields = new HashSet<>();\n    for (int i = 0; i < q.length; i += 2) {\n      if (ShardParams.DISTRIB_SINGLE_PASS.equals(q[i].toString()) && Boolean.parseBoolean(q[i + 1].toString())) {\n        assertTrue(\"distrib.singlePass=true made more requests than number of shards\",\n            numRequests == sliceCount);\n        distribSinglePass = true;\n      }\n      if (CommonParams.FL.equals(q[i].toString())) {\n        fls.addAll(StrUtils.splitSmart(q[i + 1].toString(), ','));\n      }\n      if (CommonParams.SORT.equals(q[i].toString())) {\n        String val = q[i + 1].toString().trim();\n        // take care of asc/desc decorators\n        sortFields.addAll(StrUtils.splitSmart(StrUtils.splitSmart(val, ' ').get(0), ','));\n      }\n    }\n\n    Set<String> idScoreFields = new HashSet<>(2);\n    idScoreFields.add(\"id\"); // id is always requested in GET_TOP_IDS phase\n    // score is optional, requested only if sorted by score\n    if (fls.contains(\"score\") || sortFields.contains(\"score\")) idScoreFields.add(\"score\");\n\n    if (idScoreFields.containsAll(fls) && !fls.isEmpty()) {\n      // if id and/or score are the only fields being requested then we implicitly turn on distribSinglePass=true\n      distribSinglePass = true;\n    }\n\n    if (distribSinglePass) {\n      Map<String, Object> debugMap = response.getDebugMap();\n      SimpleOrderedMap<Object> track = (SimpleOrderedMap<Object>) debugMap.get(\"track\");\n      assertNotNull(track);\n      assertNotNull(track.get(\"EXECUTE_QUERY\"));\n      assertNull(\"A single pass request should not have a GET_FIELDS phase\", track.get(\"GET_FIELDS\"));\n\n      // all fields should be requested in one go but even if 'id' is not requested by user\n      // it must still be fetched in this phase to merge correctly\n      Set<String> reqAndIdScoreFields = new HashSet<>(fls);\n      reqAndIdScoreFields.addAll(idScoreFields);\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n    } else {\n      // we are assuming there are facet refinement or distributed idf requests here\n      assertTrue(\"distrib.singlePass=false made more requests than 2 * number of shards.\" +\n              \" Actual: \" + numRequests + \" but expected <= \" + sliceCount * 2,\n          numRequests <= sliceCount * 2);\n\n      // only id and/or score should be requested\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n\n      // only originally requested fields must be requested in GET_FIELDS request\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n    }\n\n    return response;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/DistributedQueryComponentOptimizationTest#queryWithAsserts(String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/DistributedQueryComponentOptimizationTest#queryWithAsserts(String...).mjava","sourceNew":"  /**\n   * This test now asserts that every distrib.singlePass query:\n   * <ol>\n   * <li>Makes exactly 'numSlices' number of shard requests</li>\n   * <li>Makes no GET_FIELDS requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests all fields that are present in 'fl' param</li>\n   * </ol>\n   * <p>\n   * It also asserts that every regular two phase distribtued search:\n   * <ol>\n   * <li>Makes at most 2 * 'numSlices' number of shard requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests no fields other than id and score in GET_TOP_IDS request</li>\n   * <li>Requests exactly the fields that are present in 'fl' param in GET_FIELDS request and no others</li>\n   * </ol>\n   * <p>\n   * and also asserts that each query which requests id or score or both behaves exactly like a single pass query\n   */\n  private QueryResponse queryWithAsserts(String... q) throws Exception {\n    TrackingShardHandlerFactory.RequestTrackingQueue trackingQueue = new TrackingShardHandlerFactory.RequestTrackingQueue();\n    // the jettys doesn't include the control jetty which is exactly what we need here\n    TrackingShardHandlerFactory.setTrackingQueue(cluster, trackingQueue);\n\n    // let's add debug=track to such requests so we can use DebugComponent responses for assertions\n    QueryResponse response = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"debug\", \"track\", q));\n\n    Map<String, List<TrackingShardHandlerFactory.ShardRequestAndParams>> requests = trackingQueue.getAllRequests();\n    int numRequests = getNumRequests(requests);\n\n    boolean distribSinglePass = false;\n\n    Set<String> fls = new HashSet<>();\n    Set<String> sortFields = new HashSet<>();\n    for (int i = 0; i < q.length; i += 2) {\n      if (ShardParams.DISTRIB_SINGLE_PASS.equals(q[i].toString()) && Boolean.parseBoolean(q[i + 1].toString())) {\n        assertTrue(\"distrib.singlePass=true made more requests than number of shards\",\n            numRequests == sliceCount);\n        distribSinglePass = true;\n      }\n      if (CommonParams.FL.equals(q[i].toString())) {\n        fls.addAll(StrUtils.splitSmart(q[i + 1].toString(), ','));\n      }\n      if (CommonParams.SORT.equals(q[i].toString())) {\n        String val = q[i + 1].toString().trim();\n        // take care of asc/desc decorators\n        sortFields.addAll(StrUtils.splitSmart(StrUtils.splitSmart(val, ' ').get(0), ','));\n      }\n    }\n\n    Set<String> idScoreFields = new HashSet<>(2);\n    idScoreFields.add(\"id\"); // id is always requested in GET_TOP_IDS phase\n    // score is optional, requested only if sorted by score\n    if (fls.contains(\"score\") || sortFields.contains(\"score\")) idScoreFields.add(\"score\");\n\n    if (idScoreFields.containsAll(fls) && !fls.isEmpty()) {\n      // if id and/or score are the only fields being requested then we implicitly turn on distribSinglePass=true\n      distribSinglePass = true;\n    }\n\n    if (distribSinglePass) {\n      Map<String, Object> debugMap = response.getDebugMap();\n      @SuppressWarnings({\"unchecked\"})\n      SimpleOrderedMap<Object> track = (SimpleOrderedMap<Object>) debugMap.get(\"track\");\n      assertNotNull(track);\n      assertNotNull(track.get(\"EXECUTE_QUERY\"));\n      assertNull(\"A single pass request should not have a GET_FIELDS phase\", track.get(\"GET_FIELDS\"));\n\n      // all fields should be requested in one go but even if 'id' is not requested by user\n      // it must still be fetched in this phase to merge correctly\n      Set<String> reqAndIdScoreFields = new HashSet<>(fls);\n      reqAndIdScoreFields.addAll(idScoreFields);\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n    } else {\n      // we are assuming there are facet refinement or distributed idf requests here\n      assertTrue(\"distrib.singlePass=false made more requests than 2 * number of shards.\" +\n              \" Actual: \" + numRequests + \" but expected <= \" + sliceCount * 2,\n          numRequests <= sliceCount * 2);\n\n      // only id and/or score should be requested\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n\n      // only originally requested fields must be requested in GET_FIELDS request\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n    }\n\n    return response;\n  }\n\n","sourceOld":"  /**\n   * This test now asserts that every distrib.singlePass query:\n   * <ol>\n   * <li>Makes exactly 'numSlices' number of shard requests</li>\n   * <li>Makes no GET_FIELDS requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests all fields that are present in 'fl' param</li>\n   * </ol>\n   * <p>\n   * It also asserts that every regular two phase distribtued search:\n   * <ol>\n   * <li>Makes at most 2 * 'numSlices' number of shard requests</li>\n   * <li>Must request the unique key field from shards</li>\n   * <li>Must request the score if 'fl' has score or sort by score is requested</li>\n   * <li>Requests no fields other than id and score in GET_TOP_IDS request</li>\n   * <li>Requests exactly the fields that are present in 'fl' param in GET_FIELDS request and no others</li>\n   * </ol>\n   * <p>\n   * and also asserts that each query which requests id or score or both behaves exactly like a single pass query\n   */\n  private QueryResponse queryWithAsserts(String... q) throws Exception {\n    TrackingShardHandlerFactory.RequestTrackingQueue trackingQueue = new TrackingShardHandlerFactory.RequestTrackingQueue();\n    // the jettys doesn't include the control jetty which is exactly what we need here\n    TrackingShardHandlerFactory.setTrackingQueue(cluster, trackingQueue);\n\n    // let's add debug=track to such requests so we can use DebugComponent responses for assertions\n    QueryResponse response = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"debug\", \"track\", q));\n\n    Map<String, List<TrackingShardHandlerFactory.ShardRequestAndParams>> requests = trackingQueue.getAllRequests();\n    int numRequests = getNumRequests(requests);\n\n    boolean distribSinglePass = false;\n\n    Set<String> fls = new HashSet<>();\n    Set<String> sortFields = new HashSet<>();\n    for (int i = 0; i < q.length; i += 2) {\n      if (ShardParams.DISTRIB_SINGLE_PASS.equals(q[i].toString()) && Boolean.parseBoolean(q[i + 1].toString())) {\n        assertTrue(\"distrib.singlePass=true made more requests than number of shards\",\n            numRequests == sliceCount);\n        distribSinglePass = true;\n      }\n      if (CommonParams.FL.equals(q[i].toString())) {\n        fls.addAll(StrUtils.splitSmart(q[i + 1].toString(), ','));\n      }\n      if (CommonParams.SORT.equals(q[i].toString())) {\n        String val = q[i + 1].toString().trim();\n        // take care of asc/desc decorators\n        sortFields.addAll(StrUtils.splitSmart(StrUtils.splitSmart(val, ' ').get(0), ','));\n      }\n    }\n\n    Set<String> idScoreFields = new HashSet<>(2);\n    idScoreFields.add(\"id\"); // id is always requested in GET_TOP_IDS phase\n    // score is optional, requested only if sorted by score\n    if (fls.contains(\"score\") || sortFields.contains(\"score\")) idScoreFields.add(\"score\");\n\n    if (idScoreFields.containsAll(fls) && !fls.isEmpty()) {\n      // if id and/or score are the only fields being requested then we implicitly turn on distribSinglePass=true\n      distribSinglePass = true;\n    }\n\n    if (distribSinglePass) {\n      Map<String, Object> debugMap = response.getDebugMap();\n      SimpleOrderedMap<Object> track = (SimpleOrderedMap<Object>) debugMap.get(\"track\");\n      assertNotNull(track);\n      assertNotNull(track.get(\"EXECUTE_QUERY\"));\n      assertNull(\"A single pass request should not have a GET_FIELDS phase\", track.get(\"GET_FIELDS\"));\n\n      // all fields should be requested in one go but even if 'id' is not requested by user\n      // it must still be fetched in this phase to merge correctly\n      Set<String> reqAndIdScoreFields = new HashSet<>(fls);\n      reqAndIdScoreFields.addAll(idScoreFields);\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, reqAndIdScoreFields.toArray(new String[reqAndIdScoreFields.size()]));\n    } else {\n      // we are assuming there are facet refinement or distributed idf requests here\n      assertTrue(\"distrib.singlePass=false made more requests than 2 * number of shards.\" +\n              \" Actual: \" + numRequests + \" but expected <= \" + sliceCount * 2,\n          numRequests <= sliceCount * 2);\n\n      // only id and/or score should be requested\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_TOP_IDS, idScoreFields.toArray(new String[idScoreFields.size()]));\n\n      // only originally requested fields must be requested in GET_FIELDS request\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD1,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n      assertParamsEquals(trackingQueue, COLLECTION, SHARD2,\n          CommonParams.FL, ShardRequest.PURPOSE_GET_FIELDS, fls.toArray(new String[fls.size()]));\n    }\n\n    return response;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5ebf70dabe6279454c5ff460bdea3f0dc2814a86":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5ebf70dabe6279454c5ff460bdea3f0dc2814a86"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5ebf70dabe6279454c5ff460bdea3f0dc2814a86","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89"],"5ebf70dabe6279454c5ff460bdea3f0dc2814a86":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e98520789adb1d5ad05afb4956eca0944a929688"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}