{"path":"lucene/core/src/java/org/apache/lucene/util/Version#parse(String).mjava","commits":[{"id":"057a1793765d068ea9302f1a29e21734ee58d41e","date":1408130117,"type":0,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/Version#parse(String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Parse a version number of the form {@code \"major.minor.bugfix.prerelease\"}.\n   *\n   * Part {@code \".bugfix\"} and part {@code \".prerelease\"} are optional.\n   * Note that this is forwards compatible: the parsed version does not have to exist as\n   * a constant.\n   */\n  public static Version parse(String version) {\n    String[] pieces = version.split(\"\\\\.\");\n    if (pieces.length < 2 || pieces.length > 4) {\n      throw new IllegalArgumentException(\"Version is not in form major.minor.bugfix(.prerelease): \" + version);\n    }\n\n    int major = Integer.parseInt(pieces[0]);\n    int minor = Integer.parseInt(pieces[1]);\n    int bugfix = 0;\n    int prerelease = 0;\n    if (pieces.length > 2) {\n      bugfix = Integer.parseInt(pieces[2]);\n    }\n    if (pieces.length > 3) {\n      prerelease = Integer.parseInt(pieces[3]);\n      if (prerelease == 0) {\n        throw new IllegalArgumentException(\"Invalid value \" + prerelease + \" for prelrease of version \" + version +\", should be 1 or 2\");\n      }\n    }\n\n    return new Version(major, minor, bugfix, prerelease);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e2420f5fc81a6b19783f84250b5a5a3f19eb46a","date":1410373276,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/Version#parse(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/Version#parse(String).mjava","sourceNew":"  /**\n   * Parse a version number of the form {@code \"major.minor.bugfix.prerelease\"}.\n   *\n   * Part {@code \".bugfix\"} and part {@code \".prerelease\"} are optional.\n   * Note that this is forwards compatible: the parsed version does not have to exist as\n   * a constant.\n   */\n  public static Version parse(String version) {\n    String[] pieces = version.split(\"\\\\.\");\n    if (pieces.length < 2 || pieces.length > 4) {\n      throw new IllegalArgumentException(\"Version is not in form major.minor.bugfix(.prerelease): \" + version);\n    }\n\n    int major = Integer.parseInt(pieces[0]);\n    int minor = Integer.parseInt(pieces[1]);\n    int bugfix = 0;\n    int prerelease = 0;\n    if (pieces.length > 2) {\n      bugfix = Integer.parseInt(pieces[2]);\n    }\n    if (pieces.length > 3) {\n      prerelease = Integer.parseInt(pieces[3]);\n      if (prerelease == 0) {\n        throw new IllegalArgumentException(\"Invalid value \" + prerelease + \" for prerelease of version \" + version +\", should be 1 or 2\");\n      }\n    }\n\n    return new Version(major, minor, bugfix, prerelease);\n  }\n\n","sourceOld":"  /**\n   * Parse a version number of the form {@code \"major.minor.bugfix.prerelease\"}.\n   *\n   * Part {@code \".bugfix\"} and part {@code \".prerelease\"} are optional.\n   * Note that this is forwards compatible: the parsed version does not have to exist as\n   * a constant.\n   */\n  public static Version parse(String version) {\n    String[] pieces = version.split(\"\\\\.\");\n    if (pieces.length < 2 || pieces.length > 4) {\n      throw new IllegalArgumentException(\"Version is not in form major.minor.bugfix(.prerelease): \" + version);\n    }\n\n    int major = Integer.parseInt(pieces[0]);\n    int minor = Integer.parseInt(pieces[1]);\n    int bugfix = 0;\n    int prerelease = 0;\n    if (pieces.length > 2) {\n      bugfix = Integer.parseInt(pieces[2]);\n    }\n    if (pieces.length > 3) {\n      prerelease = Integer.parseInt(pieces[3]);\n      if (prerelease == 0) {\n        throw new IllegalArgumentException(\"Invalid value \" + prerelease + \" for prelrease of version \" + version +\", should be 1 or 2\");\n      }\n    }\n\n    return new Version(major, minor, bugfix, prerelease);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46ff533a28b45377dffc601931e60e19492e6384","date":1411292651,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/Version#parse(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/Version#parse(String).mjava","sourceNew":"  /**\n   * Parse a version number of the form {@code \"major.minor.bugfix.prerelease\"}.\n   *\n   * Part {@code \".bugfix\"} and part {@code \".prerelease\"} are optional.\n   * Note that this is forwards compatible: the parsed version does not have to exist as\n   * a constant.\n   *\n   * @lucene.internal\n   */\n  public static Version parse(String version) throws ParseException {\n\n    StrictStringTokenizer tokens = new StrictStringTokenizer(version, '.');\n    if (tokens.hasMoreTokens() == false) {\n      throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n    }\n\n    int major;\n    String token = tokens.nextToken();\n    try {\n      major = Integer.parseInt(token);\n    } catch (NumberFormatException nfe) {\n      throw new ParseException(\"Failed to parse major version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n    }\n\n    if (tokens.hasMoreTokens() == false) {\n      throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n    }\n\n    int minor;\n    token = tokens.nextToken();\n    try {\n      minor = Integer.parseInt(token);\n    } catch (NumberFormatException nfe) {\n      throw new ParseException(\"Failed to parse minor version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n    }\n\n    int bugfix = 0;\n    int prerelease = 0;\n    if (tokens.hasMoreTokens()) {\n\n      token = tokens.nextToken();\n      try {\n        bugfix = Integer.parseInt(token);\n      } catch (NumberFormatException nfe) {\n        throw new ParseException(\"Failed to parse bugfix version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n      }\n\n      if (tokens.hasMoreTokens()) {\n        token = tokens.nextToken();\n        try {\n          prerelease = Integer.parseInt(token);\n        } catch (NumberFormatException nfe) {\n          throw new ParseException(\"Failed to parse prerelease version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n        }\n        if (prerelease == 0) {\n          throw new ParseException(\"Invalid value \" + prerelease + \" for prerelease; should be 1 or 2 (got: \" + version + \")\", 0);\n        }\n\n        if (tokens.hasMoreTokens()) {\n          // Too many tokens!\n          throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n        }\n      }\n    }\n\n    try {\n      return new Version(major, minor, bugfix, prerelease);\n    } catch (IllegalArgumentException iae) {\n      ParseException pe = new ParseException(\"failed to parse version string \\\"\" + version + \"\\\": \" + iae.getMessage(), 0);\n      pe.initCause(iae);\n      throw pe;\n    }\n  }\n\n","sourceOld":"  /**\n   * Parse a version number of the form {@code \"major.minor.bugfix.prerelease\"}.\n   *\n   * Part {@code \".bugfix\"} and part {@code \".prerelease\"} are optional.\n   * Note that this is forwards compatible: the parsed version does not have to exist as\n   * a constant.\n   */\n  public static Version parse(String version) {\n    String[] pieces = version.split(\"\\\\.\");\n    if (pieces.length < 2 || pieces.length > 4) {\n      throw new IllegalArgumentException(\"Version is not in form major.minor.bugfix(.prerelease): \" + version);\n    }\n\n    int major = Integer.parseInt(pieces[0]);\n    int minor = Integer.parseInt(pieces[1]);\n    int bugfix = 0;\n    int prerelease = 0;\n    if (pieces.length > 2) {\n      bugfix = Integer.parseInt(pieces[2]);\n    }\n    if (pieces.length > 3) {\n      prerelease = Integer.parseInt(pieces[3]);\n      if (prerelease == 0) {\n        throw new IllegalArgumentException(\"Invalid value \" + prerelease + \" for prerelease of version \" + version +\", should be 1 or 2\");\n      }\n    }\n\n    return new Version(major, minor, bugfix, prerelease);\n  }\n\n","bugFix":null,"bugIntro":["5ac34b647144d141ce7149cce82e57f605311e33"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ac34b647144d141ce7149cce82e57f605311e33","date":1425664003,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/Version#parse(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/Version#parse(String).mjava","sourceNew":"  /**\n   * Parse a version number of the form {@code \"major.minor.bugfix.prerelease\"}.\n   *\n   * Part {@code \".bugfix\"} and part {@code \".prerelease\"} are optional.\n   * Note that this is forwards compatible: the parsed version does not have to exist as\n   * a constant.\n   *\n   * @lucene.internal\n   */\n  public static Version parse(String version) throws ParseException {\n\n    StrictStringTokenizer tokens = new StrictStringTokenizer(version, '.');\n    if (tokens.hasMoreTokens() == false) {\n      throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n    }\n\n    int major;\n    String token = tokens.nextToken();\n    try {\n      major = Integer.parseInt(token);\n    } catch (NumberFormatException nfe) {\n      ParseException p = new ParseException(\"Failed to parse major version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n      p.initCause(nfe);\n      throw p;\n    }\n\n    if (tokens.hasMoreTokens() == false) {\n      throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n    }\n\n    int minor;\n    token = tokens.nextToken();\n    try {\n      minor = Integer.parseInt(token);\n    } catch (NumberFormatException nfe) {\n      ParseException p = new ParseException(\"Failed to parse minor version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n      p.initCause(nfe);\n      throw p;\n    }\n\n    int bugfix = 0;\n    int prerelease = 0;\n    if (tokens.hasMoreTokens()) {\n\n      token = tokens.nextToken();\n      try {\n        bugfix = Integer.parseInt(token);\n      } catch (NumberFormatException nfe) {\n        ParseException p = new ParseException(\"Failed to parse bugfix version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n        p.initCause(nfe);\n        throw p;\n      }\n\n      if (tokens.hasMoreTokens()) {\n        token = tokens.nextToken();\n        try {\n          prerelease = Integer.parseInt(token);\n        } catch (NumberFormatException nfe) {\n          ParseException p = new ParseException(\"Failed to parse prerelease version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n          p.initCause(nfe);\n          throw p;\n        }\n        if (prerelease == 0) {\n          throw new ParseException(\"Invalid value \" + prerelease + \" for prerelease; should be 1 or 2 (got: \" + version + \")\", 0);\n        }\n\n        if (tokens.hasMoreTokens()) {\n          // Too many tokens!\n          throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n        }\n      }\n    }\n\n    try {\n      return new Version(major, minor, bugfix, prerelease);\n    } catch (IllegalArgumentException iae) {\n      ParseException pe = new ParseException(\"failed to parse version string \\\"\" + version + \"\\\": \" + iae.getMessage(), 0);\n      pe.initCause(iae);\n      throw pe;\n    }\n  }\n\n","sourceOld":"  /**\n   * Parse a version number of the form {@code \"major.minor.bugfix.prerelease\"}.\n   *\n   * Part {@code \".bugfix\"} and part {@code \".prerelease\"} are optional.\n   * Note that this is forwards compatible: the parsed version does not have to exist as\n   * a constant.\n   *\n   * @lucene.internal\n   */\n  public static Version parse(String version) throws ParseException {\n\n    StrictStringTokenizer tokens = new StrictStringTokenizer(version, '.');\n    if (tokens.hasMoreTokens() == false) {\n      throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n    }\n\n    int major;\n    String token = tokens.nextToken();\n    try {\n      major = Integer.parseInt(token);\n    } catch (NumberFormatException nfe) {\n      throw new ParseException(\"Failed to parse major version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n    }\n\n    if (tokens.hasMoreTokens() == false) {\n      throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n    }\n\n    int minor;\n    token = tokens.nextToken();\n    try {\n      minor = Integer.parseInt(token);\n    } catch (NumberFormatException nfe) {\n      throw new ParseException(\"Failed to parse minor version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n    }\n\n    int bugfix = 0;\n    int prerelease = 0;\n    if (tokens.hasMoreTokens()) {\n\n      token = tokens.nextToken();\n      try {\n        bugfix = Integer.parseInt(token);\n      } catch (NumberFormatException nfe) {\n        throw new ParseException(\"Failed to parse bugfix version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n      }\n\n      if (tokens.hasMoreTokens()) {\n        token = tokens.nextToken();\n        try {\n          prerelease = Integer.parseInt(token);\n        } catch (NumberFormatException nfe) {\n          throw new ParseException(\"Failed to parse prerelease version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n        }\n        if (prerelease == 0) {\n          throw new ParseException(\"Invalid value \" + prerelease + \" for prerelease; should be 1 or 2 (got: \" + version + \")\", 0);\n        }\n\n        if (tokens.hasMoreTokens()) {\n          // Too many tokens!\n          throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n        }\n      }\n    }\n\n    try {\n      return new Version(major, minor, bugfix, prerelease);\n    } catch (IllegalArgumentException iae) {\n      ParseException pe = new ParseException(\"failed to parse version string \\\"\" + version + \"\\\": \" + iae.getMessage(), 0);\n      pe.initCause(iae);\n      throw pe;\n    }\n  }\n\n","bugFix":["46ff533a28b45377dffc601931e60e19492e6384"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/Version#parse(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/Version#parse(String).mjava","sourceNew":"  /**\n   * Parse a version number of the form {@code \"major.minor.bugfix.prerelease\"}.\n   *\n   * Part {@code \".bugfix\"} and part {@code \".prerelease\"} are optional.\n   * Note that this is forwards compatible: the parsed version does not have to exist as\n   * a constant.\n   *\n   * @lucene.internal\n   */\n  public static Version parse(String version) throws ParseException {\n\n    StrictStringTokenizer tokens = new StrictStringTokenizer(version, '.');\n    if (tokens.hasMoreTokens() == false) {\n      throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n    }\n\n    int major;\n    String token = tokens.nextToken();\n    try {\n      major = Integer.parseInt(token);\n    } catch (NumberFormatException nfe) {\n      ParseException p = new ParseException(\"Failed to parse major version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n      p.initCause(nfe);\n      throw p;\n    }\n\n    if (tokens.hasMoreTokens() == false) {\n      throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n    }\n\n    int minor;\n    token = tokens.nextToken();\n    try {\n      minor = Integer.parseInt(token);\n    } catch (NumberFormatException nfe) {\n      ParseException p = new ParseException(\"Failed to parse minor version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n      p.initCause(nfe);\n      throw p;\n    }\n\n    int bugfix = 0;\n    int prerelease = 0;\n    if (tokens.hasMoreTokens()) {\n\n      token = tokens.nextToken();\n      try {\n        bugfix = Integer.parseInt(token);\n      } catch (NumberFormatException nfe) {\n        ParseException p = new ParseException(\"Failed to parse bugfix version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n        p.initCause(nfe);\n        throw p;\n      }\n\n      if (tokens.hasMoreTokens()) {\n        token = tokens.nextToken();\n        try {\n          prerelease = Integer.parseInt(token);\n        } catch (NumberFormatException nfe) {\n          ParseException p = new ParseException(\"Failed to parse prerelease version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n          p.initCause(nfe);\n          throw p;\n        }\n        if (prerelease == 0) {\n          throw new ParseException(\"Invalid value \" + prerelease + \" for prerelease; should be 1 or 2 (got: \" + version + \")\", 0);\n        }\n\n        if (tokens.hasMoreTokens()) {\n          // Too many tokens!\n          throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n        }\n      }\n    }\n\n    try {\n      return new Version(major, minor, bugfix, prerelease);\n    } catch (IllegalArgumentException iae) {\n      ParseException pe = new ParseException(\"failed to parse version string \\\"\" + version + \"\\\": \" + iae.getMessage(), 0);\n      pe.initCause(iae);\n      throw pe;\n    }\n  }\n\n","sourceOld":"  /**\n   * Parse a version number of the form {@code \"major.minor.bugfix.prerelease\"}.\n   *\n   * Part {@code \".bugfix\"} and part {@code \".prerelease\"} are optional.\n   * Note that this is forwards compatible: the parsed version does not have to exist as\n   * a constant.\n   *\n   * @lucene.internal\n   */\n  public static Version parse(String version) throws ParseException {\n\n    StrictStringTokenizer tokens = new StrictStringTokenizer(version, '.');\n    if (tokens.hasMoreTokens() == false) {\n      throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n    }\n\n    int major;\n    String token = tokens.nextToken();\n    try {\n      major = Integer.parseInt(token);\n    } catch (NumberFormatException nfe) {\n      throw new ParseException(\"Failed to parse major version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n    }\n\n    if (tokens.hasMoreTokens() == false) {\n      throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n    }\n\n    int minor;\n    token = tokens.nextToken();\n    try {\n      minor = Integer.parseInt(token);\n    } catch (NumberFormatException nfe) {\n      throw new ParseException(\"Failed to parse minor version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n    }\n\n    int bugfix = 0;\n    int prerelease = 0;\n    if (tokens.hasMoreTokens()) {\n\n      token = tokens.nextToken();\n      try {\n        bugfix = Integer.parseInt(token);\n      } catch (NumberFormatException nfe) {\n        throw new ParseException(\"Failed to parse bugfix version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n      }\n\n      if (tokens.hasMoreTokens()) {\n        token = tokens.nextToken();\n        try {\n          prerelease = Integer.parseInt(token);\n        } catch (NumberFormatException nfe) {\n          throw new ParseException(\"Failed to parse prerelease version from \\\"\" + token + \"\\\" (got: \" + version + \")\", 0);\n        }\n        if (prerelease == 0) {\n          throw new ParseException(\"Invalid value \" + prerelease + \" for prerelease; should be 1 or 2 (got: \" + version + \")\", 0);\n        }\n\n        if (tokens.hasMoreTokens()) {\n          // Too many tokens!\n          throw new ParseException(\"Version is not in form major.minor.bugfix(.prerelease) (got: \" + version + \")\", 0);\n        }\n      }\n    }\n\n    try {\n      return new Version(major, minor, bugfix, prerelease);\n    } catch (IllegalArgumentException iae) {\n      ParseException pe = new ParseException(\"failed to parse version string \\\"\" + version + \"\\\": \" + iae.getMessage(), 0);\n      pe.initCause(iae);\n      throw pe;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5e2420f5fc81a6b19783f84250b5a5a3f19eb46a":["057a1793765d068ea9302f1a29e21734ee58d41e"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["46ff533a28b45377dffc601931e60e19492e6384","5ac34b647144d141ce7149cce82e57f605311e33"],"5ac34b647144d141ce7149cce82e57f605311e33":["46ff533a28b45377dffc601931e60e19492e6384"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"46ff533a28b45377dffc601931e60e19492e6384":["5e2420f5fc81a6b19783f84250b5a5a3f19eb46a"],"057a1793765d068ea9302f1a29e21734ee58d41e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ac34b647144d141ce7149cce82e57f605311e33"]},"commit2Childs":{"5e2420f5fc81a6b19783f84250b5a5a3f19eb46a":["46ff533a28b45377dffc601931e60e19492e6384"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"5ac34b647144d141ce7149cce82e57f605311e33":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["057a1793765d068ea9302f1a29e21734ee58d41e"],"46ff533a28b45377dffc601931e60e19492e6384":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","5ac34b647144d141ce7149cce82e57f605311e33"],"057a1793765d068ea9302f1a29e21734ee58d41e":["5e2420f5fc81a6b19783f84250b5a5a3f19eb46a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}