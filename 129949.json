{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","commits":[{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    cloudManager.submit(new LeaderElection(Collections.singleton(collectionName), true));\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4422b331d00607258b0ed3e43934306e67764aa","date":1513943901,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    cloudManager.submit(new LeaderElection(Collections.singleton(collectionName), true));\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","bugFix":null,"bugIntro":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1","date":1523453934,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43345f1452f9510f8aaadae6156fe0c834e7d957","date":1523483670,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad60b6945c360ff89899d716d9cdec8dd674e2a0","date":1528114819,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27639bb5e041490ce599065875dd2f6d8beef62a","date":1532829373,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    CreateCollectionCmd.checkMaxShardsPerNode(props, usePolicyFramework);\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n\n    // modify the `withCollection` and store this new collection's name with it\n    if (withCollection != null) {\n      ZkNodeProps message = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n          ZkStateReader.COLLECTION_PROP, withCollection,\n          CollectionAdminParams.COLOCATED_WITH, collectionName);\n      cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n    }\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    List<String> shardNames = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    ClusterState clusterState = getClusterState();\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"042b92cf48996255bedb0c3c4bf772d7e06e4dea","date":1534272102,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    CreateCollectionCmd.checkMaxShardsPerNode(props, usePolicyFramework);\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n\n    // modify the `withCollection` and store this new collection's name with it\n    if (withCollection != null) {\n      ZkNodeProps message = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n          ZkStateReader.COLLECTION_PROP, withCollection,\n          CollectionAdminParams.COLOCATED_WITH, collectionName);\n      cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n    }\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    CreateCollectionCmd.checkMaxShardsPerNode(props, usePolicyFramework);\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, false);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n\n    // modify the `withCollection` and store this new collection's name with it\n    if (withCollection != null) {\n      ZkNodeProps message = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n          ZkStateReader.COLLECTION_PROP, withCollection,\n          CollectionAdminParams.COLOCATED_WITH, collectionName);\n      cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n    }\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","bugFix":["a4422b331d00607258b0ed3e43934306e67764aa","1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    CreateCollectionCmd.checkMaxShardsPerNode(props, usePolicyFramework);\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      log.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n\n    // modify the `withCollection` and store this new collection's name with it\n    if (withCollection != null) {\n      ZkNodeProps message = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n          ZkStateReader.COLLECTION_PROP, withCollection,\n          CollectionAdminParams.COLOCATED_WITH, collectionName);\n      cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n    }\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    CreateCollectionCmd.checkMaxShardsPerNode(props, usePolicyFramework);\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      LOG.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n\n    // modify the `withCollection` and store this new collection's name with it\n    if (withCollection != null) {\n      ZkNodeProps message = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n          ZkStateReader.COLLECTION_PROP, withCollection,\n          CollectionAdminParams.COLOCATED_WITH, collectionName);\n      cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n    }\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea","date":1538045138,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    final String collectionName = props.getStr(NAME);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    CreateCollectionCmd.checkMaxShardsPerNode(props, usePolicyFramework);\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      log.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), cmd.collection, props,\n        shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n\n    // modify the `withCollection` and store this new collection's name with it\n    if (withCollection != null) {\n      ZkNodeProps message = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n          ZkStateReader.COLLECTION_PROP, withCollection,\n          CollectionAdminParams.COLOCATED_WITH, collectionName);\n      cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n    }\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    List<String> nodeList = new ArrayList<>();\n    final String collectionName = props.getStr(NAME);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    CreateCollectionCmd.checkMaxShardsPerNode(props, usePolicyFramework);\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      log.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), props,\n        nodeList, shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n\n    // modify the `withCollection` and store this new collection's name with it\n    if (withCollection != null) {\n      ZkNodeProps message = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n          ZkStateReader.COLLECTION_PROP, withCollection,\n          CollectionAdminParams.COLOCATED_WITH, collectionName);\n      cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n    }\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc18bc8ea2e2c1e308757ff50671c774438e9f3e","date":1538052583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    final String collectionName = props.getStr(NAME);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    CreateCollectionCmd.checkMaxShardsPerNode(props, usePolicyFramework);\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      log.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), cmd.collection, props,\n        shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n\n    // modify the `withCollection` and store this new collection's name with it\n    if (withCollection != null) {\n      ZkNodeProps message = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n          ZkStateReader.COLLECTION_PROP, withCollection,\n          CollectionAdminParams.COLOCATED_WITH, collectionName);\n      cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n    }\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    final String collectionName = props.getStr(NAME);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    CreateCollectionCmd.checkMaxShardsPerNode(props, usePolicyFramework);\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      log.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), cmd.collection, props,\n        shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", 0);\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", 0);\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n\n    // modify the `withCollection` and store this new collection's name with it\n    if (withCollection != null) {\n      ZkNodeProps message = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n          ZkStateReader.COLLECTION_PROP, withCollection,\n          CollectionAdminParams.COLOCATED_WITH, collectionName);\n      cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n    }\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8254aa20264eb7a88d556bbe0346667937ed9c2a","date":1538494545,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    final String collectionName = props.getStr(NAME);\n    log.debug(\"-- simCreateCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    CreateCollectionCmd.checkMaxShardsPerNode(props, usePolicyFramework);\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    lock.lockInterruptibly();\n    ZkWriteCommand cmd = ZkWriteCommand.noop();\n    try {\n      cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n      if (cmd.noop) {\n        log.warn(\"Collection {} already exists. exit\", collectionName);\n        log.debug(\"-- collection: {}, clusterState: {}\", collectionName, clusterState);\n        results.add(\"success\", \"no-op\");\n        return;\n      }\n      // add collection props\n      DocCollection coll = cmd.collection;\n      collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n      colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>());\n      // add slice props\n      coll.getSlices().forEach(s -> {\n        Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n        s.getProperties().forEach((k, v) -> {\n          if (k != null && v != null) {\n            sliceProps.put(k, v);\n          }\n        });\n        colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), sh -> new ArrayList<>());\n      });\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps message = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n      }\n      // force recreation of collection states\n      collectionsStatesRef.set(null);\n\n    } finally {\n      lock.unlock();\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), cmd.collection, props,\n        shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n    log.debug(\"-- finished createCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    final String collectionName = props.getStr(NAME);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    CreateCollectionCmd.checkMaxShardsPerNode(props, usePolicyFramework);\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    ZkWriteCommand cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n    if (cmd.noop) {\n      log.warn(\"Collection {} already exists. exit\", collectionName);\n      results.add(\"success\", \"no-op\");\n      return;\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), cmd.collection, props,\n        shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n    // add collection props\n    DocCollection coll = cmd.collection;\n    collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n    // add slice props\n    coll.getSlices().forEach(s -> {\n      Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n          .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n      s.getProperties().forEach((k, v) -> {\n        if (k != null && v != null) {\n          sliceProps.put(k, v);\n        }\n      });\n    });\n\n    // modify the `withCollection` and store this new collection's name with it\n    if (withCollection != null) {\n      ZkNodeProps message = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n          ZkStateReader.COLLECTION_PROP, withCollection,\n          CollectionAdminParams.COLOCATED_WITH, collectionName);\n      cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n    }\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01322d51122b6cbe6b5ba6059fffba67798dae72","date":1539067228,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    final String collectionName = props.getStr(NAME);\n    log.debug(\"-- simCreateCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    int maxShardsPerNode = props.getInt(MAX_SHARDS_PER_NODE, 1);\n    if (maxShardsPerNode == -1) maxShardsPerNode = Integer.MAX_VALUE;\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    lock.lockInterruptibly();\n    ZkWriteCommand cmd = ZkWriteCommand.noop();\n    try {\n      cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n      if (cmd.noop) {\n        log.warn(\"Collection {} already exists. exit\", collectionName);\n        log.debug(\"-- collection: {}, clusterState: {}\", collectionName, clusterState);\n        results.add(\"success\", \"no-op\");\n        return;\n      }\n      // add collection props\n      DocCollection coll = cmd.collection;\n      collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n      colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>());\n      // add slice props\n      coll.getSlices().forEach(s -> {\n        Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n        s.getProperties().forEach((k, v) -> {\n          if (k != null && v != null) {\n            sliceProps.put(k, v);\n          }\n        });\n        colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), sh -> new ArrayList<>());\n      });\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps message = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n      }\n      // force recreation of collection states\n      collectionsStatesRef.set(null);\n\n    } finally {\n      lock.unlock();\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), cmd.collection, props,\n        shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n    log.debug(\"-- finished createCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    final String collectionName = props.getStr(NAME);\n    log.debug(\"-- simCreateCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    CreateCollectionCmd.checkMaxShardsPerNode(props, usePolicyFramework);\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    lock.lockInterruptibly();\n    ZkWriteCommand cmd = ZkWriteCommand.noop();\n    try {\n      cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n      if (cmd.noop) {\n        log.warn(\"Collection {} already exists. exit\", collectionName);\n        log.debug(\"-- collection: {}, clusterState: {}\", collectionName, clusterState);\n        results.add(\"success\", \"no-op\");\n        return;\n      }\n      // add collection props\n      DocCollection coll = cmd.collection;\n      collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n      colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>());\n      // add slice props\n      coll.getSlices().forEach(s -> {\n        Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n        s.getProperties().forEach((k, v) -> {\n          if (k != null && v != null) {\n            sliceProps.put(k, v);\n          }\n        });\n        colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), sh -> new ArrayList<>());\n      });\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps message = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n      }\n      // force recreation of collection states\n      collectionsStatesRef.set(null);\n\n    } finally {\n      lock.unlock();\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), cmd.collection, props,\n        shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n    log.debug(\"-- finished createCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"374cde0030d329720d59d1c6336d1089bbcd6fd9","date":1544808129,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    final String collectionName = props.getStr(NAME);\n    log.debug(\"-- simCreateCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    int maxShardsPerNode = props.getInt(MAX_SHARDS_PER_NODE, 1);\n    if (maxShardsPerNode == -1) maxShardsPerNode = Integer.MAX_VALUE;\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    lock.lockInterruptibly();\n    try {\n      collectionsStatesRef.set(null);\n    } finally {\n      lock.unlock();\n    }\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    lock.lockInterruptibly();\n    ZkWriteCommand cmd = ZkWriteCommand.noop();\n    try {\n      cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n      if (cmd.noop) {\n        log.warn(\"Collection {} already exists. exit\", collectionName);\n        log.debug(\"-- collection: {}, clusterState: {}\", collectionName, clusterState);\n        results.add(\"success\", \"no-op\");\n        return;\n      }\n      // add collection props\n      DocCollection coll = cmd.collection;\n      collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n      colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>());\n      // add slice props\n      coll.getSlices().forEach(s -> {\n        Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n        s.getProperties().forEach((k, v) -> {\n          if (k != null && v != null) {\n            sliceProps.put(k, v);\n          }\n        });\n        colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), sh -> new ArrayList<>());\n      });\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps message = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n      }\n      // force recreation of collection states\n      collectionsStatesRef.set(null);\n\n    } finally {\n      lock.unlock();\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), cmd.collection, props,\n        shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n\n    // force recreation of collection states\n    lock.lockInterruptibly();\n    try {\n      collectionsStatesRef.set(null);\n    } finally {\n      lock.unlock();\n    }\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n    log.debug(\"-- finished createCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    final String collectionName = props.getStr(NAME);\n    log.debug(\"-- simCreateCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    int maxShardsPerNode = props.getInt(MAX_SHARDS_PER_NODE, 1);\n    if (maxShardsPerNode == -1) maxShardsPerNode = Integer.MAX_VALUE;\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    collectionsStatesRef.set(null);\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    lock.lockInterruptibly();\n    ZkWriteCommand cmd = ZkWriteCommand.noop();\n    try {\n      cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n      if (cmd.noop) {\n        log.warn(\"Collection {} already exists. exit\", collectionName);\n        log.debug(\"-- collection: {}, clusterState: {}\", collectionName, clusterState);\n        results.add(\"success\", \"no-op\");\n        return;\n      }\n      // add collection props\n      DocCollection coll = cmd.collection;\n      collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n      colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>());\n      // add slice props\n      coll.getSlices().forEach(s -> {\n        Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n        s.getProperties().forEach((k, v) -> {\n          if (k != null && v != null) {\n            sliceProps.put(k, v);\n          }\n        });\n        colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), sh -> new ArrayList<>());\n      });\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps message = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n      }\n      // force recreation of collection states\n      collectionsStatesRef.set(null);\n\n    } finally {\n      lock.unlock();\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), cmd.collection, props,\n        shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n\n    // force recreation of collection states\n    collectionsStatesRef.set(null);\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n    log.debug(\"-- finished createCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66b87d86427dfa19b2ef36b66de83aa9655cea33","date":1552627668,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    final String collectionName = props.getStr(NAME);\n    log.debug(\"-- simCreateCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    int maxShardsPerNode = props.getInt(MAX_SHARDS_PER_NODE, 1);\n    if (maxShardsPerNode == -1) maxShardsPerNode = Integer.MAX_VALUE;\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    lock.lockInterruptibly();\n    try {\n      collectionsStatesRef.set(null);\n    } finally {\n      lock.unlock();\n    }\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    ZkWriteCommand cmd = ZkWriteCommand.noop();\n    \n    lock.lockInterruptibly();\n    try {\n      cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n      if (cmd.noop) {\n        log.warn(\"Collection {} already exists. exit\", collectionName);\n        log.debug(\"-- collection: {}, clusterState: {}\", collectionName, clusterState);\n        results.add(\"success\", \"no-op\");\n        return;\n      }\n      // add collection props\n      DocCollection coll = cmd.collection;\n      collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n      colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>());\n      // add slice props\n      coll.getSlices().forEach(s -> {\n        Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n        s.getProperties().forEach((k, v) -> {\n          if (k != null && v != null) {\n            sliceProps.put(k, v);\n          }\n        });\n        colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), sh -> new ArrayList<>());\n      });\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps message = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n      }\n      // force recreation of collection states\n      collectionsStatesRef.set(null);\n\n    } finally {\n      lock.unlock();\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), cmd.collection, props,\n        shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n\n    // force recreation of collection states\n    lock.lockInterruptibly();\n    try {\n      collectionsStatesRef.set(null);\n    } finally {\n      lock.unlock();\n    }\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n    log.debug(\"-- finished createCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    final String collectionName = props.getStr(NAME);\n    log.debug(\"-- simCreateCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    int maxShardsPerNode = props.getInt(MAX_SHARDS_PER_NODE, 1);\n    if (maxShardsPerNode == -1) maxShardsPerNode = Integer.MAX_VALUE;\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    lock.lockInterruptibly();\n    try {\n      collectionsStatesRef.set(null);\n    } finally {\n      lock.unlock();\n    }\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    lock.lockInterruptibly();\n    ZkWriteCommand cmd = ZkWriteCommand.noop();\n    try {\n      cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n      if (cmd.noop) {\n        log.warn(\"Collection {} already exists. exit\", collectionName);\n        log.debug(\"-- collection: {}, clusterState: {}\", collectionName, clusterState);\n        results.add(\"success\", \"no-op\");\n        return;\n      }\n      // add collection props\n      DocCollection coll = cmd.collection;\n      collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n      colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>());\n      // add slice props\n      coll.getSlices().forEach(s -> {\n        Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n        s.getProperties().forEach((k, v) -> {\n          if (k != null && v != null) {\n            sliceProps.put(k, v);\n          }\n        });\n        colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), sh -> new ArrayList<>());\n      });\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps message = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n      }\n      // force recreation of collection states\n      collectionsStatesRef.set(null);\n\n    } finally {\n      lock.unlock();\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), cmd.collection, props,\n        shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n\n    // force recreation of collection states\n    lock.lockInterruptibly();\n    try {\n      collectionsStatesRef.set(null);\n    } finally {\n      lock.unlock();\n    }\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n    log.debug(\"-- finished createCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":5,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimClusterStateProvider#simCreateCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    final String collectionName = props.getStr(NAME);\n    log.debug(\"-- simCreateCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    int maxShardsPerNode = props.getInt(MAX_SHARDS_PER_NODE, 1);\n    if (maxShardsPerNode == -1) maxShardsPerNode = Integer.MAX_VALUE;\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    lock.lockInterruptibly();\n    try {\n      collectionsStatesRef.set(null);\n    } finally {\n      lock.unlock();\n    }\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    ZkWriteCommand cmd = ZkWriteCommand.noop();\n    \n    lock.lockInterruptibly();\n    try {\n      cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n      if (cmd.noop) {\n        log.warn(\"Collection {} already exists. exit\", collectionName);\n        log.debug(\"-- collection: {}, clusterState: {}\", collectionName, clusterState);\n        results.add(\"success\", \"no-op\");\n        return;\n      }\n      // add collection props\n      DocCollection coll = cmd.collection;\n      collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n      colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>());\n      // add slice props\n      coll.getSlices().forEach(s -> {\n        Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n        s.getProperties().forEach((k, v) -> {\n          if (k != null && v != null) {\n            sliceProps.put(k, v);\n          }\n        });\n        colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), sh -> new ArrayList<>());\n      });\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps message = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n      }\n      // force recreation of collection states\n      collectionsStatesRef.set(null);\n\n    } finally {\n      lock.unlock();\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), cmd.collection, props,\n        shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    if (totalReplicas != replicaPositions.size()) {\n      throw new RuntimeException(\"unexpected number of replica positions: expected \" + totalReplicas + \" but got \" + replicaPositions.size());\n    }\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n\n    // force recreation of collection states\n    lock.lockInterruptibly();\n    try {\n      collectionsStatesRef.set(null);\n    } finally {\n      lock.unlock();\n    }\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n    log.debug(\"-- finished createCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n  }\n\n","sourceOld":"  /**\n   * Create a new collection. This operation uses policy framework for node and replica assignments.\n   * @param props collection details\n   * @param results results of the operation.\n   */\n  public void simCreateCollection(ZkNodeProps props, NamedList results) throws Exception {\n    ensureNotClosed();\n    if (props.getStr(CommonAdminParams.ASYNC) != null) {\n      results.add(CoreAdminParams.REQUESTID, props.getStr(CommonAdminParams.ASYNC));\n    }\n    boolean waitForFinalState = props.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    final String collectionName = props.getStr(NAME);\n    log.debug(\"-- simCreateCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n\n    String router = props.getStr(\"router.name\", DocRouter.DEFAULT_NAME);\n    String policy = props.getStr(Policy.POLICY);\n    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();\n    boolean usePolicyFramework = !autoScalingConfig.getPolicy().getClusterPolicy().isEmpty() || policy != null;\n\n    // fail fast if parameters are wrong or incomplete\n    List<String> shardNames = CreateCollectionCmd.populateShardNames(props, router);\n    int maxShardsPerNode = props.getInt(MAX_SHARDS_PER_NODE, 1);\n    if (maxShardsPerNode == -1) maxShardsPerNode = Integer.MAX_VALUE;\n    CreateCollectionCmd.checkReplicaTypes(props);\n\n    // always force getting fresh state\n    lock.lockInterruptibly();\n    try {\n      collectionsStatesRef.set(null);\n    } finally {\n      lock.unlock();\n    }\n    final ClusterState clusterState = getClusterState();\n\n    String withCollection = props.getStr(CollectionAdminParams.WITH_COLLECTION);\n    String wcShard = null;\n    if (withCollection != null) {\n      if (!clusterState.hasCollection(withCollection)) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The 'withCollection' does not exist: \" + withCollection);\n      } else  {\n        DocCollection collection = clusterState.getCollection(withCollection);\n        if (collection.getActiveSlices().size() > 1)  {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + collection.getActiveSlices().size());\n        }\n        wcShard = collection.getActiveSlices().iterator().next().getName();\n      }\n    }\n    final String withCollectionShard = wcShard;\n\n    ZkWriteCommand cmd = ZkWriteCommand.noop();\n    \n    lock.lockInterruptibly();\n    try {\n      cmd = new ClusterStateMutator(cloudManager).createCollection(clusterState, props);\n      if (cmd.noop) {\n        log.warn(\"Collection {} already exists. exit\", collectionName);\n        log.debug(\"-- collection: {}, clusterState: {}\", collectionName, clusterState);\n        results.add(\"success\", \"no-op\");\n        return;\n      }\n      // add collection props\n      DocCollection coll = cmd.collection;\n      collProperties.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>()).putAll(coll.getProperties());\n      colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>());\n      // add slice props\n      coll.getSlices().forEach(s -> {\n        Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(coll.getName(), c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), slice -> new ConcurrentHashMap<>());\n        s.getProperties().forEach((k, v) -> {\n          if (k != null && v != null) {\n            sliceProps.put(k, v);\n          }\n        });\n        colShardReplicaMap.computeIfAbsent(collectionName, c -> new ConcurrentHashMap<>())\n            .computeIfAbsent(s.getName(), sh -> new ArrayList<>());\n      });\n\n      // modify the `withCollection` and store this new collection's name with it\n      if (withCollection != null) {\n        ZkNodeProps message = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, MODIFYCOLLECTION.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollection,\n            CollectionAdminParams.COLOCATED_WITH, collectionName);\n        cmd = new CollectionMutator(cloudManager).modifyCollection(clusterState,message);\n      }\n      // force recreation of collection states\n      collectionsStatesRef.set(null);\n\n    } finally {\n      lock.unlock();\n    }\n    opDelays.computeIfAbsent(collectionName, c -> new HashMap<>()).putAll(defaultOpDelays);\n\n    opDelay(collectionName, CollectionParams.CollectionAction.CREATE.name());\n\n    AtomicReference<PolicyHelper.SessionWrapper> sessionWrapper = new AtomicReference<>();\n    List<ReplicaPosition> replicaPositions = CreateCollectionCmd.buildReplicaPositions(cloudManager, getClusterState(), cmd.collection, props,\n        shardNames, sessionWrapper);\n    if (sessionWrapper.get() != null) {\n      sessionWrapper.get().release();\n    }\n    // calculate expected number of positions\n    int numTlogReplicas = props.getInt(TLOG_REPLICAS, 0);\n    int numNrtReplicas = props.getInt(NRT_REPLICAS, props.getInt(REPLICATION_FACTOR, numTlogReplicas>0?0:1));\n    int numPullReplicas = props.getInt(PULL_REPLICAS, 0);\n    int totalReplicas = shardNames.size() * (numNrtReplicas + numPullReplicas + numTlogReplicas);\n    Assert.assertEquals(\"unexpected number of replica positions\", totalReplicas, replicaPositions.size());\n    final CountDownLatch finalStateLatch = new CountDownLatch(replicaPositions.size());\n    AtomicInteger replicaNum = new AtomicInteger(1);\n    replicaPositions.forEach(pos -> {\n\n      if (withCollection != null) {\n        // check that we have a replica of `withCollection` on this node and if not, create one\n        DocCollection collection = clusterState.getCollection(withCollection);\n        List<Replica> replicas = collection.getReplicas(pos.node);\n        if (replicas == null || replicas.isEmpty()) {\n          Map<String, Object> replicaProps = new HashMap<>();\n          replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n          replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n          String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", withCollection, withCollectionShard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n              collection.getReplicas().size() + 1);\n          try {\n            replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n            replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n            replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n            ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, withCollection, 0),\n                coreName, withCollection, withCollectionShard, pos.type, pos.node, replicaProps);\n            cloudManager.submit(() -> {\n              simAddReplica(pos.node, ri, false);\n              // do not count down the latch here\n              return true;\n            });\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n      }\n\n      Map<String, Object> replicaProps = new HashMap<>();\n      replicaProps.put(ZkStateReader.NODE_NAME_PROP, pos.node);\n      replicaProps.put(ZkStateReader.REPLICA_TYPE, pos.type.toString());\n      String coreName = String.format(Locale.ROOT, \"%s_%s_replica_%s%s\", collectionName, pos.shard, pos.type.name().substring(0,1).toLowerCase(Locale.ROOT),\n          replicaNum.getAndIncrement());\n      try {\n        replicaProps.put(ZkStateReader.CORE_NAME_PROP, coreName);\n        replicaProps.put(\"SEARCHER.searcher.deletedDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.numDocs\", new AtomicLong(0));\n        replicaProps.put(\"SEARCHER.searcher.maxDoc\", new AtomicLong(0));\n        ReplicaInfo ri = new ReplicaInfo(\"core_node\" + Assign.incAndGetId(stateManager, collectionName, 0),\n            coreName, collectionName, pos.shard, pos.type, pos.node, replicaProps);\n        cloudManager.submit(() -> {\n          simAddReplica(pos.node, ri, true);\n          finalStateLatch.countDown();\n          return true;\n        });\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    });\n\n    // force recreation of collection states\n    lock.lockInterruptibly();\n    try {\n      collectionsStatesRef.set(null);\n    } finally {\n      lock.unlock();\n    }\n    //simRunLeaderElection(Collections.singleton(collectionName), true);\n    if (waitForFinalState) {\n      boolean finished = finalStateLatch.await(cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, 60, TimeUnit.MILLISECONDS),\n          TimeUnit.MILLISECONDS);\n      if (!finished) {\n        results.add(\"failure\", \"Timeout waiting for all replicas to become active.\");\n        return;\n      }\n    }\n    results.add(\"success\", \"\");\n    log.debug(\"-- finished createCollection {}, currentVersion={}\", collectionName, clusterStateVersion);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["e9f71a1c6c905e9489b4d25c83c8d628d978a8ea"],"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"8254aa20264eb7a88d556bbe0346667937ed9c2a":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["a4422b331d00607258b0ed3e43934306e67764aa","ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1"],"374cde0030d329720d59d1c6336d1089bbcd6fd9":["01322d51122b6cbe6b5ba6059fffba67798dae72"],"01322d51122b6cbe6b5ba6059fffba67798dae72":["8254aa20264eb7a88d556bbe0346667937ed9c2a"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["27639bb5e041490ce599065875dd2f6d8beef62a"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["a4422b331d00607258b0ed3e43934306e67764aa"],"66b87d86427dfa19b2ef36b66de83aa9655cea33":["374cde0030d329720d59d1c6336d1089bbcd6fd9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["43345f1452f9510f8aaadae6156fe0c834e7d957","ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"a4422b331d00607258b0ed3e43934306e67764aa":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["66b87d86427dfa19b2ef36b66de83aa9655cea33"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ad60b6945c360ff89899d716d9cdec8dd674e2a0":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"f592209545c71895260367152601e9200399776d":["43345f1452f9510f8aaadae6156fe0c834e7d957","ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"27639bb5e041490ce599065875dd2f6d8beef62a":["ad60b6945c360ff89899d716d9cdec8dd674e2a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"]},"commit2Childs":{"fc18bc8ea2e2c1e308757ff50671c774438e9f3e":["8254aa20264eb7a88d556bbe0346667937ed9c2a"],"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea":["fc18bc8ea2e2c1e308757ff50671c774438e9f3e"],"8254aa20264eb7a88d556bbe0346667937ed9c2a":["01322d51122b6cbe6b5ba6059fffba67798dae72"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["b70042a8a492f7054d480ccdd2be9796510d4327","ad60b6945c360ff89899d716d9cdec8dd674e2a0","f592209545c71895260367152601e9200399776d"],"374cde0030d329720d59d1c6336d1089bbcd6fd9":["66b87d86427dfa19b2ef36b66de83aa9655cea33"],"01322d51122b6cbe6b5ba6059fffba67798dae72":["374cde0030d329720d59d1c6336d1089bbcd6fd9"],"042b92cf48996255bedb0c3c4bf772d7e06e4dea":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"66b87d86427dfa19b2ef36b66de83aa9655cea33":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"a4422b331d00607258b0ed3e43934306e67764aa":["43345f1452f9510f8aaadae6156fe0c834e7d957","ce71a9836bf1eba34a0ab31884e9eb8ad3f1cef1"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["a4422b331d00607258b0ed3e43934306e67764aa"],"ad60b6945c360ff89899d716d9cdec8dd674e2a0":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","27639bb5e041490ce599065875dd2f6d8beef62a"],"f592209545c71895260367152601e9200399776d":[],"27639bb5e041490ce599065875dd2f6d8beef62a":["042b92cf48996255bedb0c3c4bf772d7e06e4dea"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["e9f71a1c6c905e9489b4d25c83c8d628d978a8ea"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}