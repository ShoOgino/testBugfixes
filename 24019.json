{"path":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","commits":[{"id":"0ad9ec888e587ca9a3279368245cdf00aabdc108","date":1338832525,"type":1,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n\tprotected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n\t    NamedList response, boolean suggestionsMayOverlap) {\n\t\tint maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\t\tint maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n\t\tint maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n\t\tboolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n\t\tboolean shard = params.getBool(ShardParams.IS_SHARD, false);\n\n\t\tSpellCheckCollator collator = new SpellCheckCollator();\n\t\tList<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb, maxCollations, maxCollationTries, maxCollationEvaluations, suggestionsMayOverlap);\n    //by sorting here we guarantee a non-distributed request returns all \n\t\t//results in the same order as a distributed request would, \n\t\t//even in cases when the internal rank is the same.\n\t\tCollections.sort(collations);\n\t\t\n\t\tfor (SpellCheckCollation collation : collations) {\n\t\t\tif (collationExtendedResults) {\n\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n\t\t\t\tif(maxCollationTries>0 && shard)\n\t\t\t\t{\n\t\t\t\t\textendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n\t\t\t\t}\n\t\t\t\tresponse.add(\"collation\", extendedResult);\n\t\t\t} else {\n\t\t\t\tresponse.add(\"collation\", collation.getCollationQuery());\n\t\t\t\tif(maxCollationTries>0 && shard)\n\t\t\t\t{\n\t\t\t\t\tresponse.add(\"collationInternalRank\", collation.getInternalRank());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n\tprotected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n\t\t\tNamedList response) {\n\t\tint maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\t\tint maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n\t\tint maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n\t\tboolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n\t\tboolean shard = params.getBool(ShardParams.IS_SHARD, false);\n\n\t\tSpellCheckCollator collator = new SpellCheckCollator();\n\t\tList<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb, maxCollations, maxCollationTries, maxCollationEvaluations);\n\t\t//by sorting here we guarantee a non-distributed request returns all \n\t\t//results in the same order as a distributed request would, \n\t\t//even in cases when the internal rank is the same.\n\t\tCollections.sort(collations);\n\t\t\n\t\tfor (SpellCheckCollation collation : collations) {\n\t\t\tif (collationExtendedResults) {\n\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n\t\t\t\tif(maxCollationTries>0 && shard)\n\t\t\t\t{\n\t\t\t\t\textendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n\t\t\t\t}\n\t\t\t\tresponse.add(\"collation\", extendedResult);\n\t\t\t} else {\n\t\t\t\tresponse.add(\"collation\", collation.getCollationQuery());\n\t\t\t\tif(maxCollationTries>0 && shard)\n\t\t\t\t{\n\t\t\t\t\tresponse.add(\"collationInternalRank\", collation.getInternalRank());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n\n    SpellCheckCollator collator = new SpellCheckCollator();\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb, maxCollations, maxCollationTries, maxCollationEvaluations, suggestionsMayOverlap);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new NamedList();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        response.add(\"collation\", extendedResult);\n      } else {\n        response.add(\"collation\", collation.getCollationQuery());\n        if(maxCollationTries>0 && shard)\n        {\n          response.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n\tprotected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n\t    NamedList response, boolean suggestionsMayOverlap) {\n\t\tint maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n\t\tint maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n\t\tint maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n\t\tboolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n\t\tboolean shard = params.getBool(ShardParams.IS_SHARD, false);\n\n\t\tSpellCheckCollator collator = new SpellCheckCollator();\n\t\tList<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb, maxCollations, maxCollationTries, maxCollationEvaluations, suggestionsMayOverlap);\n    //by sorting here we guarantee a non-distributed request returns all \n\t\t//results in the same order as a distributed request would, \n\t\t//even in cases when the internal rank is the same.\n\t\tCollections.sort(collations);\n\t\t\n\t\tfor (SpellCheckCollation collation : collations) {\n\t\t\tif (collationExtendedResults) {\n\t\t\t\tNamedList extendedResult = new NamedList();\n\t\t\t\textendedResult.add(\"collationQuery\", collation.getCollationQuery());\n\t\t\t\textendedResult.add(\"hits\", collation.getHits());\n\t\t\t\textendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n\t\t\t\tif(maxCollationTries>0 && shard)\n\t\t\t\t{\n\t\t\t\t\textendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n\t\t\t\t}\n\t\t\t\tresponse.add(\"collation\", extendedResult);\n\t\t\t} else {\n\t\t\t\tresponse.add(\"collation\", collation.getCollationQuery());\n\t\t\t\tif(maxCollationTries>0 && shard)\n\t\t\t\t{\n\t\t\t\t\tresponse.add(\"collationInternalRank\", collation.getInternalRank());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ebcafb9e6302e7e39ce2199768a1428d22dd3ce0","date":1367858986,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n        .setReportHits(collationExtendedResults);\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new NamedList();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        response.add(\"collation\", extendedResult);\n      } else {\n        response.add(\"collation\", collation.getCollationQuery());\n        if(maxCollationTries>0 && shard)\n        {\n          response.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n\n    SpellCheckCollator collator = new SpellCheckCollator();\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb, maxCollations, maxCollationTries, maxCollationEvaluations, suggestionsMayOverlap);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new NamedList();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        response.add(\"collation\", extendedResult);\n      } else {\n        response.add(\"collation\", collation.getCollationQuery());\n        if(maxCollationTries>0 && shard)\n        {\n          response.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d93bd328514720a5d9f50266ea72059833876b71","date":1367860677,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n    ;\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new NamedList();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        response.add(\"collation\", extendedResult);\n      } else {\n        response.add(\"collation\", collation.getCollationQuery());\n        if(maxCollationTries>0 && shard)\n        {\n          response.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n        .setReportHits(collationExtendedResults);\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new NamedList();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        response.add(\"collation\", extendedResult);\n      } else {\n        response.add(\"collation\", collation.getCollationQuery());\n        if(maxCollationTries>0 && shard)\n        {\n          response.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"343d2d9477b299075fa3a19a46e654b6c3bf552b","date":1407872410,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n    ;\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    NamedList collationList = new NamedList();\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new SimpleOrderedMap();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        collationList.add(\"collation\", extendedResult);\n      } else {\n        collationList.add(\"collation\", collation.getCollationQuery());\n        if (maxCollationTries>0 && shard) {\n          collationList.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n    response.add(\"collations\", collationList);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n    ;\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new NamedList();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        response.add(\"collation\", extendedResult);\n      } else {\n        response.add(\"collation\", collation.getCollationQuery());\n        if(maxCollationTries>0 && shard)\n        {\n          response.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"862753d1e2f4853f389dcb115747661e7bc0e384","date":1485438193,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n    ;\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    NamedList collationList = new SimpleOrderedMap();\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new SimpleOrderedMap();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        collationList.add(\"collation\", extendedResult);\n      } else {\n        collationList.add(\"collation\", collation.getCollationQuery());\n        if (maxCollationTries>0 && shard) {\n          collationList.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n    response.add(\"collations\", collationList);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n    ;\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    NamedList collationList = new NamedList();\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new SimpleOrderedMap();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        collationList.add(\"collation\", extendedResult);\n      } else {\n        collationList.add(\"collation\", collation.getCollationQuery());\n        if (maxCollationTries>0 && shard) {\n          collationList.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n    response.add(\"collations\", collationList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n    ;\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    NamedList collationList = new SimpleOrderedMap();\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new SimpleOrderedMap();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        collationList.add(\"collation\", extendedResult);\n      } else {\n        collationList.add(\"collation\", collation.getCollationQuery());\n        if (maxCollationTries>0 && shard) {\n          collationList.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n    response.add(\"collations\", collationList);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n    ;\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    NamedList collationList = new NamedList();\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new SimpleOrderedMap();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        collationList.add(\"collation\", extendedResult);\n      } else {\n        collationList.add(\"collation\", collation.getCollationQuery());\n        if (maxCollationTries>0 && shard) {\n          collationList.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n    response.add(\"collations\", collationList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"374570062523b2011ca513a2276525ff3ddf222d","date":1494268002,"type":3,"author":"jdyer1","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n    ;\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    NamedList collationList = new NamedList();\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new SimpleOrderedMap();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        collationList.add(\"collation\", extendedResult);\n      } else {\n        collationList.add(\"collation\", collation.getCollationQuery());\n        if (maxCollationTries>0 && shard) {\n          collationList.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n    response.add(\"collations\", collationList);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n    ;\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    NamedList collationList = new SimpleOrderedMap();\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new SimpleOrderedMap();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        collationList.add(\"collation\", extendedResult);\n      } else {\n        collationList.add(\"collation\", collation.getCollationQuery());\n        if (maxCollationTries>0 && shard) {\n          collationList.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n    response.add(\"collations\", collationList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n    ;\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    NamedList collationList = new NamedList();\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new SimpleOrderedMap();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        collationList.add(\"collation\", extendedResult);\n      } else {\n        collationList.add(\"collation\", collation.getCollationQuery());\n        if (maxCollationTries>0 && shard) {\n          collationList.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n    response.add(\"collations\", collationList);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n    ;\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    NamedList collationList = new SimpleOrderedMap();\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new SimpleOrderedMap();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        collationList.add(\"collation\", extendedResult);\n      } else {\n        collationList.add(\"collation\", collation.getCollationQuery());\n        if (maxCollationTries>0 && shard) {\n          collationList.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n    response.add(\"collations\", collationList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8582f07e9350eaeb33bf6c4617b8c9895d99c839","date":1591307386,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SpellCheckComponent#addCollationsToResponse(SolrParams,SpellingResult,ResponseBuilder,String,NamedList,boolean).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      @SuppressWarnings({\"rawtypes\"})NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n    ;\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    @SuppressWarnings({\"rawtypes\"})\n    NamedList collationList = new NamedList();\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList extendedResult = new SimpleOrderedMap();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        collationList.add(\"collation\", extendedResult);\n      } else {\n        collationList.add(\"collation\", collation.getCollationQuery());\n        if (maxCollationTries>0 && shard) {\n          collationList.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n    response.add(\"collations\", collationList);\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  protected void addCollationsToResponse(SolrParams params, SpellingResult spellingResult, ResponseBuilder rb, String q,\n      NamedList response, boolean suggestionsMayOverlap) {\n    int maxCollations = params.getInt(SPELLCHECK_MAX_COLLATIONS, 1);\n    int maxCollationTries = params.getInt(SPELLCHECK_MAX_COLLATION_TRIES, 0);\n    int maxCollationEvaluations = params.getInt(SPELLCHECK_MAX_COLLATION_EVALUATIONS, 10000);\n    boolean collationExtendedResults = params.getBool(SPELLCHECK_COLLATE_EXTENDED_RESULTS, false);\n    int maxCollationCollectDocs = params.getInt(SPELLCHECK_COLLATE_MAX_COLLECT_DOCS, 0);\n    // If not reporting hits counts, don't bother collecting more than 1 document per try.\n    if (!collationExtendedResults) {\n      maxCollationCollectDocs = 1;\n    }\n    boolean shard = params.getBool(ShardParams.IS_SHARD, false);\n    SpellCheckCollator collator = new SpellCheckCollator()\n        .setMaxCollations(maxCollations)\n        .setMaxCollationTries(maxCollationTries)\n        .setMaxCollationEvaluations(maxCollationEvaluations)\n        .setSuggestionsMayOverlap(suggestionsMayOverlap)\n        .setDocCollectionLimit(maxCollationCollectDocs)\n    ;\n    List<SpellCheckCollation> collations = collator.collate(spellingResult, q, rb);\n    //by sorting here we guarantee a non-distributed request returns all \n    //results in the same order as a distributed request would,\n    //even in cases when the internal rank is the same.\n    Collections.sort(collations);\n\n    NamedList collationList = new NamedList();\n    for (SpellCheckCollation collation : collations) {\n      if (collationExtendedResults) {\n        NamedList extendedResult = new SimpleOrderedMap();\n        extendedResult.add(\"collationQuery\", collation.getCollationQuery());\n        extendedResult.add(\"hits\", collation.getHits());\n        extendedResult.add(\"misspellingsAndCorrections\", collation.getMisspellingsAndCorrections());\n        if(maxCollationTries>0 && shard)\n        {\n          extendedResult.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n        collationList.add(\"collation\", extendedResult);\n      } else {\n        collationList.add(\"collation\", collation.getCollationQuery());\n        if (maxCollationTries>0 && shard) {\n          collationList.add(\"collationInternalRank\", collation.getInternalRank());\n        }\n      }\n    }\n    response.add(\"collations\", collationList);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"374570062523b2011ca513a2276525ff3ddf222d":["862753d1e2f4853f389dcb115747661e7bc0e384"],"d93bd328514720a5d9f50266ea72059833876b71":["ebcafb9e6302e7e39ce2199768a1428d22dd3ce0"],"ebcafb9e6302e7e39ce2199768a1428d22dd3ce0":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["862753d1e2f4853f389dcb115747661e7bc0e384","374570062523b2011ca513a2276525ff3ddf222d"],"862753d1e2f4853f389dcb115747661e7bc0e384":["343d2d9477b299075fa3a19a46e654b6c3bf552b"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["343d2d9477b299075fa3a19a46e654b6c3bf552b","862753d1e2f4853f389dcb115747661e7bc0e384"],"343d2d9477b299075fa3a19a46e654b6c3bf552b":["d93bd328514720a5d9f50266ea72059833876b71"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["374570062523b2011ca513a2276525ff3ddf222d"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["0ad9ec888e587ca9a3279368245cdf00aabdc108"]},"commit2Childs":{"374570062523b2011ca513a2276525ff3ddf222d":["e9017cf144952056066919f1ebc7897ff9bd71b1","8582f07e9350eaeb33bf6c4617b8c9895d99c839"],"d93bd328514720a5d9f50266ea72059833876b71":["343d2d9477b299075fa3a19a46e654b6c3bf552b"],"ebcafb9e6302e7e39ce2199768a1428d22dd3ce0":["d93bd328514720a5d9f50266ea72059833876b71"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"862753d1e2f4853f389dcb115747661e7bc0e384":["374570062523b2011ca513a2276525ff3ddf222d","e9017cf144952056066919f1ebc7897ff9bd71b1","598b5d23aa7c9732bf473c21a9cd309c44599394"],"0ad9ec888e587ca9a3279368245cdf00aabdc108":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"343d2d9477b299075fa3a19a46e654b6c3bf552b":["862753d1e2f4853f389dcb115747661e7bc0e384","598b5d23aa7c9732bf473c21a9cd309c44599394"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad9ec888e587ca9a3279368245cdf00aabdc108"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["ebcafb9e6302e7e39ce2199768a1428d22dd3ce0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"8582f07e9350eaeb33bf6c4617b8c9895d99c839":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","598b5d23aa7c9732bf473c21a9cd309c44599394","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}