{"path":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","commits":[{"id":"2c46fed43ef19dd63a005bf3a81d5e0d0f884268","date":1439122230,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#internalCompile(ParseTree).mjava","sourceNew":"  private void generateClass(ParseTree parseTree, ClassWriter classWriter, Map<String, Integer> externalsMap) {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL | Opcodes.ACC_SYNTHETIC,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EVALUATE_METHOD, null, null, classWriter);\n\n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new IllegalArgumentException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\");\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalArgumentException(\"Unrecognized function call (\" + text + \").\");\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","sourceOld":"  // internalCompile is used to create an anonymous inner class around the ANTLR listener\n  // to completely hide the implementation details of expression compilation\n  private void internalCompile(ParseTree parseTree) {\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new IllegalArgumentException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\");\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalArgumentException(\"Unrecognized function call (\" + text + \").\");\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    }.visit(parseTree);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1913cdc31b90b93ca76e020022be298a5a2d25f9","date":1439122380,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","sourceNew":"  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL | Opcodes.ACC_SYNTHETIC,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EVALUATE_METHOD, null, null, classWriter);\n\n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new IllegalArgumentException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\");\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalArgumentException(\"Unrecognized function call (\" + text + \").\");\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","sourceOld":"  private void generateClass(ParseTree parseTree, ClassWriter classWriter, Map<String, Integer> externalsMap) {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL | Opcodes.ACC_SYNTHETIC,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EVALUATE_METHOD, null, null, classWriter);\n\n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new IllegalArgumentException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\");\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalArgumentException(\"Unrecognized function call (\" + text + \").\");\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7215ad08f57a310bd0947cb4fd0d1d8ba81591fe","date":1439454136,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","sourceNew":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL | Opcodes.ACC_SYNTHETIC,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EVALUATE_METHOD, null, null, classWriter);\n\n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new IllegalArgumentException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\");\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalArgumentException(\"Unrecognized function call (\" + text + \").\");\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","sourceOld":"  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL | Opcodes.ACC_SYNTHETIC,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EVALUATE_METHOD, null, null, classWriter);\n\n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new IllegalArgumentException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\");\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalArgumentException(\"Unrecognized function call (\" + text + \").\");\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      /**\n       * For internal compiler use only, do NOT use\n       */\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10fcb49fe038c75fa2e8f8029db57203be947728","date":1452203404,"type":3,"author":"Tomas Eduardo Fernandez Lobbe","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","sourceNew":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL | Opcodes.ACC_SYNTHETIC,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EVALUATE_METHOD, null, null, classWriter);\n    \n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    JavascriptBaseVisitor<Void> visitor = new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new ParseRuntimeException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\", \n                ctx.start.getStartIndex());\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new ParseRuntimeException(\"Unrecognized function call (\" + text + \").\", ctx.start.getStartIndex());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    };\n    \n    try {\n      visitor.visit(parseTree);\n    } catch (final ParseRuntimeException e) {\n      ParseException exception = new ParseException(\"Invalid expression '\" + sourceText + \"': \" + e.getMessage(), e.position);\n      exception.initCause(e);\n      throw exception;\n    }\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","sourceOld":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL | Opcodes.ACC_SYNTHETIC,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EVALUATE_METHOD, null, null, classWriter);\n\n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new IllegalArgumentException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\");\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalArgumentException(\"Unrecognized function call (\" + text + \").\");\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44c33cf9023a8944dcc4e84a056c08be7af288c5","date":1452205446,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","sourceNew":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EVALUATE_METHOD, null, null, classWriter);\n    \n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    JavascriptBaseVisitor<Void> visitor = new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new ParseRuntimeException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\", \n                ctx.start.getStartIndex());\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new ParseRuntimeException(\"Unrecognized function call (\" + text + \").\", ctx.start.getStartIndex());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    };\n    \n    try {\n      visitor.visit(parseTree);\n    } catch (final ParseRuntimeException e) {\n      ParseException exception = new ParseException(\"Invalid expression '\" + sourceText + \"': \" + e.getMessage(), e.position);\n      exception.initCause(e);\n      throw exception;\n    }\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","sourceOld":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL | Opcodes.ACC_SYNTHETIC,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,\n        EVALUATE_METHOD, null, null, classWriter);\n    \n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    JavascriptBaseVisitor<Void> visitor = new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new ParseRuntimeException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\", \n                ctx.start.getStartIndex());\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new ParseRuntimeException(\"Unrecognized function call (\" + text + \").\", ctx.start.getStartIndex());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    };\n    \n    try {\n      visitor.visit(parseTree);\n    } catch (final ParseRuntimeException e) {\n      ParseException exception = new ParseException(\"Invalid expression '\" + sourceText + \"': \" + e.getMessage(), e.position);\n      exception.initCause(e);\n      throw exception;\n    }\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70eccb1c774388e66090a3a2603a01400458a303","date":1452209894,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","sourceNew":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EVALUATE_METHOD, null, null, classWriter);\n    \n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throwChecked(new ParseException(\n                \"Invalid expression '\" + sourceText + \"': Expected (\" + \n                arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\", \n                ctx.start.getStartIndex()));\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throwChecked(new ParseException(\"Invalid expression '\" + sourceText + \"': Unrecognized function call (\" +\n              text + \").\", ctx.start.getStartIndex()));\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n      \n      /** Needed to throw checked ParseException in this visitor (that does not allow it). */\n      private void throwChecked(Throwable t) {\n        this.<Error>throwChecked0(t);\n      }\n      \n      @SuppressWarnings(\"unchecked\")\n      private <T extends Throwable> void throwChecked0(Throwable t) throws T {\n        throw (T) t;\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","sourceOld":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EVALUATE_METHOD, null, null, classWriter);\n    \n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    JavascriptBaseVisitor<Void> visitor = new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throw new ParseRuntimeException(\n                \"Expected (\" + arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\", \n                ctx.start.getStartIndex());\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new ParseRuntimeException(\"Unrecognized function call (\" + text + \").\", ctx.start.getStartIndex());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    };\n    \n    try {\n      visitor.visit(parseTree);\n    } catch (final ParseRuntimeException e) {\n      ParseException exception = new ParseException(\"Invalid expression '\" + sourceText + \"': \" + e.getMessage(), e.position);\n      exception.initCause(e);\n      throw exception;\n    }\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7ae1ad302fc92a61505409a38838f2b1a4a2b092","date":1483787106,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","sourceNew":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EVALUATE_METHOD, null, null, classWriter);\n    \n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throwChecked(new ParseException(\n                \"Invalid expression '\" + sourceText + \"': Expected (\" + \n                arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\", \n                ctx.start.getStartIndex()));\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(0);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throwChecked(new ParseException(\"Invalid expression '\" + sourceText + \"': Unrecognized function call (\" +\n              text + \").\", ctx.start.getStartIndex()));\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n      \n      /** Needed to throw checked ParseException in this visitor (that does not allow it). */\n      private void throwChecked(Throwable t) {\n        this.<Error>throwChecked0(t);\n      }\n      \n      @SuppressWarnings(\"unchecked\")\n      private <T extends Throwable> void throwChecked0(Throwable t) throws T {\n        throw (T) t;\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","sourceOld":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EVALUATE_METHOD, null, null, classWriter);\n    \n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throwChecked(new ParseException(\n                \"Invalid expression '\" + sourceText + \"': Expected (\" + \n                arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\", \n                ctx.start.getStartIndex()));\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throwChecked(new ParseException(\"Invalid expression '\" + sourceText + \"': Unrecognized function call (\" +\n              text + \").\", ctx.start.getStartIndex()));\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n      \n      /** Needed to throw checked ParseException in this visitor (that does not allow it). */\n      private void throwChecked(Throwable t) {\n        this.<Error>throwChecked0(t);\n      }\n      \n      @SuppressWarnings(\"unchecked\")\n      private <T extends Throwable> void throwChecked0(Throwable t) throws T {\n        throw (T) t;\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","sourceNew":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EVALUATE_METHOD, null, null, classWriter);\n    \n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throwChecked(new ParseException(\n                \"Invalid expression '\" + sourceText + \"': Expected (\" + \n                arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\", \n                ctx.start.getStartIndex()));\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(0);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throwChecked(new ParseException(\"Invalid expression '\" + sourceText + \"': Unrecognized function call (\" +\n              text + \").\", ctx.start.getStartIndex()));\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n      \n      /** Needed to throw checked ParseException in this visitor (that does not allow it). */\n      private void throwChecked(Throwable t) {\n        this.<Error>throwChecked0(t);\n      }\n      \n      @SuppressWarnings(\"unchecked\")\n      private <T extends Throwable> void throwChecked0(Throwable t) throws T {\n        throw (T) t;\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","sourceOld":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EVALUATE_METHOD, null, null, classWriter);\n    \n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throwChecked(new ParseException(\n                \"Invalid expression '\" + sourceText + \"': Expected (\" + \n                arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\", \n                ctx.start.getStartIndex()));\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(1);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.loadArg(0);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throwChecked(new ParseException(\"Invalid expression '\" + sourceText + \"': Unrecognized function call (\" +\n              text + \").\", ctx.start.getStartIndex()));\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n      \n      /** Needed to throw checked ParseException in this visitor (that does not allow it). */\n      private void throwChecked(Throwable t) {\n        this.<Error>throwChecked0(t);\n      }\n      \n      @SuppressWarnings(\"unchecked\")\n      private <T extends Throwable> void throwChecked0(Throwable t) throws T {\n        throw (T) t;\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8eb6b07bcb86da69c4a188327cf7e1ea8ae4ec0d","date":1495118387,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","sourceNew":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EVALUATE_METHOD, null, null, classWriter);\n    \n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        try {\n          if (method != null) {\n            int arity = method.getParameterTypes().length;\n  \n            if (arguments != arity) {\n              throw new ParseException(\n                  \"Invalid expression '\" + sourceText + \"': Expected (\" + \n                  arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\", \n                  ctx.start.getStartIndex());\n            }\n  \n            typeStack.push(Type.DOUBLE_TYPE);\n  \n            for (int argument = 0; argument < arguments; ++argument) {\n              visit(ctx.expression(argument));\n            }\n  \n            typeStack.pop();\n  \n            gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n                org.objectweb.asm.commons.Method.getMethod(method));\n  \n            gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n          } else if (!parens || arguments == 0 && text.contains(\".\")) {\n            int index;\n  \n            text = normalizeQuotes(ctx.getText());\n  \n            if (externalsMap.containsKey(text)) {\n              index = externalsMap.get(text);\n            } else {\n              index = externalsMap.size();\n              externalsMap.put(text, index);\n            }\n  \n            gen.loadArg(0);\n            gen.push(index);\n            gen.arrayLoad(FUNCTION_VALUES_TYPE);\n            gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n            gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n          } else {\n            throw new ParseException(\"Invalid expression '\" + sourceText + \"': Unrecognized function call (\" +\n                text + \").\", ctx.start.getStartIndex());\n          }\n          return null;\n        } catch (ParseException e) {\n          // The API doesn't allow checked exceptions here, so propagate up the stack. This is unwrapped\n          // in getAntlrParseTree. \n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","sourceOld":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EVALUATE_METHOD, null, null, classWriter);\n    \n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throwChecked(new ParseException(\n                \"Invalid expression '\" + sourceText + \"': Expected (\" + \n                arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\", \n                ctx.start.getStartIndex()));\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(0);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throwChecked(new ParseException(\"Invalid expression '\" + sourceText + \"': Unrecognized function call (\" +\n              text + \").\", ctx.start.getStartIndex()));\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n      \n      /** Needed to throw checked ParseException in this visitor (that does not allow it). */\n      private void throwChecked(Throwable t) {\n        this.<Error>throwChecked0(t);\n      }\n      \n      @SuppressWarnings(\"unchecked\")\n      private <T extends Throwable> void throwChecked0(Throwable t) throws T {\n        throw (T) t;\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","pathOld":"lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler#generateClass(ParseTree,ClassWriter,Map[String,Integer]).mjava","sourceNew":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EVALUATE_METHOD, null, null, classWriter);\n    \n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        try {\n          if (method != null) {\n            int arity = method.getParameterTypes().length;\n  \n            if (arguments != arity) {\n              throw new ParseException(\n                  \"Invalid expression '\" + sourceText + \"': Expected (\" + \n                  arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\", \n                  ctx.start.getStartIndex());\n            }\n  \n            typeStack.push(Type.DOUBLE_TYPE);\n  \n            for (int argument = 0; argument < arguments; ++argument) {\n              visit(ctx.expression(argument));\n            }\n  \n            typeStack.pop();\n  \n            gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n                org.objectweb.asm.commons.Method.getMethod(method));\n  \n            gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n          } else if (!parens || arguments == 0 && text.contains(\".\")) {\n            int index;\n  \n            text = normalizeQuotes(ctx.getText());\n  \n            if (externalsMap.containsKey(text)) {\n              index = externalsMap.get(text);\n            } else {\n              index = externalsMap.size();\n              externalsMap.put(text, index);\n            }\n  \n            gen.loadArg(0);\n            gen.push(index);\n            gen.arrayLoad(FUNCTION_VALUES_TYPE);\n            gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n            gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n          } else {\n            throw new ParseException(\"Invalid expression '\" + sourceText + \"': Unrecognized function call (\" +\n                text + \").\", ctx.start.getStartIndex());\n          }\n          return null;\n        } catch (ParseException e) {\n          // The API doesn't allow checked exceptions here, so propagate up the stack. This is unwrapped\n          // in getAntlrParseTree. \n          throw new RuntimeException(e);\n        }\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","sourceOld":"  /**\n   * Sends the bytecode of class file to {@link ClassWriter}.\n   */\n  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {\n    classWriter.visit(CLASSFILE_VERSION,\n        Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,\n        COMPILED_EXPRESSION_INTERNAL,\n        null, EXPRESSION_TYPE.getInternalName(), null);\n    final String clippedSourceText = (sourceText.length() <= MAX_SOURCE_LENGTH) ?\n        sourceText : (sourceText.substring(0, MAX_SOURCE_LENGTH - 3) + \"...\");\n    classWriter.visitSource(clippedSourceText, null);\n    \n    final GeneratorAdapter constructor = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EXPRESSION_CTOR, null, null, classWriter);\n    constructor.loadThis();\n    constructor.loadArgs();\n    constructor.invokeConstructor(EXPRESSION_TYPE, EXPRESSION_CTOR);\n    constructor.returnValue();\n    constructor.endMethod();\n    \n    final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC,\n        EVALUATE_METHOD, null, null, classWriter);\n    \n    // to completely hide the ANTLR visitor we use an anonymous impl:\n    new JavascriptBaseVisitor<Void>() {\n      private final Deque<Type> typeStack = new ArrayDeque<>();\n\n      @Override\n      public Void visitCompile(JavascriptParser.CompileContext ctx) {\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(ctx.expression());\n        typeStack.pop();\n\n        return null;\n      }\n\n      @Override\n      public Void visitPrecedence(JavascriptParser.PrecedenceContext ctx) {\n        visit(ctx.expression());\n\n        return null;\n      }\n\n      @Override\n      public Void visitNumeric(JavascriptParser.NumericContext ctx) {\n        if (ctx.HEX() != null) {\n          pushLong(Long.parseLong(ctx.HEX().getText().substring(2), 16));\n        } else if (ctx.OCTAL() != null) {\n          pushLong(Long.parseLong(ctx.OCTAL().getText().substring(1), 8));\n        } else if (ctx.DECIMAL() != null) {\n          gen.push(Double.parseDouble(ctx.DECIMAL().getText()));\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitExternal(JavascriptParser.ExternalContext ctx) {\n        String text = ctx.VARIABLE().getText();\n        int arguments = ctx.expression().size();\n        boolean parens = ctx.LP() != null && ctx.RP() != null;\n        Method method = parens ? functions.get(text) : null;\n\n        if (method != null) {\n          int arity = method.getParameterTypes().length;\n\n          if (arguments != arity) {\n            throwChecked(new ParseException(\n                \"Invalid expression '\" + sourceText + \"': Expected (\" + \n                arity + \") arguments for function call (\" + text + \"), but found (\" + arguments + \").\", \n                ctx.start.getStartIndex()));\n          }\n\n          typeStack.push(Type.DOUBLE_TYPE);\n\n          for (int argument = 0; argument < arguments; ++argument) {\n            visit(ctx.expression(argument));\n          }\n\n          typeStack.pop();\n\n          gen.invokeStatic(Type.getType(method.getDeclaringClass()),\n              org.objectweb.asm.commons.Method.getMethod(method));\n\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else if (!parens || arguments == 0 && text.contains(\".\")) {\n          int index;\n\n          text = normalizeQuotes(ctx.getText());\n\n          if (externalsMap.containsKey(text)) {\n            index = externalsMap.get(text);\n          } else {\n            index = externalsMap.size();\n            externalsMap.put(text, index);\n          }\n\n          gen.loadArg(0);\n          gen.push(index);\n          gen.arrayLoad(FUNCTION_VALUES_TYPE);\n          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n        } else {\n          throwChecked(new ParseException(\"Invalid expression '\" + sourceText + \"': Unrecognized function call (\" +\n              text + \").\", ctx.start.getStartIndex()));\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitUnary(JavascriptParser.UnaryContext ctx) {\n        if (ctx.BOOLNOT() != null) {\n          Label labelNotTrue = new Label();\n          Label labelNotReturn = new Label();\n\n          typeStack.push(Type.INT_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitJumpInsn(Opcodes.IFEQ, labelNotTrue);\n          pushBoolean(false);\n          gen.goTo(labelNotReturn);\n          gen.visitLabel(labelNotTrue);\n          pushBoolean(true);\n          gen.visitLabel(labelNotReturn);\n\n        } else if (ctx.BWNOT() != null) {\n          typeStack.push(Type.LONG_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.push(-1L);\n          gen.visitInsn(Opcodes.LXOR);\n          gen.cast(Type.LONG_TYPE, typeStack.peek());\n\n        } else if (ctx.ADD() != null) {\n          visit(ctx.expression());\n\n        } else if (ctx.SUB() != null) {\n          typeStack.push(Type.DOUBLE_TYPE);\n          visit(ctx.expression());\n          typeStack.pop();\n          gen.visitInsn(Opcodes.DNEG);\n          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());\n\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        return null;\n      }\n\n      @Override\n      public Void visitMuldiv(JavascriptParser.MuldivContext ctx) {\n        int opcode;\n\n        if (ctx.MUL() != null) {\n          opcode = Opcodes.DMUL;\n        } else if (ctx.DIV() != null) {\n          opcode = Opcodes.DDIV;\n        } else if (ctx.REM() != null) {\n          opcode = Opcodes.DREM;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitAddsub(JavascriptParser.AddsubContext ctx) {\n        int opcode;\n\n        if (ctx.ADD() != null) {\n          opcode = Opcodes.DADD;\n        } else if (ctx.SUB() != null) {\n          opcode = Opcodes.DSUB;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushArith(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwshift(JavascriptParser.BwshiftContext ctx) {\n        int opcode;\n\n        if (ctx.LSH() != null) {\n          opcode = Opcodes.LSHL;\n        } else if (ctx.RSH() != null) {\n          opcode = Opcodes.LSHR;\n        } else if (ctx.USH() != null) {\n          opcode = Opcodes.LUSHR;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushShift(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolcomp(JavascriptParser.BoolcompContext ctx) {\n        int opcode;\n\n        if (ctx.LT() != null) {\n          opcode = GeneratorAdapter.LT;\n        } else if (ctx.LTE() != null) {\n          opcode = GeneratorAdapter.LE;\n        } else if (ctx.GT() != null) {\n          opcode = GeneratorAdapter.GT;\n        } else if (ctx.GTE() != null) {\n          opcode = GeneratorAdapter.GE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooleqne(JavascriptParser.BooleqneContext ctx) {\n        int opcode;\n\n        if (ctx.EQ() != null) {\n          opcode = GeneratorAdapter.EQ;\n        } else if (ctx.NE() != null) {\n          opcode = GeneratorAdapter.NE;\n        } else {\n          throw new IllegalStateException(\"Unknown operation specified: \" + ctx.getText());\n        }\n\n        pushCond(opcode, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwand(JavascriptParser.BwandContext ctx) {\n        pushBitwise(Opcodes.LAND, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwxor(JavascriptParser.BwxorContext ctx) {\n        pushBitwise(Opcodes.LXOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBwor(JavascriptParser.BworContext ctx) {\n        pushBitwise(Opcodes.LOR, ctx.expression(0), ctx.expression(1));\n\n        return null;\n      }\n\n      @Override\n      public Void visitBooland(JavascriptParser.BoolandContext ctx) {\n        Label andFalse = new Label();\n        Label andEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFEQ, andFalse);\n        typeStack.pop();\n        pushBoolean(true);\n        gen.goTo(andEnd);\n        gen.visitLabel(andFalse);\n        pushBoolean(false);\n        gen.visitLabel(andEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitBoolor(JavascriptParser.BoolorContext ctx) {\n        Label orTrue = new Label();\n        Label orEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        visit(ctx.expression(1));\n        gen.visitJumpInsn(Opcodes.IFNE, orTrue);\n        typeStack.pop();\n        pushBoolean(false);\n        gen.goTo(orEnd);\n        gen.visitLabel(orTrue);\n        pushBoolean(true);\n        gen.visitLabel(orEnd);\n\n        return null;\n      }\n\n      @Override\n      public Void visitConditional(JavascriptParser.ConditionalContext ctx) {\n        Label condFalse = new Label();\n        Label condEnd = new Label();\n\n        typeStack.push(Type.INT_TYPE);\n        visit(ctx.expression(0));\n        typeStack.pop();\n        gen.visitJumpInsn(Opcodes.IFEQ, condFalse);\n        visit(ctx.expression(1));\n        gen.goTo(condEnd);\n        gen.visitLabel(condFalse);\n        visit(ctx.expression(2));\n        gen.visitLabel(condEnd);\n\n        return null;\n      }\n\n      private void pushArith(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE, Type.DOUBLE_TYPE);\n      }\n\n      private void pushShift(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.INT_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBitwise(int operator, ExpressionContext left, ExpressionContext right) {\n        pushBinaryOp(operator, left, right, Type.LONG_TYPE, Type.LONG_TYPE, Type.LONG_TYPE);\n      }\n\n      private void pushBinaryOp(int operator, ExpressionContext left, ExpressionContext right,\n                                Type leftType, Type rightType, Type returnType) {\n        typeStack.push(leftType);\n        visit(left);\n        typeStack.pop();\n        typeStack.push(rightType);\n        visit(right);\n        typeStack.pop();\n        gen.visitInsn(operator);\n        gen.cast(returnType, typeStack.peek());\n      }\n\n      private void pushCond(int operator, ExpressionContext left, ExpressionContext right) {\n        Label labelTrue = new Label();\n        Label labelReturn = new Label();\n\n        typeStack.push(Type.DOUBLE_TYPE);\n        visit(left);\n        visit(right);\n        typeStack.pop();\n\n        gen.ifCmp(Type.DOUBLE_TYPE, operator, labelTrue);\n        pushBoolean(false);\n        gen.goTo(labelReturn);\n        gen.visitLabel(labelTrue);\n        pushBoolean(true);\n        gen.visitLabel(labelReturn);\n      }\n\n      private void pushBoolean(boolean truth) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push(truth);\n            break;\n          case Type.LONG:\n            gen.push(truth ? 1L : 0L);\n            break;\n          case Type.DOUBLE:\n            gen.push(truth ? 1. : 0.);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n\n      private void pushLong(long i) {\n        switch (typeStack.peek().getSort()) {\n          case Type.INT:\n            gen.push((int) i);\n            break;\n          case Type.LONG:\n            gen.push(i);\n            break;\n          case Type.DOUBLE:\n            gen.push((double) i);\n            break;\n          default:\n            throw new IllegalStateException(\"Invalid expected type: \" + typeStack.peek());\n        }\n      }\n      \n      /** Needed to throw checked ParseException in this visitor (that does not allow it). */\n      private void throwChecked(Throwable t) {\n        this.<Error>throwChecked0(t);\n      }\n      \n      @SuppressWarnings(\"unchecked\")\n      private <T extends Throwable> void throwChecked0(Throwable t) throws T {\n        throw (T) t;\n      }\n    }.visit(parseTree);\n    \n    gen.returnValue();\n    gen.endMethod();\n    \n    classWriter.visitEnd();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"10fcb49fe038c75fa2e8f8029db57203be947728":["7215ad08f57a310bd0947cb4fd0d1d8ba81591fe"],"7215ad08f57a310bd0947cb4fd0d1d8ba81591fe":["1913cdc31b90b93ca76e020022be298a5a2d25f9"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["7ae1ad302fc92a61505409a38838f2b1a4a2b092","8eb6b07bcb86da69c4a188327cf7e1ea8ae4ec0d"],"70eccb1c774388e66090a3a2603a01400458a303":["44c33cf9023a8944dcc4e84a056c08be7af288c5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7ae1ad302fc92a61505409a38838f2b1a4a2b092":["70eccb1c774388e66090a3a2603a01400458a303"],"44c33cf9023a8944dcc4e84a056c08be7af288c5":["10fcb49fe038c75fa2e8f8029db57203be947728"],"2c46fed43ef19dd63a005bf3a81d5e0d0f884268":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["70eccb1c774388e66090a3a2603a01400458a303","7ae1ad302fc92a61505409a38838f2b1a4a2b092"],"8eb6b07bcb86da69c4a188327cf7e1ea8ae4ec0d":["7ae1ad302fc92a61505409a38838f2b1a4a2b092"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8eb6b07bcb86da69c4a188327cf7e1ea8ae4ec0d"],"1913cdc31b90b93ca76e020022be298a5a2d25f9":["2c46fed43ef19dd63a005bf3a81d5e0d0f884268"]},"commit2Childs":{"10fcb49fe038c75fa2e8f8029db57203be947728":["44c33cf9023a8944dcc4e84a056c08be7af288c5"],"7215ad08f57a310bd0947cb4fd0d1d8ba81591fe":["10fcb49fe038c75fa2e8f8029db57203be947728"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"70eccb1c774388e66090a3a2603a01400458a303":["7ae1ad302fc92a61505409a38838f2b1a4a2b092","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2c46fed43ef19dd63a005bf3a81d5e0d0f884268"],"7ae1ad302fc92a61505409a38838f2b1a4a2b092":["e9017cf144952056066919f1ebc7897ff9bd71b1","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","8eb6b07bcb86da69c4a188327cf7e1ea8ae4ec0d"],"44c33cf9023a8944dcc4e84a056c08be7af288c5":["70eccb1c774388e66090a3a2603a01400458a303"],"2c46fed43ef19dd63a005bf3a81d5e0d0f884268":["1913cdc31b90b93ca76e020022be298a5a2d25f9"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"8eb6b07bcb86da69c4a188327cf7e1ea8ae4ec0d":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1913cdc31b90b93ca76e020022be298a5a2d25f9":["7215ad08f57a310bd0947cb4fd0d1d8ba81591fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}