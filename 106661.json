{"path":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","sourceNew":"    // Returns true if first is < second\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      final float firstScore = shardHits[first.shardIndex][first.hitIndex].score;\n      final float secondScore = shardHits[second.shardIndex][second.hitIndex].score;\n\n      if (firstScore < secondScore) {\n        return false;\n      } else if (firstScore > secondScore) {\n        return true;\n      } else {\n        // Tie break: earlier shard wins\n        if (first.shardIndex < second.shardIndex) {\n          return true;\n        } else if (first.shardIndex > second.shardIndex) {\n          return false;\n        } else {\n          // Tie break in same shard: resolve however the\n          // shard had resolved it:\n          assert first.hitIndex != second.hitIndex;\n          return first.hitIndex < second.hitIndex;\n        }\n      }\n    }\n\n","sourceOld":"    // Returns true if first is < second\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      final float firstScore = shardHits[first.shardIndex][first.hitIndex].score;\n      final float secondScore = shardHits[second.shardIndex][second.hitIndex].score;\n\n      if (firstScore < secondScore) {\n        return false;\n      } else if (firstScore > secondScore) {\n        return true;\n      } else {\n        // Tie break: earlier shard wins\n        if (first.shardIndex < second.shardIndex) {\n          return true;\n        } else if (first.shardIndex > second.shardIndex) {\n          return false;\n        } else {\n          // Tie break in same shard: resolve however the\n          // shard had resolved it:\n          assert first.hitIndex != second.hitIndex;\n          return first.hitIndex < second.hitIndex;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","sourceNew":"    // Returns true if first is < second\n    @Override\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      final float firstScore = shardHits[first.shardIndex][first.hitIndex].score;\n      final float secondScore = shardHits[second.shardIndex][second.hitIndex].score;\n\n      if (firstScore < secondScore) {\n        return false;\n      } else if (firstScore > secondScore) {\n        return true;\n      } else {\n        // Tie break: earlier shard wins\n        if (first.shardIndex < second.shardIndex) {\n          return true;\n        } else if (first.shardIndex > second.shardIndex) {\n          return false;\n        } else {\n          // Tie break in same shard: resolve however the\n          // shard had resolved it:\n          assert first.hitIndex != second.hitIndex;\n          return first.hitIndex < second.hitIndex;\n        }\n      }\n    }\n\n","sourceOld":"    // Returns true if first is < second\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      final float firstScore = shardHits[first.shardIndex][first.hitIndex].score;\n      final float secondScore = shardHits[second.shardIndex][second.hitIndex].score;\n\n      if (firstScore < secondScore) {\n        return false;\n      } else if (firstScore > secondScore) {\n        return true;\n      } else {\n        // Tie break: earlier shard wins\n        if (first.shardIndex < second.shardIndex) {\n          return true;\n        } else if (first.shardIndex > second.shardIndex) {\n          return false;\n        } else {\n          // Tie break in same shard: resolve however the\n          // shard had resolved it:\n          assert first.hitIndex != second.hitIndex;\n          return first.hitIndex < second.hitIndex;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","sourceNew":"    // Returns true if first is < second\n    @Override\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      final float firstScore = shardHits[first.shardIndex][first.hitIndex].score;\n      final float secondScore = shardHits[second.shardIndex][second.hitIndex].score;\n\n      if (firstScore < secondScore) {\n        return false;\n      } else if (firstScore > secondScore) {\n        return true;\n      } else {\n        // Tie break: earlier shard wins\n        if (first.shardIndex < second.shardIndex) {\n          return true;\n        } else if (first.shardIndex > second.shardIndex) {\n          return false;\n        } else {\n          // Tie break in same shard: resolve however the\n          // shard had resolved it:\n          assert first.hitIndex != second.hitIndex;\n          return first.hitIndex < second.hitIndex;\n        }\n      }\n    }\n\n","sourceOld":"    // Returns true if first is < second\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      final float firstScore = shardHits[first.shardIndex][first.hitIndex].score;\n      final float secondScore = shardHits[second.shardIndex][second.hitIndex].score;\n\n      if (firstScore < secondScore) {\n        return false;\n      } else if (firstScore > secondScore) {\n        return true;\n      } else {\n        // Tie break: earlier shard wins\n        if (first.shardIndex < second.shardIndex) {\n          return true;\n        } else if (first.shardIndex > second.shardIndex) {\n          return false;\n        } else {\n          // Tie break in same shard: resolve however the\n          // shard had resolved it:\n          assert first.hitIndex != second.hitIndex;\n          return first.hitIndex < second.hitIndex;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"500a89755c0c3953ca1886b5abb653b8cef8e299","date":1487933004,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","sourceNew":"    // Returns true if first is < second\n    @Override\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      ScoreDoc firstScoreDoc = shardHits[first.shardIndex][first.hitIndex];\n      ScoreDoc secondScoreDoc = shardHits[second.shardIndex][second.hitIndex];\n      if (firstScoreDoc.score < secondScoreDoc.score) {\n        return false;\n      } else if (firstScoreDoc.score > secondScoreDoc.score) {\n        return true;\n      } else {\n        return tieBreakLessThan(first, firstScoreDoc, second, secondScoreDoc);\n      }\n    }\n\n","sourceOld":"    // Returns true if first is < second\n    @Override\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      final float firstScore = shardHits[first.shardIndex][first.hitIndex].score;\n      final float secondScore = shardHits[second.shardIndex][second.hitIndex].score;\n\n      if (firstScore < secondScore) {\n        return false;\n      } else if (firstScore > secondScore) {\n        return true;\n      } else {\n        // Tie break: earlier shard wins\n        if (first.shardIndex < second.shardIndex) {\n          return true;\n        } else if (first.shardIndex > second.shardIndex) {\n          return false;\n        } else {\n          // Tie break in same shard: resolve however the\n          // shard had resolved it:\n          assert first.hitIndex != second.hitIndex;\n          return first.hitIndex < second.hitIndex;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"36510a8e3c1ec60d366b45f8f716e9dc47589661","date":1561989412,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","sourceNew":"    // Returns true if first is < second\n    @Override\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      ScoreDoc firstScoreDoc = shardHits[first.shardIndex][first.hitIndex];\n      ScoreDoc secondScoreDoc = shardHits[second.shardIndex][second.hitIndex];\n      if (firstScoreDoc.score < secondScoreDoc.score) {\n        return false;\n      } else if (firstScoreDoc.score > secondScoreDoc.score) {\n        return true;\n      } else {\n        return tieBreakLessThan(first, firstScoreDoc, second, secondScoreDoc, tieBreakerComparator);\n      }\n    }\n\n","sourceOld":"    // Returns true if first is < second\n    @Override\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      ScoreDoc firstScoreDoc = shardHits[first.shardIndex][first.hitIndex];\n      ScoreDoc secondScoreDoc = shardHits[second.shardIndex][second.hitIndex];\n      if (firstScoreDoc.score < secondScoreDoc.score) {\n        return false;\n      } else if (firstScoreDoc.score > secondScoreDoc.score) {\n        return true;\n      } else {\n        return tieBreakLessThan(first, firstScoreDoc, second, secondScoreDoc);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f4f6b0fb6f08ac48f438f03002a283a63cb9992","date":1561992803,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","sourceNew":"    // Returns true if first is < second\n    @Override\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      ScoreDoc firstScoreDoc = shardHits[first.shardIndex][first.hitIndex];\n      ScoreDoc secondScoreDoc = shardHits[second.shardIndex][second.hitIndex];\n      if (firstScoreDoc.score < secondScoreDoc.score) {\n        return false;\n      } else if (firstScoreDoc.score > secondScoreDoc.score) {\n        return true;\n      } else {\n        return tieBreakLessThan(first, firstScoreDoc, second, secondScoreDoc);\n      }\n    }\n\n","sourceOld":"    // Returns true if first is < second\n    @Override\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      ScoreDoc firstScoreDoc = shardHits[first.shardIndex][first.hitIndex];\n      ScoreDoc secondScoreDoc = shardHits[second.shardIndex][second.hitIndex];\n      if (firstScoreDoc.score < secondScoreDoc.score) {\n        return false;\n      } else if (firstScoreDoc.score > secondScoreDoc.score) {\n        return true;\n      } else {\n        return tieBreakLessThan(first, firstScoreDoc, second, secondScoreDoc, tieBreakerComparator);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fccd4a691aac1aff06ab8110d8693514a34160c3","date":1562092518,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopDocs.ScoreMergeSortQueue#lessThan(ShardRef,ShardRef).mjava","sourceNew":"    // Returns true if first is < second\n    @Override\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      ScoreDoc firstScoreDoc = shardHits[first.shardIndex][first.hitIndex];\n      ScoreDoc secondScoreDoc = shardHits[second.shardIndex][second.hitIndex];\n      if (firstScoreDoc.score < secondScoreDoc.score) {\n        return false;\n      } else if (firstScoreDoc.score > secondScoreDoc.score) {\n        return true;\n      } else {\n        return tieBreakLessThan(first, firstScoreDoc, second, secondScoreDoc, tieBreakerComparator);\n      }\n    }\n\n","sourceOld":"    // Returns true if first is < second\n    @Override\n    public boolean lessThan(ShardRef first, ShardRef second) {\n      assert first != second;\n      ScoreDoc firstScoreDoc = shardHits[first.shardIndex][first.hitIndex];\n      ScoreDoc secondScoreDoc = shardHits[second.shardIndex][second.hitIndex];\n      if (firstScoreDoc.score < secondScoreDoc.score) {\n        return false;\n      } else if (firstScoreDoc.score > secondScoreDoc.score) {\n        return true;\n      } else {\n        return tieBreakLessThan(first, firstScoreDoc, second, secondScoreDoc);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","7530de27b87b961b51f01bd1299b7004d46e8823"],"36510a8e3c1ec60d366b45f8f716e9dc47589661":["500a89755c0c3953ca1886b5abb653b8cef8e299"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["5f4f6b0fb6f08ac48f438f03002a283a63cb9992"],"500a89755c0c3953ca1886b5abb653b8cef8e299":["7530de27b87b961b51f01bd1299b7004d46e8823"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7530de27b87b961b51f01bd1299b7004d46e8823":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"5f4f6b0fb6f08ac48f438f03002a283a63cb9992":["36510a8e3c1ec60d366b45f8f716e9dc47589661"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"36510a8e3c1ec60d366b45f8f716e9dc47589661":["5f4f6b0fb6f08ac48f438f03002a283a63cb9992"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"500a89755c0c3953ca1886b5abb653b8cef8e299":["36510a8e3c1ec60d366b45f8f716e9dc47589661"],"fccd4a691aac1aff06ab8110d8693514a34160c3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","500a89755c0c3953ca1886b5abb653b8cef8e299"],"5f4f6b0fb6f08ac48f438f03002a283a63cb9992":["fccd4a691aac1aff06ab8110d8693514a34160c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}