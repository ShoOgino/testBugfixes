{"path":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86365ce8db75e42ebe10805e99e92c463fef63b6","date":1330370408,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random, defaultCodecSupportsDocValues());\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random, defaultCodecSupportsDocValues());\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random, defaultCodecSupportsDocValues());\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random, defaultCodecSupportsDocValues());\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final BytesRefFSTEnum.InputOutput fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), defaultCodecSupportsDocValues());\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random, defaultCodecSupportsDocValues());\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random.nextBoolean());\n\n    final boolean doRewrite = random.nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random.nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString());\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57ae3024996ccdb3c36c42cb890e1efb37df4ce8","date":1338343651,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), defaultCodecSupportsDocValues());\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","date":1338430031,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = IndexReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2b0f649857e40b1429ab946a302da32f695eed9f","date":1339002543,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n      while((term = termsEnum.next()) != null) {\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"edb74c83fff94196b864e08ca033d92823252cb7","date":1339593164,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000));\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d19974432be9aed28ee7dca73bdf01d139e763a9","date":1342822166,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["459280d4c73660ea582f38afce7968563068fe49"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final MockDirectoryWrapper dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7bc05750bfdc6c5be37417e7e1a078c8a2da023","date":1343929264,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    // TODO: is this necessary? we use the annotation...\n    final String defaultFormat = _TestUtil.getPostingsFormat(\"abracadabra\");\n    if (defaultFormat.equals(\"SimpleText\") || defaultFormat.equals(\"Memory\")) {\n      // no\n      Codec.setDefault(_TestUtil.alwaysPostingsFormat(new Lucene40PostingsFormat()));\n    }\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49f4d9c4e29f2345e789073801e7945431a23ca3","date":1355344131,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        for(int rewriteIter=0;rewriteIter<2;rewriteIter++) {\n          if (rewriteIter == 1) {\n            if (doRewrite) {\n              // Verify again, with packed FST:\n              fst = fst.pack(_TestUtil.nextInt(random, 1, 10), _TestUtil.nextInt(random, 0, 10000000), random.nextFloat());\n            } else {\n              break;\n            }\n          }\n          // Now confirm BytesRefFSTEnum and TermsEnum act the\n          // same:\n          final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n          int num = atLeast(1000);\n          for(int iter=0;iter<num;iter++) {\n            final BytesRef randomTerm = new BytesRef(getRandomString(random));\n        \n            if (VERBOSE) {\n              System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n            }\n\n            final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n            final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n\n            if (seekResult == TermsEnum.SeekStatus.END) {\n              assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n            } else {\n              assertSame(termsEnum, fstEnum, storeOrd);\n              for(int nextIter=0;nextIter<10;nextIter++) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: next\");\n                  if (storeOrd) {\n                    System.out.println(\"  ord=\" + termsEnum.ord());\n                  }\n                }\n                if (termsEnum.next() != null) {\n                  if (VERBOSE) {\n                    System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                  }\n                  assertNotNull(fstEnum.next());\n                  assertSame(termsEnum, fstEnum, storeOrd);\n                } else {\n                  if (VERBOSE) {\n                    System.out.println(\"  end!\");\n                  }\n                  BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                  if (nextResult != null) {\n                    System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                    fail();\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb8af2aec0a8574cf50cad6939d4475179595eca","date":1357675799,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, true);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e6354dd7c71fe122926fc53d7d29f715b1283db","date":1357915185,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, true);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","date":1358188277,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, true);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, true);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39","date":1370266419,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton(random().nextBoolean());\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = _TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e1151ecb4798f5c31137aec032c241638018ed20","date":1394284367,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","date":1394564625,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0d579490a72f2e6297eaa648940611234c57cf1","date":1395917140,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = TestUtil.createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c","date":1396633078,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = TestUtil.createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a0f5bb79c600763ffe7b8141df59a3169d31e48","date":1396689440,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = TestUtil.getTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8405d98acebb7e287bf7ac40e937ba05b8661285","date":1401433291,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.sizeInBytes() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["d4769bdea5a853f1841c485bc1fd9d79cb7022fc"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac34f0c5bb9274821fb0cb18075234e02002e9bf","date":1402508126,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      LightAutomaton automaton = new RegExp(\".*\", RegExp.NONE).toLightAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      LightAutomaton automaton = new RegExp(\".*\", RegExp.NONE).toLightAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();    \n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f838187609fee3a1afa5f162f93c796046242c84","date":1406216791,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, null, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.shutdown();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRef scratchIntsRef = new IntsRef();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":["1ec890fad2ea96317f4429e0aa0085bb25673641"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final File tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator(null);\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b084aac8181b28fb44fa34869a3137484ddde90","date":1428901096,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a time limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int RUN_TIME_MSEC = atLeast(500);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && System.currentTimeMillis() < stopTime) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1abb939fb41b2fe4f89fd518f3da288c0213341d","date":1435657417,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fst.getNodeCount() + \" nodes; \" + fst.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a1862266772deb28cdcb7d996b64d2177022687","date":1453077824,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer, true);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"221076a44effb5561a3b799974ba1a35119fbcc0","date":1457468497,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random(), true);\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6244579a467d5f2673ac98265d74bddbea1a8114","date":1478786509,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    final boolean doRewrite = random().nextBoolean();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, doRewrite, PackedInts.DEFAULT, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04e775de416dd2d8067b10db1c8af975a1d5017e","date":1539906554,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiTerms.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiFields.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae67e1f82a53594208ca929f382ee861dad3d7a8","date":1557134375,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, true, 15, true);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiTerms.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiTerms.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59a1204a92958bea883656169000a87a6c55c2d0","date":1562106073,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiTerms.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, true, 15, true);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiTerms.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":3,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    FSTCompiler<Long> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiTerms.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        fstCompiler.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = fstCompiler.compile();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fstCompiler.getNodeCount() + \" nodes; \" + fstCompiler.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiTerms.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    FSTCompiler<Long> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiTerms.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        fstCompiler.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = fstCompiler.compile();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fstCompiler.getNodeCount() + \" nodes; \" + fstCompiler.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    Builder<Long> builder = new Builder<>(FST.INPUT_TYPE.BYTE1, 0, 0, true, true, Integer.MAX_VALUE, outputs, true, 15);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiTerms.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        builder.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = builder.finish();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + builder.getNodeCount() + \" nodes; \" + builder.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","date":1579652839,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs#testRealTerms().mjava","sourceNew":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  @Slow\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(50);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    FSTCompiler<Long> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiTerms.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        fstCompiler.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = fstCompiler.compile();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fstCompiler.getNodeCount() + \" nodes; \" + fstCompiler.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Build FST for all unique terms in the test line docs\n  // file, up until a doc limit\n  public void testRealTerms() throws Exception {\n\n    final LineFileDocs docs = new LineFileDocs(random());\n    final int numDocs = TEST_NIGHTLY ? atLeast(1000) : atLeast(100);\n    MockAnalyzer analyzer = new MockAnalyzer(random());\n    analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));\n\n    final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);\n    final Path tempDir = createTempDir(\"fstlines\");\n    final Directory dir = newFSDirectory(tempDir);\n    final IndexWriter writer = new IndexWriter(dir, conf);\n    Document doc;\n    int docCount = 0;\n    while((doc = docs.nextDoc()) != null && docCount < numDocs) {\n      writer.addDocument(doc);\n      docCount++;\n    }\n    IndexReader r = DirectoryReader.open(writer);\n    writer.close();\n    final PositiveIntOutputs outputs = PositiveIntOutputs.getSingleton();\n\n    FSTCompiler<Long> fstCompiler = new FSTCompiler<>(FST.INPUT_TYPE.BYTE1, outputs);\n\n    boolean storeOrd = random().nextBoolean();\n    if (VERBOSE) {\n      if (storeOrd) {\n        System.out.println(\"FST stores ord\");\n      } else {\n        System.out.println(\"FST stores docFreq\");\n      }\n    }\n    Terms terms = MultiTerms.getTerms(r, \"body\");\n    if (terms != null) {\n      final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();\n      final TermsEnum termsEnum = terms.iterator();\n      if (VERBOSE) {\n        System.out.println(\"TEST: got termsEnum=\" + termsEnum);\n      }\n      BytesRef term;\n      int ord = 0;\n\n      Automaton automaton = new RegExp(\".*\", RegExp.NONE).toAutomaton();\n      final TermsEnum termsEnum2 = terms.intersect(new CompiledAutomaton(automaton, false, false), null);\n\n      while((term = termsEnum.next()) != null) {\n        BytesRef term2 = termsEnum2.next();\n        assertNotNull(term2);\n        assertEquals(term, term2);\n        assertEquals(termsEnum.docFreq(), termsEnum2.docFreq());\n        assertEquals(termsEnum.totalTermFreq(), termsEnum2.totalTermFreq());\n\n        if (ord == 0) {\n          try {\n            termsEnum.ord();\n          } catch (UnsupportedOperationException uoe) {\n            if (VERBOSE) {\n              System.out.println(\"TEST: codec doesn't support ord; FST stores docFreq\");\n            }\n            storeOrd = false;\n          }\n        }\n        final int output;\n        if (storeOrd) {\n          output = ord;\n        } else {\n          output = termsEnum.docFreq();\n        }\n        fstCompiler.add(Util.toIntsRef(term, scratchIntsRef), (long) output);\n        ord++;\n        if (VERBOSE && ord % 100000 == 0 && LuceneTestCase.TEST_NIGHTLY) {\n          System.out.println(ord + \" terms...\");\n        }\n      }\n      FST<Long> fst = fstCompiler.compile();\n      if (VERBOSE) {\n        System.out.println(\"FST: \" + docCount + \" docs; \" + ord + \" terms; \" + fstCompiler.getNodeCount() + \" nodes; \" + fstCompiler.getArcCount() + \" arcs;\" + \" \" + fst.ramBytesUsed() + \" bytes\");\n      }\n\n      if (ord > 0) {\n        final Random random = new Random(random().nextLong());\n        // Now confirm BytesRefFSTEnum and TermsEnum act the\n        // same:\n        final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<>(fst);\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          final BytesRef randomTerm = new BytesRef(getRandomString(random));\n          \n          if (VERBOSE) {\n            System.out.println(\"TEST: seek non-exist \" + randomTerm.utf8ToString() + \" \" + randomTerm);\n          }\n          \n          final TermsEnum.SeekStatus seekResult = termsEnum.seekCeil(randomTerm);\n          final InputOutput<Long> fstSeekResult = fstEnum.seekCeil(randomTerm);\n          \n          if (seekResult == TermsEnum.SeekStatus.END) {\n            assertNull(\"got \" + (fstSeekResult == null ? \"null\" : fstSeekResult.input.utf8ToString()) + \" but expected null\", fstSeekResult);\n          } else {\n            assertSame(termsEnum, fstEnum, storeOrd);\n            for(int nextIter=0;nextIter<10;nextIter++) {\n              if (VERBOSE) {\n                System.out.println(\"TEST: next\");\n                if (storeOrd) {\n                  System.out.println(\"  ord=\" + termsEnum.ord());\n                }\n              }\n              if (termsEnum.next() != null) {\n                if (VERBOSE) {\n                  System.out.println(\"  term=\" + termsEnum.term().utf8ToString());\n                }\n                assertNotNull(fstEnum.next());\n                assertSame(termsEnum, fstEnum, storeOrd);\n              } else {\n                if (VERBOSE) {\n                  System.out.println(\"  end!\");\n                }\n                BytesRefFSTEnum.InputOutput<Long> nextResult = fstEnum.next();\n                if (nextResult != null) {\n                  System.out.println(\"expected null but got: input=\" + nextResult.input.utf8ToString() + \" output=\" + outputs.outputToString(nextResult.output));\n                  fail();\n                }\n                break;\n              }\n            }\n          }\n        }\n        \n      }\n    }\n\n    r.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["6b084aac8181b28fb44fa34869a3137484ddde90"],"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["f4abec28b874149a7223e32cc7a01704c27790de"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["4e6354dd7c71fe122926fc53d7d29f715b1283db","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["221076a44effb5561a3b799974ba1a35119fbcc0","6244579a467d5f2673ac98265d74bddbea1a8114"],"221076a44effb5561a3b799974ba1a35119fbcc0":["2a1862266772deb28cdcb7d996b64d2177022687"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"b7bc05750bfdc6c5be37417e7e1a078c8a2da023":["d19974432be9aed28ee7dca73bdf01d139e763a9"],"aba371508186796cc6151d8223a5b4e16d02e26e":["edb74c83fff94196b864e08ca033d92823252cb7","d19974432be9aed28ee7dca73bdf01d139e763a9"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"edb74c83fff94196b864e08ca033d92823252cb7":["2b0f649857e40b1429ab946a302da32f695eed9f"],"5c84485629d80d203608e8975a1139de9933cc38":["8405d98acebb7e287bf7ac40e937ba05b8661285","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"6b084aac8181b28fb44fa34869a3137484ddde90":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"86365ce8db75e42ebe10805e99e92c463fef63b6":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"f4abec28b874149a7223e32cc7a01704c27790de":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"d19974432be9aed28ee7dca73bdf01d139e763a9":["edb74c83fff94196b864e08ca033d92823252cb7"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["d0d579490a72f2e6297eaa648940611234c57cf1"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","b7bc05750bfdc6c5be37417e7e1a078c8a2da023"],"04e775de416dd2d8067b10db1c8af975a1d5017e":["6244579a467d5f2673ac98265d74bddbea1a8114"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["59a1204a92958bea883656169000a87a6c55c2d0"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["b7bc05750bfdc6c5be37417e7e1a078c8a2da023","49f4d9c4e29f2345e789073801e7945431a23ca3"],"8405d98acebb7e287bf7ac40e937ba05b8661285":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4":["6613659748fe4411a7dcf85266e55db1f95f7315","e1151ecb4798f5c31137aec032c241638018ed20"],"fb8af2aec0a8574cf50cad6939d4475179595eca":["49f4d9c4e29f2345e789073801e7945431a23ca3"],"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"e1151ecb4798f5c31137aec032c241638018ed20":["6613659748fe4411a7dcf85266e55db1f95f7315"],"2a1862266772deb28cdcb7d996b64d2177022687":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["edb74c83fff94196b864e08ca033d92823252cb7","d19974432be9aed28ee7dca73bdf01d139e763a9"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["59a1204a92958bea883656169000a87a6c55c2d0","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","fb8af2aec0a8574cf50cad6939d4475179595eca"],"49f4d9c4e29f2345e789073801e7945431a23ca3":["b7bc05750bfdc6c5be37417e7e1a078c8a2da023"],"2b0f649857e40b1429ab946a302da32f695eed9f":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["e1151ecb4798f5c31137aec032c241638018ed20"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["f838187609fee3a1afa5f162f93c796046242c84"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["fb8af2aec0a8574cf50cad6939d4475179595eca"],"6613659748fe4411a7dcf85266e55db1f95f7315":["6b1e6a1c51433ebaa34dc0b76d7ab1876072be39"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["86365ce8db75e42ebe10805e99e92c463fef63b6"],"6244579a467d5f2673ac98265d74bddbea1a8114":["221076a44effb5561a3b799974ba1a35119fbcc0"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["04e775de416dd2d8067b10db1c8af975a1d5017e"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","b7bc05750bfdc6c5be37417e7e1a078c8a2da023"],"d0d579490a72f2e6297eaa648940611234c57cf1":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"f838187609fee3a1afa5f162f93c796046242c84":["5c84485629d80d203608e8975a1139de9933cc38"],"59a1204a92958bea883656169000a87a6c55c2d0":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["8405d98acebb7e287bf7ac40e937ba05b8661285"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"]},"commit2Childs":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["2a1862266772deb28cdcb7d996b64d2177022687"],"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["6b084aac8181b28fb44fa34869a3137484ddde90"],"2a0f5bb79c600763ffe7b8141df59a3169d31e48":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","86365ce8db75e42ebe10805e99e92c463fef63b6"],"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"221076a44effb5561a3b799974ba1a35119fbcc0":["199dfa410f1fdbfd3294106b04096cce5ed34b21","6244579a467d5f2673ac98265d74bddbea1a8114"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["f4abec28b874149a7223e32cc7a01704c27790de"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"b7bc05750bfdc6c5be37417e7e1a078c8a2da023":["d6f074e73200c07d54f242d3880a8da5a35ff97b","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","49f4d9c4e29f2345e789073801e7945431a23ca3","8fd5be977c105554c6a7b68afcdbc511439723ab"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["2b0f649857e40b1429ab946a302da32f695eed9f"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"edb74c83fff94196b864e08ca033d92823252cb7":["aba371508186796cc6151d8223a5b4e16d02e26e","d19974432be9aed28ee7dca73bdf01d139e763a9","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["8405d98acebb7e287bf7ac40e937ba05b8661285"],"5c84485629d80d203608e8975a1139de9933cc38":["f838187609fee3a1afa5f162f93c796046242c84"],"6b084aac8181b28fb44fa34869a3137484ddde90":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"86365ce8db75e42ebe10805e99e92c463fef63b6":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f4abec28b874149a7223e32cc7a01704c27790de":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"d19974432be9aed28ee7dca73bdf01d139e763a9":["b7bc05750bfdc6c5be37417e7e1a078c8a2da023","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c":["2a0f5bb79c600763ffe7b8141df59a3169d31e48"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"04e775de416dd2d8067b10db1c8af975a1d5017e":["ae67e1f82a53594208ca929f382ee861dad3d7a8"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["4e6354dd7c71fe122926fc53d7d29f715b1283db"],"8405d98acebb7e287bf7ac40e937ba05b8661285":["5c84485629d80d203608e8975a1139de9933cc38","ac34f0c5bb9274821fb0cb18075234e02002e9bf"],"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4":[],"fb8af2aec0a8574cf50cad6939d4475179595eca":["4e6354dd7c71fe122926fc53d7d29f715b1283db","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"6b1e6a1c51433ebaa34dc0b76d7ab1876072be39":["6613659748fe4411a7dcf85266e55db1f95f7315"],"e1151ecb4798f5c31137aec032c241638018ed20":["a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"2a1862266772deb28cdcb7d996b64d2177022687":["221076a44effb5561a3b799974ba1a35119fbcc0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"4e6354dd7c71fe122926fc53d7d29f715b1283db":["8917bfede3b4ca30f4305c1e391e9218959cd723"],"49f4d9c4e29f2345e789073801e7945431a23ca3":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","fb8af2aec0a8574cf50cad6939d4475179595eca"],"2b0f649857e40b1429ab946a302da32f695eed9f":["edb74c83fff94196b864e08ca033d92823252cb7"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["2a0f5bb79c600763ffe7b8141df59a3169d31e48","d0d579490a72f2e6297eaa648940611234c57cf1"],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["8917bfede3b4ca30f4305c1e391e9218959cd723","6b1e6a1c51433ebaa34dc0b76d7ab1876072be39"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"6613659748fe4411a7dcf85266e55db1f95f7315":["a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","e1151ecb4798f5c31137aec032c241638018ed20"],"6244579a467d5f2673ac98265d74bddbea1a8114":["199dfa410f1fdbfd3294106b04096cce5ed34b21","04e775de416dd2d8067b10db1c8af975a1d5017e"],"ae67e1f82a53594208ca929f382ee861dad3d7a8":["59a1204a92958bea883656169000a87a6c55c2d0"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"d0d579490a72f2e6297eaa648940611234c57cf1":["a9a24bae1e63c3bb5ff2fb47b0119240d840ee7c"],"f838187609fee3a1afa5f162f93c796046242c84":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"59a1204a92958bea883656169000a87a6c55c2d0":["0f5661e6a04d3172e262ad741b717924f2f1b6a5","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"ac34f0c5bb9274821fb0cb18075234e02002e9bf":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","8917bfede3b4ca30f4305c1e391e9218959cd723","199dfa410f1fdbfd3294106b04096cce5ed34b21","d6f074e73200c07d54f242d3880a8da5a35ff97b","a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","8fd5be977c105554c6a7b68afcdbc511439723ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}