{"path":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(DocumentsWriterThreadState).mjava","commits":[{"id":"5a0af3a442be522899177e5e11384a45a6784a3f","date":1205348952,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(DocumentsWriterThreadState).mjava","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(ThreadState).mjava","sourceNew":"  /** Does the synchronized work to finish/flush the\n   * inverted document. */\n  private synchronized void finishDocument(DocumentsWriterThreadState state) throws IOException, AbortException {\n    if (abortCount > 0) {\n      // Forcefully idle this threadstate -- its state will\n      // be reset by abort()\n      state.isIdle = true;\n      notifyAll();\n      return;\n    }\n\n    if (ramBufferSize != IndexWriter.DISABLE_AUTO_FLUSH\n        && numBytesUsed >= ramBufferSize)\n      balanceRAM();\n\n    // Now write the indexed document to the real files.\n    if (nextWriteDocID == state.docID) {\n      // It's my turn, so write everything now:\n      nextWriteDocID++;\n      state.writeDocument();\n      state.isIdle = true;\n      notifyAll();\n\n      // If any states were waiting on me, sweep through and\n      // flush those that are enabled by my write.\n      if (numWaiting > 0) {\n        boolean any = true;\n        while(any) {\n          any = false;\n          for(int i=0;i<numWaiting;) {\n            final DocumentsWriterThreadState s = waitingThreadStates[i];\n            if (s.docID == nextWriteDocID) {\n              s.writeDocument();\n              s.isIdle = true;\n              nextWriteDocID++;\n              any = true;\n              if (numWaiting > i+1)\n                // Swap in the last waiting state to fill in\n                // the hole we just created.  It's important\n                // to do this as-we-go and not at the end of\n                // the loop, because if we hit an aborting\n                // exception in one of the s.writeDocument\n                // calls (above), it leaves this array in an\n                // inconsistent state:\n                waitingThreadStates[i] = waitingThreadStates[numWaiting-1];\n              numWaiting--;\n            } else {\n              assert !s.isIdle;\n              i++;\n            }\n          }\n        }\n      }\n    } else {\n      // Another thread got a docID before me, but, it\n      // hasn't finished its processing.  So add myself to\n      // the line but don't hold up this thread.\n      waitingThreadStates[numWaiting++] = state;\n    }\n  }\n\n","sourceOld":"  /** Does the synchronized work to finish/flush the\n   * inverted document. */\n  private synchronized void finishDocument(ThreadState state) throws IOException, AbortException {\n    if (abortCount > 0) {\n      // Forcefully idle this threadstate -- its state will\n      // be reset by abort()\n      state.isIdle = true;\n      notifyAll();\n      return;\n    }\n\n    if (ramBufferSize != IndexWriter.DISABLE_AUTO_FLUSH\n        && numBytesUsed >= ramBufferSize)\n      balanceRAM();\n\n    // Now write the indexed document to the real files.\n    if (nextWriteDocID == state.docID) {\n      // It's my turn, so write everything now:\n      nextWriteDocID++;\n      state.writeDocument();\n      state.isIdle = true;\n      notifyAll();\n\n      // If any states were waiting on me, sweep through and\n      // flush those that are enabled by my write.\n      if (numWaiting > 0) {\n        boolean any = true;\n        while(any) {\n          any = false;\n          for(int i=0;i<numWaiting;) {\n            final ThreadState s = waitingThreadStates[i];\n            if (s.docID == nextWriteDocID) {\n              s.writeDocument();\n              s.isIdle = true;\n              nextWriteDocID++;\n              any = true;\n              if (numWaiting > i+1)\n                // Swap in the last waiting state to fill in\n                // the hole we just created.  It's important\n                // to do this as-we-go and not at the end of\n                // the loop, because if we hit an aborting\n                // exception in one of the s.writeDocument\n                // calls (above), it leaves this array in an\n                // inconsistent state:\n                waitingThreadStates[i] = waitingThreadStates[numWaiting-1];\n              numWaiting--;\n            } else {\n              assert !s.isIdle;\n              i++;\n            }\n          }\n        }\n      }\n    } else {\n      // Another thread got a docID before me, but, it\n      // hasn't finished its processing.  So add myself to\n      // the line but don't hold up this thread.\n      waitingThreadStates[numWaiting++] = state;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5350389bf83287111f7760b9e3db3af8e3648474","date":1216372812,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/DocumentsWriter#finishDocument(DocumentsWriterThreadState).mjava","sourceNew":null,"sourceOld":"  /** Does the synchronized work to finish/flush the\n   * inverted document. */\n  private synchronized void finishDocument(DocumentsWriterThreadState state) throws IOException, AbortException {\n    if (abortCount > 0) {\n      // Forcefully idle this threadstate -- its state will\n      // be reset by abort()\n      state.isIdle = true;\n      notifyAll();\n      return;\n    }\n\n    if (ramBufferSize != IndexWriter.DISABLE_AUTO_FLUSH\n        && numBytesUsed >= ramBufferSize)\n      balanceRAM();\n\n    // Now write the indexed document to the real files.\n    if (nextWriteDocID == state.docID) {\n      // It's my turn, so write everything now:\n      nextWriteDocID++;\n      state.writeDocument();\n      state.isIdle = true;\n      notifyAll();\n\n      // If any states were waiting on me, sweep through and\n      // flush those that are enabled by my write.\n      if (numWaiting > 0) {\n        boolean any = true;\n        while(any) {\n          any = false;\n          for(int i=0;i<numWaiting;) {\n            final DocumentsWriterThreadState s = waitingThreadStates[i];\n            if (s.docID == nextWriteDocID) {\n              s.writeDocument();\n              s.isIdle = true;\n              nextWriteDocID++;\n              any = true;\n              if (numWaiting > i+1)\n                // Swap in the last waiting state to fill in\n                // the hole we just created.  It's important\n                // to do this as-we-go and not at the end of\n                // the loop, because if we hit an aborting\n                // exception in one of the s.writeDocument\n                // calls (above), it leaves this array in an\n                // inconsistent state:\n                waitingThreadStates[i] = waitingThreadStates[numWaiting-1];\n              numWaiting--;\n            } else {\n              assert !s.isIdle;\n              i++;\n            }\n          }\n        }\n      }\n    } else {\n      // Another thread got a docID before me, but, it\n      // hasn't finished its processing.  So add myself to\n      // the line but don't hold up this thread.\n      waitingThreadStates[numWaiting++] = state;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5a0af3a442be522899177e5e11384a45a6784a3f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5350389bf83287111f7760b9e3db3af8e3648474":["5a0af3a442be522899177e5e11384a45a6784a3f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5350389bf83287111f7760b9e3db3af8e3648474"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5a0af3a442be522899177e5e11384a45a6784a3f"],"5a0af3a442be522899177e5e11384a45a6784a3f":["5350389bf83287111f7760b9e3db3af8e3648474"],"5350389bf83287111f7760b9e3db3af8e3648474":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}