{"path":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","commits":[{"id":"3fd3cdfbce4b551bb8ca4678682a5a891d0890ca","date":1436588269,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","pathOld":"/dev/null","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instnace, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, new Comparator<ReplicaCount>() {\n      @Override\n      public int compare(ReplicaCount x, ReplicaCount y) {\n        return (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1);\n      }\n    });\n    return sortedNodeList;\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instnace, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instnace, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, new Comparator<ReplicaCount>() {\n      @Override\n      public int compare(ReplicaCount x, ReplicaCount y) {\n        return (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1);\n      }\n    });\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz KrasiÅ„ski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instnace, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instnace, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instnace, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fcf710a8fcd590cf55c855d422c7a10fce3e6117","date":1485842253,"type":5,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,Object,CoreContainer).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/Assign#getNodesForNewReplicas(ClusterState,String,String,int,String,CoreContainer).mjava","sourceNew":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          Object createNodeSet, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = null;\n\n    if (createNodeSet instanceof List) {\n      createNodeList = (List) createNodeSet;\n    } else {\n      createNodeList = createNodeSet == null ? null : StrUtils.splitSmart((String) createNodeSet, \",\", true);\n    }\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","sourceOld":"  // Only called from createShard and addReplica (so far).\n  //\n  // Gets a list of candidate nodes to put the required replica(s) on. Throws errors if not enough replicas\n  // could be created on live nodes given maxShardsPerNode, Replication factor (if from createShard) etc.\n  public static List<ReplicaCount> getNodesForNewReplicas(ClusterState clusterState, String collectionName,\n                                                          String shard, int numberOfNodes,\n                                                          String createNodeSetStr, CoreContainer cc) {\n    DocCollection coll = clusterState.getCollection(collectionName);\n    Integer maxShardsPerNode = coll.getInt(MAX_SHARDS_PER_NODE, 1);\n    List<String> createNodeList = createNodeSetStr  == null ? null: StrUtils.splitSmart(createNodeSetStr, \",\", true);\n\n     HashMap<String, ReplicaCount> nodeNameVsShardCount = getNodeNameVsShardCount(collectionName, clusterState, createNodeList);\n\n    if (createNodeList == null) { // We only care if we haven't been told to put new replicas on specific nodes.\n      int availableSlots = 0;\n      for (Map.Entry<String, ReplicaCount> ent : nodeNameVsShardCount.entrySet()) {\n        //ADDREPLICA can put more than maxShardsPerNode on an instance, so this test is necessary.\n        if (maxShardsPerNode > ent.getValue().thisCollectionNodes) {\n          availableSlots += (maxShardsPerNode - ent.getValue().thisCollectionNodes);\n        }\n      }\n      if (availableSlots < numberOfNodes) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n            String.format(Locale.ROOT, \"Cannot create %d new replicas for collection %s given the current number of live nodes and a maxShardsPerNode of %d\",\n                numberOfNodes, collectionName, maxShardsPerNode));\n      }\n    }\n\n    List l = (List) coll.get(DocCollection.RULE);\n    if (l != null) {\n      return getNodesViaRules(clusterState, shard, numberOfNodes, cc, coll, createNodeList, l);\n    }\n\n    ArrayList<ReplicaCount> sortedNodeList = new ArrayList<>(nodeNameVsShardCount.values());\n    Collections.sort(sortedNodeList, (x, y) -> (x.weight() < y.weight()) ? -1 : ((x.weight() == y.weight()) ? 0 : 1));\n    return sortedNodeList;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"3fd3cdfbce4b551bb8ca4678682a5a891d0890ca":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a0c04b71951333291abc7f317109a6a5957bd28":["3fd3cdfbce4b551bb8ca4678682a5a891d0890ca"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3a0c04b71951333291abc7f317109a6a5957bd28","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["3a0c04b71951333291abc7f317109a6a5957bd28","0158ced21948b6626f733c1c42c1e18d94449789"],"0158ced21948b6626f733c1c42c1e18d94449789":["3a0c04b71951333291abc7f317109a6a5957bd28"]},"commit2Childs":{"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3fd3cdfbce4b551bb8ca4678682a5a891d0890ca"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"3fd3cdfbce4b551bb8ca4678682a5a891d0890ca":["3a0c04b71951333291abc7f317109a6a5957bd28"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"3a0c04b71951333291abc7f317109a6a5957bd28":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["fcf710a8fcd590cf55c855d422c7a10fce3e6117","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}