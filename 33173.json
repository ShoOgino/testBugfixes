{"path":"solr/core/src/java/org/apache/solr/cluster/placement/impl/ReplicaPlacementImpl#toReplicaPositions(Set[ReplicaPlacement]).mjava","commits":[{"id":"f5d9700b23e8e9b11b845fcecef89dbdf21373d9","date":1600294231,"type":0,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cluster/placement/impl/ReplicaPlacementImpl#toReplicaPositions(Set[ReplicaPlacement]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Translates a set of {@link ReplicaPlacement} returned by a plugin into a list of {@link ReplicaPosition} expected\n   * by {@link org.apache.solr.cloud.api.collections.Assign.AssignStrategy}\n   */\n  static List<ReplicaPosition> toReplicaPositions(Set<ReplicaPlacement> replicaPlacementSet) {\n    // The replica index in ReplicaPosition is not as strict a concept as it might seem. It is used in rules\n    // based placement (for sorting replicas) but its presence in ReplicaPosition is not justified (and when the code\n    // is executing here, it means rules based placement is not used).\n    // Looking at ReplicaAssigner.tryAllPermutations, it is well possible to create replicas with same index\n    // living on a given node for the same shard. This likely never happens because of the way replicas are\n    // placed on nodes (never two on the same node for same shard). Adopting the same shortcut/bad design here,\n    // but index should be removed at some point from ReplicaPosition.\n    List<ReplicaPosition> replicaPositions = new ArrayList<>(replicaPlacementSet.size());\n    int index = 0; // This really an arbitrary value when adding replicas and a possible source of core name collisions\n    for (ReplicaPlacement placement : replicaPlacementSet) {\n      replicaPositions.add(new ReplicaPosition(placement.getShardName(), index++, SimpleClusterAbstractionsImpl.ReplicaImpl.toCloudReplicaType(placement.getReplicaType()), placement.getNode().getName()));\n    }\n\n    return replicaPositions;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65352f844eb9e9a677ec4eb2abced4404f08181d","date":1600297608,"type":0,"author":"noblepaul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cluster/placement/impl/ReplicaPlacementImpl#toReplicaPositions(Set[ReplicaPlacement]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Translates a set of {@link ReplicaPlacement} returned by a plugin into a list of {@link ReplicaPosition} expected\n   * by {@link org.apache.solr.cloud.api.collections.Assign.AssignStrategy}\n   */\n  static List<ReplicaPosition> toReplicaPositions(Set<ReplicaPlacement> replicaPlacementSet) {\n    // The replica index in ReplicaPosition is not as strict a concept as it might seem. It is used in rules\n    // based placement (for sorting replicas) but its presence in ReplicaPosition is not justified (and when the code\n    // is executing here, it means rules based placement is not used).\n    // Looking at ReplicaAssigner.tryAllPermutations, it is well possible to create replicas with same index\n    // living on a given node for the same shard. This likely never happens because of the way replicas are\n    // placed on nodes (never two on the same node for same shard). Adopting the same shortcut/bad design here,\n    // but index should be removed at some point from ReplicaPosition.\n    List<ReplicaPosition> replicaPositions = new ArrayList<>(replicaPlacementSet.size());\n    int index = 0; // This really an arbitrary value when adding replicas and a possible source of core name collisions\n    for (ReplicaPlacement placement : replicaPlacementSet) {\n      replicaPositions.add(new ReplicaPosition(placement.getShardName(), index++, SimpleClusterAbstractionsImpl.ReplicaImpl.toCloudReplicaType(placement.getReplicaType()), placement.getNode().getName()));\n    }\n\n    return replicaPositions;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"65352f844eb9e9a677ec4eb2abced4404f08181d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f5d9700b23e8e9b11b845fcecef89dbdf21373d9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65352f844eb9e9a677ec4eb2abced4404f08181d"]},"commit2Childs":{"f5d9700b23e8e9b11b845fcecef89dbdf21373d9":["65352f844eb9e9a677ec4eb2abced4404f08181d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f5d9700b23e8e9b11b845fcecef89dbdf21373d9","65352f844eb9e9a677ec4eb2abced4404f08181d"],"65352f844eb9e9a677ec4eb2abced4404f08181d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}