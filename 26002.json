{"path":"solr/core/src/test/org/apache/solr/handler/component/PhrasesIdentificationComponentTest#testWhiteboxScorcesStopwords().mjava","commits":[{"id":"0d1411e62d30c460b09c6f3643df82daa10a27cc","date":1536256256,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/PhrasesIdentificationComponentTest#testWhiteboxScorcesStopwords().mjava","pathOld":"/dev/null","sourceNew":"  public void testWhiteboxScorcesStopwords() throws Exception {\n    final String input = \"why the lazy dog brown fox\";\n    final Map<String,Double> fieldWeights = new TreeMap<>();\n    fieldWeights.put(\"multigrams_title\", 1.0D); \n    fieldWeights.put(\"multigrams_title_stop\", 1.0D);\n    \n    { // If our analysisField uses all terms,\n      // be we also generate scores from a field that filters stopwords...\n      final SchemaField analysisField = h.getCore().getLatestSchema().getField(\"multigrams_title\");\n      assertNotNull(analysisField);\n      \n      final List<Phrase> phrases = Phrase.extractPhrases(input, analysisField, 3, 7);\n      try (SolrQueryRequest req = req()) {\n        Phrase.populateStats(phrases, fieldWeights.keySet(), req.getSearcher());\n      }\n      Phrase.populateScores(phrases, fieldWeights, 3, 7);\n\n      // phrases that span the stop word should have valid scores from the field that doesn't care\n      // about stop words, but the stopword field should reject them\n      final Phrase why_the_lazy = phrases.get(2);\n      assertEquals(\"why the lazy\", why_the_lazy.getSubSequence());\n      assertThat(why_the_lazy.toString(), why_the_lazy.getFieldScore(\"multigrams_title\"), greaterThan(0.0D) );\n      assertEquals(why_the_lazy.toString(), -1.0D, why_the_lazy.getFieldScore(\"multigrams_title_stop\"), 0.0D);\n      \n      final Phrase the_lazy_dog = phrases.get(8);\n      assertEquals(\"the lazy dog\", the_lazy_dog.getSubSequence());\n      assertThat(the_lazy_dog.toString(), the_lazy_dog.getFieldScore(\"multigrams_title\"), greaterThan(0.0D) );\n      assertEquals(the_lazy_dog.toString(), -1.0D, the_lazy_dog.getFieldScore(\"multigrams_title_stop\"), 0.0D);\n      \n      // sanity check that good scores are still possible with stopwords\n      // \"brown fox\" should score positively in both fields, and overall...\n      final Phrase brown_fox = phrases.get(phrases.size()-2);\n      assertEquals(\"brown fox\", brown_fox.getSubSequence());\n      assertThat(brown_fox.toString(), brown_fox.getFieldScore(\"multigrams_title\"), greaterThan(0.0D));\n      assertThat(brown_fox.toString(), brown_fox.getFieldScore(\"multigrams_title_stop\"), greaterThan(0.0D) );\n      assertThat(brown_fox.toString(), brown_fox.getTotalScore(), greaterThan(0.0D));\n    }\n    \n    { // now flip things: our analysisField filters stopwords, \n      // but we also generates scores from a field that doesn't know about them...\n      //\n      // (NOTE: the parser will still generate _some_ candidate phrases spaning the stop word position,\n      // but not ones that start with the stopword)\n      final SchemaField analysisField = h.getCore().getLatestSchema().getField(\"multigrams_title_stop\");\n      assertNotNull(analysisField);\n      \n      final List<Phrase> phrases = Phrase.extractPhrases(input, analysisField, 3, 7);\n      try (SolrQueryRequest req = req()) {\n        Phrase.populateStats(phrases, fieldWeights.keySet(), req.getSearcher());\n      }\n      Phrase.populateScores(phrases, fieldWeights, 3, 7);\n      assertTrue(phrases.toString(), 0 < phrases.size());\n\n      for (Phrase p : phrases) {\n        if (p.getPositionStart() <= 2 && 2 < p.getPositionEnd()) {\n          // phrases that span the stop word should have valid scores from the field that doesn't care\n          // about stop words, but the stopword field should reject them\n          assertEquals(p.toString(), -1.0D, p.getFieldScore(\"multigrams_title\"), 0.0D);\n          assertEquals(p.toString(), -1.0D, p.getFieldScore(\"multigrams_title_stop\"), 0.0D);\n        }\n      }\n      \n      // sanity check that good scores are still possible with stopwords\n      // \"brown fox\" should score positively in both fields, and overall...\n      final Phrase brown_fox = phrases.get(phrases.size()-2);\n      assertEquals(\"brown fox\", brown_fox.getSubSequence());\n      assertThat(brown_fox.toString(), brown_fox.getFieldScore(\"multigrams_title\"), greaterThan(0.0D));\n      assertThat(brown_fox.toString(), brown_fox.getFieldScore(\"multigrams_title_stop\"), greaterThan(0.0D) );\n      assertThat(brown_fox.toString(), brown_fox.getTotalScore(), greaterThan(0.0D));\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/component/PhrasesIdentificationComponentTest#testWhiteboxScorcesStopwords().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/component/PhrasesIdentificationComponentTest#testWhiteboxScorcesStopwords().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public void testWhiteboxScorcesStopwords() throws Exception {\n    final String input = \"why the lazy dog brown fox\";\n    final Map<String,Double> fieldWeights = new TreeMap<>();\n    fieldWeights.put(\"multigrams_title\", 1.0D); \n    fieldWeights.put(\"multigrams_title_stop\", 1.0D);\n    \n    { // If our analysisField uses all terms,\n      // be we also generate scores from a field that filters stopwords...\n      final SchemaField analysisField = h.getCore().getLatestSchema().getField(\"multigrams_title\");\n      assertNotNull(analysisField);\n      \n      final List<Phrase> phrases = Phrase.extractPhrases(input, analysisField, 3, 7);\n      try (SolrQueryRequest req = req()) {\n        Phrase.populateStats(phrases, fieldWeights.keySet(), req.getSearcher());\n      }\n      Phrase.populateScores(phrases, fieldWeights, 3, 7);\n\n      // phrases that span the stop word should have valid scores from the field that doesn't care\n      // about stop words, but the stopword field should reject them\n      final Phrase why_the_lazy = phrases.get(2);\n      assertEquals(\"why the lazy\", why_the_lazy.getSubSequence());\n      assertThat(why_the_lazy.toString(), why_the_lazy.getFieldScore(\"multigrams_title\"), greaterThan(0.0D) );\n      assertEquals(why_the_lazy.toString(), -1.0D, why_the_lazy.getFieldScore(\"multigrams_title_stop\"), 0.0D);\n      \n      final Phrase the_lazy_dog = phrases.get(8);\n      assertEquals(\"the lazy dog\", the_lazy_dog.getSubSequence());\n      assertThat(the_lazy_dog.toString(), the_lazy_dog.getFieldScore(\"multigrams_title\"), greaterThan(0.0D) );\n      assertEquals(the_lazy_dog.toString(), -1.0D, the_lazy_dog.getFieldScore(\"multigrams_title_stop\"), 0.0D);\n      \n      // sanity check that good scores are still possible with stopwords\n      // \"brown fox\" should score positively in both fields, and overall...\n      final Phrase brown_fox = phrases.get(phrases.size()-2);\n      assertEquals(\"brown fox\", brown_fox.getSubSequence());\n      assertThat(brown_fox.toString(), brown_fox.getFieldScore(\"multigrams_title\"), greaterThan(0.0D));\n      assertThat(brown_fox.toString(), brown_fox.getFieldScore(\"multigrams_title_stop\"), greaterThan(0.0D) );\n      assertThat(brown_fox.toString(), brown_fox.getTotalScore(), greaterThan(0.0D));\n    }\n    \n    { // now flip things: our analysisField filters stopwords, \n      // but we also generates scores from a field that doesn't know about them...\n      //\n      // (NOTE: the parser will still generate _some_ candidate phrases spaning the stop word position,\n      // but not ones that start with the stopword)\n      final SchemaField analysisField = h.getCore().getLatestSchema().getField(\"multigrams_title_stop\");\n      assertNotNull(analysisField);\n      \n      final List<Phrase> phrases = Phrase.extractPhrases(input, analysisField, 3, 7);\n      try (SolrQueryRequest req = req()) {\n        Phrase.populateStats(phrases, fieldWeights.keySet(), req.getSearcher());\n      }\n      Phrase.populateScores(phrases, fieldWeights, 3, 7);\n      assertTrue(phrases.toString(), 0 < phrases.size());\n\n      for (Phrase p : phrases) {\n        if (p.getPositionStart() <= 2 && 2 < p.getPositionEnd()) {\n          // phrases that span the stop word should have valid scores from the field that doesn't care\n          // about stop words, but the stopword field should reject them\n          assertEquals(p.toString(), -1.0D, p.getFieldScore(\"multigrams_title\"), 0.0D);\n          assertEquals(p.toString(), -1.0D, p.getFieldScore(\"multigrams_title_stop\"), 0.0D);\n        }\n      }\n      \n      // sanity check that good scores are still possible with stopwords\n      // \"brown fox\" should score positively in both fields, and overall...\n      final Phrase brown_fox = phrases.get(phrases.size()-2);\n      assertEquals(\"brown fox\", brown_fox.getSubSequence());\n      assertThat(brown_fox.toString(), brown_fox.getFieldScore(\"multigrams_title\"), greaterThan(0.0D));\n      assertThat(brown_fox.toString(), brown_fox.getFieldScore(\"multigrams_title_stop\"), greaterThan(0.0D) );\n      assertThat(brown_fox.toString(), brown_fox.getTotalScore(), greaterThan(0.0D));\n    }\n    \n  }\n\n","sourceOld":"  public void testWhiteboxScorcesStopwords() throws Exception {\n    final String input = \"why the lazy dog brown fox\";\n    final Map<String,Double> fieldWeights = new TreeMap<>();\n    fieldWeights.put(\"multigrams_title\", 1.0D); \n    fieldWeights.put(\"multigrams_title_stop\", 1.0D);\n    \n    { // If our analysisField uses all terms,\n      // be we also generate scores from a field that filters stopwords...\n      final SchemaField analysisField = h.getCore().getLatestSchema().getField(\"multigrams_title\");\n      assertNotNull(analysisField);\n      \n      final List<Phrase> phrases = Phrase.extractPhrases(input, analysisField, 3, 7);\n      try (SolrQueryRequest req = req()) {\n        Phrase.populateStats(phrases, fieldWeights.keySet(), req.getSearcher());\n      }\n      Phrase.populateScores(phrases, fieldWeights, 3, 7);\n\n      // phrases that span the stop word should have valid scores from the field that doesn't care\n      // about stop words, but the stopword field should reject them\n      final Phrase why_the_lazy = phrases.get(2);\n      assertEquals(\"why the lazy\", why_the_lazy.getSubSequence());\n      assertThat(why_the_lazy.toString(), why_the_lazy.getFieldScore(\"multigrams_title\"), greaterThan(0.0D) );\n      assertEquals(why_the_lazy.toString(), -1.0D, why_the_lazy.getFieldScore(\"multigrams_title_stop\"), 0.0D);\n      \n      final Phrase the_lazy_dog = phrases.get(8);\n      assertEquals(\"the lazy dog\", the_lazy_dog.getSubSequence());\n      assertThat(the_lazy_dog.toString(), the_lazy_dog.getFieldScore(\"multigrams_title\"), greaterThan(0.0D) );\n      assertEquals(the_lazy_dog.toString(), -1.0D, the_lazy_dog.getFieldScore(\"multigrams_title_stop\"), 0.0D);\n      \n      // sanity check that good scores are still possible with stopwords\n      // \"brown fox\" should score positively in both fields, and overall...\n      final Phrase brown_fox = phrases.get(phrases.size()-2);\n      assertEquals(\"brown fox\", brown_fox.getSubSequence());\n      assertThat(brown_fox.toString(), brown_fox.getFieldScore(\"multigrams_title\"), greaterThan(0.0D));\n      assertThat(brown_fox.toString(), brown_fox.getFieldScore(\"multigrams_title_stop\"), greaterThan(0.0D) );\n      assertThat(brown_fox.toString(), brown_fox.getTotalScore(), greaterThan(0.0D));\n    }\n    \n    { // now flip things: our analysisField filters stopwords, \n      // but we also generates scores from a field that doesn't know about them...\n      //\n      // (NOTE: the parser will still generate _some_ candidate phrases spaning the stop word position,\n      // but not ones that start with the stopword)\n      final SchemaField analysisField = h.getCore().getLatestSchema().getField(\"multigrams_title_stop\");\n      assertNotNull(analysisField);\n      \n      final List<Phrase> phrases = Phrase.extractPhrases(input, analysisField, 3, 7);\n      try (SolrQueryRequest req = req()) {\n        Phrase.populateStats(phrases, fieldWeights.keySet(), req.getSearcher());\n      }\n      Phrase.populateScores(phrases, fieldWeights, 3, 7);\n      assertTrue(phrases.toString(), 0 < phrases.size());\n\n      for (Phrase p : phrases) {\n        if (p.getPositionStart() <= 2 && 2 < p.getPositionEnd()) {\n          // phrases that span the stop word should have valid scores from the field that doesn't care\n          // about stop words, but the stopword field should reject them\n          assertEquals(p.toString(), -1.0D, p.getFieldScore(\"multigrams_title\"), 0.0D);\n          assertEquals(p.toString(), -1.0D, p.getFieldScore(\"multigrams_title_stop\"), 0.0D);\n        }\n      }\n      \n      // sanity check that good scores are still possible with stopwords\n      // \"brown fox\" should score positively in both fields, and overall...\n      final Phrase brown_fox = phrases.get(phrases.size()-2);\n      assertEquals(\"brown fox\", brown_fox.getSubSequence());\n      assertThat(brown_fox.toString(), brown_fox.getFieldScore(\"multigrams_title\"), greaterThan(0.0D));\n      assertThat(brown_fox.toString(), brown_fox.getFieldScore(\"multigrams_title_stop\"), greaterThan(0.0D) );\n      assertThat(brown_fox.toString(), brown_fox.getTotalScore(), greaterThan(0.0D));\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0d1411e62d30c460b09c6f3643df82daa10a27cc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["0d1411e62d30c460b09c6f3643df82daa10a27cc"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d1411e62d30c460b09c6f3643df82daa10a27cc"],"0d1411e62d30c460b09c6f3643df82daa10a27cc":["e98520789adb1d5ad05afb4956eca0944a929688"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}