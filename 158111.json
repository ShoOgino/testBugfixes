{"path":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperStatusHandler#getZkStatus(String,ZkDynamicConfig).mjava","commits":[{"id":"861042e9f93a922bfb6b6b2c3d44b61fb3504894","date":1587133827,"type":1,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperStatusHandler#getZkStatus(String,ZkDynamicConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperStatusHandler#getZkStatus(String).mjava","sourceNew":"  /**\n   * For each zk host, resolved either from zk connection string or from zk dynamic reconfiguration config,\n   * fetch all config and status info from ZK API and returns as a map, where key is hostname\n   * @param zkHost zookeeper connection string\n   * @param zkDynamicConfig list of zk dynamic config objects\n   * @return map of zookeeper config and status per zk host\n   */\n  protected Map<String, Object> getZkStatus(String zkHost, ZkDynamicConfig zkDynamicConfig) {\n    final ZkDynamicConfig hostsFromConnectionString = ZkDynamicConfig.fromZkConnectString(zkHost);\n    final ZkDynamicConfig zookeepers;\n    boolean dynamicReconfig;\n    final List<String> errors = new ArrayList<>();\n    String status = STATUS_NA;\n\n    if (zkDynamicConfig.size() == 0) {\n      // Fallback to parsing zkHost for older zk servers without support for dynamic reconfiguration\n      dynamicReconfig = false;\n      zookeepers = hostsFromConnectionString;\n    } else {\n      dynamicReconfig = true;\n      List<String> connStringHosts = hostsFromConnectionString.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      List<String> dynamicHosts = zkDynamicConfig.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      if (!connStringHosts.containsAll(dynamicHosts)) {\n        errors.add(\"Your ZK connection string (\" + connStringHosts.size() + \" hosts) is different from the \" +\n                \"dynamic ensemble config (\" + dynamicHosts.size() + \" hosts). Solr does not currently support \" +\n                \"dynamic reconfiguration and will only be able to connect to the zk hosts in your connection string.\");\n        status = STATUS_YELLOW;\n      }\n      zookeepers = zkDynamicConfig; // Clone input\n    }\n    final Map<String, Object> zkStatus = new HashMap<>();\n    final List<Object> details = new ArrayList<>();\n    int numOk = 0;\n    int standalone = 0;\n    int followers = 0;\n    int reportedFollowers = 0;\n    int leaders = 0;\n    zkStatus.put(\"ensembleSize\", zookeepers.size());\n    zkStatus.put(\"zkHost\", zkHost);\n    for (ZkDynamicConfig.Server zk : zookeepers.getServers()) {\n      final String zkClientHostPort = zk.resolveClientPortAddress() + \":\" + zk.clientPort;\n      try {\n        Map<String, Object> stat = monitorZookeeper(zkClientHostPort);\n        if (stat.containsKey(\"errors\")) {\n          errors.addAll((List<String>)stat.get(\"errors\"));\n          stat.remove(\"errors\");\n        }\n        details.add(stat);\n        if (\"true\".equals(String.valueOf(stat.get(\"ok\")))) {\n          numOk++;\n        }\n        String state = String.valueOf(stat.get(\"zk_server_state\"));\n        if (\"follower\".equals(state) || \"observer\".equals(state)) {\n          followers++;\n        } else if (\"leader\".equals(state)) {\n          leaders++;\n          reportedFollowers = Integer.parseInt(String.valueOf(stat.get(\"zk_followers\")));\n        } else if (\"standalone\".equals(state)) {\n          standalone++;\n        }\n        if (zk.role != null) {\n          stat.put(\"role\", zk.role);\n        }\n      } catch (SolrException se) {\n        log.warn(\"Failed talking to zookeeper \" + zkClientHostPort, se);\n        errors.add(se.getMessage());\n        Map<String, Object> stat = new HashMap<>();\n        stat.put(\"host\", zkClientHostPort);\n        stat.put(\"ok\", false);\n        status = STATUS_YELLOW;\n        details.add(stat);\n      }\n    }\n    zkStatus.put(\"details\", details);\n    zkStatus.put(\"dynamicReconfig\", dynamicReconfig);\n    if (followers+leaders > 0 && standalone > 0) {\n      status = STATUS_RED;\n      errors.add(\"The zk nodes do not agree on their mode, check details\");\n    }\n    if (standalone > 1) {\n      status = STATUS_RED;\n      errors.add(\"Only one zk allowed in standalone mode\");\n    }\n    if (leaders > 1) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Only one leader allowed, got \" + leaders);\n    }\n    if (followers > 0 && leaders == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"We do not have a leader\");\n    }\n    if (leaders > 0 && followers != reportedFollowers) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Leader reports \" + reportedFollowers + \" followers, but we only found \" + followers + \n        \". Please check zkHost configuration\");\n    }\n    if (followers+leaders == 0 && standalone == 1) {\n      zkStatus.put(\"mode\", \"standalone\");\n    }\n    if (followers+leaders > 0 && (zookeepers.size())%2 == 0) {\n      if (!STATUS_RED.equals(status)) {\n        status = STATUS_YELLOW;\n      }\n      errors.add(\"We have an even number of zookeepers which is not recommended\");\n    }\n    if (followers+leaders > 0 && standalone == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n    }\n    if (status.equals(STATUS_NA)) {\n      if (numOk == zookeepers.size()) {\n        status = STATUS_GREEN;\n      } else if (numOk < zookeepers.size() && numOk > zookeepers.size() / 2) {\n        status = STATUS_YELLOW;\n        errors.add(\"Some zookeepers are down: \" + numOk + \"/\" + zookeepers.size());\n      } else {\n        status = STATUS_RED;\n        errors.add(\"Mismatch in number of zookeeper nodes live. numOK=\" + numOk + \", expected \" + zookeepers.size());\n      }\n    }\n    zkStatus.put(\"status\", status);\n    if (!errors.isEmpty()) {\n      zkStatus.put(\"errors\", errors);\n    }\n    return zkStatus;\n  }\n\n","sourceOld":"  /*\n   Gets all info from ZK API and returns as a map\n   */\n  protected Map<String, Object> getZkStatus(String zkHost) {\n    Map<String, Object> zkStatus = new HashMap<>();\n    List<String> zookeepers = Arrays.asList(zkHost.split(\"/\")[0].split(\",\"));\n    List<Object> details = new ArrayList<>();\n    int numOk = 0;\n    String status = STATUS_NA;\n    int standalone = 0;\n    int followers = 0;\n    int reportedFollowers = 0;\n    int leaders = 0;\n    List<String> errors = new ArrayList<>();\n    zkStatus.put(\"ensembleSize\", zookeepers.size());\n    zkStatus.put(\"zkHost\", zkHost);\n    for (String zk : zookeepers) {\n      try {\n        Map<String, Object> stat = monitorZookeeper(zk);\n        if (stat.containsKey(\"errors\")) {\n          errors.addAll((List<String>)stat.get(\"errors\"));\n          stat.remove(\"errors\");\n        }\n        details.add(stat);\n        if (\"true\".equals(String.valueOf(stat.get(\"ok\")))) {\n          numOk++;\n        }\n        String state = String.valueOf(stat.get(\"zk_server_state\"));\n        if (\"follower\".equals(state)) {\n          followers++;\n        } else if (\"leader\".equals(state)) {\n          leaders++;\n          reportedFollowers = Integer.parseInt(String.valueOf(stat.get(\"zk_followers\")));\n        } else if (\"standalone\".equals(state)) {\n          standalone++;\n        }\n      } catch (SolrException se) {\n        log.warn(\"Failed talking to zookeeper \" + zk, se);\n        errors.add(se.getMessage());\n        Map<String, Object> stat = new HashMap<>();\n        stat.put(\"host\", zk);\n        stat.put(\"ok\", false);\n        status = STATUS_YELLOW;\n        details.add(stat);\n      }\n    }\n    zkStatus.put(\"details\", details);\n    if (followers+leaders > 0 && standalone > 0) {\n      status = STATUS_RED;\n      errors.add(\"The zk nodes do not agree on their mode, check details\");\n    }\n    if (standalone > 1) {\n      status = STATUS_RED;\n      errors.add(\"Only one zk allowed in standalone mode\");\n    }\n    if (leaders > 1) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Only one leader allowed, got \" + leaders);\n    }\n    if (followers > 0 && leaders == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"We do not have a leader\");\n    }\n    if (leaders > 0 && followers != reportedFollowers) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Leader reports \" + reportedFollowers + \" followers, but we only found \" + followers + \n        \". Please check zkHost configuration\");\n    }\n    if (followers+leaders == 0 && standalone == 1) {\n      zkStatus.put(\"mode\", \"standalone\");\n    }\n    if (followers+leaders > 0 && (zookeepers.size())%2 == 0) {\n      if (!STATUS_RED.equals(status)) {\n        status = STATUS_YELLOW;\n      }\n      errors.add(\"We have an even number of zookeepers which is not recommended\");\n    }\n    if (followers+leaders > 0 && standalone == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n    }\n    if (status.equals(STATUS_NA)) {\n      if (numOk == zookeepers.size()) {\n        status = STATUS_GREEN;\n      } else if (numOk < zookeepers.size() && numOk > zookeepers.size() / 2) {\n        status = STATUS_YELLOW;\n        errors.add(\"Some zookeepers are down: \" + numOk + \"/\" + zookeepers.size());\n      } else {\n        status = STATUS_RED;\n        errors.add(\"Mismatch in number of zookeeper nodes live. numOK=\" + numOk + \", expected \" + zookeepers.size());\n      }\n    }\n    zkStatus.put(\"status\", status);\n    if (!errors.isEmpty()) {\n      zkStatus.put(\"errors\", errors);\n    }\n    return zkStatus;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperStatusHandler#getZkStatus(String,ZkDynamicConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperStatusHandler#getZkStatus(String,ZkDynamicConfig).mjava","sourceNew":"  /**\n   * For each zk host, resolved either from zk connection string or from zk dynamic reconfiguration config,\n   * fetch all config and status info from ZK API and returns as a map, where key is hostname\n   * @param zkHost zookeeper connection string\n   * @param zkDynamicConfig list of zk dynamic config objects\n   * @return map of zookeeper config and status per zk host\n   */\n  protected Map<String, Object> getZkStatus(String zkHost, ZkDynamicConfig zkDynamicConfig) {\n    final ZkDynamicConfig hostsFromConnectionString = ZkDynamicConfig.fromZkConnectString(zkHost);\n    final ZkDynamicConfig zookeepers;\n    boolean dynamicReconfig;\n    final List<String> errors = new ArrayList<>();\n    String status = STATUS_NA;\n\n    if (zkDynamicConfig.size() == 0) {\n      // Fallback to parsing zkHost for older zk servers without support for dynamic reconfiguration\n      dynamicReconfig = false;\n      zookeepers = hostsFromConnectionString;\n    } else {\n      dynamicReconfig = true;\n      List<String> connStringHosts = hostsFromConnectionString.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      List<String> dynamicHosts = zkDynamicConfig.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      if (!connStringHosts.containsAll(dynamicHosts)) {\n        errors.add(\"Your ZK connection string (\" + connStringHosts.size() + \" hosts) is different from the \" +\n                \"dynamic ensemble config (\" + dynamicHosts.size() + \" hosts). Solr does not currently support \" +\n                \"dynamic reconfiguration and will only be able to connect to the zk hosts in your connection string.\");\n        status = STATUS_YELLOW;\n      }\n      zookeepers = zkDynamicConfig; // Clone input\n    }\n    final Map<String, Object> zkStatus = new HashMap<>();\n    final List<Object> details = new ArrayList<>();\n    int numOk = 0;\n    int standalone = 0;\n    int followers = 0;\n    int reportedFollowers = 0;\n    int leaders = 0;\n    zkStatus.put(\"ensembleSize\", zookeepers.size());\n    zkStatus.put(\"zkHost\", zkHost);\n    for (ZkDynamicConfig.Server zk : zookeepers.getServers()) {\n      final String zkClientHostPort = zk.resolveClientPortAddress() + \":\" + zk.clientPort;\n      try {\n        Map<String, Object> stat = monitorZookeeper(zkClientHostPort);\n        if (stat.containsKey(\"errors\")) {\n          errors.addAll((List<String>)stat.get(\"errors\"));\n          stat.remove(\"errors\");\n        }\n        details.add(stat);\n        if (\"true\".equals(String.valueOf(stat.get(\"ok\")))) {\n          numOk++;\n        }\n        String state = String.valueOf(stat.get(\"zk_server_state\"));\n        if (\"follower\".equals(state) || \"observer\".equals(state)) {\n          followers++;\n        } else if (\"leader\".equals(state)) {\n          leaders++;\n          reportedFollowers = Integer.parseInt(String.valueOf(stat.get(\"zk_followers\")));\n        } else if (\"standalone\".equals(state)) {\n          standalone++;\n        }\n        if (zk.role != null) {\n          stat.put(\"role\", zk.role);\n        }\n      } catch (SolrException se) {\n        log.warn(\"Failed talking to zookeeper {}\", zkClientHostPort, se);\n        errors.add(se.getMessage());\n        Map<String, Object> stat = new HashMap<>();\n        stat.put(\"host\", zkClientHostPort);\n        stat.put(\"ok\", false);\n        status = STATUS_YELLOW;\n        details.add(stat);\n      }\n    }\n    zkStatus.put(\"details\", details);\n    zkStatus.put(\"dynamicReconfig\", dynamicReconfig);\n    if (followers+leaders > 0 && standalone > 0) {\n      status = STATUS_RED;\n      errors.add(\"The zk nodes do not agree on their mode, check details\");\n    }\n    if (standalone > 1) {\n      status = STATUS_RED;\n      errors.add(\"Only one zk allowed in standalone mode\");\n    }\n    if (leaders > 1) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Only one leader allowed, got \" + leaders);\n    }\n    if (followers > 0 && leaders == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"We do not have a leader\");\n    }\n    if (leaders > 0 && followers != reportedFollowers) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Leader reports \" + reportedFollowers + \" followers, but we only found \" + followers + \n        \". Please check zkHost configuration\");\n    }\n    if (followers+leaders == 0 && standalone == 1) {\n      zkStatus.put(\"mode\", \"standalone\");\n    }\n    if (followers+leaders > 0 && (zookeepers.size())%2 == 0) {\n      if (!STATUS_RED.equals(status)) {\n        status = STATUS_YELLOW;\n      }\n      errors.add(\"We have an even number of zookeepers which is not recommended\");\n    }\n    if (followers+leaders > 0 && standalone == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n    }\n    if (status.equals(STATUS_NA)) {\n      if (numOk == zookeepers.size()) {\n        status = STATUS_GREEN;\n      } else if (numOk < zookeepers.size() && numOk > zookeepers.size() / 2) {\n        status = STATUS_YELLOW;\n        errors.add(\"Some zookeepers are down: \" + numOk + \"/\" + zookeepers.size());\n      } else {\n        status = STATUS_RED;\n        errors.add(\"Mismatch in number of zookeeper nodes live. numOK=\" + numOk + \", expected \" + zookeepers.size());\n      }\n    }\n    zkStatus.put(\"status\", status);\n    if (!errors.isEmpty()) {\n      zkStatus.put(\"errors\", errors);\n    }\n    return zkStatus;\n  }\n\n","sourceOld":"  /**\n   * For each zk host, resolved either from zk connection string or from zk dynamic reconfiguration config,\n   * fetch all config and status info from ZK API and returns as a map, where key is hostname\n   * @param zkHost zookeeper connection string\n   * @param zkDynamicConfig list of zk dynamic config objects\n   * @return map of zookeeper config and status per zk host\n   */\n  protected Map<String, Object> getZkStatus(String zkHost, ZkDynamicConfig zkDynamicConfig) {\n    final ZkDynamicConfig hostsFromConnectionString = ZkDynamicConfig.fromZkConnectString(zkHost);\n    final ZkDynamicConfig zookeepers;\n    boolean dynamicReconfig;\n    final List<String> errors = new ArrayList<>();\n    String status = STATUS_NA;\n\n    if (zkDynamicConfig.size() == 0) {\n      // Fallback to parsing zkHost for older zk servers without support for dynamic reconfiguration\n      dynamicReconfig = false;\n      zookeepers = hostsFromConnectionString;\n    } else {\n      dynamicReconfig = true;\n      List<String> connStringHosts = hostsFromConnectionString.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      List<String> dynamicHosts = zkDynamicConfig.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      if (!connStringHosts.containsAll(dynamicHosts)) {\n        errors.add(\"Your ZK connection string (\" + connStringHosts.size() + \" hosts) is different from the \" +\n                \"dynamic ensemble config (\" + dynamicHosts.size() + \" hosts). Solr does not currently support \" +\n                \"dynamic reconfiguration and will only be able to connect to the zk hosts in your connection string.\");\n        status = STATUS_YELLOW;\n      }\n      zookeepers = zkDynamicConfig; // Clone input\n    }\n    final Map<String, Object> zkStatus = new HashMap<>();\n    final List<Object> details = new ArrayList<>();\n    int numOk = 0;\n    int standalone = 0;\n    int followers = 0;\n    int reportedFollowers = 0;\n    int leaders = 0;\n    zkStatus.put(\"ensembleSize\", zookeepers.size());\n    zkStatus.put(\"zkHost\", zkHost);\n    for (ZkDynamicConfig.Server zk : zookeepers.getServers()) {\n      final String zkClientHostPort = zk.resolveClientPortAddress() + \":\" + zk.clientPort;\n      try {\n        Map<String, Object> stat = monitorZookeeper(zkClientHostPort);\n        if (stat.containsKey(\"errors\")) {\n          errors.addAll((List<String>)stat.get(\"errors\"));\n          stat.remove(\"errors\");\n        }\n        details.add(stat);\n        if (\"true\".equals(String.valueOf(stat.get(\"ok\")))) {\n          numOk++;\n        }\n        String state = String.valueOf(stat.get(\"zk_server_state\"));\n        if (\"follower\".equals(state) || \"observer\".equals(state)) {\n          followers++;\n        } else if (\"leader\".equals(state)) {\n          leaders++;\n          reportedFollowers = Integer.parseInt(String.valueOf(stat.get(\"zk_followers\")));\n        } else if (\"standalone\".equals(state)) {\n          standalone++;\n        }\n        if (zk.role != null) {\n          stat.put(\"role\", zk.role);\n        }\n      } catch (SolrException se) {\n        log.warn(\"Failed talking to zookeeper \" + zkClientHostPort, se);\n        errors.add(se.getMessage());\n        Map<String, Object> stat = new HashMap<>();\n        stat.put(\"host\", zkClientHostPort);\n        stat.put(\"ok\", false);\n        status = STATUS_YELLOW;\n        details.add(stat);\n      }\n    }\n    zkStatus.put(\"details\", details);\n    zkStatus.put(\"dynamicReconfig\", dynamicReconfig);\n    if (followers+leaders > 0 && standalone > 0) {\n      status = STATUS_RED;\n      errors.add(\"The zk nodes do not agree on their mode, check details\");\n    }\n    if (standalone > 1) {\n      status = STATUS_RED;\n      errors.add(\"Only one zk allowed in standalone mode\");\n    }\n    if (leaders > 1) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Only one leader allowed, got \" + leaders);\n    }\n    if (followers > 0 && leaders == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"We do not have a leader\");\n    }\n    if (leaders > 0 && followers != reportedFollowers) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Leader reports \" + reportedFollowers + \" followers, but we only found \" + followers + \n        \". Please check zkHost configuration\");\n    }\n    if (followers+leaders == 0 && standalone == 1) {\n      zkStatus.put(\"mode\", \"standalone\");\n    }\n    if (followers+leaders > 0 && (zookeepers.size())%2 == 0) {\n      if (!STATUS_RED.equals(status)) {\n        status = STATUS_YELLOW;\n      }\n      errors.add(\"We have an even number of zookeepers which is not recommended\");\n    }\n    if (followers+leaders > 0 && standalone == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n    }\n    if (status.equals(STATUS_NA)) {\n      if (numOk == zookeepers.size()) {\n        status = STATUS_GREEN;\n      } else if (numOk < zookeepers.size() && numOk > zookeepers.size() / 2) {\n        status = STATUS_YELLOW;\n        errors.add(\"Some zookeepers are down: \" + numOk + \"/\" + zookeepers.size());\n      } else {\n        status = STATUS_RED;\n        errors.add(\"Mismatch in number of zookeeper nodes live. numOK=\" + numOk + \", expected \" + zookeepers.size());\n      }\n    }\n    zkStatus.put(\"status\", status);\n    if (!errors.isEmpty()) {\n      zkStatus.put(\"errors\", errors);\n    }\n    return zkStatus;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e593401f7b75b207ee04c2f8381fc5df0251b1d4","date":1589273853,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperStatusHandler#getZkStatus(String,ZkDynamicConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperStatusHandler#getZkStatus(String,ZkDynamicConfig).mjava","sourceNew":"  /**\n   * For each zk host, resolved either from zk connection string or from zk dynamic reconfiguration config,\n   * fetch all config and status info from ZK API and returns as a map, where key is hostname\n   * @param zkHost zookeeper connection string\n   * @param zkDynamicConfig list of zk dynamic config objects\n   * @return map of zookeeper config and status per zk host\n   */\n  protected Map<String, Object> getZkStatus(String zkHost, ZkDynamicConfig zkDynamicConfig) {\n    final ZkDynamicConfig hostsFromConnectionString = ZkDynamicConfig.fromZkConnectString(zkHost);\n    final ZkDynamicConfig zookeepers;\n    boolean dynamicReconfig;\n    final List<String> errors = new ArrayList<>();\n    String status = STATUS_NA;\n\n    if (zkDynamicConfig.size() == 0) {\n      // Fallback to parsing zkHost for older zk servers without support for dynamic reconfiguration\n      dynamicReconfig = false;\n      zookeepers = hostsFromConnectionString;\n    } else {\n      dynamicReconfig = true;\n      List<String> connStringHosts = hostsFromConnectionString.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      List<String> dynamicHosts = zkDynamicConfig.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      if (!connStringHosts.containsAll(dynamicHosts)) {\n        errors.add(\"Your ZK connection string (\" + connStringHosts.size() + \" hosts) is different from the \" +\n                \"dynamic ensemble config (\" + dynamicHosts.size() + \" hosts). Solr does not currently support \" +\n                \"dynamic reconfiguration and will only be able to connect to the zk hosts in your connection string.\");\n        status = STATUS_YELLOW;\n      }\n      zookeepers = zkDynamicConfig; // Clone input\n    }\n    final Map<String, Object> zkStatus = new HashMap<>();\n    final List<Object> details = new ArrayList<>();\n    int numOk = 0;\n    int standalone = 0;\n    int followers = 0;\n    int reportedFollowers = 0;\n    int leaders = 0;\n    zkStatus.put(\"ensembleSize\", zookeepers.size());\n    zkStatus.put(\"zkHost\", zkHost);\n    for (ZkDynamicConfig.Server zk : zookeepers.getServers()) {\n      final String zkClientHostPort = zk.resolveClientPortAddress() + \":\" + zk.clientPort;\n      try {\n        Map<String, Object> stat = monitorZookeeper(zkClientHostPort);\n        if (stat.containsKey(\"errors\")) {\n          errors.addAll((List<String>)stat.get(\"errors\"));\n          stat.remove(\"errors\");\n        }\n        details.add(stat);\n        if (\"true\".equals(String.valueOf(stat.get(\"ok\")))) {\n          numOk++;\n        }\n        String state = String.valueOf(stat.get(\"zk_server_state\"));\n        if (\"follower\".equals(state) || \"observer\".equals(state)) {\n          followers++;\n        } else if (\"leader\".equals(state)) {\n          leaders++;\n          reportedFollowers = Math.max(\n              Integer.parseInt((String) stat.getOrDefault(\"zk_followers\", \"0\")),\n              Integer.parseInt((String) stat.getOrDefault(\"zk_synced_followers\", \"0\"))\n          );\n        } else if (\"standalone\".equals(state)) {\n          standalone++;\n        }\n        if (zk.role != null) {\n          stat.put(\"role\", zk.role);\n        }\n      } catch (SolrException se) {\n        log.warn(\"Failed talking to zookeeper {}\", zkClientHostPort, se);\n        errors.add(se.getMessage());\n        Map<String, Object> stat = new HashMap<>();\n        stat.put(\"host\", zkClientHostPort);\n        stat.put(\"ok\", false);\n        status = STATUS_YELLOW;\n        details.add(stat);\n      }\n    }\n    zkStatus.put(\"details\", details);\n    zkStatus.put(\"dynamicReconfig\", dynamicReconfig);\n    if (followers+leaders > 0 && standalone > 0) {\n      status = STATUS_RED;\n      errors.add(\"The zk nodes do not agree on their mode, check details\");\n    }\n    if (standalone > 1) {\n      status = STATUS_RED;\n      errors.add(\"Only one zk allowed in standalone mode\");\n    }\n    if (leaders > 1) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Only one leader allowed, got \" + leaders);\n    }\n    if (followers > 0 && leaders == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"We do not have a leader\");\n    }\n    if (leaders > 0 && followers != reportedFollowers) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Leader reports \" + reportedFollowers + \" followers, but we only found \" + followers + \n        \". Please check zkHost configuration\");\n    }\n    if (followers+leaders == 0 && standalone == 1) {\n      zkStatus.put(\"mode\", \"standalone\");\n    }\n    if (followers+leaders > 0 && (zookeepers.size())%2 == 0) {\n      if (!STATUS_RED.equals(status)) {\n        status = STATUS_YELLOW;\n      }\n      errors.add(\"We have an even number of zookeepers which is not recommended\");\n    }\n    if (followers+leaders > 0 && standalone == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n    }\n    if (status.equals(STATUS_NA)) {\n      if (numOk == zookeepers.size()) {\n        status = STATUS_GREEN;\n      } else if (numOk < zookeepers.size() && numOk > zookeepers.size() / 2) {\n        status = STATUS_YELLOW;\n        errors.add(\"Some zookeepers are down: \" + numOk + \"/\" + zookeepers.size());\n      } else {\n        status = STATUS_RED;\n        errors.add(\"Mismatch in number of zookeeper nodes live. numOK=\" + numOk + \", expected \" + zookeepers.size());\n      }\n    }\n    zkStatus.put(\"status\", status);\n    if (!errors.isEmpty()) {\n      zkStatus.put(\"errors\", errors);\n    }\n    return zkStatus;\n  }\n\n","sourceOld":"  /**\n   * For each zk host, resolved either from zk connection string or from zk dynamic reconfiguration config,\n   * fetch all config and status info from ZK API and returns as a map, where key is hostname\n   * @param zkHost zookeeper connection string\n   * @param zkDynamicConfig list of zk dynamic config objects\n   * @return map of zookeeper config and status per zk host\n   */\n  protected Map<String, Object> getZkStatus(String zkHost, ZkDynamicConfig zkDynamicConfig) {\n    final ZkDynamicConfig hostsFromConnectionString = ZkDynamicConfig.fromZkConnectString(zkHost);\n    final ZkDynamicConfig zookeepers;\n    boolean dynamicReconfig;\n    final List<String> errors = new ArrayList<>();\n    String status = STATUS_NA;\n\n    if (zkDynamicConfig.size() == 0) {\n      // Fallback to parsing zkHost for older zk servers without support for dynamic reconfiguration\n      dynamicReconfig = false;\n      zookeepers = hostsFromConnectionString;\n    } else {\n      dynamicReconfig = true;\n      List<String> connStringHosts = hostsFromConnectionString.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      List<String> dynamicHosts = zkDynamicConfig.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      if (!connStringHosts.containsAll(dynamicHosts)) {\n        errors.add(\"Your ZK connection string (\" + connStringHosts.size() + \" hosts) is different from the \" +\n                \"dynamic ensemble config (\" + dynamicHosts.size() + \" hosts). Solr does not currently support \" +\n                \"dynamic reconfiguration and will only be able to connect to the zk hosts in your connection string.\");\n        status = STATUS_YELLOW;\n      }\n      zookeepers = zkDynamicConfig; // Clone input\n    }\n    final Map<String, Object> zkStatus = new HashMap<>();\n    final List<Object> details = new ArrayList<>();\n    int numOk = 0;\n    int standalone = 0;\n    int followers = 0;\n    int reportedFollowers = 0;\n    int leaders = 0;\n    zkStatus.put(\"ensembleSize\", zookeepers.size());\n    zkStatus.put(\"zkHost\", zkHost);\n    for (ZkDynamicConfig.Server zk : zookeepers.getServers()) {\n      final String zkClientHostPort = zk.resolveClientPortAddress() + \":\" + zk.clientPort;\n      try {\n        Map<String, Object> stat = monitorZookeeper(zkClientHostPort);\n        if (stat.containsKey(\"errors\")) {\n          errors.addAll((List<String>)stat.get(\"errors\"));\n          stat.remove(\"errors\");\n        }\n        details.add(stat);\n        if (\"true\".equals(String.valueOf(stat.get(\"ok\")))) {\n          numOk++;\n        }\n        String state = String.valueOf(stat.get(\"zk_server_state\"));\n        if (\"follower\".equals(state) || \"observer\".equals(state)) {\n          followers++;\n        } else if (\"leader\".equals(state)) {\n          leaders++;\n          reportedFollowers = Integer.parseInt(String.valueOf(stat.get(\"zk_followers\")));\n        } else if (\"standalone\".equals(state)) {\n          standalone++;\n        }\n        if (zk.role != null) {\n          stat.put(\"role\", zk.role);\n        }\n      } catch (SolrException se) {\n        log.warn(\"Failed talking to zookeeper {}\", zkClientHostPort, se);\n        errors.add(se.getMessage());\n        Map<String, Object> stat = new HashMap<>();\n        stat.put(\"host\", zkClientHostPort);\n        stat.put(\"ok\", false);\n        status = STATUS_YELLOW;\n        details.add(stat);\n      }\n    }\n    zkStatus.put(\"details\", details);\n    zkStatus.put(\"dynamicReconfig\", dynamicReconfig);\n    if (followers+leaders > 0 && standalone > 0) {\n      status = STATUS_RED;\n      errors.add(\"The zk nodes do not agree on their mode, check details\");\n    }\n    if (standalone > 1) {\n      status = STATUS_RED;\n      errors.add(\"Only one zk allowed in standalone mode\");\n    }\n    if (leaders > 1) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Only one leader allowed, got \" + leaders);\n    }\n    if (followers > 0 && leaders == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"We do not have a leader\");\n    }\n    if (leaders > 0 && followers != reportedFollowers) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Leader reports \" + reportedFollowers + \" followers, but we only found \" + followers + \n        \". Please check zkHost configuration\");\n    }\n    if (followers+leaders == 0 && standalone == 1) {\n      zkStatus.put(\"mode\", \"standalone\");\n    }\n    if (followers+leaders > 0 && (zookeepers.size())%2 == 0) {\n      if (!STATUS_RED.equals(status)) {\n        status = STATUS_YELLOW;\n      }\n      errors.add(\"We have an even number of zookeepers which is not recommended\");\n    }\n    if (followers+leaders > 0 && standalone == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n    }\n    if (status.equals(STATUS_NA)) {\n      if (numOk == zookeepers.size()) {\n        status = STATUS_GREEN;\n      } else if (numOk < zookeepers.size() && numOk > zookeepers.size() / 2) {\n        status = STATUS_YELLOW;\n        errors.add(\"Some zookeepers are down: \" + numOk + \"/\" + zookeepers.size());\n      } else {\n        status = STATUS_RED;\n        errors.add(\"Mismatch in number of zookeeper nodes live. numOK=\" + numOk + \", expected \" + zookeepers.size());\n      }\n    }\n    zkStatus.put(\"status\", status);\n    if (!errors.isEmpty()) {\n      zkStatus.put(\"errors\", errors);\n    }\n    return zkStatus;\n  }\n\n","bugFix":["861042e9f93a922bfb6b6b2c3d44b61fb3504894"],"bugIntro":["e2e572da46604eb6afebc7b0f11d14a26d65b846"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba055e19afc289adcb5bedaf68513793a7254012","date":1591268575,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperStatusHandler#getZkStatus(String,ZkDynamicConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperStatusHandler#getZkStatus(String,ZkDynamicConfig).mjava","sourceNew":"  /**\n   * For each zk host, resolved either from zk connection string or from zk dynamic reconfiguration config,\n   * fetch all config and status info from ZK API and returns as a map, where key is hostname\n   * @param zkHost zookeeper connection string\n   * @param zkDynamicConfig list of zk dynamic config objects\n   * @return map of zookeeper config and status per zk host\n   */\n  @SuppressWarnings({\"unchecked\"})\n  protected Map<String, Object> getZkStatus(String zkHost, ZkDynamicConfig zkDynamicConfig) {\n    final ZkDynamicConfig hostsFromConnectionString = ZkDynamicConfig.fromZkConnectString(zkHost);\n    final ZkDynamicConfig zookeepers;\n    boolean dynamicReconfig;\n    final List<String> errors = new ArrayList<>();\n    String status = STATUS_NA;\n\n    if (zkDynamicConfig.size() == 0) {\n      // Fallback to parsing zkHost for older zk servers without support for dynamic reconfiguration\n      dynamicReconfig = false;\n      zookeepers = hostsFromConnectionString;\n    } else {\n      dynamicReconfig = true;\n      List<String> connStringHosts = hostsFromConnectionString.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      List<String> dynamicHosts = zkDynamicConfig.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      if (!connStringHosts.containsAll(dynamicHosts)) {\n        errors.add(\"Your ZK connection string (\" + connStringHosts.size() + \" hosts) is different from the \" +\n                \"dynamic ensemble config (\" + dynamicHosts.size() + \" hosts). Solr does not currently support \" +\n                \"dynamic reconfiguration and will only be able to connect to the zk hosts in your connection string.\");\n        status = STATUS_YELLOW;\n      }\n      zookeepers = zkDynamicConfig; // Clone input\n    }\n    final Map<String, Object> zkStatus = new HashMap<>();\n    final List<Object> details = new ArrayList<>();\n    int numOk = 0;\n    int standalone = 0;\n    int followers = 0;\n    int reportedFollowers = 0;\n    int leaders = 0;\n    zkStatus.put(\"ensembleSize\", zookeepers.size());\n    zkStatus.put(\"zkHost\", zkHost);\n    for (ZkDynamicConfig.Server zk : zookeepers.getServers()) {\n      final String zkClientHostPort = zk.resolveClientPortAddress() + \":\" + zk.clientPort;\n      try {\n        Map<String, Object> stat = monitorZookeeper(zkClientHostPort);\n        if (stat.containsKey(\"errors\")) {\n          errors.addAll((List<String>)stat.get(\"errors\"));\n          stat.remove(\"errors\");\n        }\n        details.add(stat);\n        if (\"true\".equals(String.valueOf(stat.get(\"ok\")))) {\n          numOk++;\n        }\n        String state = String.valueOf(stat.get(\"zk_server_state\"));\n        if (\"follower\".equals(state) || \"observer\".equals(state)) {\n          followers++;\n        } else if (\"leader\".equals(state)) {\n          leaders++;\n          reportedFollowers = Math.max(\n              Integer.parseInt((String) stat.getOrDefault(\"zk_followers\", \"0\")),\n              Integer.parseInt((String) stat.getOrDefault(\"zk_synced_followers\", \"0\"))\n          );\n        } else if (\"standalone\".equals(state)) {\n          standalone++;\n        }\n        if (zk.role != null) {\n          stat.put(\"role\", zk.role);\n        }\n      } catch (SolrException se) {\n        log.warn(\"Failed talking to zookeeper {}\", zkClientHostPort, se);\n        errors.add(se.getMessage());\n        Map<String, Object> stat = new HashMap<>();\n        stat.put(\"host\", zkClientHostPort);\n        stat.put(\"ok\", false);\n        status = STATUS_YELLOW;\n        details.add(stat);\n      }\n    }\n    zkStatus.put(\"details\", details);\n    zkStatus.put(\"dynamicReconfig\", dynamicReconfig);\n    if (followers+leaders > 0 && standalone > 0) {\n      status = STATUS_RED;\n      errors.add(\"The zk nodes do not agree on their mode, check details\");\n    }\n    if (standalone > 1) {\n      status = STATUS_RED;\n      errors.add(\"Only one zk allowed in standalone mode\");\n    }\n    if (leaders > 1) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Only one leader allowed, got \" + leaders);\n    }\n    if (followers > 0 && leaders == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"We do not have a leader\");\n    }\n    if (leaders > 0 && followers != reportedFollowers) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Leader reports \" + reportedFollowers + \" followers, but we only found \" + followers + \n        \". Please check zkHost configuration\");\n    }\n    if (followers+leaders == 0 && standalone == 1) {\n      zkStatus.put(\"mode\", \"standalone\");\n    }\n    if (followers+leaders > 0 && (zookeepers.size())%2 == 0) {\n      if (!STATUS_RED.equals(status)) {\n        status = STATUS_YELLOW;\n      }\n      errors.add(\"We have an even number of zookeepers which is not recommended\");\n    }\n    if (followers+leaders > 0 && standalone == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n    }\n    if (status.equals(STATUS_NA)) {\n      if (numOk == zookeepers.size()) {\n        status = STATUS_GREEN;\n      } else if (numOk < zookeepers.size() && numOk > zookeepers.size() / 2) {\n        status = STATUS_YELLOW;\n        errors.add(\"Some zookeepers are down: \" + numOk + \"/\" + zookeepers.size());\n      } else {\n        status = STATUS_RED;\n        errors.add(\"Mismatch in number of zookeeper nodes live. numOK=\" + numOk + \", expected \" + zookeepers.size());\n      }\n    }\n    zkStatus.put(\"status\", status);\n    if (!errors.isEmpty()) {\n      zkStatus.put(\"errors\", errors);\n    }\n    return zkStatus;\n  }\n\n","sourceOld":"  /**\n   * For each zk host, resolved either from zk connection string or from zk dynamic reconfiguration config,\n   * fetch all config and status info from ZK API and returns as a map, where key is hostname\n   * @param zkHost zookeeper connection string\n   * @param zkDynamicConfig list of zk dynamic config objects\n   * @return map of zookeeper config and status per zk host\n   */\n  protected Map<String, Object> getZkStatus(String zkHost, ZkDynamicConfig zkDynamicConfig) {\n    final ZkDynamicConfig hostsFromConnectionString = ZkDynamicConfig.fromZkConnectString(zkHost);\n    final ZkDynamicConfig zookeepers;\n    boolean dynamicReconfig;\n    final List<String> errors = new ArrayList<>();\n    String status = STATUS_NA;\n\n    if (zkDynamicConfig.size() == 0) {\n      // Fallback to parsing zkHost for older zk servers without support for dynamic reconfiguration\n      dynamicReconfig = false;\n      zookeepers = hostsFromConnectionString;\n    } else {\n      dynamicReconfig = true;\n      List<String> connStringHosts = hostsFromConnectionString.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      List<String> dynamicHosts = zkDynamicConfig.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      if (!connStringHosts.containsAll(dynamicHosts)) {\n        errors.add(\"Your ZK connection string (\" + connStringHosts.size() + \" hosts) is different from the \" +\n                \"dynamic ensemble config (\" + dynamicHosts.size() + \" hosts). Solr does not currently support \" +\n                \"dynamic reconfiguration and will only be able to connect to the zk hosts in your connection string.\");\n        status = STATUS_YELLOW;\n      }\n      zookeepers = zkDynamicConfig; // Clone input\n    }\n    final Map<String, Object> zkStatus = new HashMap<>();\n    final List<Object> details = new ArrayList<>();\n    int numOk = 0;\n    int standalone = 0;\n    int followers = 0;\n    int reportedFollowers = 0;\n    int leaders = 0;\n    zkStatus.put(\"ensembleSize\", zookeepers.size());\n    zkStatus.put(\"zkHost\", zkHost);\n    for (ZkDynamicConfig.Server zk : zookeepers.getServers()) {\n      final String zkClientHostPort = zk.resolveClientPortAddress() + \":\" + zk.clientPort;\n      try {\n        Map<String, Object> stat = monitorZookeeper(zkClientHostPort);\n        if (stat.containsKey(\"errors\")) {\n          errors.addAll((List<String>)stat.get(\"errors\"));\n          stat.remove(\"errors\");\n        }\n        details.add(stat);\n        if (\"true\".equals(String.valueOf(stat.get(\"ok\")))) {\n          numOk++;\n        }\n        String state = String.valueOf(stat.get(\"zk_server_state\"));\n        if (\"follower\".equals(state) || \"observer\".equals(state)) {\n          followers++;\n        } else if (\"leader\".equals(state)) {\n          leaders++;\n          reportedFollowers = Math.max(\n              Integer.parseInt((String) stat.getOrDefault(\"zk_followers\", \"0\")),\n              Integer.parseInt((String) stat.getOrDefault(\"zk_synced_followers\", \"0\"))\n          );\n        } else if (\"standalone\".equals(state)) {\n          standalone++;\n        }\n        if (zk.role != null) {\n          stat.put(\"role\", zk.role);\n        }\n      } catch (SolrException se) {\n        log.warn(\"Failed talking to zookeeper {}\", zkClientHostPort, se);\n        errors.add(se.getMessage());\n        Map<String, Object> stat = new HashMap<>();\n        stat.put(\"host\", zkClientHostPort);\n        stat.put(\"ok\", false);\n        status = STATUS_YELLOW;\n        details.add(stat);\n      }\n    }\n    zkStatus.put(\"details\", details);\n    zkStatus.put(\"dynamicReconfig\", dynamicReconfig);\n    if (followers+leaders > 0 && standalone > 0) {\n      status = STATUS_RED;\n      errors.add(\"The zk nodes do not agree on their mode, check details\");\n    }\n    if (standalone > 1) {\n      status = STATUS_RED;\n      errors.add(\"Only one zk allowed in standalone mode\");\n    }\n    if (leaders > 1) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Only one leader allowed, got \" + leaders);\n    }\n    if (followers > 0 && leaders == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"We do not have a leader\");\n    }\n    if (leaders > 0 && followers != reportedFollowers) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Leader reports \" + reportedFollowers + \" followers, but we only found \" + followers + \n        \". Please check zkHost configuration\");\n    }\n    if (followers+leaders == 0 && standalone == 1) {\n      zkStatus.put(\"mode\", \"standalone\");\n    }\n    if (followers+leaders > 0 && (zookeepers.size())%2 == 0) {\n      if (!STATUS_RED.equals(status)) {\n        status = STATUS_YELLOW;\n      }\n      errors.add(\"We have an even number of zookeepers which is not recommended\");\n    }\n    if (followers+leaders > 0 && standalone == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n    }\n    if (status.equals(STATUS_NA)) {\n      if (numOk == zookeepers.size()) {\n        status = STATUS_GREEN;\n      } else if (numOk < zookeepers.size() && numOk > zookeepers.size() / 2) {\n        status = STATUS_YELLOW;\n        errors.add(\"Some zookeepers are down: \" + numOk + \"/\" + zookeepers.size());\n      } else {\n        status = STATUS_RED;\n        errors.add(\"Mismatch in number of zookeeper nodes live. numOK=\" + numOk + \", expected \" + zookeepers.size());\n      }\n    }\n    zkStatus.put(\"status\", status);\n    if (!errors.isEmpty()) {\n      zkStatus.put(\"errors\", errors);\n    }\n    return zkStatus;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e1d86fe37bc067ae054ff809ec807433b2b7387","date":1596011582,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperStatusHandler#getZkStatus(String,ZkDynamicConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperStatusHandler#getZkStatus(String,ZkDynamicConfig).mjava","sourceNew":"  /**\n   * For each zk host, resolved either from zk connection string or from zk dynamic reconfiguration config,\n   * fetch all config and status info from ZK API and returns as a map, where key is hostname\n   * @param zkHost zookeeper connection string\n   * @param zkDynamicConfig list of zk dynamic config objects\n   * @return map of zookeeper config and status per zk host\n   */\n  @SuppressWarnings({\"unchecked\"})\n  protected Map<String, Object> getZkStatus(String zkHost, ZkDynamicConfig zkDynamicConfig) {\n    final ZkDynamicConfig hostsFromConnectionString = ZkDynamicConfig.fromZkConnectString(zkHost);\n    final ZkDynamicConfig zookeepers;\n    boolean dynamicReconfig;\n    final List<String> errors = new ArrayList<>();\n    String status = STATUS_NA;\n\n    if (zkDynamicConfig.size() == 0) {\n      // Fallback to parsing zkHost for older zk servers without support for dynamic reconfiguration\n      dynamicReconfig = false;\n      zookeepers = hostsFromConnectionString;\n    } else {\n      dynamicReconfig = true;\n      List<String> connStringHosts = hostsFromConnectionString.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      List<String> dynamicHosts = zkDynamicConfig.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" +\n                  (h.clientPort != null ? h.clientPort : hostsFromConnectionString.getServers().get(0).clientPort))\n          .sorted().collect(Collectors.toList());\n      if (!connStringHosts.containsAll(dynamicHosts)) {\n        errors.add(\"Your ZK connection string (\" + connStringHosts.size() + \" hosts) is different from the \" +\n                \"dynamic ensemble config (\" + dynamicHosts.size() + \" hosts). Solr does not currently support \" +\n                \"dynamic reconfiguration and will only be able to connect to the zk hosts in your connection string.\");\n        status = STATUS_YELLOW;\n      }\n      if (zkDynamicConfig.getServers().get(0).clientPort != null) {\n        // If we have dynamic config with client ports, use this list to iterate servers\n        zookeepers = zkDynamicConfig;\n      } else {\n        // Use list from connection string since client port is missing on dynamic config from ZK\n        zookeepers = hostsFromConnectionString;\n      }\n    }\n    final Map<String, Object> zkStatus = new HashMap<>();\n    final List<Object> details = new ArrayList<>();\n    int numOk = 0;\n    int standalone = 0;\n    int followers = 0;\n    int reportedFollowers = 0;\n    int leaders = 0;\n    zkStatus.put(\"ensembleSize\", zookeepers.size());\n    zkStatus.put(\"zkHost\", zkHost);\n    for (ZkDynamicConfig.Server zk : zookeepers.getServers()) {\n      final String zkClientHostPort = zk.resolveClientPortAddress() + \":\" + zk.clientPort;\n      try {\n        Map<String, Object> stat = monitorZookeeper(zkClientHostPort);\n        if (stat.containsKey(\"errors\")) {\n          errors.addAll((List<String>)stat.get(\"errors\"));\n          stat.remove(\"errors\");\n        }\n        details.add(stat);\n        if (\"true\".equals(String.valueOf(stat.get(\"ok\")))) {\n          numOk++;\n        }\n        String state = String.valueOf(stat.get(\"zk_server_state\"));\n        if (\"follower\".equals(state) || \"observer\".equals(state)) {\n          followers++;\n        } else if (\"leader\".equals(state)) {\n          leaders++;\n          reportedFollowers = Math.max(\n              Integer.parseInt((String) stat.getOrDefault(\"zk_followers\", \"0\")),\n              Integer.parseInt((String) stat.getOrDefault(\"zk_synced_followers\", \"0\"))\n          );\n        } else if (\"standalone\".equals(state)) {\n          standalone++;\n        }\n        if (zk.role != null) {\n          stat.put(\"role\", zk.role);\n        }\n      } catch (SolrException se) {\n        log.warn(\"Failed talking to zookeeper {}\", zkClientHostPort, se);\n        errors.add(se.getMessage());\n        Map<String, Object> stat = new HashMap<>();\n        stat.put(\"host\", zkClientHostPort);\n        stat.put(\"ok\", false);\n        status = STATUS_YELLOW;\n        details.add(stat);\n      }\n    }\n    zkStatus.put(\"details\", details);\n    zkStatus.put(\"dynamicReconfig\", dynamicReconfig);\n    if (followers+leaders > 0 && standalone > 0) {\n      status = STATUS_RED;\n      errors.add(\"The zk nodes do not agree on their mode, check details\");\n    }\n    if (standalone > 1) {\n      status = STATUS_RED;\n      errors.add(\"Only one zk allowed in standalone mode\");\n    }\n    if (leaders > 1) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Only one leader allowed, got \" + leaders);\n    }\n    if (followers > 0 && leaders == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"We do not have a leader\");\n    }\n    if (leaders > 0 && followers != reportedFollowers) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Leader reports \" + reportedFollowers + \" followers, but we only found \" + followers + \n        \". Please check zkHost configuration\");\n    }\n    if (followers+leaders == 0 && standalone == 1) {\n      zkStatus.put(\"mode\", \"standalone\");\n    }\n    if (followers+leaders > 0 && (zookeepers.size())%2 == 0) {\n      if (!STATUS_RED.equals(status)) {\n        status = STATUS_YELLOW;\n      }\n      errors.add(\"We have an even number of zookeepers which is not recommended\");\n    }\n    if (followers+leaders > 0 && standalone == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n    }\n    if (status.equals(STATUS_NA)) {\n      if (numOk == zookeepers.size()) {\n        status = STATUS_GREEN;\n      } else if (numOk < zookeepers.size() && numOk > zookeepers.size() / 2) {\n        status = STATUS_YELLOW;\n        errors.add(\"Some zookeepers are down: \" + numOk + \"/\" + zookeepers.size());\n      } else {\n        status = STATUS_RED;\n        errors.add(\"Mismatch in number of zookeeper nodes live. numOK=\" + numOk + \", expected \" + zookeepers.size());\n      }\n    }\n    zkStatus.put(\"status\", status);\n    if (!errors.isEmpty()) {\n      zkStatus.put(\"errors\", errors);\n    }\n    return zkStatus;\n  }\n\n","sourceOld":"  /**\n   * For each zk host, resolved either from zk connection string or from zk dynamic reconfiguration config,\n   * fetch all config and status info from ZK API and returns as a map, where key is hostname\n   * @param zkHost zookeeper connection string\n   * @param zkDynamicConfig list of zk dynamic config objects\n   * @return map of zookeeper config and status per zk host\n   */\n  @SuppressWarnings({\"unchecked\"})\n  protected Map<String, Object> getZkStatus(String zkHost, ZkDynamicConfig zkDynamicConfig) {\n    final ZkDynamicConfig hostsFromConnectionString = ZkDynamicConfig.fromZkConnectString(zkHost);\n    final ZkDynamicConfig zookeepers;\n    boolean dynamicReconfig;\n    final List<String> errors = new ArrayList<>();\n    String status = STATUS_NA;\n\n    if (zkDynamicConfig.size() == 0) {\n      // Fallback to parsing zkHost for older zk servers without support for dynamic reconfiguration\n      dynamicReconfig = false;\n      zookeepers = hostsFromConnectionString;\n    } else {\n      dynamicReconfig = true;\n      List<String> connStringHosts = hostsFromConnectionString.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      List<String> dynamicHosts = zkDynamicConfig.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      if (!connStringHosts.containsAll(dynamicHosts)) {\n        errors.add(\"Your ZK connection string (\" + connStringHosts.size() + \" hosts) is different from the \" +\n                \"dynamic ensemble config (\" + dynamicHosts.size() + \" hosts). Solr does not currently support \" +\n                \"dynamic reconfiguration and will only be able to connect to the zk hosts in your connection string.\");\n        status = STATUS_YELLOW;\n      }\n      zookeepers = zkDynamicConfig; // Clone input\n    }\n    final Map<String, Object> zkStatus = new HashMap<>();\n    final List<Object> details = new ArrayList<>();\n    int numOk = 0;\n    int standalone = 0;\n    int followers = 0;\n    int reportedFollowers = 0;\n    int leaders = 0;\n    zkStatus.put(\"ensembleSize\", zookeepers.size());\n    zkStatus.put(\"zkHost\", zkHost);\n    for (ZkDynamicConfig.Server zk : zookeepers.getServers()) {\n      final String zkClientHostPort = zk.resolveClientPortAddress() + \":\" + zk.clientPort;\n      try {\n        Map<String, Object> stat = monitorZookeeper(zkClientHostPort);\n        if (stat.containsKey(\"errors\")) {\n          errors.addAll((List<String>)stat.get(\"errors\"));\n          stat.remove(\"errors\");\n        }\n        details.add(stat);\n        if (\"true\".equals(String.valueOf(stat.get(\"ok\")))) {\n          numOk++;\n        }\n        String state = String.valueOf(stat.get(\"zk_server_state\"));\n        if (\"follower\".equals(state) || \"observer\".equals(state)) {\n          followers++;\n        } else if (\"leader\".equals(state)) {\n          leaders++;\n          reportedFollowers = Math.max(\n              Integer.parseInt((String) stat.getOrDefault(\"zk_followers\", \"0\")),\n              Integer.parseInt((String) stat.getOrDefault(\"zk_synced_followers\", \"0\"))\n          );\n        } else if (\"standalone\".equals(state)) {\n          standalone++;\n        }\n        if (zk.role != null) {\n          stat.put(\"role\", zk.role);\n        }\n      } catch (SolrException se) {\n        log.warn(\"Failed talking to zookeeper {}\", zkClientHostPort, se);\n        errors.add(se.getMessage());\n        Map<String, Object> stat = new HashMap<>();\n        stat.put(\"host\", zkClientHostPort);\n        stat.put(\"ok\", false);\n        status = STATUS_YELLOW;\n        details.add(stat);\n      }\n    }\n    zkStatus.put(\"details\", details);\n    zkStatus.put(\"dynamicReconfig\", dynamicReconfig);\n    if (followers+leaders > 0 && standalone > 0) {\n      status = STATUS_RED;\n      errors.add(\"The zk nodes do not agree on their mode, check details\");\n    }\n    if (standalone > 1) {\n      status = STATUS_RED;\n      errors.add(\"Only one zk allowed in standalone mode\");\n    }\n    if (leaders > 1) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Only one leader allowed, got \" + leaders);\n    }\n    if (followers > 0 && leaders == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"We do not have a leader\");\n    }\n    if (leaders > 0 && followers != reportedFollowers) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Leader reports \" + reportedFollowers + \" followers, but we only found \" + followers + \n        \". Please check zkHost configuration\");\n    }\n    if (followers+leaders == 0 && standalone == 1) {\n      zkStatus.put(\"mode\", \"standalone\");\n    }\n    if (followers+leaders > 0 && (zookeepers.size())%2 == 0) {\n      if (!STATUS_RED.equals(status)) {\n        status = STATUS_YELLOW;\n      }\n      errors.add(\"We have an even number of zookeepers which is not recommended\");\n    }\n    if (followers+leaders > 0 && standalone == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n    }\n    if (status.equals(STATUS_NA)) {\n      if (numOk == zookeepers.size()) {\n        status = STATUS_GREEN;\n      } else if (numOk < zookeepers.size() && numOk > zookeepers.size() / 2) {\n        status = STATUS_YELLOW;\n        errors.add(\"Some zookeepers are down: \" + numOk + \"/\" + zookeepers.size());\n      } else {\n        status = STATUS_RED;\n        errors.add(\"Mismatch in number of zookeeper nodes live. numOK=\" + numOk + \", expected \" + zookeepers.size());\n      }\n    }\n    zkStatus.put(\"status\", status);\n    if (!errors.isEmpty()) {\n      zkStatus.put(\"errors\", errors);\n    }\n    return zkStatus;\n  }\n\n","bugFix":["861042e9f93a922bfb6b6b2c3d44b61fb3504894"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e2e572da46604eb6afebc7b0f11d14a26d65b846","date":1598429022,"type":3,"author":"Philipp Trulson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperStatusHandler#getZkStatus(String,ZkDynamicConfig).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ZookeeperStatusHandler#getZkStatus(String,ZkDynamicConfig).mjava","sourceNew":"  /**\n   * For each zk host, resolved either from zk connection string or from zk dynamic reconfiguration config,\n   * fetch all config and status info from ZK API and returns as a map, where key is hostname\n   * @param zkHost zookeeper connection string\n   * @param zkDynamicConfig list of zk dynamic config objects\n   * @return map of zookeeper config and status per zk host\n   */\n  @SuppressWarnings({\"unchecked\"})\n  protected Map<String, Object> getZkStatus(String zkHost, ZkDynamicConfig zkDynamicConfig) {\n    final ZkDynamicConfig hostsFromConnectionString = ZkDynamicConfig.fromZkConnectString(zkHost);\n    final ZkDynamicConfig zookeepers;\n    boolean dynamicReconfig;\n    final List<String> errors = new ArrayList<>();\n    String status = STATUS_NA;\n\n    if (zkDynamicConfig.size() == 0) {\n      // Fallback to parsing zkHost for older zk servers without support for dynamic reconfiguration\n      dynamicReconfig = false;\n      zookeepers = hostsFromConnectionString;\n    } else {\n      dynamicReconfig = true;\n      List<String> connStringHosts = hostsFromConnectionString.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      List<String> dynamicHosts = zkDynamicConfig.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" +\n                  (h.clientPort != null ? h.clientPort : hostsFromConnectionString.getServers().get(0).clientPort))\n          .sorted().collect(Collectors.toList());\n      if (!connStringHosts.containsAll(dynamicHosts)) {\n        errors.add(\"Your ZK connection string (\" + connStringHosts.size() + \" hosts) is different from the \" +\n                \"dynamic ensemble config (\" + dynamicHosts.size() + \" hosts). Solr does not currently support \" +\n                \"dynamic reconfiguration and will only be able to connect to the zk hosts in your connection string.\");\n        status = STATUS_YELLOW;\n      }\n      if (zkDynamicConfig.getServers().get(0).clientPort != null) {\n        // If we have dynamic config with client ports, use this list to iterate servers\n        zookeepers = zkDynamicConfig;\n      } else {\n        // Use list from connection string since client port is missing on dynamic config from ZK\n        zookeepers = hostsFromConnectionString;\n      }\n    }\n    final Map<String, Object> zkStatus = new HashMap<>();\n    final List<Object> details = new ArrayList<>();\n    int numOk = 0;\n    int standalone = 0;\n    int followers = 0;\n    int reportedFollowers = 0;\n    int leaders = 0;\n    zkStatus.put(\"ensembleSize\", zookeepers.size());\n    zkStatus.put(\"zkHost\", zkHost);\n    for (ZkDynamicConfig.Server zk : zookeepers.getServers()) {\n      final String zkClientHostPort = zk.resolveClientPortAddress() + \":\" + zk.clientPort;\n      try {\n        Map<String, Object> stat = monitorZookeeper(zkClientHostPort);\n        if (stat.containsKey(\"errors\")) {\n          errors.addAll((List<String>)stat.get(\"errors\"));\n          stat.remove(\"errors\");\n        }\n        details.add(stat);\n        if (\"true\".equals(String.valueOf(stat.get(\"ok\")))) {\n          numOk++;\n        }\n        String state = String.valueOf(stat.get(\"zk_server_state\"));\n        if (\"follower\".equals(state) || \"observer\".equals(state)) {\n          followers++;\n        } else if (\"leader\".equals(state)) {\n          leaders++;\n          reportedFollowers = Math.max(\n              (int) Float.parseFloat((String) stat.getOrDefault(\"zk_followers\", \"0\")),\n              (int) Float.parseFloat((String) stat.getOrDefault(\"zk_synced_followers\", \"0\"))\n          );\n        } else if (\"standalone\".equals(state)) {\n          standalone++;\n        }\n        if (zk.role != null) {\n          stat.put(\"role\", zk.role);\n        }\n      } catch (SolrException se) {\n        log.warn(\"Failed talking to zookeeper {}\", zkClientHostPort, se);\n        errors.add(se.getMessage());\n        Map<String, Object> stat = new HashMap<>();\n        stat.put(\"host\", zkClientHostPort);\n        stat.put(\"ok\", false);\n        status = STATUS_YELLOW;\n        details.add(stat);\n      }\n    }\n    zkStatus.put(\"details\", details);\n    zkStatus.put(\"dynamicReconfig\", dynamicReconfig);\n    if (followers+leaders > 0 && standalone > 0) {\n      status = STATUS_RED;\n      errors.add(\"The zk nodes do not agree on their mode, check details\");\n    }\n    if (standalone > 1) {\n      status = STATUS_RED;\n      errors.add(\"Only one zk allowed in standalone mode\");\n    }\n    if (leaders > 1) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Only one leader allowed, got \" + leaders);\n    }\n    if (followers > 0 && leaders == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"We do not have a leader\");\n    }\n    if (leaders > 0 && followers != reportedFollowers) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Leader reports \" + reportedFollowers + \" followers, but we only found \" + followers + \n        \". Please check zkHost configuration\");\n    }\n    if (followers+leaders == 0 && standalone == 1) {\n      zkStatus.put(\"mode\", \"standalone\");\n    }\n    if (followers+leaders > 0 && (zookeepers.size())%2 == 0) {\n      if (!STATUS_RED.equals(status)) {\n        status = STATUS_YELLOW;\n      }\n      errors.add(\"We have an even number of zookeepers which is not recommended\");\n    }\n    if (followers+leaders > 0 && standalone == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n    }\n    if (status.equals(STATUS_NA)) {\n      if (numOk == zookeepers.size()) {\n        status = STATUS_GREEN;\n      } else if (numOk < zookeepers.size() && numOk > zookeepers.size() / 2) {\n        status = STATUS_YELLOW;\n        errors.add(\"Some zookeepers are down: \" + numOk + \"/\" + zookeepers.size());\n      } else {\n        status = STATUS_RED;\n        errors.add(\"Mismatch in number of zookeeper nodes live. numOK=\" + numOk + \", expected \" + zookeepers.size());\n      }\n    }\n    zkStatus.put(\"status\", status);\n    if (!errors.isEmpty()) {\n      zkStatus.put(\"errors\", errors);\n    }\n    return zkStatus;\n  }\n\n","sourceOld":"  /**\n   * For each zk host, resolved either from zk connection string or from zk dynamic reconfiguration config,\n   * fetch all config and status info from ZK API and returns as a map, where key is hostname\n   * @param zkHost zookeeper connection string\n   * @param zkDynamicConfig list of zk dynamic config objects\n   * @return map of zookeeper config and status per zk host\n   */\n  @SuppressWarnings({\"unchecked\"})\n  protected Map<String, Object> getZkStatus(String zkHost, ZkDynamicConfig zkDynamicConfig) {\n    final ZkDynamicConfig hostsFromConnectionString = ZkDynamicConfig.fromZkConnectString(zkHost);\n    final ZkDynamicConfig zookeepers;\n    boolean dynamicReconfig;\n    final List<String> errors = new ArrayList<>();\n    String status = STATUS_NA;\n\n    if (zkDynamicConfig.size() == 0) {\n      // Fallback to parsing zkHost for older zk servers without support for dynamic reconfiguration\n      dynamicReconfig = false;\n      zookeepers = hostsFromConnectionString;\n    } else {\n      dynamicReconfig = true;\n      List<String> connStringHosts = hostsFromConnectionString.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" + h.clientPort)\n          .sorted().collect(Collectors.toList());\n      List<String> dynamicHosts = zkDynamicConfig.getServers().stream()\n          .map(h -> h.resolveClientPortAddress() + \":\" +\n                  (h.clientPort != null ? h.clientPort : hostsFromConnectionString.getServers().get(0).clientPort))\n          .sorted().collect(Collectors.toList());\n      if (!connStringHosts.containsAll(dynamicHosts)) {\n        errors.add(\"Your ZK connection string (\" + connStringHosts.size() + \" hosts) is different from the \" +\n                \"dynamic ensemble config (\" + dynamicHosts.size() + \" hosts). Solr does not currently support \" +\n                \"dynamic reconfiguration and will only be able to connect to the zk hosts in your connection string.\");\n        status = STATUS_YELLOW;\n      }\n      if (zkDynamicConfig.getServers().get(0).clientPort != null) {\n        // If we have dynamic config with client ports, use this list to iterate servers\n        zookeepers = zkDynamicConfig;\n      } else {\n        // Use list from connection string since client port is missing on dynamic config from ZK\n        zookeepers = hostsFromConnectionString;\n      }\n    }\n    final Map<String, Object> zkStatus = new HashMap<>();\n    final List<Object> details = new ArrayList<>();\n    int numOk = 0;\n    int standalone = 0;\n    int followers = 0;\n    int reportedFollowers = 0;\n    int leaders = 0;\n    zkStatus.put(\"ensembleSize\", zookeepers.size());\n    zkStatus.put(\"zkHost\", zkHost);\n    for (ZkDynamicConfig.Server zk : zookeepers.getServers()) {\n      final String zkClientHostPort = zk.resolveClientPortAddress() + \":\" + zk.clientPort;\n      try {\n        Map<String, Object> stat = monitorZookeeper(zkClientHostPort);\n        if (stat.containsKey(\"errors\")) {\n          errors.addAll((List<String>)stat.get(\"errors\"));\n          stat.remove(\"errors\");\n        }\n        details.add(stat);\n        if (\"true\".equals(String.valueOf(stat.get(\"ok\")))) {\n          numOk++;\n        }\n        String state = String.valueOf(stat.get(\"zk_server_state\"));\n        if (\"follower\".equals(state) || \"observer\".equals(state)) {\n          followers++;\n        } else if (\"leader\".equals(state)) {\n          leaders++;\n          reportedFollowers = Math.max(\n              Integer.parseInt((String) stat.getOrDefault(\"zk_followers\", \"0\")),\n              Integer.parseInt((String) stat.getOrDefault(\"zk_synced_followers\", \"0\"))\n          );\n        } else if (\"standalone\".equals(state)) {\n          standalone++;\n        }\n        if (zk.role != null) {\n          stat.put(\"role\", zk.role);\n        }\n      } catch (SolrException se) {\n        log.warn(\"Failed talking to zookeeper {}\", zkClientHostPort, se);\n        errors.add(se.getMessage());\n        Map<String, Object> stat = new HashMap<>();\n        stat.put(\"host\", zkClientHostPort);\n        stat.put(\"ok\", false);\n        status = STATUS_YELLOW;\n        details.add(stat);\n      }\n    }\n    zkStatus.put(\"details\", details);\n    zkStatus.put(\"dynamicReconfig\", dynamicReconfig);\n    if (followers+leaders > 0 && standalone > 0) {\n      status = STATUS_RED;\n      errors.add(\"The zk nodes do not agree on their mode, check details\");\n    }\n    if (standalone > 1) {\n      status = STATUS_RED;\n      errors.add(\"Only one zk allowed in standalone mode\");\n    }\n    if (leaders > 1) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Only one leader allowed, got \" + leaders);\n    }\n    if (followers > 0 && leaders == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"We do not have a leader\");\n    }\n    if (leaders > 0 && followers != reportedFollowers) {\n      zkStatus.put(\"mode\", \"ensemble\");\n      status = STATUS_RED;\n      errors.add(\"Leader reports \" + reportedFollowers + \" followers, but we only found \" + followers + \n        \". Please check zkHost configuration\");\n    }\n    if (followers+leaders == 0 && standalone == 1) {\n      zkStatus.put(\"mode\", \"standalone\");\n    }\n    if (followers+leaders > 0 && (zookeepers.size())%2 == 0) {\n      if (!STATUS_RED.equals(status)) {\n        status = STATUS_YELLOW;\n      }\n      errors.add(\"We have an even number of zookeepers which is not recommended\");\n    }\n    if (followers+leaders > 0 && standalone == 0) {\n      zkStatus.put(\"mode\", \"ensemble\");\n    }\n    if (status.equals(STATUS_NA)) {\n      if (numOk == zookeepers.size()) {\n        status = STATUS_GREEN;\n      } else if (numOk < zookeepers.size() && numOk > zookeepers.size() / 2) {\n        status = STATUS_YELLOW;\n        errors.add(\"Some zookeepers are down: \" + numOk + \"/\" + zookeepers.size());\n      } else {\n        status = STATUS_RED;\n        errors.add(\"Mismatch in number of zookeeper nodes live. numOK=\" + numOk + \", expected \" + zookeepers.size());\n      }\n    }\n    zkStatus.put(\"status\", status);\n    if (!errors.isEmpty()) {\n      zkStatus.put(\"errors\", errors);\n    }\n    return zkStatus;\n  }\n\n","bugFix":["e593401f7b75b207ee04c2f8381fc5df0251b1d4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ba055e19afc289adcb5bedaf68513793a7254012":["e593401f7b75b207ee04c2f8381fc5df0251b1d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5e1d86fe37bc067ae054ff809ec807433b2b7387":["ba055e19afc289adcb5bedaf68513793a7254012"],"861042e9f93a922bfb6b6b2c3d44b61fb3504894":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"575e66bd4b2349209027f6801184da7fc3cba13f":["861042e9f93a922bfb6b6b2c3d44b61fb3504894"],"e2e572da46604eb6afebc7b0f11d14a26d65b846":["5e1d86fe37bc067ae054ff809ec807433b2b7387"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e2e572da46604eb6afebc7b0f11d14a26d65b846"],"e593401f7b75b207ee04c2f8381fc5df0251b1d4":["575e66bd4b2349209027f6801184da7fc3cba13f"]},"commit2Childs":{"ba055e19afc289adcb5bedaf68513793a7254012":["5e1d86fe37bc067ae054ff809ec807433b2b7387"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["861042e9f93a922bfb6b6b2c3d44b61fb3504894"],"5e1d86fe37bc067ae054ff809ec807433b2b7387":["e2e572da46604eb6afebc7b0f11d14a26d65b846"],"861042e9f93a922bfb6b6b2c3d44b61fb3504894":["575e66bd4b2349209027f6801184da7fc3cba13f"],"575e66bd4b2349209027f6801184da7fc3cba13f":["e593401f7b75b207ee04c2f8381fc5df0251b1d4"],"e2e572da46604eb6afebc7b0f11d14a26d65b846":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e593401f7b75b207ee04c2f8381fc5df0251b1d4":["ba055e19afc289adcb5bedaf68513793a7254012"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}