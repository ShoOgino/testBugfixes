{"path":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testSortedIndexWithInvalidSort().mjava","commits":[{"id":"67d866889b0c200f91ef946ae758a42d324216da","date":1544206319,"type":0,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testSortedIndexWithInvalidSort().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Tests that {@link CheckIndex} can detect invalid sort on sorted indices created\n   * before https://issues.apache.org/jira/browse/LUCENE-8592.\n   */\n  public void testSortedIndexWithInvalidSort() throws Exception {\n    Path path = createTempDir(\"sorted\");\n    String name = \"sorted-invalid.7.5.0.zip\";\n    InputStream resource = TestBackwardsCompatibility.class.getResourceAsStream(name);\n    assertNotNull(\"Sorted index index \" + name + \" not found\", resource);\n    TestUtil.unzip(resource, path);\n\n    Directory dir = FSDirectory.open(path);\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    Sort sort = reader.leaves().get(0).reader().getMetaData().getSort();\n    assertNotNull(sort);\n    assertEquals(\"<long: \\\"dateDV\\\">! missingValue=-9223372036854775808\", sort.toString());\n    reader.close();\n    CheckIndex.Status status = TestUtil.checkIndex(dir);\n    assertEquals(1, status.segmentInfos.size());\n    assertNotNull(status.segmentInfos.get(0).indexSortStatus.error);\n    assertEquals(status.segmentInfos.get(0).indexSortStatus.error.getMessage(),\n        \"segment has indexSort=<long: \\\"dateDV\\\">! missingValue=-9223372036854775808 but docID=4 sorts after docID=5\");\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66dc286cff642f0c485052d838cfba579b3f84d3","date":1544206544,"type":4,"author":"Jim Ferenczi","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testSortedIndexWithInvalidSort().mjava","sourceNew":null,"sourceOld":"  /**\n   * Tests that {@link CheckIndex} can detect invalid sort on sorted indices created\n   * before https://issues.apache.org/jira/browse/LUCENE-8592.\n   */\n  public void testSortedIndexWithInvalidSort() throws Exception {\n    Path path = createTempDir(\"sorted\");\n    String name = \"sorted-invalid.7.5.0.zip\";\n    InputStream resource = TestBackwardsCompatibility.class.getResourceAsStream(name);\n    assertNotNull(\"Sorted index index \" + name + \" not found\", resource);\n    TestUtil.unzip(resource, path);\n\n    Directory dir = FSDirectory.open(path);\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    Sort sort = reader.leaves().get(0).reader().getMetaData().getSort();\n    assertNotNull(sort);\n    assertEquals(\"<long: \\\"dateDV\\\">! missingValue=-9223372036854775808\", sort.toString());\n    reader.close();\n    CheckIndex.Status status = TestUtil.checkIndex(dir);\n    assertEquals(1, status.segmentInfos.size());\n    assertNotNull(status.segmentInfos.get(0).indexSortStatus.error);\n    assertEquals(status.segmentInfos.get(0).indexSortStatus.error.getMessage(),\n        \"segment has indexSort=<long: \\\"dateDV\\\">! missingValue=-9223372036854775808 but docID=4 sorts after docID=5\");\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"76b2395079a51ec9c99b4d38c3967f035ab47cdb","date":1544206602,"type":0,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testSortedIndexWithInvalidSort().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Tests that {@link CheckIndex} can detect invalid sort on sorted indices created\n   * before https://issues.apache.org/jira/browse/LUCENE-8592.\n   */\n  public void testSortedIndexWithInvalidSort() throws Exception {\n    Path path = createTempDir(\"sorted\");\n    String name = \"sorted-invalid.7.5.0.zip\";\n    InputStream resource = TestBackwardsCompatibility.class.getResourceAsStream(name);\n    assertNotNull(\"Sorted index index \" + name + \" not found\", resource);\n    TestUtil.unzip(resource, path);\n\n    Directory dir = FSDirectory.open(path);\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    Sort sort = reader.leaves().get(0).reader().getMetaData().getSort();\n    assertNotNull(sort);\n    assertEquals(\"<long: \\\"dateDV\\\">! missingValue=-9223372036854775808\", sort.toString());\n    reader.close();\n    CheckIndex.Status status = TestUtil.checkIndex(dir);\n    assertEquals(1, status.segmentInfos.size());\n    assertNotNull(status.segmentInfos.get(0).indexSortStatus.error);\n    assertEquals(status.segmentInfos.get(0).indexSortStatus.error.getMessage(),\n        \"segment has indexSort=<long: \\\"dateDV\\\">! missingValue=-9223372036854775808 but docID=4 sorts after docID=5\");\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d722b735bc69d2234e957cb69cf96ad28ea7e1c3","date":1546867201,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testSortedIndexWithInvalidSort().mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testSortedIndexWithInvalidSort().mjava","sourceNew":"  /**\n   * Tests that {@link CheckIndex} can detect invalid sort on sorted indices created\n   * before https://issues.apache.org/jira/browse/LUCENE-8592.\n   */\n  public void testSortedIndexWithInvalidSort() throws Exception {\n    assumeTrue(\"Reenable when 8.0 is released\", false);\n    Path path = createTempDir(\"sorted\");\n    String name = \"sorted-invalid.8.0.0.zip\";\n    InputStream resource = TestBackwardsCompatibility.class.getResourceAsStream(name);\n    assertNotNull(\"Sorted index index \" + name + \" not found\", resource);\n    TestUtil.unzip(resource, path);\n\n    Directory dir = FSDirectory.open(path);\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    Sort sort = reader.leaves().get(0).reader().getMetaData().getSort();\n    assertNotNull(sort);\n    assertEquals(\"<long: \\\"dateDV\\\">! missingValue=-9223372036854775808\", sort.toString());\n    reader.close();\n    CheckIndex.Status status = TestUtil.checkIndex(dir);\n    assertEquals(1, status.segmentInfos.size());\n    assertNotNull(status.segmentInfos.get(0).indexSortStatus.error);\n    assertEquals(status.segmentInfos.get(0).indexSortStatus.error.getMessage(),\n        \"segment has indexSort=<long: \\\"dateDV\\\">! missingValue=-9223372036854775808 but docID=4 sorts after docID=5\");\n    dir.close();\n  }\n\n","sourceOld":"  /**\n   * Tests that {@link CheckIndex} can detect invalid sort on sorted indices created\n   * before https://issues.apache.org/jira/browse/LUCENE-8592.\n   */\n  public void testSortedIndexWithInvalidSort() throws Exception {\n    Path path = createTempDir(\"sorted\");\n    String name = \"sorted-invalid.7.5.0.zip\";\n    InputStream resource = TestBackwardsCompatibility.class.getResourceAsStream(name);\n    assertNotNull(\"Sorted index index \" + name + \" not found\", resource);\n    TestUtil.unzip(resource, path);\n\n    Directory dir = FSDirectory.open(path);\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    Sort sort = reader.leaves().get(0).reader().getMetaData().getSort();\n    assertNotNull(sort);\n    assertEquals(\"<long: \\\"dateDV\\\">! missingValue=-9223372036854775808\", sort.toString());\n    reader.close();\n    CheckIndex.Status status = TestUtil.checkIndex(dir);\n    assertEquals(1, status.segmentInfos.size());\n    assertNotNull(status.segmentInfos.get(0).indexSortStatus.error);\n    assertEquals(status.segmentInfos.get(0).indexSortStatus.error.getMessage(),\n        \"segment has indexSort=<long: \\\"dateDV\\\">! missingValue=-9223372036854775808 but docID=4 sorts after docID=5\");\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c167f43985b3d924e6402ded39beada51a81b6b","date":1552568413,"type":4,"author":"jimczi","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/index/TestBackwardsCompatibility#testSortedIndexWithInvalidSort().mjava","sourceNew":null,"sourceOld":"  /**\n   * Tests that {@link CheckIndex} can detect invalid sort on sorted indices created\n   * before https://issues.apache.org/jira/browse/LUCENE-8592.\n   */\n  public void testSortedIndexWithInvalidSort() throws Exception {\n    assumeTrue(\"Reenable when 8.0 is released\", false);\n    Path path = createTempDir(\"sorted\");\n    String name = \"sorted-invalid.8.0.0.zip\";\n    InputStream resource = TestBackwardsCompatibility.class.getResourceAsStream(name);\n    assertNotNull(\"Sorted index index \" + name + \" not found\", resource);\n    TestUtil.unzip(resource, path);\n\n    Directory dir = FSDirectory.open(path);\n\n    DirectoryReader reader = DirectoryReader.open(dir);\n    assertEquals(1, reader.leaves().size());\n    Sort sort = reader.leaves().get(0).reader().getMetaData().getSort();\n    assertNotNull(sort);\n    assertEquals(\"<long: \\\"dateDV\\\">! missingValue=-9223372036854775808\", sort.toString());\n    reader.close();\n    CheckIndex.Status status = TestUtil.checkIndex(dir);\n    assertEquals(1, status.segmentInfos.size());\n    assertNotNull(status.segmentInfos.get(0).indexSortStatus.error);\n    assertEquals(status.segmentInfos.get(0).indexSortStatus.error.getMessage(),\n        \"segment has indexSort=<long: \\\"dateDV\\\">! missingValue=-9223372036854775808 but docID=4 sorts after docID=5\");\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"66dc286cff642f0c485052d838cfba579b3f84d3":["67d866889b0c200f91ef946ae758a42d324216da"],"67d866889b0c200f91ef946ae758a42d324216da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"76b2395079a51ec9c99b4d38c3967f035ab47cdb":["66dc286cff642f0c485052d838cfba579b3f84d3"],"3c167f43985b3d924e6402ded39beada51a81b6b":["d722b735bc69d2234e957cb69cf96ad28ea7e1c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3c167f43985b3d924e6402ded39beada51a81b6b"],"d722b735bc69d2234e957cb69cf96ad28ea7e1c3":["76b2395079a51ec9c99b4d38c3967f035ab47cdb"]},"commit2Childs":{"66dc286cff642f0c485052d838cfba579b3f84d3":["76b2395079a51ec9c99b4d38c3967f035ab47cdb"],"67d866889b0c200f91ef946ae758a42d324216da":["66dc286cff642f0c485052d838cfba579b3f84d3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["67d866889b0c200f91ef946ae758a42d324216da"],"76b2395079a51ec9c99b4d38c3967f035ab47cdb":["d722b735bc69d2234e957cb69cf96ad28ea7e1c3"],"3c167f43985b3d924e6402ded39beada51a81b6b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d722b735bc69d2234e957cb69cf96ad28ea7e1c3":["3c167f43985b3d924e6402ded39beada51a81b6b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}