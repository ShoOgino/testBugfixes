{"path":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,OrdinalMap,int,int).mjava","commits":[{"id":"957c610636f393a85a38f1af670540028db13e6b","date":1500044517,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,OrdinalMap,int,int).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery,\n              rewrittenFromQuery, searcher.getTopReaderContext().id());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, scoreMode, joinField, ordinalMap, rewrittenToQuery,\n        rewrittenFromQuery, min, max, searcher.getTopReaderContext().id());\n  }\n\n","sourceOld":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery,\n              rewrittenFromQuery, searcher.getTopReaderContext().id());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, scoreMode, joinField, ordinalMap, rewrittenToQuery,\n        rewrittenFromQuery, min, max, searcher.getTopReaderContext().id());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":1,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,OrdinalMap,int,int).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/JoinUtil#createJoinQuery(String,Query,Query,IndexSearcher,ScoreMode,MultiDocValues.OrdinalMap,int,int).mjava","sourceNew":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery,\n              rewrittenFromQuery, searcher.getTopReaderContext().id());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, scoreMode, joinField, ordinalMap, rewrittenToQuery,\n        rewrittenFromQuery, min, max, searcher.getTopReaderContext().id());\n  }\n\n","sourceOld":"  /**\n   * A query time join using global ordinals over a dedicated join field.\n   *\n   * This join has certain restrictions and requirements:\n   * 1) A document can only refer to one other document. (but can be referred by one or more documents)\n   * 2) Documents on each side of the join must be distinguishable. Typically this can be done by adding an extra field\n   *    that identifies the \"from\" and \"to\" side and then the fromQuery and toQuery must take the this into account.\n   * 3) There must be a single sorted doc values join field used by both the \"from\" and \"to\" documents. This join field\n   *    should store the join values as UTF-8 strings.\n   * 4) An ordinal map must be provided that is created on top of the join field.\n   *\n   * Note: min and max filtering and the avg score mode will require this join to keep track of the number of times\n   * a document matches per join value. This will increase the per join cost in terms of execution time and memory.\n   *\n   * @param joinField   The {@link SortedDocValues} field containing the join values\n   * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match \"from\" documents.\n   * @param toQuery     The query identifying all documents on the \"to\" side.\n   * @param searcher    The index searcher used to execute the from query\n   * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query\n   * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map\n   *                    needs to be provided.\n   * @param min         Optionally the minimum number of \"from\" documents that are required to match for a \"to\" document\n   *                    to be a match. The min is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @param max         Optionally the maximum number of \"from\" documents that are allowed to match for a \"to\" document\n   *                    to be a match. The max is inclusive. Setting min to 0 and max to <code>Interger.MAX_VALUE</code>\n   *                    disables the min and max \"from\" documents filtering\n   * @return a {@link Query} instance that can be used to join documents based on the join field\n   * @throws IOException If I/O related errors occur\n   */\n  public static Query createJoinQuery(String joinField,\n                                      Query fromQuery,\n                                      Query toQuery,\n                                      IndexSearcher searcher,\n                                      ScoreMode scoreMode,\n                                      MultiDocValues.OrdinalMap ordinalMap,\n                                      int min,\n                                      int max) throws IOException {\n    int numSegments = searcher.getIndexReader().leaves().size();\n    final long valueCount;\n    if (numSegments == 0) {\n      return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery with no segments\");\n    } else if (numSegments == 1) {\n      // No need to use the ordinal map, because there is just one segment.\n      ordinalMap = null;\n      LeafReader leafReader = searcher.getIndexReader().leaves().get(0).reader();\n      SortedDocValues joinSortedDocValues = leafReader.getSortedDocValues(joinField);\n      if (joinSortedDocValues != null) {\n        valueCount = joinSortedDocValues.getValueCount();\n      } else {\n        return new MatchNoDocsQuery(\"JoinUtil.createJoinQuery: no join values\");\n      }\n    } else {\n      if (ordinalMap == null) {\n        throw new IllegalArgumentException(\"OrdinalMap is required, because there is more than 1 segment\");\n      }\n      valueCount = ordinalMap.getValueCount();\n    }\n\n    final Query rewrittenFromQuery = searcher.rewrite(fromQuery);\n    final Query rewrittenToQuery = searcher.rewrite(toQuery);\n    GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;\n    switch (scoreMode) {\n      case Total:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Min:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Max:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case Avg:\n        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);\n        break;\n      case None:\n        if (min <= 0 && max == Integer.MAX_VALUE) {\n          GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);\n          searcher.search(rewrittenFromQuery, globalOrdinalsCollector);\n          return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, rewrittenToQuery,\n              rewrittenFromQuery, searcher.getTopReaderContext().id());\n        } else {\n          globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);\n          break;\n        }\n      default:\n        throw new IllegalArgumentException(String.format(Locale.ROOT, \"Score mode %s isn't supported.\", scoreMode));\n    }\n    searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);\n    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, scoreMode, joinField, ordinalMap, rewrittenToQuery,\n        rewrittenFromQuery, min, max, searcher.getTopReaderContext().id());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"957c610636f393a85a38f1af670540028db13e6b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","957c610636f393a85a38f1af670540028db13e6b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["957c610636f393a85a38f1af670540028db13e6b"]},"commit2Childs":{"957c610636f393a85a38f1af670540028db13e6b":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["957c610636f393a85a38f1af670540028db13e6b","aaf90fc29510e72665ac7934f34c3d1c25efad64"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}