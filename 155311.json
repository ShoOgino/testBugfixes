{"path":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","pathOld":"solr/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","sourceNew":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random.nextBoolean();\n    int cost = cache ? 0 : random.nextBoolean() ? random.nextInt(200) : 0;\n    boolean positive = random.nextBoolean();\n    boolean exclude = facetQuery ? false : random.nextBoolean();    // can't exclude a facet query from faceting\n\n    OpenBitSet[] sets = facetQuery ? new OpenBitSet[]{model.facetQuery} :\n        (exclude ? new OpenBitSet[]{model.answer, model.facetQuery} : new OpenBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random.nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random.nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random.nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (OpenBitSet set : sets) {\n          set.clear(0,l);\n          set.clear(u+1, model.indexSize);\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random.nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random.nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (OpenBitSet set : sets) {\n          set.clear(l,u+1);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      OpenBitSet pset = new OpenBitSet(model.indexSize);\n      for (int i=0; i<pset.getBits().length; i++) {\n        pset.getBits()[i] = random.nextLong();    // set 50% of the bits on average\n      }\n      if (positive) {\n        for (OpenBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (OpenBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        doc = pset.nextSetBit(doc+1);\n        if (doc < 0 || doc >= model.indexSize) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random.nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","sourceOld":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random.nextBoolean();\n    int cost = cache ? 0 : random.nextBoolean() ? random.nextInt(200) : 0;\n    boolean positive = random.nextBoolean();\n    boolean exclude = facetQuery ? false : random.nextBoolean();    // can't exclude a facet query from faceting\n\n    OpenBitSet[] sets = facetQuery ? new OpenBitSet[]{model.facetQuery} :\n        (exclude ? new OpenBitSet[]{model.answer, model.facetQuery} : new OpenBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random.nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random.nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random.nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (OpenBitSet set : sets) {\n          set.clear(0,l);\n          set.clear(u+1, model.indexSize);\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random.nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random.nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (OpenBitSet set : sets) {\n          set.clear(l,u+1);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      OpenBitSet pset = new OpenBitSet(model.indexSize);\n      for (int i=0; i<pset.getBits().length; i++) {\n        pset.getBits()[i] = random.nextLong();    // set 50% of the bits on average\n      }\n      if (positive) {\n        for (OpenBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (OpenBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        doc = pset.nextSetBit(doc+1);\n        if (doc < 0 || doc >= model.indexSize) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random.nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","pathOld":"solr/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","sourceNew":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random.nextBoolean();\n    int cost = cache ? 0 : random.nextBoolean() ? random.nextInt(200) : 0;\n    boolean positive = random.nextBoolean();\n    boolean exclude = facetQuery ? false : random.nextBoolean();    // can't exclude a facet query from faceting\n\n    OpenBitSet[] sets = facetQuery ? new OpenBitSet[]{model.facetQuery} :\n        (exclude ? new OpenBitSet[]{model.answer, model.facetQuery} : new OpenBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random.nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random.nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random.nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (OpenBitSet set : sets) {\n          set.clear(0,l);\n          set.clear(u+1, model.indexSize);\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random.nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random.nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (OpenBitSet set : sets) {\n          set.clear(l,u+1);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      OpenBitSet pset = new OpenBitSet(model.indexSize);\n      for (int i=0; i<pset.getBits().length; i++) {\n        pset.getBits()[i] = random.nextLong();    // set 50% of the bits on average\n      }\n      if (positive) {\n        for (OpenBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (OpenBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        doc = pset.nextSetBit(doc+1);\n        if (doc < 0 || doc >= model.indexSize) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random.nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","sourceOld":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random.nextBoolean();\n    int cost = cache ? 0 : random.nextBoolean() ? random.nextInt(200) : 0;\n    boolean positive = random.nextBoolean();\n    boolean exclude = facetQuery ? false : random.nextBoolean();    // can't exclude a facet query from faceting\n\n    OpenBitSet[] sets = facetQuery ? new OpenBitSet[]{model.facetQuery} :\n        (exclude ? new OpenBitSet[]{model.answer, model.facetQuery} : new OpenBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random.nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random.nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random.nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (OpenBitSet set : sets) {\n          set.clear(0,l);\n          set.clear(u+1, model.indexSize);\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random.nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random.nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (OpenBitSet set : sets) {\n          set.clear(l,u+1);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      OpenBitSet pset = new OpenBitSet(model.indexSize);\n      for (int i=0; i<pset.getBits().length; i++) {\n        pset.getBits()[i] = random.nextLong();    // set 50% of the bits on average\n      }\n      if (positive) {\n        for (OpenBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (OpenBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        doc = pset.nextSetBit(doc+1);\n        if (doc < 0 || doc >= model.indexSize) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random.nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","pathOld":"solr/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","sourceNew":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random.nextBoolean();\n    int cost = cache ? 0 : random.nextBoolean() ? random.nextInt(200) : 0;\n    boolean positive = random.nextBoolean();\n    boolean exclude = facetQuery ? false : random.nextBoolean();    // can't exclude a facet query from faceting\n\n    OpenBitSet[] sets = facetQuery ? new OpenBitSet[]{model.facetQuery} :\n        (exclude ? new OpenBitSet[]{model.answer, model.facetQuery} : new OpenBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random.nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random.nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random.nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (OpenBitSet set : sets) {\n          set.clear(0,l);\n          set.clear(u+1, model.indexSize);\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random.nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random.nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (OpenBitSet set : sets) {\n          set.clear(l,u+1);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      OpenBitSet pset = new OpenBitSet(model.indexSize);\n      for (int i=0; i<pset.getBits().length; i++) {\n        pset.getBits()[i] = random.nextLong();    // set 50% of the bits on average\n      }\n      if (positive) {\n        for (OpenBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (OpenBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        doc = pset.nextSetBit(doc+1);\n        if (doc < 0 || doc >= model.indexSize) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random.nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","sourceOld":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random.nextBoolean();\n    int cost = cache ? 0 : random.nextBoolean() ? random.nextInt(200) : 0;\n    boolean positive = random.nextBoolean();\n    boolean exclude = facetQuery ? false : random.nextBoolean();    // can't exclude a facet query from faceting\n\n    OpenBitSet[] sets = facetQuery ? new OpenBitSet[]{model.facetQuery} :\n        (exclude ? new OpenBitSet[]{model.answer, model.facetQuery} : new OpenBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random.nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random.nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random.nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (OpenBitSet set : sets) {\n          set.clear(0,l);\n          set.clear(u+1, model.indexSize);\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random.nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random.nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (OpenBitSet set : sets) {\n          set.clear(l,u+1);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      OpenBitSet pset = new OpenBitSet(model.indexSize);\n      for (int i=0; i<pset.getBits().length; i++) {\n        pset.getBits()[i] = random.nextLong();    // set 50% of the bits on average\n      }\n      if (positive) {\n        for (OpenBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (OpenBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        doc = pset.nextSetBit(doc+1);\n        if (doc < 0 || doc >= model.indexSize) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random.nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","sourceNew":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random().nextBoolean();\n    int cost = cache ? 0 : random().nextBoolean() ? random().nextInt(200) : 0;\n    boolean positive = random().nextBoolean();\n    boolean exclude = facetQuery ? false : random().nextBoolean();    // can't exclude a facet query from faceting\n\n    OpenBitSet[] sets = facetQuery ? new OpenBitSet[]{model.facetQuery} :\n        (exclude ? new OpenBitSet[]{model.answer, model.facetQuery} : new OpenBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random().nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random().nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random().nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (OpenBitSet set : sets) {\n          set.clear(0,l);\n          set.clear(u+1, model.indexSize);\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random().nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random().nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (OpenBitSet set : sets) {\n          set.clear(l,u+1);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      OpenBitSet pset = new OpenBitSet(model.indexSize);\n      for (int i=0; i<pset.getBits().length; i++) {\n        pset.getBits()[i] = random().nextLong();    // set 50% of the bits on average\n      }\n      if (positive) {\n        for (OpenBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (OpenBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        doc = pset.nextSetBit(doc+1);\n        if (doc < 0 || doc >= model.indexSize) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random().nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","sourceOld":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random.nextBoolean();\n    int cost = cache ? 0 : random.nextBoolean() ? random.nextInt(200) : 0;\n    boolean positive = random.nextBoolean();\n    boolean exclude = facetQuery ? false : random.nextBoolean();    // can't exclude a facet query from faceting\n\n    OpenBitSet[] sets = facetQuery ? new OpenBitSet[]{model.facetQuery} :\n        (exclude ? new OpenBitSet[]{model.answer, model.facetQuery} : new OpenBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random.nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random.nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random.nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (OpenBitSet set : sets) {\n          set.clear(0,l);\n          set.clear(u+1, model.indexSize);\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random.nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random.nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (OpenBitSet set : sets) {\n          set.clear(l,u+1);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      OpenBitSet pset = new OpenBitSet(model.indexSize);\n      for (int i=0; i<pset.getBits().length; i++) {\n        pset.getBits()[i] = random.nextLong();    // set 50% of the bits on average\n      }\n      if (positive) {\n        for (OpenBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (OpenBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        doc = pset.nextSetBit(doc+1);\n        if (doc < 0 || doc >= model.indexSize) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random.nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":["af918c7c328775f9fadd5870c21f0fafc2a059cc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a69cf7f1b4cac5d5b1363402b565cd535f13e6a1","date":1392536197,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","sourceNew":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random().nextBoolean();\n    int cost = cache ? 0 : random().nextBoolean() ? random().nextInt(200) : 0;\n    boolean positive = random().nextBoolean();\n    boolean exclude = facetQuery ? false : random().nextBoolean();    // can't exclude a facet query from faceting\n\n    FixedBitSet[] sets = facetQuery ? new FixedBitSet[]{model.facetQuery} :\n        (exclude ? new FixedBitSet[]{model.answer, model.facetQuery} : new FixedBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random().nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random().nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random().nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (FixedBitSet set : sets) {\n          set.clear(0,l);\n          if (u + 1 < model.indexSize) {\n            set.clear(u+1, model.indexSize);\n          }\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random().nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random().nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (FixedBitSet set : sets) {\n          int end = Math.min(u+1, set.length());\n          set.clear(l,end);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      FixedBitSet pset = new FixedBitSet(model.indexSize);\n      for (int i=0; i<pset.getBits().length; i++) {\n        pset.getBits()[i] = random().nextLong();    // set 50% of the bits on average\n      }\n      if (positive) {\n        for (FixedBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (FixedBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        if (doc+1 >= model.indexSize) break;\n        doc = pset.nextSetBit(doc+1);\n        if (doc < 0) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random().nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","sourceOld":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random().nextBoolean();\n    int cost = cache ? 0 : random().nextBoolean() ? random().nextInt(200) : 0;\n    boolean positive = random().nextBoolean();\n    boolean exclude = facetQuery ? false : random().nextBoolean();    // can't exclude a facet query from faceting\n\n    OpenBitSet[] sets = facetQuery ? new OpenBitSet[]{model.facetQuery} :\n        (exclude ? new OpenBitSet[]{model.answer, model.facetQuery} : new OpenBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random().nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random().nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random().nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (OpenBitSet set : sets) {\n          set.clear(0,l);\n          set.clear(u+1, model.indexSize);\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random().nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random().nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (OpenBitSet set : sets) {\n          set.clear(l,u+1);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      OpenBitSet pset = new OpenBitSet(model.indexSize);\n      for (int i=0; i<pset.getBits().length; i++) {\n        pset.getBits()[i] = random().nextLong();    // set 50% of the bits on average\n      }\n      if (positive) {\n        for (OpenBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (OpenBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        doc = pset.nextSetBit(doc+1);\n        if (doc < 0 || doc >= model.indexSize) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random().nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":["af918c7c328775f9fadd5870c21f0fafc2a059cc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e","date":1414135939,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","sourceNew":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random().nextBoolean();\n    int cost = cache ? 0 : random().nextBoolean() ? random().nextInt(200) : 0;\n    boolean positive = random().nextBoolean();\n    boolean exclude = facetQuery ? false : random().nextBoolean();    // can't exclude a facet query from faceting\n\n    FixedBitSet[] sets = facetQuery ? new FixedBitSet[]{model.facetQuery} :\n        (exclude ? new FixedBitSet[]{model.answer, model.facetQuery} : new FixedBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random().nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random().nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random().nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (FixedBitSet set : sets) {\n          set.clear(0,l);\n          if (u + 1 < model.indexSize) {\n            set.clear(u+1, model.indexSize);\n          }\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random().nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random().nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (FixedBitSet set : sets) {\n          int end = Math.min(u+1, set.length());\n          set.clear(l,end);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      FixedBitSet pset = new FixedBitSet(model.indexSize);\n      for (int i=0; i<pset.getBits().length; i++) {\n        pset.getBits()[i] = random().nextLong();    // set 50% of the bits on average\n      }\n      if (positive) {\n        for (FixedBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (FixedBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        if (doc+1 >= model.indexSize) break;\n        doc = pset.nextSetBit(doc+1);\n        if (doc == DocIdSetIterator.NO_MORE_DOCS) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random().nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","sourceOld":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random().nextBoolean();\n    int cost = cache ? 0 : random().nextBoolean() ? random().nextInt(200) : 0;\n    boolean positive = random().nextBoolean();\n    boolean exclude = facetQuery ? false : random().nextBoolean();    // can't exclude a facet query from faceting\n\n    FixedBitSet[] sets = facetQuery ? new FixedBitSet[]{model.facetQuery} :\n        (exclude ? new FixedBitSet[]{model.answer, model.facetQuery} : new FixedBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random().nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random().nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random().nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (FixedBitSet set : sets) {\n          set.clear(0,l);\n          if (u + 1 < model.indexSize) {\n            set.clear(u+1, model.indexSize);\n          }\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random().nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random().nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (FixedBitSet set : sets) {\n          int end = Math.min(u+1, set.length());\n          set.clear(l,end);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      FixedBitSet pset = new FixedBitSet(model.indexSize);\n      for (int i=0; i<pset.getBits().length; i++) {\n        pset.getBits()[i] = random().nextLong();    // set 50% of the bits on average\n      }\n      if (positive) {\n        for (FixedBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (FixedBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        if (doc+1 >= model.indexSize) break;\n        doc = pset.nextSetBit(doc+1);\n        if (doc < 0) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random().nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af918c7c328775f9fadd5870c21f0fafc2a059cc","date":1430253435,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","sourceNew":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random().nextBoolean();\n    int cost = cache ? 0 : random().nextBoolean() ? random().nextInt(200) : 0;\n    boolean positive = random().nextBoolean();\n    boolean exclude = facetQuery ? false : random().nextBoolean();    // can't exclude a facet query from faceting\n\n    FixedBitSet[] sets = facetQuery ? new FixedBitSet[]{model.facetQuery} :\n        (exclude ? new FixedBitSet[]{model.answer, model.facetQuery} : new FixedBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random().nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random().nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random().nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (FixedBitSet set : sets) {\n          set.clear(0,l);\n          if (u + 1 < model.indexSize) {\n            set.clear(u+1, model.indexSize);\n          }\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random().nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random().nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (FixedBitSet set : sets) {\n          int end = Math.min(u+1, set.length());\n          set.clear(l,end);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      int numWords = FixedBitSet.bits2words(model.indexSize);\n      long[] psetBits = new long[numWords];\n      for (int i=0; i<psetBits.length; i++) {\n        psetBits[i] = random().nextLong();    // set 50% of the bits on average\n      }\n      // Make sure no 'ghost' bits are set beyond model.indexSize (see FixedBitSet.verifyGhostBitsClear)\n      if ((model.indexSize & 0x3f) != 0) {\n        long mask = -1L << model.indexSize; // & 0x3f is implicit\n\n        psetBits[numWords - 1] &= ~mask;\n      }\n      FixedBitSet pset = new FixedBitSet(psetBits, model.indexSize);\n      if (positive) {\n        for (FixedBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (FixedBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        if (doc+1 >= model.indexSize) break;\n        doc = pset.nextSetBit(doc+1);\n        if (doc == DocIdSetIterator.NO_MORE_DOCS) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random().nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","sourceOld":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random().nextBoolean();\n    int cost = cache ? 0 : random().nextBoolean() ? random().nextInt(200) : 0;\n    boolean positive = random().nextBoolean();\n    boolean exclude = facetQuery ? false : random().nextBoolean();    // can't exclude a facet query from faceting\n\n    FixedBitSet[] sets = facetQuery ? new FixedBitSet[]{model.facetQuery} :\n        (exclude ? new FixedBitSet[]{model.answer, model.facetQuery} : new FixedBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random().nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random().nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random().nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (FixedBitSet set : sets) {\n          set.clear(0,l);\n          if (u + 1 < model.indexSize) {\n            set.clear(u+1, model.indexSize);\n          }\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random().nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random().nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (FixedBitSet set : sets) {\n          int end = Math.min(u+1, set.length());\n          set.clear(l,end);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      FixedBitSet pset = new FixedBitSet(model.indexSize);\n      for (int i=0; i<pset.getBits().length; i++) {\n        pset.getBits()[i] = random().nextLong();    // set 50% of the bits on average\n      }\n      if (positive) {\n        for (FixedBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (FixedBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        if (doc+1 >= model.indexSize) break;\n        doc = pset.nextSetBit(doc+1);\n        if (doc == DocIdSetIterator.NO_MORE_DOCS) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random().nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","bugFix":["f8bf47b67b38083a0c4d9d2e3f53b59a48e8db34","629c38c4ae4e303d0617e05fbfe508140b32f0a3","a69cf7f1b4cac5d5b1363402b565cd535f13e6a1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16b25963ad38ed289ebf0f7af31269fa1ce80a11","date":1442083896,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestFiltering#makeRandomQuery(Model,boolean,boolean).mjava","sourceNew":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random().nextBoolean();\n    int cost = cache ? 0 : random().nextBoolean() ? random().nextInt(200) : 0;\n    boolean positive = random().nextBoolean();\n    boolean exclude = facetQuery ? false : random().nextBoolean();    // can't exclude a facet query from faceting\n\n    FixedBitSet[] sets = facetQuery ? new FixedBitSet[]{model.facetQuery} :\n        (exclude ? new FixedBitSet[]{model.answer, model.facetQuery} : new FixedBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random().nextInt(100) < 60) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random().nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random().nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (FixedBitSet set : sets) {\n          set.clear(0,l);\n          if (u + 1 < model.indexSize) {\n            set.clear(u+1, model.indexSize);\n          }\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random().nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random().nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (FixedBitSet set : sets) {\n          int end = Math.min(u+1, set.length());\n          set.clear(l,end);\n        }\n      }\n\n      String whichField = random().nextBoolean() ? f : f_s;\n      return random().nextBoolean() ?\n           frangeStr(f, !positive, l, u, cache, cost, exclude)   // todo: frange doesn't work on the string field?\n         :  rangeStr(whichField, !positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      int numWords = FixedBitSet.bits2words(model.indexSize);\n      long[] psetBits = new long[numWords];\n      for (int i=0; i<psetBits.length; i++) {\n        psetBits[i] = random().nextLong();    // set 50% of the bits on average\n      }\n      // Make sure no 'ghost' bits are set beyond model.indexSize (see FixedBitSet.verifyGhostBitsClear)\n      if ((model.indexSize & 0x3f) != 0) {\n        long mask = -1L << model.indexSize; // & 0x3f is implicit\n\n        psetBits[numWords - 1] &= ~mask;\n      }\n      FixedBitSet pset = new FixedBitSet(psetBits, model.indexSize);\n      if (positive) {\n        for (FixedBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (FixedBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        if (doc+1 >= model.indexSize) break;\n        doc = pset.nextSetBit(doc+1);\n        if (doc == DocIdSetIterator.NO_MORE_DOCS) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random().nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","sourceOld":"  String makeRandomQuery(Model model, boolean mainQuery, boolean facetQuery) {\n\n    boolean cache = random().nextBoolean();\n    int cost = cache ? 0 : random().nextBoolean() ? random().nextInt(200) : 0;\n    boolean positive = random().nextBoolean();\n    boolean exclude = facetQuery ? false : random().nextBoolean();    // can't exclude a facet query from faceting\n\n    FixedBitSet[] sets = facetQuery ? new FixedBitSet[]{model.facetQuery} :\n        (exclude ? new FixedBitSet[]{model.answer, model.facetQuery} : new FixedBitSet[]{model.answer, model.multiSelect, model.facetQuery});\n\n    if (random().nextInt(100) < 50) {\n      // frange\n      int l=0;\n      int u=0;\n\n      if (positive) {\n        // positive frange, make it big by taking the max of 4 tries\n        int n=-1;\n\n        for (int i=0; i<4; i++) {\n          int ll = random().nextInt(model.indexSize);\n          int uu = ll + ((ll==model.indexSize-1) ? 0 : random().nextInt(model.indexSize-l));\n          if (uu-ll+1 > n) {\n            n = uu-ll+1;\n            u = uu;\n            l = ll;\n          }\n        }\n\n        for (FixedBitSet set : sets) {\n          set.clear(0,l);\n          if (u + 1 < model.indexSize) {\n            set.clear(u+1, model.indexSize);\n          }\n        }\n      } else {\n        // negative frange.. make it relatively small\n        l = random().nextInt(model.indexSize);\n        u = Math.max(model.indexSize-1, l+random().nextInt(Math.max(model.indexSize / 10, 2)));\n\n        for (FixedBitSet set : sets) {\n          int end = Math.min(u+1, set.length());\n          set.clear(l,end);\n        }\n      }\n\n      return frangeStr(!positive, l, u, cache, cost, exclude);\n    } else {\n      // term or boolean query\n      int numWords = FixedBitSet.bits2words(model.indexSize);\n      long[] psetBits = new long[numWords];\n      for (int i=0; i<psetBits.length; i++) {\n        psetBits[i] = random().nextLong();    // set 50% of the bits on average\n      }\n      // Make sure no 'ghost' bits are set beyond model.indexSize (see FixedBitSet.verifyGhostBitsClear)\n      if ((model.indexSize & 0x3f) != 0) {\n        long mask = -1L << model.indexSize; // & 0x3f is implicit\n\n        psetBits[numWords - 1] &= ~mask;\n      }\n      FixedBitSet pset = new FixedBitSet(psetBits, model.indexSize);\n      if (positive) {\n        for (FixedBitSet set : sets) {\n          set.and(pset);\n        }\n      } else {\n        for (FixedBitSet set : sets) {\n          set.andNot(pset);\n        }\n      }\n\n\n      StringBuilder sb = new StringBuilder();\n      for (int doc=-1;;) {\n        if (doc+1 >= model.indexSize) break;\n        doc = pset.nextSetBit(doc+1);\n        if (doc == DocIdSetIterator.NO_MORE_DOCS) break;\n        sb.append((positive ? \" \":\" -\") + f+\":\"+doc);\n      }\n\n      String ret = sb.toString();\n      if (ret.length()==0) ret = (positive ? \"\":\"-\") + \"id:99999999\";\n\n      if (!cache || exclude || random().nextBoolean()) {\n        ret = \"{!cache=\" + cache\n            + ((cost != 0) ? \" cost=\"+cost : \"\")\n            + ((exclude) ? \" tag=t\" : \"\")\n            + \"}\" + ret;\n      }\n\n      return ret;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"16b25963ad38ed289ebf0f7af31269fa1ce80a11":["af918c7c328775f9fadd5870c21f0fafc2a059cc"],"a69cf7f1b4cac5d5b1363402b565cd535f13e6a1":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"af918c7c328775f9fadd5870c21f0fafc2a059cc":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["c26f00b574427b55127e869b935845554afde1fa"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["a69cf7f1b4cac5d5b1363402b565cd535f13e6a1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["16b25963ad38ed289ebf0f7af31269fa1ce80a11"]},"commit2Childs":{"16b25963ad38ed289ebf0f7af31269fa1ce80a11":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a69cf7f1b4cac5d5b1363402b565cd535f13e6a1":["0abcec02c9851c46c70a75bd42fb6e4d5348ac9e"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee"],"af918c7c328775f9fadd5870c21f0fafc2a059cc":["16b25963ad38ed289ebf0f7af31269fa1ce80a11"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["a69cf7f1b4cac5d5b1363402b565cd535f13e6a1"],"0abcec02c9851c46c70a75bd42fb6e4d5348ac9e":["af918c7c328775f9fadd5870c21f0fafc2a059cc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}