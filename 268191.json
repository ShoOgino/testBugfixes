{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","sourceNew":"    public void run() {\n      DirectoryReader currentReader = null;\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","sourceOld":"    public void run() {\n      DirectoryReader currentReader = null;\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","sourceNew":"    public void run() {\n      DirectoryReader currentReader = null;\n      Random random = LuceneTestCase.random();\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","sourceOld":"    public void run() {\n      DirectoryReader currentReader = null;\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"04f07771a2a7dd3a395700665ed839c3dae2def2","date":1339350139,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","sourceNew":"    public void run() {\n      DirectoryReader currentReader = null;\n      Random random = LuceneTestCase.random();\n      try {\n        Document doc = new Document();\n        doc.add(new TextField(\"id\", \"1\", Field.Store.NO));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","sourceOld":"    public void run() {\n      DirectoryReader currentReader = null;\n      Random random = LuceneTestCase.random();\n      try {\n        Document doc = new Document();\n        doc.add(new Field(\"id\", \"1\", TextField.TYPE_UNSTORED));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","bugFix":["a1c3710e755dc60691ac0d7fe23c9fcba0537bdc"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      DirectoryReader currentReader = null;\n      Random random = LuceneTestCase.random();\n      try {\n        Document doc = new Document();\n        doc.add(new TextField(\"id\", \"1\", Field.Store.NO));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","sourceOld":"    public void run() {\n      DirectoryReader currentReader = null;\n      Random random = LuceneTestCase.random();\n      try {\n        Document doc = new Document();\n        doc.add(new TextField(\"id\", \"1\", Field.Store.NO));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      DirectoryReader currentReader = null;\n      Random random = LuceneTestCase.random();\n      try {\n        Document doc = new Document();\n        doc.add(new TextField(\"id\", \"1\", Field.Store.NO));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","sourceOld":"    public void run() {\n      DirectoryReader currentReader = null;\n      Random random = LuceneTestCase.random();\n      try {\n        Document doc = new Document();\n        doc.add(new TextField(\"id\", \"1\", Field.Store.NO));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b516a692d03225c8f0e81a13ceed2dc32bb457d","date":1453411951,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterNRTIsCurrent.WriterThread#run().mjava","sourceNew":"    @Override\n    public void run() {\n      DirectoryReader currentReader = null;\n      Random random = LuceneTestCase.random();\n      try {\n        Document doc = new Document();\n        doc.add(new TextField(\"id\", \"1\", Field.Store.NO));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader();\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      DirectoryReader currentReader = null;\n      Random random = LuceneTestCase.random();\n      try {\n        Document doc = new Document();\n        doc.add(new TextField(\"id\", \"1\", Field.Store.NO));\n        writer.addDocument(doc);\n        holder.reader = currentReader = writer.getReader(true);\n        Term term = new Term(\"id\");\n        for (int i = 0; i < numOps && !holder.stop; i++) {\n          float nextOp = random.nextFloat();\n          if (nextOp < 0.3) {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.updateDocument(term, doc);\n          } else if (nextOp < 0.5) {\n            writer.addDocument(doc);\n          } else {\n            term.set(\"id\", new BytesRef(\"1\"));\n            writer.deleteDocuments(term);\n          }\n          if (holder.reader != currentReader) {\n            holder.reader = currentReader;\n            if (countdown) {\n              countdown = false;\n              latch.countDown();\n            }\n          }\n          if (random.nextBoolean()) {\n            writer.commit();\n            final DirectoryReader newReader = DirectoryReader\n                .openIfChanged(currentReader);\n            if (newReader != null) { \n              currentReader.decRef();\n              currentReader = newReader;\n            }\n            if (currentReader.numDocs() == 0) {\n              writer.addDocument(doc);\n            }\n          }\n        }\n      } catch (Throwable e) {\n        failed = e;\n      } finally {\n        holder.reader = null;\n        if (countdown) {\n          latch.countDown();\n        }\n        if (currentReader != null) {\n          try {\n            currentReader.decRef();\n          } catch (IOException e) {\n          }\n        }\n      }\n      if (VERBOSE) {\n        System.out.println(\"writer stopped - forced by reader: \" + holder.stop);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"04f07771a2a7dd3a395700665ed839c3dae2def2":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["04f07771a2a7dd3a395700665ed839c3dae2def2","7530de27b87b961b51f01bd1299b7004d46e8823"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7b516a692d03225c8f0e81a13ceed2dc32bb457d":["7530de27b87b961b51f01bd1299b7004d46e8823"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7530de27b87b961b51f01bd1299b7004d46e8823":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b516a692d03225c8f0e81a13ceed2dc32bb457d"]},"commit2Childs":{"04f07771a2a7dd3a395700665ed839c3dae2def2":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7b516a692d03225c8f0e81a13ceed2dc32bb457d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7b516a692d03225c8f0e81a13ceed2dc32bb457d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}