{"path":"solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.AbstractStatsValues#AbstractStatsValues(StatsField).mjava","commits":[{"id":"248f6ecc900c3a5633fd5ca6f564ea8b717720da","date":1588863846,"type":0,"author":"Mike Drob","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.AbstractStatsValues#AbstractStatsValues(StatsField).mjava","pathOld":"/dev/null","sourceNew":"    protected AbstractStatsValues(StatsField statsField) {\n      this.statsField = statsField;\n      this.computeCount = statsField.calculateStats(Stat.count);\n      this.computeMissing = statsField.calculateStats(Stat.missing);\n      this.computeCalcDistinct = statsField.calculateStats(Stat.countDistinct)\n        || statsField.calculateStats(Stat.distinctValues);\n      this.computeMin = statsField.calculateStats(Stat.min);\n      this.computeMax = statsField.calculateStats(Stat.max);\n      this.computeMinOrMax = computeMin || computeMax;\n\n      this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;\n\n      this.computeCardinality = statsField.calculateStats(Stat.cardinality);\n      if ( computeCardinality ) {\n\n        hasher = statsField.getHllOptions().getHasher();\n        hll = statsField.getHllOptions().newHLL();\n        assert null != hll : \"Cardinality requires an HLL\";\n      } else {\n        hll = null;\n        hasher = null;\n      }\n\n      // alternatively, we could refactor a common base class that doesn't know/care\n      // about either SchemaField or ValueSource - but then there would be a lot of\n      // duplicate code between \"NumericSchemaFieldStatsValues\" and\n      // \"NumericValueSourceStatsValues\" which would have diff parent classes\n      //\n      // part of the complexity here being that the StatsValues API serves two\n      // masters: collecting concrete Values from things like DocValuesStats and\n      // the distributed aggregation logic, but also collecting docIds which it\n      // then\n      // uses to go out and pull concreate values from the ValueSource\n      // (from a func, or single valued field)\n      if (null != statsField.getSchemaField()) {\n        assert null == statsField.getValueSource();\n        this.sf = statsField.getSchemaField();\n        this.ft = sf.getType();\n      } else {\n        assert null != statsField.getValueSource();\n        assert null == statsField.getSchemaField();\n        this.sf = null;\n        this.ft = null;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e","date":1596664368,"type":3,"author":"Marcus","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.AbstractStatsValues#AbstractStatsValues(StatsField).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.AbstractStatsValues#AbstractStatsValues(StatsField).mjava","sourceNew":"    protected AbstractStatsValues(StatsField statsField) {\n      this.statsField = statsField;\n      this.computeCount = statsField.calculateStats(Stat.count);\n      this.computeMissing = statsField.calculateStats(Stat.missing);\n      this.computeCalcDistinct = statsField.calculateStats(Stat.countDistinct)\n        || statsField.calculateStats(Stat.distinctValues);\n      this.computeMin = statsField.calculateStats(Stat.min);\n      this.computeMax = statsField.calculateStats(Stat.max);\n      this.computeMinOrMax = computeMin || computeMax;\n\n      this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;\n\n      this.computeCardinality = statsField.calculateStats(Stat.cardinality);\n      if ( computeCardinality ) {\n\n        hasher = statsField.getHllOptions().getHasher();\n        hll = statsField.getHllOptions().newHLL();\n        assert null != hll : \"Cardinality requires an HLL\";\n      } else {\n        hll = null;\n        hasher = null;\n      }\n\n      // alternatively, we could refactor a common base class that doesn't know/care\n      // about either SchemaField or ValueSource - but then there would be a lot of\n      // duplicate code between \"NumericSchemaFieldStatsValues\" and\n      // \"NumericValueSourceStatsValues\" which would have diff parent classes\n      //\n      // part of the complexity here being that the StatsValues API serves two\n      // leaders: collecting concrete Values from things like DocValuesStats and\n      // the distributed aggregation logic, but also collecting docIds which it\n      // then\n      // uses to go out and pull concreate values from the ValueSource\n      // (from a func, or single valued field)\n      if (null != statsField.getSchemaField()) {\n        assert null == statsField.getValueSource();\n        this.sf = statsField.getSchemaField();\n        this.ft = sf.getType();\n      } else {\n        assert null != statsField.getValueSource();\n        assert null == statsField.getSchemaField();\n        this.sf = null;\n        this.ft = null;\n      }\n    }\n\n","sourceOld":"    protected AbstractStatsValues(StatsField statsField) {\n      this.statsField = statsField;\n      this.computeCount = statsField.calculateStats(Stat.count);\n      this.computeMissing = statsField.calculateStats(Stat.missing);\n      this.computeCalcDistinct = statsField.calculateStats(Stat.countDistinct)\n        || statsField.calculateStats(Stat.distinctValues);\n      this.computeMin = statsField.calculateStats(Stat.min);\n      this.computeMax = statsField.calculateStats(Stat.max);\n      this.computeMinOrMax = computeMin || computeMax;\n\n      this.distinctValues = computeCalcDistinct ? new TreeSet<>() : null;\n\n      this.computeCardinality = statsField.calculateStats(Stat.cardinality);\n      if ( computeCardinality ) {\n\n        hasher = statsField.getHllOptions().getHasher();\n        hll = statsField.getHllOptions().newHLL();\n        assert null != hll : \"Cardinality requires an HLL\";\n      } else {\n        hll = null;\n        hasher = null;\n      }\n\n      // alternatively, we could refactor a common base class that doesn't know/care\n      // about either SchemaField or ValueSource - but then there would be a lot of\n      // duplicate code between \"NumericSchemaFieldStatsValues\" and\n      // \"NumericValueSourceStatsValues\" which would have diff parent classes\n      //\n      // part of the complexity here being that the StatsValues API serves two\n      // masters: collecting concrete Values from things like DocValuesStats and\n      // the distributed aggregation logic, but also collecting docIds which it\n      // then\n      // uses to go out and pull concreate values from the ValueSource\n      // (from a func, or single valued field)\n      if (null != statsField.getSchemaField()) {\n        assert null == statsField.getValueSource();\n        this.sf = statsField.getSchemaField();\n        this.ft = sf.getType();\n      } else {\n        assert null != statsField.getValueSource();\n        assert null == statsField.getSchemaField();\n        this.sf = null;\n        this.ft = null;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"]},"commit2Childs":{"65a5d87a40f9143cd55be76eb1dde1b32a8dae5e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"248f6ecc900c3a5633fd5ca6f564ea8b717720da":["65a5d87a40f9143cd55be76eb1dde1b32a8dae5e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["248f6ecc900c3a5633fd5ca6f564ea8b717720da"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}