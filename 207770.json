{"path":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","commits":[{"id":"1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674","date":1358098706,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,String,boolean).mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path,  DirContext dirContext, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = new File(path).getAbsolutePath();\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          \n          if (cacheValue.refCnt == 0) {\n            try {\n              // the following will decref, so\n              // first incref\n              cacheValue.refCnt++;\n              close(cacheValue.directory);\n            } catch (IOException e) {\n              SolrException.log(log, \"Error closing directory\", e);\n            }\n          }\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath, dirContext);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue();\n        newCacheValue.directory = directory;\n        newCacheValue.path = fullPath;\n        \n        injectLockFactory(directory, path, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew:\" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = new File(path).getAbsolutePath();\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          \n          if (cacheValue.refCnt == 0) {\n            try {\n              // the following will decref, so\n              // first incref\n              cacheValue.refCnt++;\n              close(cacheValue.directory);\n            } catch (IOException e) {\n              SolrException.log(log, \"Error closing directory\", e);\n            }\n          }\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue();\n        newCacheValue.directory = directory;\n        newCacheValue.path = fullPath;\n        \n        injectLockFactory(directory, path, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew:\" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,String,boolean).mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path,  DirContext dirContext, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = new File(path).getAbsolutePath();\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          \n          if (cacheValue.refCnt == 0) {\n            try {\n              // the following will decref, so\n              // first incref\n              cacheValue.refCnt++;\n              close(cacheValue.directory);\n            } catch (IOException e) {\n              SolrException.log(log, \"Error closing directory\", e);\n            }\n          }\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath, dirContext);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue();\n        newCacheValue.directory = directory;\n        newCacheValue.path = fullPath;\n        \n        injectLockFactory(directory, path, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew:\" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = new File(path).getAbsolutePath();\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          \n          if (cacheValue.refCnt == 0) {\n            try {\n              // the following will decref, so\n              // first incref\n              cacheValue.refCnt++;\n              close(cacheValue.directory);\n            } catch (IOException e) {\n              SolrException.log(log, \"Error closing directory\", e);\n            }\n          }\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue();\n        newCacheValue.directory = directory;\n        newCacheValue.path = fullPath;\n        \n        injectLockFactory(directory, path, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew:\" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cab31d869ae741ad9e0dcd49b07ef6ce51107a7c","date":1362604055,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path,  DirContext dirContext, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = new File(path).getAbsolutePath();\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          \n          if (cacheValue.refCnt == 0) {\n            try {\n              // the following will decref, so\n              // first incref\n              cacheValue.refCnt++;\n              close(cacheValue.directory);\n            } catch (IOException e) {\n              SolrException.log(log, \"Error closing directory\", e);\n            }\n          }\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath, dirContext);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue();\n        newCacheValue.directory = directory;\n        newCacheValue.path = fullPath;\n        \n        injectLockFactory(directory, path, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew: \" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path,  DirContext dirContext, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = new File(path).getAbsolutePath();\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          \n          if (cacheValue.refCnt == 0) {\n            try {\n              // the following will decref, so\n              // first incref\n              cacheValue.refCnt++;\n              close(cacheValue.directory);\n            } catch (IOException e) {\n              SolrException.log(log, \"Error closing directory\", e);\n            }\n          }\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath, dirContext);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue();\n        newCacheValue.directory = directory;\n        newCacheValue.path = fullPath;\n        \n        injectLockFactory(directory, path, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew:\" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","bugFix":["b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"948cb7389da6d4f397f5a0f89caf885a9033c959","date":1362946471,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path,  DirContext dirContext, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = normalize(path);\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          \n          if (cacheValue.refCnt == 0) {\n            try {\n              // the following will decref, so\n              // first incref\n              cacheValue.refCnt++;\n              close(cacheValue.directory);\n            } catch (IOException e) {\n              SolrException.log(log, \"Error closing directory\", e);\n            }\n          }\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath, dirContext);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue();\n        newCacheValue.directory = directory;\n        newCacheValue.path = fullPath;\n        \n        injectLockFactory(directory, fullPath, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew: \" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path,  DirContext dirContext, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = new File(path).getAbsolutePath();\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          \n          if (cacheValue.refCnt == 0) {\n            try {\n              // the following will decref, so\n              // first incref\n              cacheValue.refCnt++;\n              close(cacheValue.directory);\n            } catch (IOException e) {\n              SolrException.log(log, \"Error closing directory\", e);\n            }\n          }\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath, dirContext);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue();\n        newCacheValue.directory = directory;\n        newCacheValue.path = fullPath;\n        \n        injectLockFactory(directory, path, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew: \" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b97a32ef0f7ada102673c4b42228da75f324b52b","date":1362975614,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path,  DirContext dirContext, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = normalize(path);\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          \n          if (cacheValue.refCnt == 0) {\n            try {\n              // the following will decref, so\n              // first incref\n              cacheValue.refCnt++;\n              close(cacheValue.directory);\n            } catch (IOException e) {\n              SolrException.log(log, \"Error closing directory\", e);\n            }\n          }\n          \n          // kill the path, it will be owned by the new dir\n          // we count on it being released by directory\n          cacheValue.path = null;\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath, dirContext);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue();\n        newCacheValue.directory = directory;\n        newCacheValue.path = fullPath;\n        \n        injectLockFactory(directory, fullPath, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew: \" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path,  DirContext dirContext, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = normalize(path);\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          \n          if (cacheValue.refCnt == 0) {\n            try {\n              // the following will decref, so\n              // first incref\n              cacheValue.refCnt++;\n              close(cacheValue.directory);\n            } catch (IOException e) {\n              SolrException.log(log, \"Error closing directory\", e);\n            }\n          }\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath, dirContext);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue();\n        newCacheValue.directory = directory;\n        newCacheValue.path = fullPath;\n        \n        injectLockFactory(directory, fullPath, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew: \" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"47672449aafbeb4308705f66b6b577836a5571d4","date":1363536675,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path,  DirContext dirContext, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = normalize(path);\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          \n          if (cacheValue.refCnt == 0) {\n            try {\n              // the following will decref, so\n              // first incref\n              cacheValue.refCnt++;\n              close(cacheValue.directory);\n            } catch (IOException e) {\n              SolrException.log(log, \"Error closing directory\", e);\n            }\n          }\n          \n          // close the entry, it will be owned by the new dir\n          // we count on it being released by directory\n          cacheValue.closed = true;\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath, dirContext);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue();\n        newCacheValue.directory = directory;\n        newCacheValue.path = fullPath;\n        \n        injectLockFactory(directory, fullPath, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew: \" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path,  DirContext dirContext, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = normalize(path);\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          \n          if (cacheValue.refCnt == 0) {\n            try {\n              // the following will decref, so\n              // first incref\n              cacheValue.refCnt++;\n              close(cacheValue.directory);\n            } catch (IOException e) {\n              SolrException.log(log, \"Error closing directory\", e);\n            }\n          }\n          \n          // kill the path, it will be owned by the new dir\n          // we count on it being released by directory\n          cacheValue.path = null;\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath, dirContext);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue();\n        newCacheValue.directory = directory;\n        newCacheValue.path = fullPath;\n        \n        injectLockFactory(directory, fullPath, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew: \" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2295e2775c39b05b81f566701b1e7e9475128f2","date":1363552877,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","sourceNew":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path,  DirContext dirContext, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = normalize(path);\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          if (cacheValue.refCnt == 0) {\n            closeDirectory(cacheValue);\n          }\n          \n          // close the entry, it will be owned by the new dir\n          // we count on it being released by directory\n          cacheValue.latestForPath = true;\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath, dirContext);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue(fullPath, directory);\n        \n        injectLockFactory(directory, fullPath, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew: \" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path,  DirContext dirContext, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = normalize(path);\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          \n          if (cacheValue.refCnt == 0) {\n            try {\n              // the following will decref, so\n              // first incref\n              cacheValue.refCnt++;\n              close(cacheValue.directory);\n            } catch (IOException e) {\n              SolrException.log(log, \"Error closing directory\", e);\n            }\n          }\n          \n          // close the entry, it will be owned by the new dir\n          // we count on it being released by directory\n          cacheValue.closed = true;\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath, dirContext);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue();\n        newCacheValue.directory = directory;\n        newCacheValue.path = fullPath;\n        \n        injectLockFactory(directory, fullPath, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew: \" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54f9a16329716fa08b653c53f1c3dfc6b284d2cc","date":1363905854,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/core/CachingDirectoryFactory#get(String,DirContext,String,boolean).mjava","sourceNew":null,"sourceOld":"  /*\n   * (non-Javadoc)\n   * \n   * @see org.apache.solr.core.DirectoryFactory#get(java.lang.String,\n   * java.lang.String, boolean)\n   */\n  @Override\n  public final Directory get(String path,  DirContext dirContext, String rawLockType, boolean forceNew)\n      throws IOException {\n    String fullPath = normalize(path);\n    synchronized (this) {\n      if (closed) {\n        throw new RuntimeException(\"Already closed\");\n      }\n      \n      final CacheValue cacheValue = byPathCache.get(fullPath);\n      Directory directory = null;\n      if (cacheValue != null) {\n        directory = cacheValue.directory;\n        if (forceNew) {\n          cacheValue.doneWithDir = true;\n          \n          // we make a quick close attempt,\n          // otherwise this should be closed\n          // when whatever is using it, releases it\n          if (cacheValue.refCnt == 0) {\n            closeDirectory(cacheValue);\n          }\n          \n          // close the entry, it will be owned by the new dir\n          // we count on it being released by directory\n          cacheValue.latestForPath = true;\n          \n        }\n      }\n      \n      if (directory == null || forceNew) { \n        directory = create(fullPath, dirContext);\n        \n        directory = rateLimit(directory);\n        \n        CacheValue newCacheValue = new CacheValue(fullPath, directory);\n        \n        injectLockFactory(directory, fullPath, rawLockType);\n        \n        byDirectoryCache.put(directory, newCacheValue);\n        byPathCache.put(fullPath, newCacheValue);\n        log.info(\"return new directory for \" + fullPath + \" forceNew: \" + forceNew);\n      } else {\n        cacheValue.refCnt++;\n      }\n      \n      return directory;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"948cb7389da6d4f397f5a0f89caf885a9033c959":["cab31d869ae741ad9e0dcd49b07ef6ce51107a7c"],"47672449aafbeb4308705f66b6b577836a5571d4":["b97a32ef0f7ada102673c4b42228da75f324b52b"],"b97a32ef0f7ada102673c4b42228da75f324b52b":["948cb7389da6d4f397f5a0f89caf885a9033c959"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674"],"1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"54f9a16329716fa08b653c53f1c3dfc6b284d2cc":["e2295e2775c39b05b81f566701b1e7e9475128f2"],"e2295e2775c39b05b81f566701b1e7e9475128f2":["47672449aafbeb4308705f66b6b577836a5571d4"],"cab31d869ae741ad9e0dcd49b07ef6ce51107a7c":["1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54f9a16329716fa08b653c53f1c3dfc6b284d2cc"]},"commit2Childs":{"948cb7389da6d4f397f5a0f89caf885a9033c959":["b97a32ef0f7ada102673c4b42228da75f324b52b"],"47672449aafbeb4308705f66b6b577836a5571d4":["e2295e2775c39b05b81f566701b1e7e9475128f2"],"b97a32ef0f7ada102673c4b42228da75f324b52b":["47672449aafbeb4308705f66b6b577836a5571d4"],"8917bfede3b4ca30f4305c1e391e9218959cd723":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8917bfede3b4ca30f4305c1e391e9218959cd723","1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674"],"1eda2abfda9da3ca2bc5c5872d6b8c0f4948f674":["8917bfede3b4ca30f4305c1e391e9218959cd723","cab31d869ae741ad9e0dcd49b07ef6ce51107a7c"],"cab31d869ae741ad9e0dcd49b07ef6ce51107a7c":["948cb7389da6d4f397f5a0f89caf885a9033c959"],"54f9a16329716fa08b653c53f1c3dfc6b284d2cc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e2295e2775c39b05b81f566701b1e7e9475128f2":["54f9a16329716fa08b653c53f1c3dfc6b284d2cc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8917bfede3b4ca30f4305c1e391e9218959cd723","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}