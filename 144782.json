{"path":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/src/webapp/src/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/src/webapp/src/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/src/webapp/src/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66c64e8cfded6a585100e6430238faaf416f3fea","date":1344964603,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n      RUNNING_JETTIES.put(this, new RuntimeException());\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n      RUNNING_JETTIES.put(this, new RuntimeException());\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n      RUNNING_JETTIES.put(this, new RuntimeException());\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25959fdb8f69c74c6a5836bf42e8e98c705ad005","date":1346336175,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n      RUNNING_JETTIES.put(this, new RuntimeException());\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n      RUNNING_JETTIES.put(this, new RuntimeException());\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45fcf1edbef6678c8a5b7e3d9604aec6a3ae56b2","date":1355344477,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n      \n      this.wait(300); // always 100ms - can take a moment for our cores to come up\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"322e2184986b71f21c079e090f7b06b130b3ed13","date":1355345606,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n      \n      this.wait(300); // always 300ms - can take a moment for our cores to come up\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n      \n      this.wait(300); // always 100ms - can take a moment for our cores to come up\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f327cb201b2cdff5931f786d3b0774aff2c780a2","date":1355363976,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n      \n      this.wait(300); // always 300ms - can take a moment for our cores to come up\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d","date":1361851792,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    if (coreNodeName != null) {\n      System.setProperty(\"coreNodeName\", coreNodeName);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n    System.clearProperty(\"coreNodeName\");\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if( solrUlogDir != null) {\n      System.setProperty(\"solr.ulog.dir\", solrUlogDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    if (coreNodeName != null) {\n      System.setProperty(\"coreNodeName\", coreNodeName);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n    System.clearProperty(\"coreNodeName\");\n    System.clearProperty(\"solr.ulog.dir\");\n\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    if (coreNodeName != null) {\n      System.setProperty(\"coreNodeName\", coreNodeName);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n    System.clearProperty(\"coreNodeName\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if( solrUlogDir != null) {\n      System.setProperty(\"solr.ulog.dir\", solrUlogDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    if (coreNodeName != null) {\n      System.setProperty(\"coreNodeName\", coreNodeName);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n    System.clearProperty(\"coreNodeName\");\n    System.clearProperty(\"solr.ulog.dir\");\n\n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    if (coreNodeName != null) {\n      System.setProperty(\"coreNodeName\", coreNodeName);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n    System.clearProperty(\"coreNodeName\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dcb5de84d260a8919bf0f2d4d180df543a2ad07a","date":1381378233,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if (dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if (solrUlogDir != null) {\n      System.setProperty(\"solr.ulog.dir\", solrUlogDir);\n    }\n    if (shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    if (coreNodeName != null) {\n      System.setProperty(\"coreNodeName\", coreNodeName);\n    }\n    try {\n      \n      if (!server.isRunning()) {\n        server.start();\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr) {\n          this.wait(100);\n          if (cnt++ == 5) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n    } finally {\n      \n      System.clearProperty(\"shard\");\n      System.clearProperty(\"solr.data.dir\");\n      System.clearProperty(\"coreNodeName\");\n      System.clearProperty(\"solr.ulog.dir\");\n    }\n    \n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if( dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if( solrUlogDir != null) {\n      System.setProperty(\"solr.ulog.dir\", solrUlogDir);\n    }\n    if(shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    if (coreNodeName != null) {\n      System.setProperty(\"coreNodeName\", coreNodeName);\n    }\n    \n    if (!server.isRunning()) {\n      server.start();\n    }\n    synchronized (JettySolrRunner.this) {\n      int cnt = 0;\n      while (!waitOnSolr) {\n        this.wait(100);\n        if (cnt++ == 5) {\n          throw new RuntimeException(\"Jetty/Solr unresponsive\");\n        }\n      }\n    }\n    \n    System.clearProperty(\"shard\");\n    System.clearProperty(\"solr.data.dir\");\n    System.clearProperty(\"coreNodeName\");\n    System.clearProperty(\"solr.ulog.dir\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c66158bb16e902a21272772f1b911f04b1a55abb","date":1424959524,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(lastPort);\n    } else {\n      startedBefore = true;\n    }\n    \n    if (dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if (solrUlogDir != null) {\n      System.setProperty(\"solr.ulog.dir\", solrUlogDir);\n    }\n    if (shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    if (coreNodeName != null) {\n      System.setProperty(\"coreNodeName\", coreNodeName);\n    }\n    try {\n      \n      if (!server.isRunning()) {\n        server.start();\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr) {\n          this.wait(100);\n          if (cnt++ == 5) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n    } finally {\n      \n      System.clearProperty(\"shard\");\n      System.clearProperty(\"solr.data.dir\");\n      System.clearProperty(\"coreNodeName\");\n      System.clearProperty(\"solr.ulog.dir\");\n    }\n    \n  }\n\n","sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if (dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if (solrUlogDir != null) {\n      System.setProperty(\"solr.ulog.dir\", solrUlogDir);\n    }\n    if (shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    if (coreNodeName != null) {\n      System.setProperty(\"coreNodeName\", coreNodeName);\n    }\n    try {\n      \n      if (!server.isRunning()) {\n        server.start();\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr) {\n          this.wait(100);\n          if (cnt++ == 5) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n    } finally {\n      \n      System.clearProperty(\"shard\");\n      System.clearProperty(\"solr.data.dir\");\n      System.clearProperty(\"coreNodeName\");\n      System.clearProperty(\"solr.ulog.dir\");\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bc766d645fa848f86c381c7f6acf2c881c99399","date":1425549246,"type":4,"author":"Alan Woodward","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":null,"sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(lastPort);\n    } else {\n      startedBefore = true;\n    }\n    \n    if (dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if (solrUlogDir != null) {\n      System.setProperty(\"solr.ulog.dir\", solrUlogDir);\n    }\n    if (shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    if (coreNodeName != null) {\n      System.setProperty(\"coreNodeName\", coreNodeName);\n    }\n    try {\n      \n      if (!server.isRunning()) {\n        server.start();\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr) {\n          this.wait(100);\n          if (cnt++ == 5) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n    } finally {\n      \n      System.clearProperty(\"shard\");\n      System.clearProperty(\"solr.data.dir\");\n      System.clearProperty(\"coreNodeName\");\n      System.clearProperty(\"solr.ulog.dir\");\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":4,"author":"Ryan Ernst","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":null,"sourceOld":"  public void start(boolean waitForSolr) throws Exception {\n    // if started before, make a new server\n    if (startedBefore) {\n      waitOnSolr = false;\n      init(solrHome, context, lastPort, stopAtShutdown);\n    } else {\n      startedBefore = true;\n    }\n    \n    if (dataDir != null) {\n      System.setProperty(\"solr.data.dir\", dataDir);\n    }\n    if (solrUlogDir != null) {\n      System.setProperty(\"solr.ulog.dir\", solrUlogDir);\n    }\n    if (shards != null) {\n      System.setProperty(\"shard\", shards);\n    }\n    if (coreNodeName != null) {\n      System.setProperty(\"coreNodeName\", coreNodeName);\n    }\n    try {\n      \n      if (!server.isRunning()) {\n        server.start();\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr) {\n          this.wait(100);\n          if (cnt++ == 5) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n    } finally {\n      \n      System.clearProperty(\"shard\");\n      System.clearProperty(\"solr.data.dir\");\n      System.clearProperty(\"coreNodeName\");\n      System.clearProperty(\"solr.ulog.dir\");\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9067f5e48f2a848be55167d86815dffa21c5d46","date":1473165216,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        int port = reusePort ? lastPort : this.config.port;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        server.start();\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr) {\n          this.wait(100);\n          if (cnt++ == 5) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n      \n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n    } finally {\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        int port = reusePort ? lastPort : this.config.port;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        server.start();\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr) {\n          this.wait(100);\n          if (cnt++ == 5) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n      \n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n    } finally {\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        int port = reusePort ? lastPort : this.config.port;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        server.start();\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr) {\n          this.wait(100);\n          if (cnt++ == 5) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n      \n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n    } finally {\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        int port = reusePort ? lastPort : this.config.port;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        server.start();\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr) {\n          this.wait(100);\n          if (cnt++ == 5) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n      \n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n    } finally {\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84f20f331d8001864545c7021812d8c6509c7593","date":1517216128,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        int port = reusePort ? jettyPort : this.config.port;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        server.start();\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr) {\n          this.wait(100);\n          if (cnt++ == 5) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n      \n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n    } finally {\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        int port = reusePort ? lastPort : this.config.port;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        server.start();\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr) {\n          this.wait(100);\n          if (cnt++ == 5) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n      \n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n    } finally {\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    \n    log.info(\"Start Jetty (original configured port={})\", this.config.port);\n    \n    try {\n      int port = reusePort && jettyPort != -1 ? jettyPort : this.config.port;\n      \n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        if (config.portRetryTime > 0) {\n          retryOnPortBindFailure(config.portRetryTime, port);\n        } else {\n          server.start();\n        }\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr || !dispatchFilter.isRunning() || getCoreContainer() == null) {\n          this.wait(100);\n          if (cnt++ == 15) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n      \n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) {\n        waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n      }\n      \n      setProtocolAndHost();\n      \n      if (enableProxy) {\n        if (started) {\n          proxy.reopen();\n        } else {\n          proxy.open(getBaseUrl().toURI());\n        }\n      }    \n      \n    } finally {\n      started  = true;\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        int port = reusePort ? jettyPort : this.config.port;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        server.start();\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr) {\n          this.wait(100);\n          if (cnt++ == 5) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n      \n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n    } finally {\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","bugFix":["84f20f331d8001864545c7021812d8c6509c7593","f9067f5e48f2a848be55167d86815dffa21c5d46"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n\n    log.info(\"Start Jetty (original configured port={})\", this.config.port);\n\n    try {\n      int port = reusePort && jettyPort != -1 ? jettyPort : this.config.port;\n\n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        if (config.portRetryTime > 0) {\n          retryOnPortBindFailure(config.portRetryTime, port);\n        } else {\n          server.start();\n        }\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr || !dispatchFilter.isRunning() || getCoreContainer() == null) {\n          this.wait(100);\n          if (cnt++ == 15) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n\n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) {\n        waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n      }\n\n      setProtocolAndHost();\n\n      if (enableProxy) {\n        if (started) {\n          proxy.reopen();\n        } else {\n          proxy.open(getBaseUrl().toURI());\n        }\n      }\n\n    } finally {\n      started  = true;\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    \n    log.info(\"Start Jetty (original configured port={})\", this.config.port);\n    \n    try {\n      int port = reusePort && jettyPort != -1 ? jettyPort : this.config.port;\n      \n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        if (config.portRetryTime > 0) {\n          retryOnPortBindFailure(config.portRetryTime, port);\n        } else {\n          server.start();\n        }\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr || !dispatchFilter.isRunning() || getCoreContainer() == null) {\n          this.wait(100);\n          if (cnt++ == 15) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n      \n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) {\n        waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n      }\n      \n      setProtocolAndHost();\n      \n      if (enableProxy) {\n        if (started) {\n          proxy.reopen();\n        } else {\n          proxy.open(getBaseUrl().toURI());\n        }\n      }    \n      \n    } finally {\n      started  = true;\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c031f89d05e49433a4b3b84f0dcb8fc28df8d06","date":1569862833,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n\n    try {\n      int port = reusePort && jettyPort != -1 ? jettyPort : this.config.port;\n      log.info(\"Start Jetty (configured port={}, binding port={})\", this.config.port, port);\n\n\n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        if (config.portRetryTime > 0) {\n          retryOnPortBindFailure(config.portRetryTime, port);\n        } else {\n          server.start();\n        }\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr || !dispatchFilter.isRunning() || getCoreContainer() == null) {\n          this.wait(100);\n          if (cnt++ == 15) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n\n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) {\n        waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n      }\n\n      setProtocolAndHost();\n\n      if (enableProxy) {\n        if (started) {\n          proxy.reopen();\n        } else {\n          proxy.open(getBaseUrl().toURI());\n        }\n      }\n\n    } finally {\n      started  = true;\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n\n    log.info(\"Start Jetty (original configured port={})\", this.config.port);\n\n    try {\n      int port = reusePort && jettyPort != -1 ? jettyPort : this.config.port;\n\n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        if (config.portRetryTime > 0) {\n          retryOnPortBindFailure(config.portRetryTime, port);\n        } else {\n          server.start();\n        }\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr || !dispatchFilter.isRunning() || getCoreContainer() == null) {\n          this.wait(100);\n          if (cnt++ == 15) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n\n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) {\n        waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n      }\n\n      setProtocolAndHost();\n\n      if (enableProxy) {\n        if (started) {\n          proxy.reopen();\n        } else {\n          proxy.open(getBaseUrl().toURI());\n        }\n      }\n\n    } finally {\n      started  = true;\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#start(boolean).mjava","sourceNew":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n\n    try {\n      int port = reusePort && jettyPort != -1 ? jettyPort : this.config.port;\n      log.info(\"Start Jetty (configured port={}, binding port={})\", this.config.port, port);\n\n\n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        if (config.portRetryTime > 0) {\n          retryOnPortBindFailure(config.portRetryTime, port);\n        } else {\n          server.start();\n        }\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr || !dispatchFilter.isRunning() || getCoreContainer() == null) {\n          this.wait(100);\n          if (cnt++ == 15) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n\n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) {\n        waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n      }\n\n      setProtocolAndHost();\n\n      if (enableProxy) {\n        if (started) {\n          proxy.reopen();\n        } else {\n          proxy.open(getBaseUrl().toURI());\n        }\n      }\n\n    } finally {\n      started  = true;\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Start the Jetty server\n   *\n   * @param reusePort when true, will start up on the same port as used by any\n   *                  previous runs of this JettySolrRunner.  If false, will use\n   *                  the port specified by the server's JettyConfig.\n   *\n   * @throws Exception if an error occurs on startup\n   */\n  public void start(boolean reusePort) throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n\n    log.info(\"Start Jetty (original configured port={})\", this.config.port);\n\n    try {\n      int port = reusePort && jettyPort != -1 ? jettyPort : this.config.port;\n\n      // if started before, make a new server\n      if (startedBefore) {\n        waitOnSolr = false;\n        init(port);\n      } else {\n        startedBefore = true;\n      }\n\n      if (!server.isRunning()) {\n        if (config.portRetryTime > 0) {\n          retryOnPortBindFailure(config.portRetryTime, port);\n        } else {\n          server.start();\n        }\n      }\n      synchronized (JettySolrRunner.this) {\n        int cnt = 0;\n        while (!waitOnSolr || !dispatchFilter.isRunning() || getCoreContainer() == null) {\n          this.wait(100);\n          if (cnt++ == 15) {\n            throw new RuntimeException(\"Jetty/Solr unresponsive\");\n          }\n        }\n      }\n\n      if (config.waitForLoadingCoresToFinishMs != null && config.waitForLoadingCoresToFinishMs > 0L) {\n        waitForLoadingCoresToFinish(config.waitForLoadingCoresToFinishMs);\n      }\n\n      setProtocolAndHost();\n\n      if (enableProxy) {\n        if (started) {\n          proxy.reopen();\n        } else {\n          proxy.open(getBaseUrl().toURI());\n        }\n      }\n\n    } finally {\n      started  = true;\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f9067f5e48f2a848be55167d86815dffa21c5d46":["9bc766d645fa848f86c381c7f6acf2c881c99399"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["84f20f331d8001864545c7021812d8c6509c7593"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","66c64e8cfded6a585100e6430238faaf416f3fea"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"9bc766d645fa848f86c381c7f6acf2c881c99399":["c66158bb16e902a21272772f1b911f04b1a55abb"],"84f20f331d8001864545c7021812d8c6509c7593":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","66c64e8cfded6a585100e6430238faaf416f3fea"],"89424def13674ea17829b41c5883c54ecc31a132":["9bc766d645fa848f86c381c7f6acf2c881c99399","f9067f5e48f2a848be55167d86815dffa21c5d46"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["dcb5de84d260a8919bf0f2d4d180df543a2ad07a","9bc766d645fa848f86c381c7f6acf2c881c99399"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"dcb5de84d260a8919bf0f2d4d180df543a2ad07a":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"f327cb201b2cdff5931f786d3b0774aff2c780a2":["322e2184986b71f21c079e090f7b06b130b3ed13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["9bc766d645fa848f86c381c7f6acf2c881c99399","89424def13674ea17829b41c5883c54ecc31a132"],"25959fdb8f69c74c6a5836bf42e8e98c705ad005":["66c64e8cfded6a585100e6430238faaf416f3fea"],"2c031f89d05e49433a4b3b84f0dcb8fc28df8d06":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"322e2184986b71f21c079e090f7b06b130b3ed13":["45fcf1edbef6678c8a5b7e3d9604aec6a3ae56b2"],"66c64e8cfded6a585100e6430238faaf416f3fea":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","25959fdb8f69c74c6a5836bf42e8e98c705ad005"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9bc766d645fa848f86c381c7f6acf2c881c99399","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["c26f00b574427b55127e869b935845554afde1fa"],"45fcf1edbef6678c8a5b7e3d9604aec6a3ae56b2":["25959fdb8f69c74c6a5836bf42e8e98c705ad005"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["f327cb201b2cdff5931f786d3b0774aff2c780a2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2c031f89d05e49433a4b3b84f0dcb8fc28df8d06"],"c66158bb16e902a21272772f1b911f04b1a55abb":["dcb5de84d260a8919bf0f2d4d180df543a2ad07a"],"b0b597c65628ca9e73913a07e81691f8229bae35":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","2c031f89d05e49433a4b3b84f0dcb8fc28df8d06"]},"commit2Childs":{"f9067f5e48f2a848be55167d86815dffa21c5d46":["89424def13674ea17829b41c5883c54ecc31a132"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"c26f00b574427b55127e869b935845554afde1fa":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"9bc766d645fa848f86c381c7f6acf2c881c99399":["f9067f5e48f2a848be55167d86815dffa21c5d46","89424def13674ea17829b41c5883c54ecc31a132","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"84f20f331d8001864545c7021812d8c6509c7593":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"dcb5de84d260a8919bf0f2d4d180df543a2ad07a":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","c66158bb16e902a21272772f1b911f04b1a55abb"],"f327cb201b2cdff5931f786d3b0774aff2c780a2":["cb4a195b8dc1808cd01748bd2e0fba26ca915d4d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["84f20f331d8001864545c7021812d8c6509c7593","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"25959fdb8f69c74c6a5836bf42e8e98c705ad005":["05a14b2611ead08655a2b2bdc61632eb31316e57","45fcf1edbef6678c8a5b7e3d9604aec6a3ae56b2"],"322e2184986b71f21c079e090f7b06b130b3ed13":["f327cb201b2cdff5931f786d3b0774aff2c780a2"],"2c031f89d05e49433a4b3b84f0dcb8fc28df8d06":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"66c64e8cfded6a585100e6430238faaf416f3fea":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","25959fdb8f69c74c6a5836bf42e8e98c705ad005"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","dcb5de84d260a8919bf0f2d4d180df543a2ad07a"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","0d22ac6a4146774c1bc8400160fc0b6150294e92","66c64e8cfded6a585100e6430238faaf416f3fea","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"45fcf1edbef6678c8a5b7e3d9604aec6a3ae56b2":["322e2184986b71f21c079e090f7b06b130b3ed13"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["2c031f89d05e49433a4b3b84f0dcb8fc28df8d06","b0b597c65628ca9e73913a07e81691f8229bae35"],"cb4a195b8dc1808cd01748bd2e0fba26ca915d4d":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"c66158bb16e902a21272772f1b911f04b1a55abb":["9bc766d645fa848f86c381c7f6acf2c881c99399"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","b05c56a41b733e02a189c48895922b5bd8c7f3d1","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","05a14b2611ead08655a2b2bdc61632eb31316e57","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}