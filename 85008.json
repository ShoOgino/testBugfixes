{"path":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","commits":[{"id":"7a744f34b732efe0beb11df92bde24ccc01460dc","date":1094656002,"type":1,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,Analyzer,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field,\n                                              new StringReader(queryText));\n    Vector v = new Vector();\n    org.apache.lucene.analysis.Token t;\n\n    while (true) {\n      try {\n        t = source.next();\n      }\n      catch (IOException e) {\n        t = null;\n      }\n      if (t == null)\n        break;\n      v.addElement(t.termText());\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1)\n      return new TermQuery(new Term(field, (String) v.elementAt(0)));\n    else {\n      PhraseQuery q = new PhraseQuery();\n      q.setSlop(phraseSlop);\n      for (int i=0; i<v.size(); i++) {\n        q.add(new Term(field, (String) v.elementAt(i)));\n      }\n      return q;\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field,\n                                Analyzer analyzer,\n                                String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field,\n                                              new StringReader(queryText));\n    Vector v = new Vector();\n    org.apache.lucene.analysis.Token t;\n\n    while (true) {\n      try {\n        t = source.next();\n      }\n      catch (IOException e) {\n        t = null;\n      }\n      if (t == null)\n        break;\n      v.addElement(t.termText());\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1)\n      return new TermQuery(new Term(field, (String) v.elementAt(0)));\n    else {\n      PhraseQuery q = new PhraseQuery();\n      q.setSlop(phraseSlop);\n      for (int i=0; i<v.size(); i++) {\n        q.add(new Term(field, (String) v.elementAt(i)));\n      }\n      return q;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01b9585922e829a4f49f41499e0202f20fbe3275","date":1100358686,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    org.apache.lucene.analysis.Token t;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        t = source.next();\n      }\n      catch (IOException e) {\n        t = null;\n      }\n      if (t == null)\n        break;\n      v.addElement(t);\n      if (t.getPositionIncrement() == 1)\n        positionCount++;\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      t = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return new TermQuery(new Term(field, t.termText()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = new BooleanQuery();\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            TermQuery currentQuery = new TermQuery(\n                new Term(field, t.termText()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = new MultiPhraseQuery();\n          List multiTerms = new ArrayList();\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              multiTerms.clear();\n            }\n            multiTerms.add(new Term(field, t.termText()));\n          }\n          mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery q = new PhraseQuery();\n        q.setSlop(phraseSlop);\n        for (int i = 0; i < v.size(); i++) {\n          q.add(new Term(field, ((org.apache.lucene.analysis.Token)\n              v.elementAt(i)).termText()));\n\n        }\n        return q;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field,\n                                              new StringReader(queryText));\n    Vector v = new Vector();\n    org.apache.lucene.analysis.Token t;\n\n    while (true) {\n      try {\n        t = source.next();\n      }\n      catch (IOException e) {\n        t = null;\n      }\n      if (t == null)\n        break;\n      v.addElement(t.termText());\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1)\n      return new TermQuery(new Term(field, (String) v.elementAt(0)));\n    else {\n      PhraseQuery q = new PhraseQuery();\n      q.setSlop(phraseSlop);\n      for (int i=0; i<v.size(); i++) {\n        q.add(new Term(field, (String) v.elementAt(i)));\n      }\n      return q;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcbc8ed27f45a5a299f8414d7a886340ce7bb3db","date":1110223587,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    org.apache.lucene.analysis.Token t;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        t = source.next();\n      }\n      catch (IOException e) {\n        t = null;\n      }\n      if (t == null)\n        break;\n      v.addElement(t);\n      if (t.getPositionIncrement() == 1)\n        positionCount++;\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      t = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return new TermQuery(new Term(field, t.termText()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = new BooleanQuery(true);\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            TermQuery currentQuery = new TermQuery(\n                new Term(field, t.termText()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = new MultiPhraseQuery();\n          List multiTerms = new ArrayList();\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              multiTerms.clear();\n            }\n            multiTerms.add(new Term(field, t.termText()));\n          }\n          mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery q = new PhraseQuery();\n        q.setSlop(phraseSlop);\n        for (int i = 0; i < v.size(); i++) {\n          q.add(new Term(field, ((org.apache.lucene.analysis.Token)\n              v.elementAt(i)).termText()));\n\n        }\n        return q;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    org.apache.lucene.analysis.Token t;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        t = source.next();\n      }\n      catch (IOException e) {\n        t = null;\n      }\n      if (t == null)\n        break;\n      v.addElement(t);\n      if (t.getPositionIncrement() == 1)\n        positionCount++;\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      t = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return new TermQuery(new Term(field, t.termText()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = new BooleanQuery();\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            TermQuery currentQuery = new TermQuery(\n                new Term(field, t.termText()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = new MultiPhraseQuery();\n          List multiTerms = new ArrayList();\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              multiTerms.clear();\n            }\n            multiTerms.add(new Term(field, t.termText()));\n          }\n          mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery q = new PhraseQuery();\n        q.setSlop(phraseSlop);\n        for (int i = 0; i < v.size(); i++) {\n          q.add(new Term(field, ((org.apache.lucene.analysis.Token)\n              v.elementAt(i)).termText()));\n\n        }\n        return q;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d79a074a316c6cd3908ca819cd98ad74d1e4dd30","date":1131491144,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    org.apache.lucene.analysis.Token t;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        t = source.next();\n      }\n      catch (IOException e) {\n        t = null;\n      }\n      if (t == null)\n        break;\n      v.addElement(t);\n      if (t.getPositionIncrement() != 0)\n        positionCount += t.getPositionIncrement();\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      t = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return new TermQuery(new Term(field, t.termText()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = new BooleanQuery(true);\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            TermQuery currentQuery = new TermQuery(\n                new Term(field, t.termText()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = new MultiPhraseQuery();\n          List multiTerms = new ArrayList();\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              multiTerms.clear();\n            }\n            multiTerms.add(new Term(field, t.termText()));\n          }\n          mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery q = new PhraseQuery();\n        q.setSlop(phraseSlop);\n        for (int i = 0; i < v.size(); i++) {\n          q.add(new Term(field, ((org.apache.lucene.analysis.Token)\n              v.elementAt(i)).termText()));\n\n        }\n        return q;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    org.apache.lucene.analysis.Token t;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        t = source.next();\n      }\n      catch (IOException e) {\n        t = null;\n      }\n      if (t == null)\n        break;\n      v.addElement(t);\n      if (t.getPositionIncrement() == 1)\n        positionCount++;\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      t = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return new TermQuery(new Term(field, t.termText()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = new BooleanQuery(true);\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            TermQuery currentQuery = new TermQuery(\n                new Term(field, t.termText()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = new MultiPhraseQuery();\n          List multiTerms = new ArrayList();\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              multiTerms.clear();\n            }\n            multiTerms.add(new Term(field, t.termText()));\n          }\n          mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery q = new PhraseQuery();\n        q.setSlop(phraseSlop);\n        for (int i = 0; i < v.size(); i++) {\n          q.add(new Term(field, ((org.apache.lucene.analysis.Token)\n              v.elementAt(i)).termText()));\n\n        }\n        return q;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dcb8034cf155d661867043fbc42b577d03903036","date":1136759752,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    org.apache.lucene.analysis.Token t;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        t = source.next();\n      }\n      catch (IOException e) {\n        t = null;\n      }\n      if (t == null)\n        break;\n      v.addElement(t);\n      if (t.getPositionIncrement() != 0)\n        positionCount += t.getPositionIncrement();\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      t = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return new TermQuery(new Term(field, t.termText()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = new BooleanQuery(true);\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            TermQuery currentQuery = new TermQuery(\n                new Term(field, t.termText()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = new MultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              multiTerms.clear();\n            }\n            multiTerms.add(new Term(field, t.termText()));\n          }\n          mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery q = new PhraseQuery();\n        q.setSlop(phraseSlop);\n        for (int i = 0; i < v.size(); i++) {\n          q.add(new Term(field, ((org.apache.lucene.analysis.Token)\n              v.elementAt(i)).termText()));\n\n        }\n        return q;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    org.apache.lucene.analysis.Token t;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        t = source.next();\n      }\n      catch (IOException e) {\n        t = null;\n      }\n      if (t == null)\n        break;\n      v.addElement(t);\n      if (t.getPositionIncrement() != 0)\n        positionCount += t.getPositionIncrement();\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      t = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return new TermQuery(new Term(field, t.termText()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = new BooleanQuery(true);\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            TermQuery currentQuery = new TermQuery(\n                new Term(field, t.termText()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = new MultiPhraseQuery();\n          List multiTerms = new ArrayList();\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              multiTerms.clear();\n            }\n            multiTerms.add(new Term(field, t.termText()));\n          }\n          mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery q = new PhraseQuery();\n        q.setSlop(phraseSlop);\n        for (int i = 0; i < v.size(); i++) {\n          q.add(new Term(field, ((org.apache.lucene.analysis.Token)\n              v.elementAt(i)).termText()));\n\n        }\n        return q;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"693d6573b6621fc1265316fc6b042c24235c81d8","date":1199049557,"type":3,"author":"Doron Cohen","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    org.apache.lucene.analysis.Token t;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        t = source.next();\n      }\n      catch (IOException e) {\n        t = null;\n      }\n      if (t == null)\n        break;\n      v.addElement(t);\n      if (t.getPositionIncrement() != 0)\n        positionCount += t.getPositionIncrement();\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      t = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return new TermQuery(new Term(field, t.termText()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = new BooleanQuery(true);\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            TermQuery currentQuery = new TermQuery(\n                new Term(field, t.termText()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = new MultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (t.getPositionIncrement() > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += t.getPositionIncrement();\n            multiTerms.add(new Term(field, t.termText()));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = new PhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n        for (int i = 0; i < v.size(); i++) {\n          t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n          if (enablePositionIncrements) {\n            position += t.getPositionIncrement();\n            pq.add(new Term(field, t.termText()),position);\n          } else {\n            pq.add(new Term(field, t.termText()));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    org.apache.lucene.analysis.Token t;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        t = source.next();\n      }\n      catch (IOException e) {\n        t = null;\n      }\n      if (t == null)\n        break;\n      v.addElement(t);\n      if (t.getPositionIncrement() != 0)\n        positionCount += t.getPositionIncrement();\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      t = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return new TermQuery(new Term(field, t.termText()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = new BooleanQuery(true);\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            TermQuery currentQuery = new TermQuery(\n                new Term(field, t.termText()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = new MultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {\n              mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              multiTerms.clear();\n            }\n            multiTerms.add(new Term(field, t.termText()));\n          }\n          mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery q = new PhraseQuery();\n        q.setSlop(phraseSlop);\n        for (int i = 0; i < v.size(); i++) {\n          q.add(new Term(field, ((org.apache.lucene.analysis.Token)\n              v.elementAt(i)).termText()));\n\n        }\n        return q;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e2cb543b41c145f33390f460ee743d6693c9c6c","date":1219243087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    final org.apache.lucene.analysis.Token reusableToken = new org.apache.lucene.analysis.Token();\n    org.apache.lucene.analysis.Token nextToken;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        nextToken = source.next(reusableToken);\n      }\n      catch (IOException e) {\n        nextToken = null;\n      }\n      if (nextToken == null)\n        break;\n      v.addElement(nextToken.clone());\n      if (nextToken.getPositionIncrement() != 0)\n        positionCount += nextToken.getPositionIncrement();\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      nextToken = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return new TermQuery(new Term(field, nextToken.term()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = new BooleanQuery(true);\n          for (int i = 0; i < v.size(); i++) {\n            nextToken = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            TermQuery currentQuery = new TermQuery(\n                new Term(field, nextToken.term()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = new MultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < v.size(); i++) {\n            nextToken = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (nextToken.getPositionIncrement() > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += nextToken.getPositionIncrement();\n            multiTerms.add(new Term(field, nextToken.term()));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = new PhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n        for (int i = 0; i < v.size(); i++) {\n          nextToken = (org.apache.lucene.analysis.Token) v.elementAt(i);\n          if (enablePositionIncrements) {\n            position += nextToken.getPositionIncrement();\n            pq.add(new Term(field, nextToken.term()),position);\n          } else {\n            pq.add(new Term(field, nextToken.term()));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    org.apache.lucene.analysis.Token t;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        t = source.next();\n      }\n      catch (IOException e) {\n        t = null;\n      }\n      if (t == null)\n        break;\n      v.addElement(t);\n      if (t.getPositionIncrement() != 0)\n        positionCount += t.getPositionIncrement();\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      t = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return new TermQuery(new Term(field, t.termText()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = new BooleanQuery(true);\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            TermQuery currentQuery = new TermQuery(\n                new Term(field, t.termText()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = new MultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < v.size(); i++) {\n            t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (t.getPositionIncrement() > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += t.getPositionIncrement();\n            multiTerms.add(new Term(field, t.termText()));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = new PhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n        for (int i = 0; i < v.size(); i++) {\n          t = (org.apache.lucene.analysis.Token) v.elementAt(i);\n          if (enablePositionIncrements) {\n            position += t.getPositionIncrement();\n            pq.add(new Term(field, t.termText()),position);\n          } else {\n            pq.add(new Term(field, t.termText()));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a28fe77124a2ece3a2af0a5c1b264e07c7cae728","date":1220116339,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    final org.apache.lucene.analysis.Token reusableToken = new org.apache.lucene.analysis.Token();\n    org.apache.lucene.analysis.Token nextToken;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        nextToken = source.next(reusableToken);\n      }\n      catch (IOException e) {\n        nextToken = null;\n      }\n      if (nextToken == null)\n        break;\n      v.addElement(nextToken.clone());\n      if (nextToken.getPositionIncrement() != 0)\n        positionCount += nextToken.getPositionIncrement();\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      nextToken = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return newTermQuery(new Term(field, nextToken.term()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < v.size(); i++) {\n            nextToken = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            Query currentQuery = newTermQuery(\n                new Term(field, nextToken.term()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < v.size(); i++) {\n            nextToken = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (nextToken.getPositionIncrement() > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += nextToken.getPositionIncrement();\n            multiTerms.add(new Term(field, nextToken.term()));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n        for (int i = 0; i < v.size(); i++) {\n          nextToken = (org.apache.lucene.analysis.Token) v.elementAt(i);\n          if (enablePositionIncrements) {\n            position += nextToken.getPositionIncrement();\n            pq.add(new Term(field, nextToken.term()),position);\n          } else {\n            pq.add(new Term(field, nextToken.term()));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    final org.apache.lucene.analysis.Token reusableToken = new org.apache.lucene.analysis.Token();\n    org.apache.lucene.analysis.Token nextToken;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        nextToken = source.next(reusableToken);\n      }\n      catch (IOException e) {\n        nextToken = null;\n      }\n      if (nextToken == null)\n        break;\n      v.addElement(nextToken.clone());\n      if (nextToken.getPositionIncrement() != 0)\n        positionCount += nextToken.getPositionIncrement();\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      nextToken = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return new TermQuery(new Term(field, nextToken.term()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = new BooleanQuery(true);\n          for (int i = 0; i < v.size(); i++) {\n            nextToken = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            TermQuery currentQuery = new TermQuery(\n                new Term(field, nextToken.term()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = new MultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < v.size(); i++) {\n            nextToken = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (nextToken.getPositionIncrement() > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += nextToken.getPositionIncrement();\n            multiTerms.add(new Term(field, nextToken.term()));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = new PhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n        for (int i = 0; i < v.size(); i++) {\n          nextToken = (org.apache.lucene.analysis.Token) v.elementAt(i);\n          if (enablePositionIncrements) {\n            position += nextToken.getPositionIncrement();\n            pq.add(new Term(field, nextToken.term()),position);\n          } else {\n            pq.add(new Term(field, nextToken.term()));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7b6cdc70e097da94da79a655ed8f94477ff69f5","date":1220815360,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    List list = new ArrayList();\n    final org.apache.lucene.analysis.Token reusableToken = new org.apache.lucene.analysis.Token();\n    org.apache.lucene.analysis.Token nextToken;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        nextToken = source.next(reusableToken);\n      }\n      catch (IOException e) {\n        nextToken = null;\n      }\n      if (nextToken == null)\n        break;\n      list.add(nextToken.clone());\n      if (nextToken.getPositionIncrement() != 0)\n        positionCount += nextToken.getPositionIncrement();\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (list.size() == 0)\n      return null;\n    else if (list.size() == 1) {\n      nextToken = (org.apache.lucene.analysis.Token) list.get(0);\n      return newTermQuery(new Term(field, nextToken.term()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < list.size(); i++) {\n            nextToken = (org.apache.lucene.analysis.Token) list.get(i);\n            Query currentQuery = newTermQuery(\n                new Term(field, nextToken.term()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < list.size(); i++) {\n            nextToken = (org.apache.lucene.analysis.Token) list.get(i);\n            if (nextToken.getPositionIncrement() > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += nextToken.getPositionIncrement();\n            multiTerms.add(new Term(field, nextToken.term()));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n        for (int i = 0; i < list.size(); i++) {\n          nextToken = (org.apache.lucene.analysis.Token) list.get(i);\n          if (enablePositionIncrements) {\n            position += nextToken.getPositionIncrement();\n            pq.add(new Term(field, nextToken.term()),position);\n          } else {\n            pq.add(new Term(field, nextToken.term()));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    Vector v = new Vector();\n    final org.apache.lucene.analysis.Token reusableToken = new org.apache.lucene.analysis.Token();\n    org.apache.lucene.analysis.Token nextToken;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        nextToken = source.next(reusableToken);\n      }\n      catch (IOException e) {\n        nextToken = null;\n      }\n      if (nextToken == null)\n        break;\n      v.addElement(nextToken.clone());\n      if (nextToken.getPositionIncrement() != 0)\n        positionCount += nextToken.getPositionIncrement();\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (v.size() == 0)\n      return null;\n    else if (v.size() == 1) {\n      nextToken = (org.apache.lucene.analysis.Token) v.elementAt(0);\n      return newTermQuery(new Term(field, nextToken.term()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < v.size(); i++) {\n            nextToken = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            Query currentQuery = newTermQuery(\n                new Term(field, nextToken.term()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < v.size(); i++) {\n            nextToken = (org.apache.lucene.analysis.Token) v.elementAt(i);\n            if (nextToken.getPositionIncrement() > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += nextToken.getPositionIncrement();\n            multiTerms.add(new Term(field, nextToken.term()));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n        for (int i = 0; i < v.size(); i++) {\n          nextToken = (org.apache.lucene.analysis.Token) v.elementAt(i);\n          if (enablePositionIncrements) {\n            position += nextToken.getPositionIncrement();\n            pq.add(new Term(field, nextToken.term()),position);\n          } else {\n            pq.add(new Term(field, nextToken.term()));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74a5e7f20b4a444da9df3b2c0f331fa7a1f64223","date":1227051709,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    CachingTokenFilter buffer = new CachingTokenFilter(source);\n    TermAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n\n    org.apache.lucene.analysis.Token reusableToken = null;\n    org.apache.lucene.analysis.Token nextToken = null;\n\n\n    boolean useNewAPI = TokenStream.useNewAPIDefault();\n\n    if (useNewAPI) {\n      boolean success = false;\n      try {\n        buffer.reset();\n        success = true;\n      } catch (IOException e) {\n        // success==false if we hit an exception\n      }\n      if (success) {\n        if (buffer.hasAttribute(TermAttribute.class)) {\n          termAtt = (TermAttribute) buffer.getAttribute(TermAttribute.class);\n        }\n        if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n          posIncrAtt = (PositionIncrementAttribute) buffer.getAttribute(PositionIncrementAttribute.class);\n        }\n      }\n    } else {\n      reusableToken = new org.apache.lucene.analysis.Token();\n    }\n\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    if (useNewAPI) {\n      if (termAtt != null) {\n        try {\n          while (buffer.incrementToken()) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } else {\n      while (true) {\n        try {\n          nextToken = buffer.next(reusableToken);\n        }\n        catch (IOException e) {\n          nextToken = null;\n        }\n        if (nextToken == null)\n          break;\n        numTokens++;\n        if (nextToken.getPositionIncrement() != 0)\n          positionCount += nextToken.getPositionIncrement();\n        else\n          severalTokensAtSamePosition = true;\n      }\n    }\n    try {\n      // rewind the buffer stream\n      buffer.reset();\n\n      // close original stream - all tokens buffered\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      String term = null;\n      try {\n\n        if (useNewAPI) {\n          boolean hasNext = buffer.incrementToken();\n          assert hasNext == true;\n          term = termAtt.term();\n        } else {\n          nextToken = buffer.next(reusableToken);\n          assert nextToken != null;\n          term = nextToken.term();\n        }\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, term));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              if (useNewAPI) {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                term = termAtt.term();\n              } else {\n                nextToken = buffer.next(reusableToken);\n                assert nextToken != null;\n                term = nextToken.term();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            Query currentQuery = newTermQuery(\n                new Term(field, term));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              if (useNewAPI) {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                term = termAtt.term();\n                if (posIncrAtt != null) {\n                  positionIncrement = posIncrAtt.getPositionIncrement();\n                }\n              } else {\n                nextToken = buffer.next(reusableToken);\n                assert nextToken != null;\n                term = nextToken.term();\n                positionIncrement = nextToken.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, term));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            if (useNewAPI) {\n\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } else {\n              nextToken = buffer.next(reusableToken);\n              assert nextToken != null;\n              term = nextToken.term();\n              positionIncrement = nextToken.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, term),position);\n          } else {\n            pq.add(new Term(field, term));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    List list = new ArrayList();\n    final org.apache.lucene.analysis.Token reusableToken = new org.apache.lucene.analysis.Token();\n    org.apache.lucene.analysis.Token nextToken;\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    while (true) {\n      try {\n        nextToken = source.next(reusableToken);\n      }\n      catch (IOException e) {\n        nextToken = null;\n      }\n      if (nextToken == null)\n        break;\n      list.add(nextToken.clone());\n      if (nextToken.getPositionIncrement() != 0)\n        positionCount += nextToken.getPositionIncrement();\n      else\n        severalTokensAtSamePosition = true;\n    }\n    try {\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (list.size() == 0)\n      return null;\n    else if (list.size() == 1) {\n      nextToken = (org.apache.lucene.analysis.Token) list.get(0);\n      return newTermQuery(new Term(field, nextToken.term()));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < list.size(); i++) {\n            nextToken = (org.apache.lucene.analysis.Token) list.get(i);\n            Query currentQuery = newTermQuery(\n                new Term(field, nextToken.term()));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < list.size(); i++) {\n            nextToken = (org.apache.lucene.analysis.Token) list.get(i);\n            if (nextToken.getPositionIncrement() > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += nextToken.getPositionIncrement();\n            multiTerms.add(new Term(field, nextToken.term()));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n        for (int i = 0; i < list.size(); i++) {\n          nextToken = (org.apache.lucene.analysis.Token) list.get(i);\n          if (enablePositionIncrements) {\n            position += nextToken.getPositionIncrement();\n            pq.add(new Term(field, nextToken.term()),position);\n          } else {\n            pq.add(new Term(field, nextToken.term()));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec8b5a20a12931b8d7e616c79c5248ae06cc5568","date":1248471948,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    CachingTokenFilter buffer = new CachingTokenFilter(source);\n    TermAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n\n    boolean success = false;\n    try {\n      buffer.reset();\n      success = true;\n    } catch (IOException e) {\n      // success==false if we hit an exception\n    }\n    if (success) {\n      if (buffer.hasAttribute(TermAttribute.class)) {\n        termAtt = (TermAttribute) buffer.getAttribute(TermAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = (PositionIncrementAttribute) buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n    }\n\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    boolean hasMoreTokens = false;\n    if (termAtt != null) {\n      try {\n        hasMoreTokens = buffer.incrementToken();\n        while (hasMoreTokens) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n          hasMoreTokens = buffer.incrementToken();\n        }\n      } catch (IOException e) {\n        // ignore\n      }\n    }\n    try {\n      // rewind the buffer stream\n      buffer.reset();\n\n      // close original stream - all tokens buffered\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      String term = null;\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        term = termAtt.term();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, term));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            Query currentQuery = newTermQuery(\n                new Term(field, term));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, term));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.term();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, term),position);\n          } else {\n            pq.add(new Term(field, term));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    CachingTokenFilter buffer = new CachingTokenFilter(source);\n    TermAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n\n    org.apache.lucene.analysis.Token reusableToken = null;\n    org.apache.lucene.analysis.Token nextToken = null;\n\n\n    boolean useNewAPI = TokenStream.useNewAPIDefault();\n\n    if (useNewAPI) {\n      boolean success = false;\n      try {\n        buffer.reset();\n        success = true;\n      } catch (IOException e) {\n        // success==false if we hit an exception\n      }\n      if (success) {\n        if (buffer.hasAttribute(TermAttribute.class)) {\n          termAtt = (TermAttribute) buffer.getAttribute(TermAttribute.class);\n        }\n        if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n          posIncrAtt = (PositionIncrementAttribute) buffer.getAttribute(PositionIncrementAttribute.class);\n        }\n      }\n    } else {\n      reusableToken = new org.apache.lucene.analysis.Token();\n    }\n\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    if (useNewAPI) {\n      if (termAtt != null) {\n        try {\n          while (buffer.incrementToken()) {\n            numTokens++;\n            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n            if (positionIncrement != 0) {\n              positionCount += positionIncrement;\n            } else {\n              severalTokensAtSamePosition = true;\n            }\n          }\n        } catch (IOException e) {\n          // ignore\n        }\n      }\n    } else {\n      while (true) {\n        try {\n          nextToken = buffer.next(reusableToken);\n        }\n        catch (IOException e) {\n          nextToken = null;\n        }\n        if (nextToken == null)\n          break;\n        numTokens++;\n        if (nextToken.getPositionIncrement() != 0)\n          positionCount += nextToken.getPositionIncrement();\n        else\n          severalTokensAtSamePosition = true;\n      }\n    }\n    try {\n      // rewind the buffer stream\n      buffer.reset();\n\n      // close original stream - all tokens buffered\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      String term = null;\n      try {\n\n        if (useNewAPI) {\n          boolean hasNext = buffer.incrementToken();\n          assert hasNext == true;\n          term = termAtt.term();\n        } else {\n          nextToken = buffer.next(reusableToken);\n          assert nextToken != null;\n          term = nextToken.term();\n        }\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, term));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              if (useNewAPI) {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                term = termAtt.term();\n              } else {\n                nextToken = buffer.next(reusableToken);\n                assert nextToken != null;\n                term = nextToken.term();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            Query currentQuery = newTermQuery(\n                new Term(field, term));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              if (useNewAPI) {\n                boolean hasNext = buffer.incrementToken();\n                assert hasNext == true;\n                term = termAtt.term();\n                if (posIncrAtt != null) {\n                  positionIncrement = posIncrAtt.getPositionIncrement();\n                }\n              } else {\n                nextToken = buffer.next(reusableToken);\n                assert nextToken != null;\n                term = nextToken.term();\n                positionIncrement = nextToken.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, term));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            if (useNewAPI) {\n\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } else {\n              nextToken = buffer.next(reusableToken);\n              assert nextToken != null;\n              term = nextToken.term();\n              positionIncrement = nextToken.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, term),position);\n          } else {\n            pq.add(new Term(field, term));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f5a603e3919a020001e02985a79df6e8d576affd","date":1250103229,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source;\n    try {\n      source = analyzer.reusableTokenStream(field, new StringReader(queryText));\n      source.reset();\n    } catch (IOException e) {\n      source = analyzer.tokenStream(field, new StringReader(queryText));\n    }\n    CachingTokenFilter buffer = new CachingTokenFilter(source);\n    TermAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n\n    boolean success = false;\n    try {\n      buffer.reset();\n      success = true;\n    } catch (IOException e) {\n      // success==false if we hit an exception\n    }\n    if (success) {\n      if (buffer.hasAttribute(TermAttribute.class)) {\n        termAtt = (TermAttribute) buffer.getAttribute(TermAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = (PositionIncrementAttribute) buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n    }\n\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    boolean hasMoreTokens = false;\n    if (termAtt != null) {\n      try {\n        hasMoreTokens = buffer.incrementToken();\n        while (hasMoreTokens) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n          hasMoreTokens = buffer.incrementToken();\n        }\n      } catch (IOException e) {\n        // ignore\n      }\n    }\n    try {\n      // rewind the buffer stream\n      buffer.reset();\n\n      // close original stream - all tokens buffered\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      String term = null;\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        term = termAtt.term();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, term));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            Query currentQuery = newTermQuery(\n                new Term(field, term));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, term));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.term();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, term),position);\n          } else {\n            pq.add(new Term(field, term));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));\n    CachingTokenFilter buffer = new CachingTokenFilter(source);\n    TermAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n\n    boolean success = false;\n    try {\n      buffer.reset();\n      success = true;\n    } catch (IOException e) {\n      // success==false if we hit an exception\n    }\n    if (success) {\n      if (buffer.hasAttribute(TermAttribute.class)) {\n        termAtt = (TermAttribute) buffer.getAttribute(TermAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = (PositionIncrementAttribute) buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n    }\n\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    boolean hasMoreTokens = false;\n    if (termAtt != null) {\n      try {\n        hasMoreTokens = buffer.incrementToken();\n        while (hasMoreTokens) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n          hasMoreTokens = buffer.incrementToken();\n        }\n      } catch (IOException e) {\n        // ignore\n      }\n    }\n    try {\n      // rewind the buffer stream\n      buffer.reset();\n\n      // close original stream - all tokens buffered\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      String term = null;\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        term = termAtt.term();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, term));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            Query currentQuery = newTermQuery(\n                new Term(field, term));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, term));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.term();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, term),position);\n          } else {\n            pq.add(new Term(field, term));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d78f014fded44fbde905f4f84cdc21907b371e8","date":1254383623,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source;\n    try {\n      source = analyzer.reusableTokenStream(field, new StringReader(queryText));\n      source.reset();\n    } catch (IOException e) {\n      source = analyzer.tokenStream(field, new StringReader(queryText));\n    }\n    CachingTokenFilter buffer = new CachingTokenFilter(source);\n    TermAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n\n    boolean success = false;\n    try {\n      buffer.reset();\n      success = true;\n    } catch (IOException e) {\n      // success==false if we hit an exception\n    }\n    if (success) {\n      if (buffer.hasAttribute(TermAttribute.class)) {\n        termAtt = buffer.getAttribute(TermAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n    }\n\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    boolean hasMoreTokens = false;\n    if (termAtt != null) {\n      try {\n        hasMoreTokens = buffer.incrementToken();\n        while (hasMoreTokens) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n          hasMoreTokens = buffer.incrementToken();\n        }\n      } catch (IOException e) {\n        // ignore\n      }\n    }\n    try {\n      // rewind the buffer stream\n      buffer.reset();\n\n      // close original stream - all tokens buffered\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      String term = null;\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        term = termAtt.term();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, term));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            Query currentQuery = newTermQuery(\n                new Term(field, term));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, term));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.term();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, term),position);\n          } else {\n            pq.add(new Term(field, term));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source;\n    try {\n      source = analyzer.reusableTokenStream(field, new StringReader(queryText));\n      source.reset();\n    } catch (IOException e) {\n      source = analyzer.tokenStream(field, new StringReader(queryText));\n    }\n    CachingTokenFilter buffer = new CachingTokenFilter(source);\n    TermAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n\n    boolean success = false;\n    try {\n      buffer.reset();\n      success = true;\n    } catch (IOException e) {\n      // success==false if we hit an exception\n    }\n    if (success) {\n      if (buffer.hasAttribute(TermAttribute.class)) {\n        termAtt = (TermAttribute) buffer.getAttribute(TermAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = (PositionIncrementAttribute) buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n    }\n\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    boolean hasMoreTokens = false;\n    if (termAtt != null) {\n      try {\n        hasMoreTokens = buffer.incrementToken();\n        while (hasMoreTokens) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n          hasMoreTokens = buffer.incrementToken();\n        }\n      } catch (IOException e) {\n        // ignore\n      }\n    }\n    try {\n      // rewind the buffer stream\n      buffer.reset();\n\n      // close original stream - all tokens buffered\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      String term = null;\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        term = termAtt.term();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, term));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            Query currentQuery = newTermQuery(\n                new Term(field, term));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, term));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.term();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, term),position);\n          } else {\n            pq.add(new Term(field, term));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"84dc138e05008664b5e01dc83f6ad95bd73b91c5","date":1256054789,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source;\n    try {\n      source = analyzer.reusableTokenStream(field, new StringReader(queryText));\n      source.reset();\n    } catch (IOException e) {\n      source = analyzer.tokenStream(field, new StringReader(queryText));\n    }\n    CachingTokenFilter buffer = new CachingTokenFilter(source);\n    TermAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n\n    boolean success = false;\n    try {\n      buffer.reset();\n      success = true;\n    } catch (IOException e) {\n      // success==false if we hit an exception\n    }\n    if (success) {\n      if (buffer.hasAttribute(TermAttribute.class)) {\n        termAtt = buffer.getAttribute(TermAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n    }\n\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    boolean hasMoreTokens = false;\n    if (termAtt != null) {\n      try {\n        hasMoreTokens = buffer.incrementToken();\n        while (hasMoreTokens) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n          hasMoreTokens = buffer.incrementToken();\n        }\n      } catch (IOException e) {\n        // ignore\n      }\n    }\n    try {\n      // rewind the buffer stream\n      buffer.reset();\n\n      // close original stream - all tokens buffered\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      String term = null;\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        term = termAtt.term();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, term));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            Query currentQuery = newTermQuery(\n                new Term(field, term));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<Term>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, term));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.term();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, term),position);\n          } else {\n            pq.add(new Term(field, term));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source;\n    try {\n      source = analyzer.reusableTokenStream(field, new StringReader(queryText));\n      source.reset();\n    } catch (IOException e) {\n      source = analyzer.tokenStream(field, new StringReader(queryText));\n    }\n    CachingTokenFilter buffer = new CachingTokenFilter(source);\n    TermAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n\n    boolean success = false;\n    try {\n      buffer.reset();\n      success = true;\n    } catch (IOException e) {\n      // success==false if we hit an exception\n    }\n    if (success) {\n      if (buffer.hasAttribute(TermAttribute.class)) {\n        termAtt = buffer.getAttribute(TermAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n    }\n\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    boolean hasMoreTokens = false;\n    if (termAtt != null) {\n      try {\n        hasMoreTokens = buffer.incrementToken();\n        while (hasMoreTokens) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n          hasMoreTokens = buffer.incrementToken();\n        }\n      } catch (IOException e) {\n        // ignore\n      }\n    }\n    try {\n      // rewind the buffer stream\n      buffer.reset();\n\n      // close original stream - all tokens buffered\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      String term = null;\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        term = termAtt.term();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, term));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            Query currentQuery = newTermQuery(\n                new Term(field, term));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List multiTerms = new ArrayList();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add((Term[])multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, term));\n          }\n          if (enablePositionIncrements) {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add((Term[])multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.term();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, term),position);\n          } else {\n            pq.add(new Term(field, term));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","pathOld":"src/java/org/apache/lucene/queryParser/QueryParser#getFieldQuery(String,String).mjava","sourceNew":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source;\n    try {\n      source = analyzer.reusableTokenStream(field, new StringReader(queryText));\n      source.reset();\n    } catch (IOException e) {\n      source = analyzer.tokenStream(field, new StringReader(queryText));\n    }\n    CachingTokenFilter buffer = new CachingTokenFilter(source);\n    TermAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n\n    boolean success = false;\n    try {\n      buffer.reset();\n      success = true;\n    } catch (IOException e) {\n      // success==false if we hit an exception\n    }\n    if (success) {\n      if (buffer.hasAttribute(TermAttribute.class)) {\n        termAtt = buffer.getAttribute(TermAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n    }\n\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    boolean hasMoreTokens = false;\n    if (termAtt != null) {\n      try {\n        hasMoreTokens = buffer.incrementToken();\n        while (hasMoreTokens) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n          hasMoreTokens = buffer.incrementToken();\n        }\n      } catch (IOException e) {\n        // ignore\n      }\n    }\n    try {\n      // rewind the buffer stream\n      buffer.reset();\n\n      // close original stream - all tokens buffered\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      String term = null;\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        term = termAtt.term();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, term));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            Query currentQuery = newTermQuery(\n                new Term(field, term));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<Term>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, term));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.term();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, term),position);\n          } else {\n            pq.add(new Term(field, term));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * @exception ParseException throw in overridden method to disallow\n   */\n  protected Query getFieldQuery(String field, String queryText)  throws ParseException {\n    // Use the analyzer to get all the tokens, and then build a TermQuery,\n    // PhraseQuery, or nothing based on the term count\n\n    TokenStream source;\n    try {\n      source = analyzer.reusableTokenStream(field, new StringReader(queryText));\n      source.reset();\n    } catch (IOException e) {\n      source = analyzer.tokenStream(field, new StringReader(queryText));\n    }\n    CachingTokenFilter buffer = new CachingTokenFilter(source);\n    TermAttribute termAtt = null;\n    PositionIncrementAttribute posIncrAtt = null;\n    int numTokens = 0;\n\n    boolean success = false;\n    try {\n      buffer.reset();\n      success = true;\n    } catch (IOException e) {\n      // success==false if we hit an exception\n    }\n    if (success) {\n      if (buffer.hasAttribute(TermAttribute.class)) {\n        termAtt = buffer.getAttribute(TermAttribute.class);\n      }\n      if (buffer.hasAttribute(PositionIncrementAttribute.class)) {\n        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);\n      }\n    }\n\n    int positionCount = 0;\n    boolean severalTokensAtSamePosition = false;\n\n    boolean hasMoreTokens = false;\n    if (termAtt != null) {\n      try {\n        hasMoreTokens = buffer.incrementToken();\n        while (hasMoreTokens) {\n          numTokens++;\n          int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;\n          if (positionIncrement != 0) {\n            positionCount += positionIncrement;\n          } else {\n            severalTokensAtSamePosition = true;\n          }\n          hasMoreTokens = buffer.incrementToken();\n        }\n      } catch (IOException e) {\n        // ignore\n      }\n    }\n    try {\n      // rewind the buffer stream\n      buffer.reset();\n\n      // close original stream - all tokens buffered\n      source.close();\n    }\n    catch (IOException e) {\n      // ignore\n    }\n\n    if (numTokens == 0)\n      return null;\n    else if (numTokens == 1) {\n      String term = null;\n      try {\n        boolean hasNext = buffer.incrementToken();\n        assert hasNext == true;\n        term = termAtt.term();\n      } catch (IOException e) {\n        // safe to ignore, because we know the number of tokens\n      }\n      return newTermQuery(new Term(field, term));\n    } else {\n      if (severalTokensAtSamePosition) {\n        if (positionCount == 1) {\n          // no phrase query:\n          BooleanQuery q = newBooleanQuery(true);\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            Query currentQuery = newTermQuery(\n                new Term(field, term));\n            q.add(currentQuery, BooleanClause.Occur.SHOULD);\n          }\n          return q;\n        }\n        else {\n          // phrase query:\n          MultiPhraseQuery mpq = newMultiPhraseQuery();\n          mpq.setSlop(phraseSlop);\n          List<Term> multiTerms = new ArrayList<Term>();\n          int position = -1;\n          for (int i = 0; i < numTokens; i++) {\n            String term = null;\n            int positionIncrement = 1;\n            try {\n              boolean hasNext = buffer.incrementToken();\n              assert hasNext == true;\n              term = termAtt.term();\n              if (posIncrAtt != null) {\n                positionIncrement = posIncrAtt.getPositionIncrement();\n              }\n            } catch (IOException e) {\n              // safe to ignore, because we know the number of tokens\n            }\n\n            if (positionIncrement > 0 && multiTerms.size() > 0) {\n              if (enablePositionIncrements) {\n                mpq.add(multiTerms.toArray(new Term[0]),position);\n              } else {\n                mpq.add(multiTerms.toArray(new Term[0]));\n              }\n              multiTerms.clear();\n            }\n            position += positionIncrement;\n            multiTerms.add(new Term(field, term));\n          }\n          if (enablePositionIncrements) {\n            mpq.add(multiTerms.toArray(new Term[0]),position);\n          } else {\n            mpq.add(multiTerms.toArray(new Term[0]));\n          }\n          return mpq;\n        }\n      }\n      else {\n        PhraseQuery pq = newPhraseQuery();\n        pq.setSlop(phraseSlop);\n        int position = -1;\n\n\n        for (int i = 0; i < numTokens; i++) {\n          String term = null;\n          int positionIncrement = 1;\n\n          try {\n            boolean hasNext = buffer.incrementToken();\n            assert hasNext == true;\n            term = termAtt.term();\n            if (posIncrAtt != null) {\n              positionIncrement = posIncrAtt.getPositionIncrement();\n            }\n          } catch (IOException e) {\n            // safe to ignore, because we know the number of tokens\n          }\n\n          if (enablePositionIncrements) {\n            position += positionIncrement;\n            pq.add(new Term(field, term),position);\n          } else {\n            pq.add(new Term(field, term));\n          }\n        }\n        return pq;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7e2cb543b41c145f33390f460ee743d6693c9c6c":["693d6573b6621fc1265316fc6b042c24235c81d8"],"7a744f34b732efe0beb11df92bde24ccc01460dc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74a5e7f20b4a444da9df3b2c0f331fa7a1f64223":["c7b6cdc70e097da94da79a655ed8f94477ff69f5"],"a28fe77124a2ece3a2af0a5c1b264e07c7cae728":["7e2cb543b41c145f33390f460ee743d6693c9c6c"],"01b9585922e829a4f49f41499e0202f20fbe3275":["7a744f34b732efe0beb11df92bde24ccc01460dc"],"c7b6cdc70e097da94da79a655ed8f94477ff69f5":["a28fe77124a2ece3a2af0a5c1b264e07c7cae728"],"84dc138e05008664b5e01dc83f6ad95bd73b91c5":["8d78f014fded44fbde905f4f84cdc21907b371e8"],"d79a074a316c6cd3908ca819cd98ad74d1e4dd30":["bcbc8ed27f45a5a299f8414d7a886340ce7bb3db"],"bcbc8ed27f45a5a299f8414d7a886340ce7bb3db":["01b9585922e829a4f49f41499e0202f20fbe3275"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8d78f014fded44fbde905f4f84cdc21907b371e8":["f5a603e3919a020001e02985a79df6e8d576affd"],"f5a603e3919a020001e02985a79df6e8d576affd":["ec8b5a20a12931b8d7e616c79c5248ae06cc5568"],"dcb8034cf155d661867043fbc42b577d03903036":["d79a074a316c6cd3908ca819cd98ad74d1e4dd30"],"693d6573b6621fc1265316fc6b042c24235c81d8":["dcb8034cf155d661867043fbc42b577d03903036"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["84dc138e05008664b5e01dc83f6ad95bd73b91c5"],"ec8b5a20a12931b8d7e616c79c5248ae06cc5568":["74a5e7f20b4a444da9df3b2c0f331fa7a1f64223"]},"commit2Childs":{"7e2cb543b41c145f33390f460ee743d6693c9c6c":["a28fe77124a2ece3a2af0a5c1b264e07c7cae728"],"7a744f34b732efe0beb11df92bde24ccc01460dc":["01b9585922e829a4f49f41499e0202f20fbe3275"],"74a5e7f20b4a444da9df3b2c0f331fa7a1f64223":["ec8b5a20a12931b8d7e616c79c5248ae06cc5568"],"a28fe77124a2ece3a2af0a5c1b264e07c7cae728":["c7b6cdc70e097da94da79a655ed8f94477ff69f5"],"01b9585922e829a4f49f41499e0202f20fbe3275":["bcbc8ed27f45a5a299f8414d7a886340ce7bb3db"],"c7b6cdc70e097da94da79a655ed8f94477ff69f5":["74a5e7f20b4a444da9df3b2c0f331fa7a1f64223"],"84dc138e05008664b5e01dc83f6ad95bd73b91c5":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"d79a074a316c6cd3908ca819cd98ad74d1e4dd30":["dcb8034cf155d661867043fbc42b577d03903036"],"bcbc8ed27f45a5a299f8414d7a886340ce7bb3db":["d79a074a316c6cd3908ca819cd98ad74d1e4dd30"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7a744f34b732efe0beb11df92bde24ccc01460dc"],"8d78f014fded44fbde905f4f84cdc21907b371e8":["84dc138e05008664b5e01dc83f6ad95bd73b91c5"],"f5a603e3919a020001e02985a79df6e8d576affd":["8d78f014fded44fbde905f4f84cdc21907b371e8"],"dcb8034cf155d661867043fbc42b577d03903036":["693d6573b6621fc1265316fc6b042c24235c81d8"],"693d6573b6621fc1265316fc6b042c24235c81d8":["7e2cb543b41c145f33390f460ee743d6693c9c6c"],"ec8b5a20a12931b8d7e616c79c5248ae06cc5568":["f5a603e3919a020001e02985a79df6e8d576affd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}