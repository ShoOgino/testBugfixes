{"path":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","sourceNew":"  /**\n   * Returns <code>true</code> if an index exists at the specified directory.\n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   * @throws IOException if there is a problem with accessing the index\n   */\n  public static boolean indexExists(Directory directory) throws IOException {\n    try {\n      new SegmentInfos().read(directory);\n      return true;\n    } catch (IOException ioe) {\n      return false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns <code>true</code> if an index exists at the specified directory.\n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   * @throws IOException if there is a problem with accessing the index\n   */\n  public static boolean indexExists(Directory directory) throws IOException {\n    try {\n      new SegmentInfos().read(directory);\n      return true;\n    } catch (IOException ioe) {\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","sourceNew":"  /**\n   * Returns <code>true</code> if an index exists at the specified directory.\n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   */\n  public static boolean indexExists(Directory directory) {\n    try {\n      new SegmentInfos().read(directory);\n      return true;\n    } catch (IOException ioe) {\n      return false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns <code>true</code> if an index exists at the specified directory.\n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   * @throws IOException if there is a problem with accessing the index\n   */\n  public static boolean indexExists(Directory directory) throws IOException {\n    try {\n      new SegmentInfos().read(directory);\n      return true;\n    } catch (IOException ioe) {\n      return false;\n    }\n  }\n\n","bugFix":["5e316f9ea0ab451f736a2a2b65103c3910bfad8e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","sourceNew":"  /**\n   * Returns <code>true</code> if an index exists at the specified directory.\n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   */\n  public static boolean indexExists(Directory directory) {\n    try {\n      new SegmentInfos().read(directory);\n      return true;\n    } catch (IOException ioe) {\n      return false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns <code>true</code> if an index exists at the specified directory.\n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   * @throws IOException if there is a problem with accessing the index\n   */\n  public static boolean indexExists(Directory directory) throws IOException {\n    try {\n      new SegmentInfos().read(directory);\n      return true;\n    } catch (IOException ioe) {\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b41d447200403aa7ef7498f40bfa84da3422924d","date":1363972030,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","sourceNew":"  /**\n   * Returns <code>true</code> if an index exists at the specified directory.\n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   */\n  public static boolean indexExists(Directory directory) {\n    try {\n      new FindSegmentsFile(directory) {\n        @Override\n        protected Object doBody(String segmentFileName) throws IOException {\n          try {\n            new SegmentInfos().read(directory, segmentFileName);\n          } catch (FileNotFoundException ex) {\n            if (!directory.fileExists(segmentFileName)) {\n              throw ex;\n            }\n            /* this is ok - we might have run into a access exception here.\n             * or even worse like on LUCENE-4870 this is triggered due to\n             * too many open files on the system. In that case we rather report\n             * a false positive here since wrongly returning false from indexExist\n             * can cause data loss since IW relies on this.*/\n          }\n          return null;\n        }\n      }.run();\n      return true;\n    } catch (IOException ioe) {\n      return false;\n    }\n  }\n\n","sourceOld":"  /**\n   * Returns <code>true</code> if an index exists at the specified directory.\n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   */\n  public static boolean indexExists(Directory directory) {\n    try {\n      new SegmentInfos().read(directory);\n      return true;\n    } catch (IOException ioe) {\n      return false;\n    }\n  }\n\n","bugFix":["569a9403799d39d2fcc83f4e6d8d0693b69a3bf4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30e0912f3a3069b115cfea44ff612c44d6906386","date":1365631344,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","sourceNew":"  /**\n   * Returns <code>true</code> if an index likely exists at\n   * the specified directory.  Note that if a corrupt index\n   * exists, or if an index in the process of committing \n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   */\n  public static boolean indexExists(Directory directory) throws IOException {\n    // LUCENE-2812, LUCENE-2727, LUCENE-4738: this logic will\n    // return true in cases that should arguably be false,\n    // such as only IW.prepareCommit has been called, or a\n    // corrupt first commit, but it's too deadly to make\n    // this logic \"smarter\" and risk accidentally returning\n    // false due to various cases like file description\n    // exhaustion, access denited, etc., because in that\n    // case IndexWriter may delete the entire index.  It's\n    // safer to err towards \"index exists\" than try to be\n    // smart about detecting not-yet-fully-committed or\n    // corrupt indices.  This means that IndexWriter will\n    // throw an exception on such indices and the app must\n    // resolve the situation manually:\n    String[] files;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException nsde) {\n      // Directory does not exist --> no index exists\n      return false;\n    }\n\n    // Defensive: maybe a Directory impl returns null\n    // instead of throwing NoSuchDirectoryException:\n    if (files != null) {\n      String prefix = IndexFileNames.SEGMENTS + \"_\";\n      for(String file : files) {\n        if (file.startsWith(prefix) || file.equals(IndexFileNames.SEGMENTS_GEN)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns <code>true</code> if an index exists at the specified directory.\n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   */\n  public static boolean indexExists(Directory directory) {\n    try {\n      new FindSegmentsFile(directory) {\n        @Override\n        protected Object doBody(String segmentFileName) throws IOException {\n          try {\n            new SegmentInfos().read(directory, segmentFileName);\n          } catch (FileNotFoundException ex) {\n            if (!directory.fileExists(segmentFileName)) {\n              throw ex;\n            }\n            /* this is ok - we might have run into a access exception here.\n             * or even worse like on LUCENE-4870 this is triggered due to\n             * too many open files on the system. In that case we rather report\n             * a false positive here since wrongly returning false from indexExist\n             * can cause data loss since IW relies on this.*/\n          }\n          return null;\n        }\n      }.run();\n      return true;\n    } catch (IOException ioe) {\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4","date":1368446242,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","sourceNew":"  /**\n   * Returns <code>true</code> if an index likely exists at\n   * the specified directory.  Note that if a corrupt index\n   * exists, or if an index in the process of committing \n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   */\n  public static boolean indexExists(Directory directory) throws IOException {\n    // LUCENE-2812, LUCENE-2727, LUCENE-4738: this logic will\n    // return true in cases that should arguably be false,\n    // such as only IW.prepareCommit has been called, or a\n    // corrupt first commit, but it's too deadly to make\n    // this logic \"smarter\" and risk accidentally returning\n    // false due to various cases like file description\n    // exhaustion, access denied, etc., because in that\n    // case IndexWriter may delete the entire index.  It's\n    // safer to err towards \"index exists\" than try to be\n    // smart about detecting not-yet-fully-committed or\n    // corrupt indices.  This means that IndexWriter will\n    // throw an exception on such indices and the app must\n    // resolve the situation manually:\n    String[] files;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException nsde) {\n      // Directory does not exist --> no index exists\n      return false;\n    }\n\n    // Defensive: maybe a Directory impl returns null\n    // instead of throwing NoSuchDirectoryException:\n    if (files != null) {\n      String prefix = IndexFileNames.SEGMENTS + \"_\";\n      for(String file : files) {\n        if (file.startsWith(prefix) || file.equals(IndexFileNames.SEGMENTS_GEN)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns <code>true</code> if an index likely exists at\n   * the specified directory.  Note that if a corrupt index\n   * exists, or if an index in the process of committing \n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   */\n  public static boolean indexExists(Directory directory) throws IOException {\n    // LUCENE-2812, LUCENE-2727, LUCENE-4738: this logic will\n    // return true in cases that should arguably be false,\n    // such as only IW.prepareCommit has been called, or a\n    // corrupt first commit, but it's too deadly to make\n    // this logic \"smarter\" and risk accidentally returning\n    // false due to various cases like file description\n    // exhaustion, access denited, etc., because in that\n    // case IndexWriter may delete the entire index.  It's\n    // safer to err towards \"index exists\" than try to be\n    // smart about detecting not-yet-fully-committed or\n    // corrupt indices.  This means that IndexWriter will\n    // throw an exception on such indices and the app must\n    // resolve the situation manually:\n    String[] files;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException nsde) {\n      // Directory does not exist --> no index exists\n      return false;\n    }\n\n    // Defensive: maybe a Directory impl returns null\n    // instead of throwing NoSuchDirectoryException:\n    if (files != null) {\n      String prefix = IndexFileNames.SEGMENTS + \"_\";\n      for(String file : files) {\n        if (file.startsWith(prefix) || file.equals(IndexFileNames.SEGMENTS_GEN)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"46e4a8bdfbafda795ef9c39a2bc2d47095770299","date":1410411846,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","sourceNew":"  /**\n   * Returns <code>true</code> if an index likely exists at\n   * the specified directory.  Note that if a corrupt index\n   * exists, or if an index in the process of committing \n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   */\n  public static boolean indexExists(Directory directory) throws IOException {\n    // LUCENE-2812, LUCENE-2727, LUCENE-4738: this logic will\n    // return true in cases that should arguably be false,\n    // such as only IW.prepareCommit has been called, or a\n    // corrupt first commit, but it's too deadly to make\n    // this logic \"smarter\" and risk accidentally returning\n    // false due to various cases like file description\n    // exhaustion, access denied, etc., because in that\n    // case IndexWriter may delete the entire index.  It's\n    // safer to err towards \"index exists\" than try to be\n    // smart about detecting not-yet-fully-committed or\n    // corrupt indices.  This means that IndexWriter will\n    // throw an exception on such indices and the app must\n    // resolve the situation manually:\n    String[] files;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException nsde) {\n      // Directory does not exist --> no index exists\n      return false;\n    }\n\n    // Defensive: maybe a Directory impl returns null\n    // instead of throwing NoSuchDirectoryException:\n    if (files != null) {\n      String prefix = IndexFileNames.SEGMENTS + \"_\";\n      for(String file : files) {\n        if (file.startsWith(prefix)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns <code>true</code> if an index likely exists at\n   * the specified directory.  Note that if a corrupt index\n   * exists, or if an index in the process of committing \n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   */\n  public static boolean indexExists(Directory directory) throws IOException {\n    // LUCENE-2812, LUCENE-2727, LUCENE-4738: this logic will\n    // return true in cases that should arguably be false,\n    // such as only IW.prepareCommit has been called, or a\n    // corrupt first commit, but it's too deadly to make\n    // this logic \"smarter\" and risk accidentally returning\n    // false due to various cases like file description\n    // exhaustion, access denied, etc., because in that\n    // case IndexWriter may delete the entire index.  It's\n    // safer to err towards \"index exists\" than try to be\n    // smart about detecting not-yet-fully-committed or\n    // corrupt indices.  This means that IndexWriter will\n    // throw an exception on such indices and the app must\n    // resolve the situation manually:\n    String[] files;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException nsde) {\n      // Directory does not exist --> no index exists\n      return false;\n    }\n\n    // Defensive: maybe a Directory impl returns null\n    // instead of throwing NoSuchDirectoryException:\n    if (files != null) {\n      String prefix = IndexFileNames.SEGMENTS + \"_\";\n      for(String file : files) {\n        if (file.startsWith(prefix) || file.equals(IndexFileNames.SEGMENTS_GEN)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DirectoryReader#indexExists(Directory).mjava","sourceNew":"  /**\n   * Returns <code>true</code> if an index likely exists at\n   * the specified directory.  Note that if a corrupt index\n   * exists, or if an index in the process of committing \n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   */\n  public static boolean indexExists(Directory directory) throws IOException {\n    // LUCENE-2812, LUCENE-2727, LUCENE-4738: this logic will\n    // return true in cases that should arguably be false,\n    // such as only IW.prepareCommit has been called, or a\n    // corrupt first commit, but it's too deadly to make\n    // this logic \"smarter\" and risk accidentally returning\n    // false due to various cases like file description\n    // exhaustion, access denied, etc., because in that\n    // case IndexWriter may delete the entire index.  It's\n    // safer to err towards \"index exists\" than try to be\n    // smart about detecting not-yet-fully-committed or\n    // corrupt indices.  This means that IndexWriter will\n    // throw an exception on such indices and the app must\n    // resolve the situation manually:\n    String[] files = directory.listAll();\n\n    String prefix = IndexFileNames.SEGMENTS + \"_\";\n    for(String file : files) {\n      if (file.startsWith(prefix)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  /**\n   * Returns <code>true</code> if an index likely exists at\n   * the specified directory.  Note that if a corrupt index\n   * exists, or if an index in the process of committing \n   * @param  directory the directory to check for an index\n   * @return <code>true</code> if an index exists; <code>false</code> otherwise\n   */\n  public static boolean indexExists(Directory directory) throws IOException {\n    // LUCENE-2812, LUCENE-2727, LUCENE-4738: this logic will\n    // return true in cases that should arguably be false,\n    // such as only IW.prepareCommit has been called, or a\n    // corrupt first commit, but it's too deadly to make\n    // this logic \"smarter\" and risk accidentally returning\n    // false due to various cases like file description\n    // exhaustion, access denied, etc., because in that\n    // case IndexWriter may delete the entire index.  It's\n    // safer to err towards \"index exists\" than try to be\n    // smart about detecting not-yet-fully-committed or\n    // corrupt indices.  This means that IndexWriter will\n    // throw an exception on such indices and the app must\n    // resolve the situation manually:\n    String[] files;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException nsde) {\n      // Directory does not exist --> no index exists\n      return false;\n    }\n\n    // Defensive: maybe a Directory impl returns null\n    // instead of throwing NoSuchDirectoryException:\n    if (files != null) {\n      String prefix = IndexFileNames.SEGMENTS + \"_\";\n      for(String file : files) {\n        if (file.startsWith(prefix)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["30e0912f3a3069b115cfea44ff612c44d6906386"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"30e0912f3a3069b115cfea44ff612c44d6906386":["b41d447200403aa7ef7498f40bfa84da3422924d"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"f4abec28b874149a7223e32cc7a01704c27790de":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f4abec28b874149a7223e32cc7a01704c27790de"],"b41d447200403aa7ef7498f40bfa84da3422924d":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"]},"commit2Childs":{"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["f4abec28b874149a7223e32cc7a01704c27790de"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"30e0912f3a3069b115cfea44ff612c44d6906386":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["fe33227f6805edab2036cbb80645cc4e2d1fa424","b41d447200403aa7ef7498f40bfa84da3422924d"],"f4abec28b874149a7223e32cc7a01704c27790de":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b41d447200403aa7ef7498f40bfa84da3422924d":["30e0912f3a3069b115cfea44ff612c44d6906386"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}