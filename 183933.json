{"path":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","commits":[{"id":"ad28156288ac00b91352582904d97e6653205757","date":1486850922,"type":1,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"new\", Category.SEARCHER.toString());\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"time\", Category.SEARCHER.toString(), \"new\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"warmup\", Category.SEARCHER.toString(), \"new\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"maxReached\", Category.SEARCHER.toString(), \"new\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"errors\", Category.SEARCHER.toString(), \"new\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"new\", Category.SEARCHER.toString());\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"time\", Category.SEARCHER.toString(), \"new\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"warmup\", Category.SEARCHER.toString(), \"new\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"maxReached\", Category.SEARCHER.toString(), \"new\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"errors\", Category.SEARCHER.toString(), \"new\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"073f1aa70444ec64f3e216816af2a3b43fa38fe7","date":1488920481,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"new\", Category.SEARCHER.toString());\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"time\", Category.SEARCHER.toString(), \"new\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"warmup\", Category.SEARCHER.toString(), \"new\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"maxReached\", Category.SEARCHER.toString(), \"new\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"errors\", Category.SEARCHER.toString(), \"new\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"new\", Category.SEARCHER.toString());\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"time\", Category.SEARCHER.toString(), \"new\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"warmup\", Category.SEARCHER.toString(), \"new\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"maxReached\", Category.SEARCHER.toString(), \"new\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"errors\", Category.SEARCHER.toString(), \"new\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7392b75d2c2f2aecf31188732a0764fe0dc74ade","date":1489420141,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"new\", Category.SEARCHER.toString());\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"time\", Category.SEARCHER.toString(), \"new\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"warmup\", Category.SEARCHER.toString(), \"new\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"maxReached\", Category.SEARCHER.toString(), \"new\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"errors\", Category.SEARCHER.toString(), \"new\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"new\", Category.SEARCHER.toString());\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"time\", Category.SEARCHER.toString(), \"new\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"warmup\", Category.SEARCHER.toString(), \"new\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"maxReached\", Category.SEARCHER.toString(), \"new\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"errors\", Category.SEARCHER.toString(), \"new\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f34d83c894e07c24f5f957820777b5da2cc29e5a","date":1489491395,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"new\", Category.SEARCHER.toString());\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"time\", Category.SEARCHER.toString(), \"new\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"warmup\", Category.SEARCHER.toString(), \"new\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"maxReached\", Category.SEARCHER.toString(), \"new\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"errors\", Category.SEARCHER.toString(), \"new\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":["bfc52860e6d13d034226a760813c59d984c6817a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b","date":1489651910,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"new\", Category.SEARCHER.toString());\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"time\", Category.SEARCHER.toString(), \"new\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"warmup\", Category.SEARCHER.toString(), \"new\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"maxReached\", Category.SEARCHER.toString(), \"new\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"errors\", Category.SEARCHER.toString(), \"new\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"new\", Category.SEARCHER.toString());\n    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"time\", Category.SEARCHER.toString(), \"new\");\n    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), \"warmup\", Category.SEARCHER.toString(), \"new\");\n    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"maxReached\", Category.SEARCHER.toString(), \"new\");\n    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), \"errors\", Category.SEARCHER.toString(), \"new\");\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"917e62f3497c83634a13edd833e8e21dd6cc6496","date":1490728467,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3732e34f27916e98704736cc6924a34fffca249a","date":1490873946,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"816521ebaad5add9cb96bb88c577394e2938c40b","date":1491931343,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":["bfc52860e6d13d034226a760813c59d984c6817a","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"729cb470f975115d4c60517b2cb7c42e37a7a2e1","date":1492041760,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    this.coreContainer = coreContainer;\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    coreContainer.solrCores.addCoreDescriptor(cd);\n\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = coreContainer.getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n    // this is registered at the CONTAINER level because it's not core-specific - for now we\n    // also register it here for back-compat\n    solrFieldCacheBean.initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"core\");\n    infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to report metrics\n    if (directoryFactory instanceof SolrMetricProducer) {\n      ((SolrMetricProducer)directoryFactory).initializeMetrics(metricManager, coreMetricManager.getRegistryName(), \"directoryFactory\");\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":4,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":null,"sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir\n   *          the index directory\n   * @param config\n   *          a solr config instance\n   * @param schema\n   *          a solr schema instance\n   *\n   * @since solr 1.3\n   */\n  public SolrCore(String name, String dataDir, SolrConfig config,\n      IndexSchema schema, NamedList configSetProperties,\n      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n    \n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n    \n    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n    setName(name);\n    MDCLoggingContext.setCore(this);\n    \n    resourceLoader = config.getResourceLoader();\n    this.solrConfig = config;\n    this.configSetProperties = configSetProperties;\n    // Initialize the metrics manager\n    this.coreMetricManager = initCoreMetricManager(config);\n    this.coreMetricManager.loadReporters();\n\n    if (updateHandler == null) {\n      directoryFactory = initDirectoryFactory();\n      recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n    } else {\n      solrCoreState = updateHandler.getSolrCoreState();\n      directoryFactory = solrCoreState.getDirectoryFactory();\n      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n      isReloaded = true;\n    }\n\n    this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n    this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n    log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(), this.dataDir);\n\n    checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();\n\n    // initialize searcher-related metrics\n    initializeMetrics(metricManager, coreMetricManager.getRegistryName(), null);\n\n    // Initialize JMX\n    this.infoRegistry = initInfoRegistry(name, config);\n    infoRegistry.put(\"fieldCache\", new SolrFieldCacheMBean());\n\n    initSchema(config, schema);\n\n    this.maxWarmingSearchers = config.maxWarmingSearchers;\n    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n    booleanQueryMaxClauseCount();\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      statsCache = initStatsCache();\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n      \n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError)e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n       close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    infoRegistry.put(\"core\", this);\n\n    // register any SolrInfoMBeans SolrResourceLoader initialized\n    //\n    // this must happen after the latch is released, because a JMX server impl may\n    // choose to block on registering until properties can be fetched from an MBean,\n    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n    // from the core.\n    resourceLoader.inform(infoRegistry);\n\n    // Allow the directory factory to register MBeans as well\n    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {\n      log.debug(\"Registering JMX bean [{}] from directory factory.\", bean.getName());\n      // Not worried about concurrency, so no reason to use putIfAbsent\n      if (infoRegistry.containsKey(bean.getName())){\n        log.debug(\"Ignoring JMX bean [{}] due to name conflict.\", bean.getName());\n      } else {\n        infoRegistry.put(bean.getName(), bean);\n      }\n    }\n\n    // seed version buckets with max from index during core initialization ... requires a searcher!\n    seedVersionBuckets();\n\n    bufferUpdatesIfConstructing(coreDescriptor);\n\n    this.ruleExpiryLock = new ReentrantLock();\n    this.snapshotDelLock = new ReentrantLock();\n\n    registerConfListener();\n    \n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ad28156288ac00b91352582904d97e6653205757":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["3732e34f27916e98704736cc6924a34fffca249a"],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["816521ebaad5add9cb96bb88c577394e2938c40b"],"816521ebaad5add9cb96bb88c577394e2938c40b":["917e62f3497c83634a13edd833e8e21dd6cc6496"],"917e62f3497c83634a13edd833e8e21dd6cc6496":["f34d83c894e07c24f5f957820777b5da2cc29e5a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"073f1aa70444ec64f3e216816af2a3b43fa38fe7":["ad28156288ac00b91352582904d97e6653205757"],"f34d83c894e07c24f5f957820777b5da2cc29e5a":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"3732e34f27916e98704736cc6924a34fffca249a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"7392b75d2c2f2aecf31188732a0764fe0dc74ade":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"ab68488225b6a6c357dda72ed11dedca9914a192":["7392b75d2c2f2aecf31188732a0764fe0dc74ade","0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"]},"commit2Childs":{"ad28156288ac00b91352582904d97e6653205757":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":[],"729cb470f975115d4c60517b2cb7c42e37a7a2e1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"816521ebaad5add9cb96bb88c577394e2938c40b":["729cb470f975115d4c60517b2cb7c42e37a7a2e1"],"917e62f3497c83634a13edd833e8e21dd6cc6496":["816521ebaad5add9cb96bb88c577394e2938c40b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ad28156288ac00b91352582904d97e6653205757"],"073f1aa70444ec64f3e216816af2a3b43fa38fe7":["7392b75d2c2f2aecf31188732a0764fe0dc74ade"],"f34d83c894e07c24f5f957820777b5da2cc29e5a":["917e62f3497c83634a13edd833e8e21dd6cc6496"],"3732e34f27916e98704736cc6924a34fffca249a":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"7392b75d2c2f2aecf31188732a0764fe0dc74ade":["f34d83c894e07c24f5f957820777b5da2cc29e5a","ab68488225b6a6c357dda72ed11dedca9914a192","0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b"],"ab68488225b6a6c357dda72ed11dedca9914a192":["3732e34f27916e98704736cc6924a34fffca249a"],"0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b":["ab68488225b6a6c357dda72ed11dedca9914a192"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}