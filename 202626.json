{"path":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ENGLISH);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ENGLISH);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9279c7cd47f17e1e8b674a3741ff5f040bc680be","date":1341675760,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ENGLISH);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2acf500f78aa12b92e371fd89c719291986b6b90","date":1341846236,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ENGLISH);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46d8ada1fff8d18cb197c38c7983225162599948","date":1341853497,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ENGLISH);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ENGLISH);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","date":1419400138,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? its really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless its a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91","date":1429620941,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail!=null) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5c16d494b4cccbc6f3aa00f05421575bdb11da7","date":1464182657,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e121d43b5a10f2df530f406f935102656e9c4e8","date":1464198131,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83870855d82aba6819217abeff5a40779dbb28b4","date":1464291012,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c051bc332b82a09e43732a93136d69164d98c37","date":1466701419,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":["0f3cee3d20b0c786e6fca20539454262e29edcab"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (!expl.getDescription().endsWith(\"with freq of:\"))\n          verifyExplanation(q,doc,score,deep,detail[0]);\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"665c23854e5ad5caf7ea153341d7d24e5dffbc4a","date":1478786509,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.matches(\".*, computed as .* from:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || computedOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"199dfa410f1fdbfd3294106b04096cce5ed34b21","date":1478812506,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.matches(\".*, computed as .* from:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || computedOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n            Assert.assertTrue(\"should never get here!\",false);\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46","date":1508899684,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    // TODO: clean this up if we use junit 5 (the assert message is costly)\n    try {\n      Assert.assertEquals(score, value, explainToleranceDelta(score, value));\n    } catch (Exception e) {\n      Assert.fail(q+\": score(doc=\"+doc+\")=\"+score+\" != explanationScore=\"+value+\" Explanation: \"+expl);\n    }\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.indexOf(\"computed as\") > 0 && COMPUTED_FROM_PATTERN.matcher(descr).matches();\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        if (false == (productOf || sumOf || maxOf || computedOf || maxTimesOthers)) {\n          Assert.fail(\n              q+\": multi valued explanation description=\\\"\"+descr\n              +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n              +\" or 'sum of:' or 'max of:' - \"+expl);\n        }\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        // TODO: clean this up if we use junit 5 (the assert message is costly)\n        try {\n          Assert.assertEquals(combined, value, explainToleranceDelta(combined, value));\n        } catch (Exception e) {\n          Assert.fail(q+\": actual subDetails combined==\"+combined+\n              \" != value=\"+value+\" Explanation: \"+expl);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    Assert.assertEquals(q+\": score(doc=\"+doc+\")=\"+score+\n        \" != explanationScore=\"+value+\" Explanation: \"+expl,\n        score,value,explainToleranceDelta(score, value));\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.matches(\".*, computed as .* from:\");\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        Assert.assertTrue(\n            q+\": multi valued explanation description=\\\"\"+descr\n            +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n            +\" or 'sum of:' or 'max of:' - \"+expl,\n            productOf || sumOf || maxOf || computedOf || maxTimesOthers);\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        Assert.assertEquals(q+\": actual subDetails combined==\"+combined+\n            \" != value=\"+value+\" Explanation: \"+expl,\n            combined,value,explainToleranceDelta(combined, value));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7732a106554be0db3e03ac5211e46f6e0c285b8","date":1511975378,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    // TODO: clean this up if we use junit 5 (the assert message is costly)\n    try {\n      Assert.assertEquals(score, value, 0d);\n    } catch (Exception e) {\n      Assert.fail(q+\": score(doc=\"+doc+\")=\"+score+\" != explanationScore=\"+value+\" Explanation: \"+expl);\n    }\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.indexOf(\"computed as\") > 0 && COMPUTED_FROM_PATTERN.matcher(descr).matches();\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        if (false == (productOf || sumOf || maxOf || computedOf || maxTimesOthers)) {\n          Assert.fail(\n              q+\": multi valued explanation description=\\\"\"+descr\n              +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n              +\" or 'sum of:' or 'max of:' - \"+expl);\n        }\n        double sum = 0;\n        float product = 1;\n        float max = Float.NEGATIVE_INFINITY;\n        double maxError = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n\n          if (sumOf) {\n            // \"sum of\" is used by BooleanQuery. Making it accurate is not\n            // easy since ReqOptSumScorer casts some intermediate\n            // contributions to the score to a float before doing another sum.\n            // So we introduce some (reasonable) leniency.\n            // TODO: remove this leniency\n            maxError += Math.ulp(dval) * 2;\n          }\n        }\n        float combined;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = (float) sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = (float) (max + x * (sum - max));\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        // TODO: clean this up if we use junit 5 (the assert message is costly)\n        try {\n          Assert.assertEquals(combined, value, maxError);\n        } catch (Exception e) {\n          Assert.fail(q+\": actual subDetails combined==\"+combined+\n              \" != value=\"+value+\" Explanation: \"+expl);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    // TODO: clean this up if we use junit 5 (the assert message is costly)\n    try {\n      Assert.assertEquals(score, value, explainToleranceDelta(score, value));\n    } catch (Exception e) {\n      Assert.fail(q+\": score(doc=\"+doc+\")=\"+score+\" != explanationScore=\"+value+\" Explanation: \"+expl);\n    }\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.indexOf(\"computed as\") > 0 && COMPUTED_FROM_PATTERN.matcher(descr).matches();\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        if (false == (productOf || sumOf || maxOf || computedOf || maxTimesOthers)) {\n          Assert.fail(\n              q+\": multi valued explanation description=\\\"\"+descr\n              +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n              +\" or 'sum of:' or 'max of:' - \"+expl);\n        }\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        // TODO: clean this up if we use junit 5 (the assert message is costly)\n        try {\n          Assert.assertEquals(combined, value, explainToleranceDelta(combined, value));\n        } catch (Exception e) {\n          Assert.fail(q+\": actual subDetails combined==\"+combined+\n              \" != value=\"+value+\" Explanation: \"+expl);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    // TODO: clean this up if we use junit 5 (the assert message is costly)\n    try {\n      Assert.assertEquals(score, value, 0d);\n    } catch (Exception e) {\n      Assert.fail(q+\": score(doc=\"+doc+\")=\"+score+\" != explanationScore=\"+value+\" Explanation: \"+expl);\n    }\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.indexOf(\"computed as\") > 0 && COMPUTED_FROM_PATTERN.matcher(descr).matches();\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        if (false == (productOf || sumOf || maxOf || computedOf || maxTimesOthers)) {\n          Assert.fail(\n              q+\": multi valued explanation description=\\\"\"+descr\n              +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n              +\" or 'sum of:' or 'max of:' - \"+expl);\n        }\n        double sum = 0;\n        float product = 1;\n        float max = Float.NEGATIVE_INFINITY;\n        double maxError = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n\n          if (sumOf) {\n            // \"sum of\" is used by BooleanQuery. Making it accurate is not\n            // easy since ReqOptSumScorer casts some intermediate\n            // contributions to the score to a float before doing another sum.\n            // So we introduce some (reasonable) leniency.\n            // TODO: remove this leniency\n            maxError += Math.ulp(dval) * 2;\n          }\n        }\n        float combined;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = (float) sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = (float) (max + x * (sum - max));\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        // TODO: clean this up if we use junit 5 (the assert message is costly)\n        try {\n          Assert.assertEquals(combined, value, maxError);\n        } catch (Exception e) {\n          Assert.fail(q+\": actual subDetails combined==\"+combined+\n              \" != value=\"+value+\" Explanation: \"+expl);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    // TODO: clean this up if we use junit 5 (the assert message is costly)\n    try {\n      Assert.assertEquals(score, value, explainToleranceDelta(score, value));\n    } catch (Exception e) {\n      Assert.fail(q+\": score(doc=\"+doc+\")=\"+score+\" != explanationScore=\"+value+\" Explanation: \"+expl);\n    }\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.indexOf(\"computed as\") > 0 && COMPUTED_FROM_PATTERN.matcher(descr).matches();\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        if (false == (productOf || sumOf || maxOf || computedOf || maxTimesOthers)) {\n          Assert.fail(\n              q+\": multi valued explanation description=\\\"\"+descr\n              +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n              +\" or 'sum of:' or 'max of:' - \"+expl);\n        }\n        float sum = 0;\n        float product = 1;\n        float max = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n        }\n        float combined = 0;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = max + x * (sum - max);\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        // TODO: clean this up if we use junit 5 (the assert message is costly)\n        try {\n          Assert.assertEquals(combined, value, explainToleranceDelta(combined, value));\n        } catch (Exception e) {\n          Assert.fail(q+\": actual subDetails combined==\"+combined+\n              \" != value=\"+value+\" Explanation: \"+expl);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb","date":1512565563,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    // TODO: clean this up if we use junit 5 (the assert message is costly)\n    try {\n      Assert.assertEquals(score, value, 0d);\n    } catch (Exception e) {\n      Assert.fail(q+\": score(doc=\"+doc+\")=\"+score+\" != explanationScore=\"+value+\" Explanation: \"+expl);\n    }\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1 && COMPUTED_FROM_PATTERN.matcher(descr).matches() == false) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.indexOf(\"computed as\") > 0 && COMPUTED_FROM_PATTERN.matcher(descr).matches();\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        if (false == (productOf || sumOf || maxOf || computedOf || maxTimesOthers)) {\n          Assert.fail(\n              q+\": multi valued explanation description=\\\"\"+descr\n              +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n              +\" or 'sum of:' or 'max of:' - \"+expl);\n        }\n        double sum = 0;\n        float product = 1;\n        float max = Float.NEGATIVE_INFINITY;\n        double maxError = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n\n          if (sumOf) {\n            // \"sum of\" is used by BooleanQuery. Making it accurate is not\n            // easy since ReqOptSumScorer casts some intermediate\n            // contributions to the score to a float before doing another sum.\n            // So we introduce some (reasonable) leniency.\n            // TODO: remove this leniency\n            maxError += Math.ulp(dval) * 2;\n          }\n        }\n        float combined;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = (float) sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = (float) (max + x * (sum - max));\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        // TODO: clean this up if we use junit 5 (the assert message is costly)\n        try {\n          Assert.assertEquals(combined, value, maxError);\n        } catch (Exception e) {\n          Assert.fail(q+\": actual subDetails combined==\"+combined+\n              \" != value=\"+value+\" Explanation: \"+expl);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    // TODO: clean this up if we use junit 5 (the assert message is costly)\n    try {\n      Assert.assertEquals(score, value, 0d);\n    } catch (Exception e) {\n      Assert.fail(q+\": score(doc=\"+doc+\")=\"+score+\" != explanationScore=\"+value+\" Explanation: \"+expl);\n    }\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.indexOf(\"computed as\") > 0 && COMPUTED_FROM_PATTERN.matcher(descr).matches();\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        if (false == (productOf || sumOf || maxOf || computedOf || maxTimesOthers)) {\n          Assert.fail(\n              q+\": multi valued explanation description=\\\"\"+descr\n              +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n              +\" or 'sum of:' or 'max of:' - \"+expl);\n        }\n        double sum = 0;\n        float product = 1;\n        float max = Float.NEGATIVE_INFINITY;\n        double maxError = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n\n          if (sumOf) {\n            // \"sum of\" is used by BooleanQuery. Making it accurate is not\n            // easy since ReqOptSumScorer casts some intermediate\n            // contributions to the score to a float before doing another sum.\n            // So we introduce some (reasonable) leniency.\n            // TODO: remove this leniency\n            maxError += Math.ulp(dval) * 2;\n          }\n        }\n        float combined;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = (float) sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = (float) (max + x * (sum - max));\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        // TODO: clean this up if we use junit 5 (the assert message is costly)\n        try {\n          Assert.assertEquals(combined, value, maxError);\n        } catch (Exception e) {\n          Assert.fail(q+\": actual subDetails combined==\"+combined+\n              \" != value=\"+value+\" Explanation: \"+expl);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf","date":1514891219,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue().floatValue();\n    // TODO: clean this up if we use junit 5 (the assert message is costly)\n    try {\n      Assert.assertEquals(score, value, 0d);\n    } catch (Exception e) {\n      Assert.fail(q+\": score(doc=\"+doc+\")=\"+score+\" != explanationScore=\"+value+\" Explanation: \"+expl);\n    }\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1 && COMPUTED_FROM_PATTERN.matcher(descr).matches() == false) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.indexOf(\"computed as\") > 0 && COMPUTED_FROM_PATTERN.matcher(descr).matches();\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        if (false == (productOf || sumOf || maxOf || computedOf || maxTimesOthers)) {\n          Assert.fail(\n              q+\": multi valued explanation description=\\\"\"+descr\n              +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n              +\" or 'sum of:' or 'max of:' - \"+expl);\n        }\n        double sum = 0;\n        float product = 1;\n        float max = Float.NEGATIVE_INFINITY;\n        double maxError = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue().floatValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n\n          if (sumOf) {\n            // \"sum of\" is used by BooleanQuery. Making it accurate is not\n            // easy since ReqOptSumScorer casts some intermediate\n            // contributions to the score to a float before doing another sum.\n            // So we introduce some (reasonable) leniency.\n            // TODO: remove this leniency\n            maxError += Math.ulp(dval) * 2;\n          }\n        }\n        float combined;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = (float) sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = (float) (max + x * (sum - max));\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        // TODO: clean this up if we use junit 5 (the assert message is costly)\n        try {\n          Assert.assertEquals(combined, value, maxError);\n        } catch (Exception e) {\n          Assert.fail(q+\": actual subDetails combined==\"+combined+\n              \" != value=\"+value+\" Explanation: \"+expl);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue();\n    // TODO: clean this up if we use junit 5 (the assert message is costly)\n    try {\n      Assert.assertEquals(score, value, 0d);\n    } catch (Exception e) {\n      Assert.fail(q+\": score(doc=\"+doc+\")=\"+score+\" != explanationScore=\"+value+\" Explanation: \"+expl);\n    }\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1 && COMPUTED_FROM_PATTERN.matcher(descr).matches() == false) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.indexOf(\"computed as\") > 0 && COMPUTED_FROM_PATTERN.matcher(descr).matches();\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        if (false == (productOf || sumOf || maxOf || computedOf || maxTimesOthers)) {\n          Assert.fail(\n              q+\": multi valued explanation description=\\\"\"+descr\n              +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n              +\" or 'sum of:' or 'max of:' - \"+expl);\n        }\n        double sum = 0;\n        float product = 1;\n        float max = Float.NEGATIVE_INFINITY;\n        double maxError = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n\n          if (sumOf) {\n            // \"sum of\" is used by BooleanQuery. Making it accurate is not\n            // easy since ReqOptSumScorer casts some intermediate\n            // contributions to the score to a float before doing another sum.\n            // So we introduce some (reasonable) leniency.\n            // TODO: remove this leniency\n            maxError += Math.ulp(dval) * 2;\n          }\n        }\n        float combined;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = (float) sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = (float) (max + x * (sum - max));\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        // TODO: clean this up if we use junit 5 (the assert message is costly)\n        try {\n          Assert.assertEquals(combined, value, maxError);\n        } catch (Exception e) {\n          Assert.fail(q+\": actual subDetails combined==\"+combined+\n              \" != value=\"+value+\" Explanation: \"+expl);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4208ed8e426ae5f75a41d8b4ae53f4587e413061","date":1580475454,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  // TODO: speed up this method to not be so slow\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue().floatValue();\n    // TODO: clean this up if we use junit 5 (the assert message is costly)\n    try {\n      Assert.assertEquals(score, value, 0d);\n    } catch (Exception e) {\n      Assert.fail(q+\": score(doc=\"+doc+\")=\"+score+\" != explanationScore=\"+value+\" Explanation: \"+expl);\n    }\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1 && COMPUTED_FROM_PATTERN.matcher(descr).matches() == false) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.indexOf(\"computed as\") > 0 && COMPUTED_FROM_PATTERN.matcher(descr).matches();\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        if (false == (productOf || sumOf || maxOf || computedOf || maxTimesOthers)) {\n          Assert.fail(\n              q+\": multi valued explanation description=\\\"\"+descr\n              +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n              +\" or 'sum of:' or 'max of:' - \"+expl);\n        }\n        double sum = 0;\n        float product = 1;\n        float max = Float.NEGATIVE_INFINITY;\n        double maxError = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue().floatValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n\n          if (sumOf) {\n            // \"sum of\" is used by BooleanQuery. Making it accurate is not\n            // easy since ReqOptSumScorer casts some intermediate\n            // contributions to the score to a float before doing another sum.\n            // So we introduce some (reasonable) leniency.\n            // TODO: remove this leniency\n            maxError += Math.ulp(dval) * 2;\n          }\n        }\n        float combined;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = (float) sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = (float) (max + x * (sum - max));\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        // TODO: clean this up if we use junit 5 (the assert message is costly)\n        try {\n          Assert.assertEquals(combined, value, maxError);\n        } catch (Exception e) {\n          Assert.fail(q+\": actual subDetails combined==\"+combined+\n              \" != value=\"+value+\" Explanation: \"+expl);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue().floatValue();\n    // TODO: clean this up if we use junit 5 (the assert message is costly)\n    try {\n      Assert.assertEquals(score, value, 0d);\n    } catch (Exception e) {\n      Assert.fail(q+\": score(doc=\"+doc+\")=\"+score+\" != explanationScore=\"+value+\" Explanation: \"+expl);\n    }\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1 && COMPUTED_FROM_PATTERN.matcher(descr).matches() == false) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.indexOf(\"computed as\") > 0 && COMPUTED_FROM_PATTERN.matcher(descr).matches();\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        if (false == (productOf || sumOf || maxOf || computedOf || maxTimesOthers)) {\n          Assert.fail(\n              q+\": multi valued explanation description=\\\"\"+descr\n              +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n              +\" or 'sum of:' or 'max of:' - \"+expl);\n        }\n        double sum = 0;\n        float product = 1;\n        float max = Float.NEGATIVE_INFINITY;\n        double maxError = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue().floatValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n\n          if (sumOf) {\n            // \"sum of\" is used by BooleanQuery. Making it accurate is not\n            // easy since ReqOptSumScorer casts some intermediate\n            // contributions to the score to a float before doing another sum.\n            // So we introduce some (reasonable) leniency.\n            // TODO: remove this leniency\n            maxError += Math.ulp(dval) * 2;\n          }\n        }\n        float combined;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = (float) sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = (float) (max + x * (sum - max));\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        // TODO: clean this up if we use junit 5 (the assert message is costly)\n        try {\n          Assert.assertEquals(combined, value, maxError);\n        } catch (Exception e) {\n          Assert.fail(q+\": actual subDetails combined==\"+combined+\n              \" != value=\"+value+\" Explanation: \"+expl);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/CheckHits#verifyExplanation(String,int,float,boolean,Explanation).mjava","sourceNew":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  // TODO: speed up this method to not be so slow\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue().floatValue();\n    // TODO: clean this up if we use junit 5 (the assert message is costly)\n    try {\n      assertEquals(score, value, 0d);\n    } catch (Exception e) {\n      fail(q+\": score(doc=\"+doc+\")=\"+score+\" != explanationScore=\"+value+\" Explanation: \"+expl);\n    }\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1 && COMPUTED_FROM_PATTERN.matcher(descr).matches() == false) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.indexOf(\"computed as\") > 0 && COMPUTED_FROM_PATTERN.matcher(descr).matches();\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        if (false == (productOf || sumOf || maxOf || computedOf || maxTimesOthers)) {\n          fail(\n              q+\": multi valued explanation description=\\\"\"+descr\n              +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n              +\" or 'sum of:' or 'max of:' - \"+expl);\n        }\n        double sum = 0;\n        float product = 1;\n        float max = Float.NEGATIVE_INFINITY;\n        double maxError = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue().floatValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n\n          if (sumOf) {\n            // \"sum of\" is used by BooleanQuery. Making it accurate is not\n            // easy since ReqOptSumScorer casts some intermediate\n            // contributions to the score to a float before doing another sum.\n            // So we introduce some (reasonable) leniency.\n            // TODO: remove this leniency\n            maxError += Math.ulp(dval) * 2;\n          }\n        }\n        float combined;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = (float) sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = (float) (max + x * (sum - max));\n        } else {\n          assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        // TODO: clean this up if we use junit 5 (the assert message is costly)\n        try {\n          assertEquals(combined, value, maxError);\n        } catch (Exception e) {\n          fail(q+\": actual subDetails combined==\"+combined+\n              \" != value=\"+value+\" Explanation: \"+expl);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Assert that an explanation has the expected score, and optionally that its\n   * sub-details max/sum/factor match to that score.\n   *\n   * @param q String representation of the query for assertion messages\n   * @param doc Document ID for assertion messages\n   * @param score Real score value of doc with query q\n   * @param deep indicates whether a deep comparison of sub-Explanation details should be executed\n   * @param expl The Explanation to match against score\n   */\n  // TODO: speed up this method to not be so slow\n  public static void verifyExplanation(String q, \n                                       int doc, \n                                       float score,\n                                       boolean deep,\n                                       Explanation expl) {\n    float value = expl.getValue().floatValue();\n    // TODO: clean this up if we use junit 5 (the assert message is costly)\n    try {\n      Assert.assertEquals(score, value, 0d);\n    } catch (Exception e) {\n      Assert.fail(q+\": score(doc=\"+doc+\")=\"+score+\" != explanationScore=\"+value+\" Explanation: \"+expl);\n    }\n\n    if (!deep) return;\n\n    Explanation detail[] = expl.getDetails();\n    // TODO: can we improve this entire method? it's really geared to work only with TF/IDF\n    if (expl.getDescription().endsWith(\"computed from:\")) {\n      return; // something more complicated.\n    }\n    String descr = expl.getDescription().toLowerCase(Locale.ROOT);\n    if (descr.startsWith(\"score based on \") && descr.contains(\"child docs in range\")) {\n      Assert.assertTrue(\"Child doc explanations are missing\", detail.length > 0);\n    }\n    if (detail.length > 0) {\n      if (detail.length==1 && COMPUTED_FROM_PATTERN.matcher(descr).matches() == false) {\n        // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), \n        // just verify contained expl has same score\n        if (expl.getDescription().endsWith(\"with freq of:\") == false\n            // with dismax, even if there is a single sub explanation, its\n            // score might be different if the score is negative\n            && (score >= 0 || expl.getDescription().endsWith(\"times others of:\") == false)) {\n          verifyExplanation(q,doc,score,deep,detail[0]);\n        }\n      } else {\n        // explanation must either:\n        // - end with one of: \"product of:\", \"sum of:\", \"max of:\", or\n        // - have \"max plus <x> times others\" (where <x> is float).\n        float x = 0;\n        boolean productOf = descr.endsWith(\"product of:\");\n        boolean sumOf = descr.endsWith(\"sum of:\");\n        boolean maxOf = descr.endsWith(\"max of:\");\n        boolean computedOf = descr.indexOf(\"computed as\") > 0 && COMPUTED_FROM_PATTERN.matcher(descr).matches();\n        boolean maxTimesOthers = false;\n        if (!(productOf || sumOf || maxOf || computedOf)) {\n          // maybe 'max plus x times others'\n          int k1 = descr.indexOf(\"max plus \");\n          if (k1>=0) {\n            k1 += \"max plus \".length();\n            int k2 = descr.indexOf(\" \",k1);\n            try {\n              x = Float.parseFloat(descr.substring(k1,k2).trim());\n              if (descr.substring(k2).trim().equals(\"times others of:\")) {\n                maxTimesOthers = true;\n              }\n            } catch (NumberFormatException e) {\n            }\n          }\n        }\n        // TODO: this is a TERRIBLE assertion!!!!\n        if (false == (productOf || sumOf || maxOf || computedOf || maxTimesOthers)) {\n          Assert.fail(\n              q+\": multi valued explanation description=\\\"\"+descr\n              +\"\\\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'\"\n              +\" or 'sum of:' or 'max of:' - \"+expl);\n        }\n        double sum = 0;\n        float product = 1;\n        float max = Float.NEGATIVE_INFINITY;\n        double maxError = 0;\n        for (int i=0; i<detail.length; i++) {\n          float dval = detail[i].getValue().floatValue();\n          verifyExplanation(q,doc,dval,deep,detail[i]);\n          product *= dval;\n          sum += dval;\n          max = Math.max(max,dval);\n\n          if (sumOf) {\n            // \"sum of\" is used by BooleanQuery. Making it accurate is not\n            // easy since ReqOptSumScorer casts some intermediate\n            // contributions to the score to a float before doing another sum.\n            // So we introduce some (reasonable) leniency.\n            // TODO: remove this leniency\n            maxError += Math.ulp(dval) * 2;\n          }\n        }\n        float combined;\n        if (productOf) {\n          combined = product;\n        } else if (sumOf) {\n          combined = (float) sum;\n        } else if (maxOf) {\n          combined = max;\n        } else if (maxTimesOthers) {\n          combined = (float) (max + x * (sum - max));\n        } else {\n          Assert.assertTrue(\"should never get here!\", computedOf);\n          combined = value;\n        }\n        // TODO: clean this up if we use junit 5 (the assert message is costly)\n        try {\n          Assert.assertEquals(combined, value, maxError);\n        } catch (Exception e) {\n          Assert.fail(q+\": actual subDetails combined==\"+combined+\n              \" != value=\"+value+\" Explanation: \"+expl);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46":["665c23854e5ad5caf7ea153341d7d24e5dffbc4a"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91","e5c16d494b4cccbc6f3aa00f05421575bdb11da7"],"784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","665c23854e5ad5caf7ea153341d7d24e5dffbc4a"],"9279c7cd47f17e1e8b674a3741ff5f040bc680be":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"2acf500f78aa12b92e371fd89c719291986b6b90":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","9279c7cd47f17e1e8b674a3741ff5f040bc680be"],"83870855d82aba6819217abeff5a40779dbb28b4":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91","0e121d43b5a10f2df530f406f935102656e9c4e8"],"e5c16d494b4cccbc6f3aa00f05421575bdb11da7":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91","4c051bc332b82a09e43732a93136d69164d98c37"],"46d8ada1fff8d18cb197c38c7983225162599948":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","2acf500f78aa12b92e371fd89c719291986b6b90"],"c7732a106554be0db3e03ac5211e46f6e0c285b8":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46","c7732a106554be0db3e03ac5211e46f6e0c285b8"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["2acf500f78aa12b92e371fd89c719291986b6b90"],"b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf":["784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","2acf500f78aa12b92e371fd89c719291986b6b90"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf"],"665c23854e5ad5caf7ea153341d7d24e5dffbc4a":["4c051bc332b82a09e43732a93136d69164d98c37"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91":["8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"4c051bc332b82a09e43732a93136d69164d98c37":["0e121d43b5a10f2df530f406f935102656e9c4e8"]},"commit2Childs":{"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46":["c7732a106554be0db3e03ac5211e46f6e0c285b8","1aad05eeff7818b0833c02ac6b743aa72054963b"],"0e121d43b5a10f2df530f406f935102656e9c4e8":["83870855d82aba6819217abeff5a40779dbb28b4","4c051bc332b82a09e43732a93136d69164d98c37"],"784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb":["b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9279c7cd47f17e1e8b674a3741ff5f040bc680be","2acf500f78aa12b92e371fd89c719291986b6b90","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"199dfa410f1fdbfd3294106b04096cce5ed34b21":[],"9279c7cd47f17e1e8b674a3741ff5f040bc680be":["2acf500f78aa12b92e371fd89c719291986b6b90"],"2acf500f78aa12b92e371fd89c719291986b6b90":["46d8ada1fff8d18cb197c38c7983225162599948","8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"83870855d82aba6819217abeff5a40779dbb28b4":[],"e5c16d494b4cccbc6f3aa00f05421575bdb11da7":["0e121d43b5a10f2df530f406f935102656e9c4e8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["199dfa410f1fdbfd3294106b04096cce5ed34b21"],"46d8ada1fff8d18cb197c38c7983225162599948":[],"c7732a106554be0db3e03ac5211e46f6e0c285b8":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["784ee6cdfa2c32c6eb6c2cd6383ffe4bd320c1fb"],"8aa2bb13f56a3ad540fd2dc5e882e1ed4bf799d1":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91"],"b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"665c23854e5ad5caf7ea153341d7d24e5dffbc4a":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46","199dfa410f1fdbfd3294106b04096cce5ed34b21"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91":["0e121d43b5a10f2df530f406f935102656e9c4e8","83870855d82aba6819217abeff5a40779dbb28b4","e5c16d494b4cccbc6f3aa00f05421575bdb11da7","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4c051bc332b82a09e43732a93136d69164d98c37":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","665c23854e5ad5caf7ea153341d7d24e5dffbc4a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["199dfa410f1fdbfd3294106b04096cce5ed34b21","83870855d82aba6819217abeff5a40779dbb28b4","46d8ada1fff8d18cb197c38c7983225162599948","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}