{"path":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","commits":[{"id":"ceaef6cfc68c8ab22a684192e469a8280f9e6e70","date":1462354657,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","pathOld":"/dev/null","sourceNew":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n    // TODO: use global ords for string sort\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n    case LONG:\n      // nocommit refactor/share at least numerics here:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n    // nocommit do the rest:\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"815972da4a13279b8e975d2e32ca450649d6c295","date":1462635959,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","sourceNew":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n    // ncommit: use segment-local ords for string sort\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n    case LONG:\n      // nocommit refactor/share at least numerics here:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n    // nocommit do the rest:\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","sourceOld":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n    // TODO: use global ords for string sort\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n    case LONG:\n      // nocommit refactor/share at least numerics here:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n    // nocommit do the rest:\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e401f4940308a68c615c8893021c88c57010df5","date":1462635977,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","sourceNew":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        MultiReader multiReader = new MultiReader(readers.toArray(new LeafReader[readers.size()]));\n        final SortedDocValues sorted = MultiDocValues.getSortedValues(multiReader, sortField.getField());\n        final int[] docStarts = new int[readers.size()];\n        List<LeafReaderContext> leaves = multiReader.leaves();\n        for(int i=0;i<readers.size();i++) {\n          docStarts[i] = leaves.get(i).docBase;\n        }\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MIN_VALUE;\n        } else {\n          missingOrd = Integer.MAX_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int ordA = sorted.getOrd(docStarts[readerIndexA] + docIDA);\n            if (ordA == -1) {\n              ordA = missingOrd;\n            }\n            int ordB = sorted.getOrd(docStarts[readerIndexB] + docIDB);\n            if (ordB == -1) {\n              ordB = missingOrd;\n            }\n            return reverseMul * Integer.compare(ordA, ordB);\n          }\n        };\n      }\n\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n    case LONG:\n      // nocommit refactor/share at least numerics here:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n    // nocommit do the rest:\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","sourceOld":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n    // ncommit: use segment-local ords for string sort\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n    case LONG:\n      // nocommit refactor/share at least numerics here:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n    // nocommit do the rest:\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45bfb4d30b7e62ec7d645a5e0113362636ac4981","date":1462660573,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","sourceNew":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        MultiReader multiReader = new MultiReader(readers.toArray(new LeafReader[readers.size()]));\n        final SortedDocValues sorted = MultiDocValues.getSortedValues(multiReader, sortField.getField());\n        final int[] docStarts = new int[readers.size()];\n        List<LeafReaderContext> leaves = multiReader.leaves();\n        for(int i=0;i<readers.size();i++) {\n          docStarts[i] = leaves.get(i).docBase;\n        }\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MIN_VALUE;\n        } else {\n          missingOrd = Integer.MAX_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int ordA = sorted.getOrd(docStarts[readerIndexA] + docIDA);\n            if (ordA == -1) {\n              ordA = missingOrd;\n            }\n            int ordB = sorted.getOrd(docStarts[readerIndexB] + docIDB);\n            if (ordB == -1) {\n              ordB = missingOrd;\n            }\n            return reverseMul * Integer.compare(ordA, ordB);\n          }\n        };\n      }\n\n    case LONG:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case DOUBLE:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final double missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            double valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Double.longBitsToDouble(values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            double valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Double.longBitsToDouble(values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Double.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case FLOAT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final float missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            float valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Float.intBitsToFloat((int) values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            float valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Float.intBitsToFloat((int) values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Float.compare(valueA, valueB);\n          }\n        };\n      }\n\n    // nocommit do the rest:\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","sourceOld":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        MultiReader multiReader = new MultiReader(readers.toArray(new LeafReader[readers.size()]));\n        final SortedDocValues sorted = MultiDocValues.getSortedValues(multiReader, sortField.getField());\n        final int[] docStarts = new int[readers.size()];\n        List<LeafReaderContext> leaves = multiReader.leaves();\n        for(int i=0;i<readers.size();i++) {\n          docStarts[i] = leaves.get(i).docBase;\n        }\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MIN_VALUE;\n        } else {\n          missingOrd = Integer.MAX_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int ordA = sorted.getOrd(docStarts[readerIndexA] + docIDA);\n            if (ordA == -1) {\n              ordA = missingOrd;\n            }\n            int ordB = sorted.getOrd(docStarts[readerIndexB] + docIDB);\n            if (ordB == -1) {\n              ordB = missingOrd;\n            }\n            return reverseMul * Integer.compare(ordA, ordB);\n          }\n        };\n      }\n\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n    case LONG:\n      // nocommit refactor/share at least numerics here:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n    // nocommit do the rest:\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d8200beeffd3fa5155855f4cb8a8a5e38aeff14","date":1462698019,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","sourceNew":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        MultiReader multiReader = new MultiReader(readers.toArray(new LeafReader[readers.size()]));\n        final SortedDocValues sorted = MultiDocValues.getSortedValues(multiReader, sortField.getField());\n        final int[] docStarts = new int[readers.size()];\n        List<LeafReaderContext> leaves = multiReader.leaves();\n        for(int i=0;i<readers.size();i++) {\n          docStarts[i] = leaves.get(i).docBase;\n        }\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MIN_VALUE;\n        } else {\n          missingOrd = Integer.MAX_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int ordA = sorted.getOrd(docStarts[readerIndexA] + docIDA);\n            if (ordA == -1) {\n              ordA = missingOrd;\n            }\n            int ordB = sorted.getOrd(docStarts[readerIndexB] + docIDB);\n            if (ordB == -1) {\n              ordB = missingOrd;\n            }\n            return reverseMul * Integer.compare(ordA, ordB);\n          }\n        };\n      }\n\n    case LONG:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case DOUBLE:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final double missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            double valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Double.longBitsToDouble(values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            double valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Double.longBitsToDouble(values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Double.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case FLOAT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final float missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            float valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Float.intBitsToFloat((int) values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            float valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Float.intBitsToFloat((int) values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Float.compare(valueA, valueB);\n          }\n        };\n      }\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","sourceOld":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        MultiReader multiReader = new MultiReader(readers.toArray(new LeafReader[readers.size()]));\n        final SortedDocValues sorted = MultiDocValues.getSortedValues(multiReader, sortField.getField());\n        final int[] docStarts = new int[readers.size()];\n        List<LeafReaderContext> leaves = multiReader.leaves();\n        for(int i=0;i<readers.size();i++) {\n          docStarts[i] = leaves.get(i).docBase;\n        }\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MIN_VALUE;\n        } else {\n          missingOrd = Integer.MAX_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int ordA = sorted.getOrd(docStarts[readerIndexA] + docIDA);\n            if (ordA == -1) {\n              ordA = missingOrd;\n            }\n            int ordB = sorted.getOrd(docStarts[readerIndexB] + docIDB);\n            if (ordB == -1) {\n              ordB = missingOrd;\n            }\n            return reverseMul * Integer.compare(ordA, ordB);\n          }\n        };\n      }\n\n    case LONG:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case DOUBLE:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final double missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            double valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Double.longBitsToDouble(values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            double valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Double.longBitsToDouble(values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Double.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case FLOAT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final float missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            float valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Float.intBitsToFloat((int) values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            float valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Float.intBitsToFloat((int) values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Float.compare(valueA, valueB);\n          }\n        };\n      }\n\n    // nocommit do the rest:\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ad56fe9e068c425e8ac38f2263714e167490c2","date":1462704115,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","sourceNew":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        MultiReader multiReader = new MultiReader(readers.toArray(new LeafReader[readers.size()]));\n        final SortedDocValues sorted = MultiDocValues.getSortedValues(multiReader, sortField.getField());\n        final int[] docStarts = new int[readers.size()];\n        List<LeafReaderContext> leaves = multiReader.leaves();\n        for(int i=0;i<readers.size();i++) {\n          docStarts[i] = leaves.get(i).docBase;\n        }\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int ordA = sorted.getOrd(docStarts[readerIndexA] + docIDA);\n            if (ordA == -1) {\n              ordA = missingOrd;\n            }\n            int ordB = sorted.getOrd(docStarts[readerIndexB] + docIDB);\n            if (ordB == -1) {\n              ordB = missingOrd;\n            }\n            return reverseMul * Integer.compare(ordA, ordB);\n          }\n        };\n      }\n\n    case LONG:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final long missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case DOUBLE:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final double missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            double valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Double.longBitsToDouble(values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            double valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Double.longBitsToDouble(values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Double.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case FLOAT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final float missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            float valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Float.intBitsToFloat((int) values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            float valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Float.intBitsToFloat((int) values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Float.compare(valueA, valueB);\n          }\n        };\n      }\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","sourceOld":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        MultiReader multiReader = new MultiReader(readers.toArray(new LeafReader[readers.size()]));\n        final SortedDocValues sorted = MultiDocValues.getSortedValues(multiReader, sortField.getField());\n        final int[] docStarts = new int[readers.size()];\n        List<LeafReaderContext> leaves = multiReader.leaves();\n        for(int i=0;i<readers.size();i++) {\n          docStarts[i] = leaves.get(i).docBase;\n        }\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MIN_VALUE;\n        } else {\n          missingOrd = Integer.MAX_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int ordA = sorted.getOrd(docStarts[readerIndexA] + docIDA);\n            if (ordA == -1) {\n              ordA = missingOrd;\n            }\n            int ordB = sorted.getOrd(docStarts[readerIndexB] + docIDB);\n            if (ordB == -1) {\n              ordB = missingOrd;\n            }\n            return reverseMul * Integer.compare(ordA, ordB);\n          }\n        };\n      }\n\n    case LONG:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case DOUBLE:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final double missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            double valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Double.longBitsToDouble(values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            double valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Double.longBitsToDouble(values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Double.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case FLOAT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final float missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            float valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Float.intBitsToFloat((int) values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            float valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Float.intBitsToFloat((int) values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Float.compare(valueA, valueB);\n          }\n        };\n      }\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","pathOld":"/dev/null","sourceNew":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        MultiReader multiReader = new MultiReader(readers.toArray(new LeafReader[readers.size()]));\n        final SortedDocValues sorted = MultiDocValues.getSortedValues(multiReader, sortField.getField());\n        final int[] docStarts = new int[readers.size()];\n        List<LeafReaderContext> leaves = multiReader.leaves();\n        for(int i=0;i<readers.size();i++) {\n          docStarts[i] = leaves.get(i).docBase;\n        }\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int ordA = sorted.getOrd(docStarts[readerIndexA] + docIDA);\n            if (ordA == -1) {\n              ordA = missingOrd;\n            }\n            int ordB = sorted.getOrd(docStarts[readerIndexB] + docIDB);\n            if (ordB == -1) {\n              ordB = missingOrd;\n            }\n            return reverseMul * Integer.compare(ordA, ordB);\n          }\n        };\n      }\n\n    case LONG:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final long missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case DOUBLE:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final double missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            double valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Double.longBitsToDouble(values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            double valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Double.longBitsToDouble(values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Double.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case FLOAT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final float missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            float valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Float.intBitsToFloat((int) values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            float valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Float.intBitsToFloat((int) values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Float.compare(valueA, valueB);\n          }\n        };\n      }\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","pathOld":"/dev/null","sourceNew":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        MultiReader multiReader = new MultiReader(readers.toArray(new LeafReader[readers.size()]));\n        final SortedDocValues sorted = MultiDocValues.getSortedValues(multiReader, sortField.getField());\n        final int[] docStarts = new int[readers.size()];\n        List<LeafReaderContext> leaves = multiReader.leaves();\n        for(int i=0;i<readers.size();i++) {\n          docStarts[i] = leaves.get(i).docBase;\n        }\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int ordA = sorted.getOrd(docStarts[readerIndexA] + docIDA);\n            if (ordA == -1) {\n              ordA = missingOrd;\n            }\n            int ordB = sorted.getOrd(docStarts[readerIndexB] + docIDB);\n            if (ordB == -1) {\n              ordB = missingOrd;\n            }\n            return reverseMul * Integer.compare(ordA, ordB);\n          }\n        };\n      }\n\n    case LONG:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final long missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case DOUBLE:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final double missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            double valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Double.longBitsToDouble(values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            double valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Double.longBitsToDouble(values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Double.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case FLOAT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final float missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            float valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Float.intBitsToFloat((int) values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            float valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Float.intBitsToFloat((int) values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Float.compare(valueA, valueB);\n          }\n        };\n      }\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","pathOld":"/dev/null","sourceNew":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        MultiReader multiReader = new MultiReader(readers.toArray(new LeafReader[readers.size()]));\n        final SortedDocValues sorted = MultiDocValues.getSortedValues(multiReader, sortField.getField());\n        final int[] docStarts = new int[readers.size()];\n        List<LeafReaderContext> leaves = multiReader.leaves();\n        for(int i=0;i<readers.size();i++) {\n          docStarts[i] = leaves.get(i).docBase;\n        }\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int ordA = sorted.getOrd(docStarts[readerIndexA] + docIDA);\n            if (ordA == -1) {\n              ordA = missingOrd;\n            }\n            int ordB = sorted.getOrd(docStarts[readerIndexB] + docIDB);\n            if (ordB == -1) {\n              ordB = missingOrd;\n            }\n            return reverseMul * Integer.compare(ordA, ordB);\n          }\n        };\n      }\n\n    case LONG:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final long missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case DOUBLE:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final double missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            double valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Double.longBitsToDouble(values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            double valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Double.longBitsToDouble(values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Double.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case FLOAT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final float missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            float valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Float.intBitsToFloat((int) values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            float valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Float.intBitsToFloat((int) values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Float.compare(valueA, valueB);\n          }\n        };\n      }\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":4,"author":"Mike McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","sourceNew":null,"sourceOld":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        MultiReader multiReader = new MultiReader(readers.toArray(new LeafReader[readers.size()]));\n        final SortedDocValues sorted = MultiDocValues.getSortedValues(multiReader, sortField.getField());\n        final int[] docStarts = new int[readers.size()];\n        List<LeafReaderContext> leaves = multiReader.leaves();\n        for(int i=0;i<readers.size();i++) {\n          docStarts[i] = leaves.get(i).docBase;\n        }\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int ordA = sorted.getOrd(docStarts[readerIndexA] + docIDA);\n            if (ordA == -1) {\n              ordA = missingOrd;\n            }\n            int ordB = sorted.getOrd(docStarts[readerIndexB] + docIDB);\n            if (ordB == -1) {\n              ordB = missingOrd;\n            }\n            return reverseMul * Integer.compare(ordA, ordB);\n          }\n        };\n      }\n\n    case LONG:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final long missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case DOUBLE:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final double missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            double valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Double.longBitsToDouble(values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            double valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Double.longBitsToDouble(values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Double.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case FLOAT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final float missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            float valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Float.intBitsToFloat((int) values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            float valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Float.intBitsToFloat((int) values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Float.compare(valueA, valueB);\n          }\n        };\n      }\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiSorter#getComparator(List[CodecReader],SortField).mjava","sourceNew":null,"sourceOld":"  private static CrossReaderComparator getComparator(List<CodecReader> readers, SortField sortField) throws IOException {\n    switch(sortField.getType()) {\n\n    case STRING:\n      {\n        // this uses the efficient segment-local ordinal map:\n        MultiReader multiReader = new MultiReader(readers.toArray(new LeafReader[readers.size()]));\n        final SortedDocValues sorted = MultiDocValues.getSortedValues(multiReader, sortField.getField());\n        final int[] docStarts = new int[readers.size()];\n        List<LeafReaderContext> leaves = multiReader.leaves();\n        for(int i=0;i<readers.size();i++) {\n          docStarts[i] = leaves.get(i).docBase;\n        }\n        final int missingOrd;\n        if (sortField.getMissingValue() == SortField.STRING_LAST) {\n          missingOrd = Integer.MAX_VALUE;\n        } else {\n          missingOrd = Integer.MIN_VALUE;\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int ordA = sorted.getOrd(docStarts[readerIndexA] + docIDA);\n            if (ordA == -1) {\n              ordA = missingOrd;\n            }\n            int ordB = sorted.getOrd(docStarts[readerIndexB] + docIDB);\n            if (ordB == -1) {\n              ordB = missingOrd;\n            }\n            return reverseMul * Integer.compare(ordA, ordB);\n          }\n        };\n      }\n\n    case LONG:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final long missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Long) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            long valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            long valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Long.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case INT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final int missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Integer) sortField.getMissingValue();\n        } else {\n          missingValue = 0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            int valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = (int) values.get(readerIndexA).get(docIDA);\n            } else {\n              valueA = missingValue;\n            }\n\n            int valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = (int) values.get(readerIndexB).get(docIDB);\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Integer.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case DOUBLE:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final double missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Double) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            double valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Double.longBitsToDouble(values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            double valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Double.longBitsToDouble(values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Double.compare(valueA, valueB);\n          }\n        };\n      }\n\n    case FLOAT:\n      {\n        List<NumericDocValues> values = new ArrayList<>();\n        List<Bits> docsWithFields = new ArrayList<>();\n        for(CodecReader reader : readers) {\n          values.add(DocValues.getNumeric(reader, sortField.getField()));\n          docsWithFields.add(DocValues.getDocsWithField(reader, sortField.getField()));\n        }\n\n        final int reverseMul;\n        if (sortField.getReverse()) {\n          reverseMul = -1;\n        } else {\n          reverseMul = 1;\n        }\n\n        final float missingValue;\n\n        if (sortField.getMissingValue() != null) {\n          missingValue = (Float) sortField.getMissingValue();\n        } else {\n          missingValue = 0.0f;\n        }\n\n        return new CrossReaderComparator() {\n          @Override\n          public int compare(int readerIndexA, int docIDA, int readerIndexB, int docIDB) {\n            float valueA;\n            if (docsWithFields.get(readerIndexA).get(docIDA)) {\n              valueA = Float.intBitsToFloat((int) values.get(readerIndexA).get(docIDA));\n            } else {\n              valueA = missingValue;\n            }\n\n            float valueB;\n            if (docsWithFields.get(readerIndexB).get(docIDB)) {\n              valueB = Float.intBitsToFloat((int) values.get(readerIndexB).get(docIDB));\n            } else {\n              valueB = missingValue;\n            }\n            return reverseMul * Float.compare(valueA, valueB);\n          }\n        };\n      }\n\n    default:\n      throw new IllegalArgumentException(\"unhandled SortField.getType()=\" + sortField.getType());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"45bfb4d30b7e62ec7d645a5e0113362636ac4981":["5e401f4940308a68c615c8893021c88c57010df5"],"0ad30c6a479e764150a3316e57263319775f1df2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3d33e731a93d4b57e662ff094f64f94a745422d4"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0ad30c6a479e764150a3316e57263319775f1df2"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["d470c8182e92b264680e34081b75e70a9f2b3c89","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"6d8200beeffd3fa5155855f4cb8a8a5e38aeff14":["45bfb4d30b7e62ec7d645a5e0113362636ac4981"],"5e401f4940308a68c615c8893021c88c57010df5":["815972da4a13279b8e975d2e32ca450649d6c295"],"815972da4a13279b8e975d2e32ca450649d6c295":["ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a8ad56fe9e068c425e8ac38f2263714e167490c2"],"a8ad56fe9e068c425e8ac38f2263714e167490c2":["6d8200beeffd3fa5155855f4cb8a8a5e38aeff14"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"]},"commit2Childs":{"45bfb4d30b7e62ec7d645a5e0113362636ac4981":["6d8200beeffd3fa5155855f4cb8a8a5e38aeff14"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["815972da4a13279b8e975d2e32ca450649d6c295"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad30c6a479e764150a3316e57263319775f1df2","d470c8182e92b264680e34081b75e70a9f2b3c89","ceaef6cfc68c8ab22a684192e469a8280f9e6e70","3d33e731a93d4b57e662ff094f64f94a745422d4"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"5e401f4940308a68c615c8893021c88c57010df5":["45bfb4d30b7e62ec7d645a5e0113362636ac4981"],"6d8200beeffd3fa5155855f4cb8a8a5e38aeff14":["a8ad56fe9e068c425e8ac38f2263714e167490c2"],"815972da4a13279b8e975d2e32ca450649d6c295":["5e401f4940308a68c615c8893021c88c57010df5"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"a8ad56fe9e068c425e8ac38f2263714e167490c2":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}