{"path":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","commits":[{"id":"b1b26212116cd764dfc34c7f93ecaa718ec27ef3","date":1493832602,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+intfield(7)+\":6 OR \"+intfield(3)+\":3)\");\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n\n    }\n\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ee13909dc9aa9b5a6384e0e9553259dba8b1297e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+intfield(7)+\":6 OR \"+intfield(3)+\":3)\");\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n\n    }\n\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ee13909dc9aa9b5a6384e0e9553259dba8b1297e","date":1499358800,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","sourceNew":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // sanity check our test methods can handle a query matching no docs\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"empty_top\", top);\n      assertFacetCountsAreCorrect(facets, strfield(7) + \":bogus\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, \"-*:*\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having sub-terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(8), strfield(8), null));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(null, null, \"-*:*\")));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n  \n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+intfield(7)+\":6 OR \"+intfield(3)+\":3)\");\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n\n    }\n  }\n\n","sourceOld":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+intfield(7)+\":6 OR \"+intfield(3)+\":3)\");\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n\n    }\n\n    \n  }\n\n","bugFix":["b1b26212116cd764dfc34c7f93ecaa718ec27ef3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e73d8d559120669b47658108d818b637df5456ea","date":1499401413,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","sourceNew":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // sanity check our test methods can handle a query matching no docs\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"empty_top\", top);\n      assertFacetCountsAreCorrect(facets, strfield(7) + \":bogus\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, \"-*:*\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having sub-terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(8), strfield(8), null));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(null, null, \"-*:*\")));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n  \n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+intfield(7)+\":6 OR \"+intfield(3)+\":3)\");\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n\n    }\n  }\n\n","sourceOld":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+intfield(7)+\":6 OR \"+intfield(3)+\":3)\");\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n\n    }\n\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"20e27469285c87fe39ba0fcaf9c290f18bb0f1cf","date":1507135648,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","sourceNew":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // sanity check our test methods can handle a query matching no docs\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"empty_top\", top);\n      assertFacetCountsAreCorrect(facets, strfield(7) + \":bogus\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, \"-*:*\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having sub-terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(8), strfield(8), null));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(null, null, \"-*:*\")));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n  \n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+intfield(7)+\":6 OR \"+intfield(3)+\":3)\");\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n\n    }\n\n    { // low limits, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 0, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 0, true));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n    \n    { // low limit, high overrequest\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, UNIQUE_FIELD_VALS + 10, false);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, UNIQUE_FIELD_VALS + 10, false));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n    \n    { // low limit, low overrequest, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 7, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 7, true));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n    \n  }\n\n","sourceOld":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // sanity check our test methods can handle a query matching no docs\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"empty_top\", top);\n      assertFacetCountsAreCorrect(facets, strfield(7) + \":bogus\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, \"-*:*\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having sub-terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(8), strfield(8), null));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(null, null, \"-*:*\")));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n  \n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+intfield(7)+\":6 OR \"+intfield(3)+\":3)\");\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d7859b8e6a469429413db808a609e8468be14c03","date":1507222263,"type":3,"author":"tballison","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","sourceNew":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // sanity check our test methods can handle a query matching no docs\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"empty_top\", top);\n      assertFacetCountsAreCorrect(facets, strfield(7) + \":bogus\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, \"-*:*\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having sub-terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(8), strfield(8), null));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(null, null, \"-*:*\")));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n  \n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+intfield(7)+\":6 OR \"+intfield(3)+\":3)\");\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n\n    }\n\n    { // low limits, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 0, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 0, true));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n    \n    { // low limit, high overrequest\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, UNIQUE_FIELD_VALS + 10, false);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, UNIQUE_FIELD_VALS + 10, false));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n    \n    { // low limit, low overrequest, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 7, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 7, true));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n    \n  }\n\n","sourceOld":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // sanity check our test methods can handle a query matching no docs\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"empty_top\", top);\n      assertFacetCountsAreCorrect(facets, strfield(7) + \":bogus\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, \"-*:*\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having sub-terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(8), strfield(8), null));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(null, null, \"-*:*\")));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n  \n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+intfield(7)+\":6 OR \"+intfield(3)+\":3)\");\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"efe1ad0eb9567f77ec7d5bf446d38340ad8d2bd1","date":1527210146,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","sourceNew":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // sanity check our test methods can handle a query matching no docs\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"empty_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, strfield(7) + \":bogus\");\n      assertEquals(\"Empty search result shouldn't have found a single bucket\",\n                   UNIQUE_FIELD_VALS, maxBuckets.get());\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, \"-*:*\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"filtered_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"*:*\");\n      assertEquals(\"Empty join filter shouldn't have found a single bucket\",\n                   UNIQUE_FIELD_VALS, maxBuckets.get());\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having sub-terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(8), strfield(8), null));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(null, null, \"-*:*\")));\n      facets.put(\"filtered_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"*:*\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS);\n    }\n  \n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":16 OR \"+strfield(9)+\":16 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+intfield(7)+\":16 OR \"+intfield(3)+\":13)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":16 OR \"+strfield(9)+\":16 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n\n    }\n\n    { // low limits, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 0, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 0, true));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n    { // low limit, high overrequest\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, UNIQUE_FIELD_VALS + 10, false);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, UNIQUE_FIELD_VALS + 10, false));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n    { // low limit, low overrequest, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 7, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 7, true));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n  }\n\n","sourceOld":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // sanity check our test methods can handle a query matching no docs\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"empty_top\", top);\n      assertFacetCountsAreCorrect(facets, strfield(7) + \":bogus\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, \"-*:*\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having sub-terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(8), strfield(8), null));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(null, null, \"-*:*\")));\n      facets.put(\"filtered_top\", top);\n      assertFacetCountsAreCorrect(facets, \"*:*\");\n    }\n  \n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+intfield(7)+\":6 OR \"+intfield(3)+\":3)\");\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n\n    }\n\n    { // low limits, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 0, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 0, true));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n    \n    { // low limit, high overrequest\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, UNIQUE_FIELD_VALS + 10, false);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, UNIQUE_FIELD_VALS + 10, false));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n    \n    { // low limit, low overrequest, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 7, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 7, true));\n      facets.put(\"facet_4\", top);\n      assertFacetCountsAreCorrect(facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92910727264a23a47b7a6c94b0f75d655537b9ea","date":1540414655,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/facet/TestCloudJSONFacetJoinDomain#testBespoke().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudJSONFacetJoinDomain#testBespoke().mjava","sourceNew":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // sanity check our test methods can handle a query matching no docs\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"empty_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, strfield(7) + \":bogus\");\n      assertEquals(\"Empty search result shouldn't have found a single bucket\",\n                   UNIQUE_FIELD_VALS, maxBuckets.get());\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, \"-*:*\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"filtered_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"*:*\");\n      assertEquals(\"Empty join filter shouldn't have found a single bucket\",\n                   UNIQUE_FIELD_VALS, maxBuckets.get());\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having sub-terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(8), strfield(8), null));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(null, null, \"-*:*\")));\n      facets.put(\"filtered_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"*:*\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS);\n    }\n  \n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":16 OR \"+strfield(9)+\":16 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+intfield(7)+\":16 OR \"+intfield(3)+\":13)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":16 OR \"+strfield(9)+\":16 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n\n    }\n\n    { // low limits, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 0, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 0, true));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n    { // low limit, high overrequest\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, UNIQUE_FIELD_VALS + 10, false);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, UNIQUE_FIELD_VALS + 10, false));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n    { // low limit, low overrequest, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 7, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 7, true));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n  }\n\n","sourceOld":"  /** \n   * Test some small, hand crafted, but non-trivial queries that are\n   * easier to trace/debug then a pure random monstrosity.\n   * (ie: if something obvious gets broken, this test may fail faster and in a more obvious way then testRandom)\n   */\n  public void testBespoke() throws Exception {\n\n    { // sanity check our test methods can handle a query matching no docs\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"empty_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, strfield(7) + \":bogus\");\n      assertEquals(\"Empty search result shouldn't have found a single bucket\",\n                   UNIQUE_FIELD_VALS, maxBuckets.get());\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, \"-*:*\"));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"filtered_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"*:*\");\n      assertEquals(\"Empty join filter shouldn't have found a single bucket\",\n                   UNIQUE_FIELD_VALS, maxBuckets.get());\n    }\n    \n    { // sanity check our test methods can handle a query where a facet filter prevents any doc from having sub-terms\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(8), strfield(8), null));\n      top.subFacets.put(\"sub\", new TermFacet(strfield(11), new JoinDomain(null, null, \"-*:*\")));\n      facets.put(\"filtered_top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"*:*\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS);\n    }\n  \n    { // strings\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(strfield(8), strfield(8), null)));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":16 OR \"+strfield(9)+\":16 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n    }\n\n    { // ints\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(intfield(9), new JoinDomain(intfield(5), intfield(9), null));\n      facets.put(\"top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+intfield(7)+\":16 OR \"+intfield(3)+\":13)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n    }\n\n    { // some domains with filter only, no actual join\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9), new JoinDomain(null, null, strfield(9)+\":[* TO *]\"));\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11), new JoinDomain(null, null, strfield(3)+\":[* TO 5]\")));\n      facets.put(\"top\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":16 OR \"+strfield(9)+\":16 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < UNIQUE_FIELD_VALS * UNIQUE_FIELD_VALS);\n\n    }\n\n    { // low limits, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 0, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 0, true));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n    { // low limit, high overrequest\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, UNIQUE_FIELD_VALS + 10, false);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, UNIQUE_FIELD_VALS + 10, false));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n    { // low limit, low overrequest, explicit refinement\n      Map<String,TermFacet> facets = new LinkedHashMap<>();\n      TermFacet top = new TermFacet(strfield(9),\n                                    new JoinDomain(strfield(5), strfield(9), strfield(9)+\":[* TO *]\"),\n                                    5, 7, true);\n      top.subFacets.put(\"facet_5\", new TermFacet(strfield(11),\n                                                 new JoinDomain(strfield(8), strfield(8), null),\n                                                 10, 7, true));\n      facets.put(\"facet_4\", top);\n      final AtomicInteger maxBuckets = new AtomicInteger(5 * 10);\n      assertFacetCountsAreCorrect(maxBuckets, facets, \"(\"+strfield(7)+\":6 OR \"+strfield(9)+\":6 OR \"+strfield(6)+\":19 OR \"+strfield(0)+\":11)\");\n      assertTrue(\"Didn't check a single bucket???\", maxBuckets.get() < 5 * 10);\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ee13909dc9aa9b5a6384e0e9553259dba8b1297e":["b1b26212116cd764dfc34c7f93ecaa718ec27ef3"],"b1b26212116cd764dfc34c7f93ecaa718ec27ef3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"efe1ad0eb9567f77ec7d5bf446d38340ad8d2bd1":["20e27469285c87fe39ba0fcaf9c290f18bb0f1cf"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b1b26212116cd764dfc34c7f93ecaa718ec27ef3"],"d7859b8e6a469429413db808a609e8468be14c03":["ee13909dc9aa9b5a6384e0e9553259dba8b1297e","20e27469285c87fe39ba0fcaf9c290f18bb0f1cf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e73d8d559120669b47658108d818b637df5456ea":["e9017cf144952056066919f1ebc7897ff9bd71b1","ee13909dc9aa9b5a6384e0e9553259dba8b1297e"],"92910727264a23a47b7a6c94b0f75d655537b9ea":["efe1ad0eb9567f77ec7d5bf446d38340ad8d2bd1"],"20e27469285c87fe39ba0fcaf9c290f18bb0f1cf":["ee13909dc9aa9b5a6384e0e9553259dba8b1297e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["92910727264a23a47b7a6c94b0f75d655537b9ea"]},"commit2Childs":{"ee13909dc9aa9b5a6384e0e9553259dba8b1297e":["d7859b8e6a469429413db808a609e8468be14c03","e73d8d559120669b47658108d818b637df5456ea","20e27469285c87fe39ba0fcaf9c290f18bb0f1cf"],"b1b26212116cd764dfc34c7f93ecaa718ec27ef3":["ee13909dc9aa9b5a6384e0e9553259dba8b1297e","e9017cf144952056066919f1ebc7897ff9bd71b1"],"efe1ad0eb9567f77ec7d5bf446d38340ad8d2bd1":["92910727264a23a47b7a6c94b0f75d655537b9ea"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["e73d8d559120669b47658108d818b637df5456ea"],"d7859b8e6a469429413db808a609e8468be14c03":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b1b26212116cd764dfc34c7f93ecaa718ec27ef3","e9017cf144952056066919f1ebc7897ff9bd71b1"],"e73d8d559120669b47658108d818b637df5456ea":[],"92910727264a23a47b7a6c94b0f75d655537b9ea":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"20e27469285c87fe39ba0fcaf9c290f18bb0f1cf":["efe1ad0eb9567f77ec7d5bf446d38340ad8d2bd1","d7859b8e6a469429413db808a609e8468be14c03"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d7859b8e6a469429413db808a609e8468be14c03","e73d8d559120669b47658108d818b637df5456ea","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}