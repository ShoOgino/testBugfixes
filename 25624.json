{"path":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataOutput#toArrayCopy().mjava","commits":[{"id":"fad01f81cc24b33263ccec7dbff3fb907702f91e","date":1535461373,"type":0,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataOutput#toArrayCopy().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Return a contiguous array with the current content written to the output. The returned\n   * array is always a copy (can be mutated).\n   */\n  public byte[] toArrayCopy() {\n    if (blocks.size() == 0) {\n      return EMPTY_BYTE_ARRAY;\n    }\n\n    // We could try to detect single-block, array-based ByteBuffer here\n    // and use Arrays.copyOfRange, but I don't think it's worth the extra\n    // instance checks.\n\n    byte [] arr = new byte[Math.toIntExact(size())];\n    int offset = 0;\n    for (ByteBuffer bb : toBufferList()) {\n      int len = bb.remaining();\n      bb.get(arr, offset, len);\n      offset += len;\n    }\n    return arr;\n  }  \n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"026ea77412266e9bae6039097f946631d6e8218f","date":1545990925,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataOutput#toArrayCopy().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/store/ByteBuffersDataOutput#toArrayCopy().mjava","sourceNew":"  /**\n   * Return a contiguous array with the current content written to the output. The returned\n   * array is always a copy (can be mutated).\n   *\n   * If the {@link #size()} of the underlying buffers exceeds maximum size of Java array, an\n   * {@link RuntimeException} will be thrown.\n   */\n  public byte[] toArrayCopy() {\n    if (blocks.size() == 0) {\n      return EMPTY_BYTE_ARRAY;\n    }\n\n    // We could try to detect single-block, array-based ByteBuffer here\n    // and use Arrays.copyOfRange, but I don't think it's worth the extra\n    // instance checks.\n    long size = size();\n    if (size > Integer.MAX_VALUE) {\n      throw new RuntimeException(\"Data exceeds maximum size of a single byte array: \" + size);\n    }\n\n    byte [] arr = new byte[Math.toIntExact(size())];\n    int offset = 0;\n    for (ByteBuffer bb : toBufferList()) {\n      int len = bb.remaining();\n      bb.get(arr, offset, len);\n      offset += len;\n    }\n    return arr;\n  }  \n\n","sourceOld":"  /**\n   * Return a contiguous array with the current content written to the output. The returned\n   * array is always a copy (can be mutated).\n   */\n  public byte[] toArrayCopy() {\n    if (blocks.size() == 0) {\n      return EMPTY_BYTE_ARRAY;\n    }\n\n    // We could try to detect single-block, array-based ByteBuffer here\n    // and use Arrays.copyOfRange, but I don't think it's worth the extra\n    // instance checks.\n\n    byte [] arr = new byte[Math.toIntExact(size())];\n    int offset = 0;\n    for (ByteBuffer bb : toBufferList()) {\n      int len = bb.remaining();\n      bb.get(arr, offset, len);\n      offset += len;\n    }\n    return arr;\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"026ea77412266e9bae6039097f946631d6e8218f":["fad01f81cc24b33263ccec7dbff3fb907702f91e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fad01f81cc24b33263ccec7dbff3fb907702f91e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["026ea77412266e9bae6039097f946631d6e8218f"]},"commit2Childs":{"026ea77412266e9bae6039097f946631d6e8218f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fad01f81cc24b33263ccec7dbff3fb907702f91e"],"fad01f81cc24b33263ccec7dbff3fb907702f91e":["026ea77412266e9bae6039097f946631d6e8218f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}