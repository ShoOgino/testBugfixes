{"path":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","commits":[{"id":"eb55f624eb53f26cfb7f9614b862fb7657633358","date":1414519951,"type":0,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"/dev/null","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(\"id\");\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      // TODO: Are the mintf and mindf defaults ok at '1' ?\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", 1));\n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["2100a5b744ecaec4d2b191a7da9083feb50a6f7f","655260340014c640e7d0f9a7a7ea1f00f36f65e5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d32e559c96d0c16fe041e1608a4bbbf8a6c9a4e1","date":1414624217,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      // TODO: Are the mintf and mindf defaults ok at '1' ?\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", 1));\n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(\"id\");\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      // TODO: Are the mintf and mindf defaults ok at '1' ?\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", 1));\n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"776417a20af3930a363a226c989867f65e93ee91","date":1434582735,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxntp\"));\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      // TODO: Are the mintf and mindf defaults ok at '1' ?\n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", 1));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", 1));\n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"caeebbaa964f57dceaab0b9cb5800882e88d57ff","date":1435075428,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxntp\"));\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"655260340014c640e7d0f9a7a7ea1f00f36f65e5","date":1436227523,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        mlt.setFieldNames(qf);\n      } else {\n\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      }\n\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":["eb55f624eb53f26cfb7f9614b862fb7657633358"],"bugIntro":["2100a5b744ecaec4d2b191a7da9083feb50a6f7f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ed95a777f3860385e015fb8a082e4b66a5aa6bb8","date":1448307668,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          Float b = boostFields.get(((TermQuery) q).getTerm().field());\n\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      return mlt.like(scoreDocs[0].doc);\n\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":["2100a5b744ecaec4d2b191a7da9083feb50a6f7f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19cb756f0ad73c8d898cb8bfdd9f04bcc6e3b7c1","date":1451604685,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          Float b = boostFields.get(((TermQuery) q).getTerm().field());\n\n          if (b != null) {\n            q = new BoostQuery(q, b);\n          }\n\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":["2100a5b744ecaec4d2b191a7da9083feb50a6f7f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c8a0e442f7b61f811680273b25da95994a724466","date":1467878549,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setDisableCoord(boostedMLTQuery.isCoordDisabled());\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.setDisableCoord(true);\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8ed124d21605b0e41f648c25f80f60ba1828e78a","date":1477056513,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n      // what happens if value is explicitly set to false?\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\", false));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":["2100a5b744ecaec4d2b191a7da9083feb50a6f7f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n      // what happens if value is explicitly set to false?\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\", false));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      if(localParams.getInt(\"mintf\") != null)\n        mlt.setMinTermFreq(localParams.getInt(\"mintf\"));\n      \n      if(localParams.getInt(\"mindf\") != null)\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\"));\n      \n      if(localParams.get(\"minwl\") != null)\n        mlt.setMinWordLen(localParams.getInt(\"minwl\"));\n\n      if(localParams.get(\"maxwl\") != null)\n        mlt.setMaxWordLen(localParams.getInt(\"maxwl\"));\n\n      if(localParams.get(\"maxqt\") != null)\n        mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\"));\n\n      if(localParams.get(\"maxntp\") != null)\n        mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\"));\n\n      if(localParams.get(\"maxdf\") != null) {\n        mlt.setMaxDocFreq(localParams.getInt(\"maxdf\"));\n      }\n\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\"));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2100a5b744ecaec4d2b191a7da9083feb50a6f7f","date":1483995984,"type":3,"author":"anshum","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n      // what happens if value is explicitly set to false?\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\", false));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":["8ed124d21605b0e41f648c25f80f60ba1828e78a","ed95a777f3860385e015fb8a082e4b66a5aa6bb8","655260340014c640e7d0f9a7a7ea1f00f36f65e5","19cb756f0ad73c8d898cb8bfdd9f04bcc6e3b7c1","eb55f624eb53f26cfb7f9614b862fb7657633358"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n\n      // what happens if value is explicitly set to false?\n      if(localParams.get(\"boost\") != null) {\n        mlt.setBoost(localParams.getBool(\"boost\", false));\n        boostFields = SolrPluginUtils.parseFieldBoosts(qf);\n      }\n      \n      ArrayList<String> fields = new ArrayList<>();\n\n      if (qf != null) {\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n      } else {\n        Map<String, SchemaField> fieldNames = req.getSearcher().getSchema().getFields();\n        for (String fieldName : fieldNames.keySet()) {\n          if (fieldNames.get(fieldName).indexed() && fieldNames.get(fieldName).stored())\n            if (fieldNames.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n      }\n      if( fields.size() < 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fields.toArray(new String[fields.size()]));\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d81baa64023bbb9b43f6d929ee168b105940d30","date":1486492702,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumericType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39fdbc59d893f5a211736e861fe145798a40b9ff","date":1498161919,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = newQ.build();\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 2);\n      if (td.totalHits.value != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 1);\n      if (td.totalHits != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f97fc3d287be2a8d7f513f0de3249b50dda47299","date":1568378558,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 2);\n      if (td.totalHits.value != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (Map.Entry<String, SchemaField> entry : fieldDefinitions.entrySet()) {\n          if (entry.getValue().indexed() && entry.getValue().stored())\n            if (entry.getValue().getType().getNumberType() == null)\n              fields.add(entry.getKey());\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 2);\n      if (td.totalHits.value != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (String fieldName : fieldDefinitions.keySet()) {\n          if (fieldDefinitions.get(fieldName).indexed() && fieldDefinitions.get(fieldName).stored())\n            if (fieldDefinitions.get(fieldName).getType().getNumberType() == null)\n              fields.add(fieldName);\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50dfd19525c8d73e856dca6edb64b7aea074037f","date":1591579225,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","pathOld":"solr/core/src/java/org/apache/solr/search/mlt/SimpleMLTQParser#parse().mjava","sourceNew":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 2);\n      if (td.totalHits.value != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        ArrayList<String> fields = new ArrayList();\n        for (Map.Entry<String, SchemaField> entry : fieldDefinitions.entrySet()) {\n          if (entry.getValue().indexed() && entry.getValue().stored())\n            if (entry.getValue().getType().getNumberType() == null)\n              fields.add(entry.getKey());\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","sourceOld":"  public Query parse() {\n\n    String defaultField = req.getSchema().getUniqueKeyField().getName();\n    String uniqueValue = localParams.get(QueryParsing.V);\n    String[] qf = localParams.getParams(\"qf\");\n\n    SolrIndexSearcher searcher = req.getSearcher();\n    Query docIdQuery = createIdQuery(defaultField, uniqueValue);\n    Map<String,Float> boostFields = new HashMap<>();\n\n    try {\n      TopDocs td = searcher.search(docIdQuery, 2);\n      if (td.totalHits.value != 1) throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST, \"Error completing MLT request. Could not fetch \" +\n          \"document with id [\" + uniqueValue + \"]\");\n      ScoreDoc[] scoreDocs = td.scoreDocs;\n      MoreLikeThis mlt = new MoreLikeThis(req.getSearcher().getIndexReader());\n      \n      mlt.setMinTermFreq(localParams.getInt(\"mintf\", MoreLikeThis.DEFAULT_MIN_TERM_FREQ));\n      mlt.setMinDocFreq(localParams.getInt(\"mindf\", MoreLikeThis.DEFAULT_MIN_DOC_FREQ));\n      mlt.setMinWordLen(localParams.getInt(\"minwl\", MoreLikeThis.DEFAULT_MIN_WORD_LENGTH));\n      mlt.setMaxWordLen(localParams.getInt(\"maxwl\", MoreLikeThis.DEFAULT_MAX_WORD_LENGTH));\n      mlt.setMaxQueryTerms(localParams.getInt(\"maxqt\", MoreLikeThis.DEFAULT_MAX_QUERY_TERMS));\n      mlt.setMaxNumTokensParsed(localParams.getInt(\"maxntp\", MoreLikeThis.DEFAULT_MAX_NUM_TOKENS_PARSED));\n      mlt.setMaxDocFreq(localParams.getInt(\"maxdf\", MoreLikeThis.DEFAULT_MAX_DOC_FREQ));\n      Boolean boost = localParams.getBool(\"boost\", false);\n      mlt.setBoost(boost);\n\n      String[] fieldNames;\n      \n      if (qf != null) {\n        ArrayList<String> fields = new ArrayList<>();\n        for (String fieldName : qf) {\n          if (!StringUtils.isEmpty(fieldName))  {\n            String[] strings = splitList.split(fieldName);\n            for (String string : strings) {\n              if (!StringUtils.isEmpty(string)) {\n                fields.add(string);\n              }\n            }\n          }\n        }\n        // Parse field names and boosts from the fields\n        boostFields = SolrPluginUtils.parseFieldBoosts(fields.toArray(new String[0]));\n        fieldNames = boostFields.keySet().toArray(new String[0]);\n      } else {\n        Map<String, SchemaField> fieldDefinitions = req.getSearcher().getSchema().getFields();\n        ArrayList<String> fields = new ArrayList();\n        for (Map.Entry<String, SchemaField> entry : fieldDefinitions.entrySet()) {\n          if (entry.getValue().indexed() && entry.getValue().stored())\n            if (entry.getValue().getType().getNumberType() == null)\n              fields.add(entry.getKey());\n        }\n        fieldNames = fields.toArray(new String[0]);\n      }\n      if (fieldNames.length < 1) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"MoreLikeThis requires at least one similarity field: qf\" );\n      }\n\n      mlt.setFieldNames(fieldNames);\n      mlt.setAnalyzer(req.getSchema().getIndexAnalyzer());\n\n      Query rawMLTQuery = mlt.like(scoreDocs[0].doc);\n      BooleanQuery boostedMLTQuery = (BooleanQuery) rawMLTQuery;\n\n      if (boost && boostFields.size() > 0) {\n        BooleanQuery.Builder newQ = new BooleanQuery.Builder();\n        newQ.setMinimumNumberShouldMatch(boostedMLTQuery.getMinimumNumberShouldMatch());\n\n        for (BooleanClause clause : boostedMLTQuery) {\n          Query q = clause.getQuery();\n          float originalBoost = 1f;\n          if (q instanceof BoostQuery) {\n            BoostQuery bq = (BoostQuery) q;\n            q = bq.getQuery();\n            originalBoost = bq.getBoost();\n          }\n          Float fieldBoost = boostFields.get(((TermQuery) q).getTerm().field());\n          q = ((fieldBoost != null) ? new BoostQuery(q, fieldBoost * originalBoost) : clause.getQuery());\n          newQ.add(q, clause.getOccur());\n        }\n\n        boostedMLTQuery = QueryUtils.build(newQ, this);\n      }\n\n      // exclude current document from results\n      BooleanQuery.Builder realMLTQuery = new BooleanQuery.Builder();\n      realMLTQuery.add(boostedMLTQuery, BooleanClause.Occur.MUST);\n      realMLTQuery.add(docIdQuery, BooleanClause.Occur.MUST_NOT);\n\n      return realMLTQuery.build();\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n          \"Error completing MLT request\" + e.getMessage());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"eb55f624eb53f26cfb7f9614b862fb7657633358":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"caeebbaa964f57dceaab0b9cb5800882e88d57ff":["776417a20af3930a363a226c989867f65e93ee91"],"ed95a777f3860385e015fb8a082e4b66a5aa6bb8":["655260340014c640e7d0f9a7a7ea1f00f36f65e5"],"39fdbc59d893f5a211736e861fe145798a40b9ff":["3d81baa64023bbb9b43f6d929ee168b105940d30"],"2100a5b744ecaec4d2b191a7da9083feb50a6f7f":["8ed124d21605b0e41f648c25f80f60ba1828e78a"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","2100a5b744ecaec4d2b191a7da9083feb50a6f7f"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["3d81baa64023bbb9b43f6d929ee168b105940d30","39fdbc59d893f5a211736e861fe145798a40b9ff"],"28288370235ed02234a64753cdbf0c6ec096304a":["3d81baa64023bbb9b43f6d929ee168b105940d30","39fdbc59d893f5a211736e861fe145798a40b9ff"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["19cb756f0ad73c8d898cb8bfdd9f04bcc6e3b7c1","c8a0e442f7b61f811680273b25da95994a724466"],"8ed124d21605b0e41f648c25f80f60ba1828e78a":["c8a0e442f7b61f811680273b25da95994a724466"],"d32e559c96d0c16fe041e1608a4bbbf8a6c9a4e1":["eb55f624eb53f26cfb7f9614b862fb7657633358"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["2100a5b744ecaec4d2b191a7da9083feb50a6f7f"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["f97fc3d287be2a8d7f513f0de3249b50dda47299"],"19cb756f0ad73c8d898cb8bfdd9f04bcc6e3b7c1":["ed95a777f3860385e015fb8a082e4b66a5aa6bb8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","8ed124d21605b0e41f648c25f80f60ba1828e78a"],"776417a20af3930a363a226c989867f65e93ee91":["d32e559c96d0c16fe041e1608a4bbbf8a6c9a4e1"],"c8a0e442f7b61f811680273b25da95994a724466":["19cb756f0ad73c8d898cb8bfdd9f04bcc6e3b7c1"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["28288370235ed02234a64753cdbf0c6ec096304a"],"f97fc3d287be2a8d7f513f0de3249b50dda47299":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"655260340014c640e7d0f9a7a7ea1f00f36f65e5":["caeebbaa964f57dceaab0b9cb5800882e88d57ff"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["50dfd19525c8d73e856dca6edb64b7aea074037f"]},"commit2Childs":{"eb55f624eb53f26cfb7f9614b862fb7657633358":["d32e559c96d0c16fe041e1608a4bbbf8a6c9a4e1"],"caeebbaa964f57dceaab0b9cb5800882e88d57ff":["655260340014c640e7d0f9a7a7ea1f00f36f65e5"],"ed95a777f3860385e015fb8a082e4b66a5aa6bb8":["19cb756f0ad73c8d898cb8bfdd9f04bcc6e3b7c1"],"39fdbc59d893f5a211736e861fe145798a40b9ff":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"2100a5b744ecaec4d2b191a7da9083feb50a6f7f":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","3d81baa64023bbb9b43f6d929ee168b105940d30"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"8ed124d21605b0e41f648c25f80f60ba1828e78a":["2100a5b744ecaec4d2b191a7da9083feb50a6f7f","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"d32e559c96d0c16fe041e1608a4bbbf8a6c9a4e1":["776417a20af3930a363a226c989867f65e93ee91"],"3d81baa64023bbb9b43f6d929ee168b105940d30":["39fdbc59d893f5a211736e861fe145798a40b9ff","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"50dfd19525c8d73e856dca6edb64b7aea074037f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"19cb756f0ad73c8d898cb8bfdd9f04bcc6e3b7c1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","c8a0e442f7b61f811680273b25da95994a724466"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["eb55f624eb53f26cfb7f9614b862fb7657633358"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7"],"776417a20af3930a363a226c989867f65e93ee91":["caeebbaa964f57dceaab0b9cb5800882e88d57ff"],"c8a0e442f7b61f811680273b25da95994a724466":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","8ed124d21605b0e41f648c25f80f60ba1828e78a"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["f97fc3d287be2a8d7f513f0de3249b50dda47299"],"f97fc3d287be2a8d7f513f0de3249b50dda47299":["50dfd19525c8d73e856dca6edb64b7aea074037f"],"655260340014c640e7d0f9a7a7ea1f00f36f65e5":["ed95a777f3860385e015fb8a082e4b66a5aa6bb8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}