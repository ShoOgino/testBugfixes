{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","commits":[{"id":"f67c3a1123a063e580a2e6ec51b9eb7c273666ce","date":1487877483,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          List<String> terms = (List<String>)resp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)resp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)resp.get(\"queryDocFreq\");\n          numDocs += (Integer)resp.get(\"numDocs\");\n          resultCount += (Integer)resp.get(\"resultCount\");\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(String term : mergeFreqs.keySet() ) {\n          int[] freqs = mergeFreqs.get(term);\n          Map map = new HashMap();\n          map.put(\"term\", term);\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)Math.log(freqs[1]) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0083b99694eda9623bc01747fd55949a79af54fa","date":1488215006,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          List<String> terms = (List<String>)resp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)resp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)resp.get(\"queryDocFreq\");\n          numDocs += (Integer)resp.get(\"numDocs\");\n          resultCount += (Integer)resp.get(\"resultCount\");\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(String term : mergeFreqs.keySet() ) {\n          int[] freqs = mergeFreqs.get(term);\n          Map map = new HashMap();\n          map.put(\"term\", term);\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          List<String> terms = (List<String>)resp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)resp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)resp.get(\"queryDocFreq\");\n          numDocs += (Integer)resp.get(\"numDocs\");\n          resultCount += (Integer)resp.get(\"resultCount\");\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(String term : mergeFreqs.keySet() ) {\n          int[] freqs = mergeFreqs.get(term);\n          Map map = new HashMap();\n          map.put(\"term\", term);\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)Math.log(freqs[1]) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e5922fb6b9f0e49b31ce0436420a7f4392031c4","date":1489025486,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShards(zkHost, collection, streamContext))) {\n          NamedList resp = getTopTermsCall.get();\n\n          List<String> terms = (List<String>)resp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)resp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)resp.get(\"queryDocFreq\");\n          numDocs += (Integer)resp.get(\"numDocs\");\n          resultCount += (Integer)resp.get(\"resultCount\");\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(String term : mergeFreqs.keySet() ) {\n          int[] freqs = mergeFreqs.get(term);\n          Map map = new HashMap();\n          map.put(\"term\", term);\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          List<String> terms = (List<String>)resp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)resp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)resp.get(\"queryDocFreq\");\n          numDocs += (Integer)resp.get(\"numDocs\");\n          resultCount += (Integer)resp.get(\"resultCount\");\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(String term : mergeFreqs.keySet() ) {\n          int[] freqs = mergeFreqs.get(term);\n          Map map = new HashMap();\n          map.put(\"term\", term);\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bfa0f7f6fca863376793e8c93f38bf996014a46","date":1533039519,"type":3,"author":"Alexandre Rafalovitch","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShards(zkHost, collection, streamContext))) {\n          NamedList fullResp = getTopTermsCall.get();\n          Map stResp = (Map)fullResp.get(\"significantTerms\");\n\n          List<String> terms = (List<String>)stResp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)stResp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)stResp.get(\"queryDocFreq\");\n          numDocs += (Integer)stResp.get(\"numDocs\");\n\n          SolrDocumentList searchResp = (SolrDocumentList) fullResp.get(\"response\");\n          resultCount += searchResp.getNumFound();\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(String term : mergeFreqs.keySet() ) {\n          int[] freqs = mergeFreqs.get(term);\n          Map map = new HashMap();\n          map.put(\"term\", term);\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShards(zkHost, collection, streamContext))) {\n          NamedList resp = getTopTermsCall.get();\n\n          List<String> terms = (List<String>)resp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)resp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)resp.get(\"queryDocFreq\");\n          numDocs += (Integer)resp.get(\"numDocs\");\n          resultCount += (Integer)resp.get(\"resultCount\");\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(String term : mergeFreqs.keySet() ) {\n          int[] freqs = mergeFreqs.get(term);\n          Map map = new HashMap();\n          map.put(\"term\", term);\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","date":1571070979,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShards(zkHost, collection, streamContext))) {\n          NamedList fullResp = getTopTermsCall.get();\n          Map stResp = (Map)fullResp.get(\"significantTerms\");\n\n          List<String> terms = (List<String>)stResp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)stResp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)stResp.get(\"queryDocFreq\");\n          numDocs += (Integer)stResp.get(\"numDocs\");\n\n          SolrDocumentList searchResp = (SolrDocumentList) fullResp.get(\"response\");\n          resultCount += searchResp.getNumFound();\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(Map.Entry<String, int[]> entry : mergeFreqs.entrySet()) {\n          int[] freqs = entry.getValue();\n          Map map = new HashMap();\n          map.put(\"term\", entry.getKey());\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShards(zkHost, collection, streamContext))) {\n          NamedList fullResp = getTopTermsCall.get();\n          Map stResp = (Map)fullResp.get(\"significantTerms\");\n\n          List<String> terms = (List<String>)stResp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)stResp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)stResp.get(\"queryDocFreq\");\n          numDocs += (Integer)stResp.get(\"numDocs\");\n\n          SolrDocumentList searchResp = (SolrDocumentList) fullResp.get(\"response\");\n          resultCount += searchResp.getNumFound();\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(String term : mergeFreqs.keySet() ) {\n          int[] freqs = mergeFreqs.get(term);\n          Map map = new HashMap();\n          map.put(\"term\", term);\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShards(zkHost, collection, streamContext))) {\n          NamedList fullResp = getTopTermsCall.get();\n          Map stResp = (Map)fullResp.get(\"significantTerms\");\n\n          List<String> terms = (List<String>)stResp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)stResp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)stResp.get(\"queryDocFreq\");\n          numDocs += (Integer)stResp.get(\"numDocs\");\n\n          SolrDocumentList searchResp = (SolrDocumentList) fullResp.get(\"response\");\n          resultCount += searchResp.getNumFound();\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(Map.Entry<String, int[]> entry : mergeFreqs.entrySet()) {\n          int[] freqs = entry.getValue();\n          Map map = new HashMap();\n          map.put(\"term\", entry.getKey());\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShards(zkHost, collection, streamContext))) {\n          NamedList fullResp = getTopTermsCall.get();\n          Map stResp = (Map)fullResp.get(\"significantTerms\");\n\n          List<String> terms = (List<String>)stResp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)stResp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)stResp.get(\"queryDocFreq\");\n          numDocs += (Integer)stResp.get(\"numDocs\");\n\n          SolrDocumentList searchResp = (SolrDocumentList) fullResp.get(\"response\");\n          resultCount += searchResp.getNumFound();\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(String term : mergeFreqs.keySet() ) {\n          int[] freqs = mergeFreqs.get(term);\n          Map map = new HashMap();\n          map.put(\"term\", term);\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"804a8d5358fe7b7563b85ee7838714d720b89272","date":1591624987,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShards(zkHost, collection, streamContext))) {\n          NamedList fullResp = getTopTermsCall.get();\n          Map stResp = (Map)fullResp.get(\"significantTerms\");\n\n          List<String> terms = (List<String>)stResp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)stResp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)stResp.get(\"queryDocFreq\");\n          numDocs += (Integer)stResp.get(\"numDocs\");\n\n          SolrDocumentList searchResp = (SolrDocumentList) fullResp.get(\"response\");\n          resultCount += searchResp.getNumFound();\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(Map.Entry<String, int[]> entry : mergeFreqs.entrySet()) {\n          int[] freqs = entry.getValue();\n          Map map = new HashMap();\n          map.put(\"term\", entry.getKey());\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        tuples.add(Tuple.EOF());\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShards(zkHost, collection, streamContext))) {\n          NamedList fullResp = getTopTermsCall.get();\n          Map stResp = (Map)fullResp.get(\"significantTerms\");\n\n          List<String> terms = (List<String>)stResp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)stResp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)stResp.get(\"queryDocFreq\");\n          numDocs += (Integer)stResp.get(\"numDocs\");\n\n          SolrDocumentList searchResp = (SolrDocumentList) fullResp.get(\"response\");\n          resultCount += searchResp.getNumFound();\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(Map.Entry<String, int[]> entry : mergeFreqs.entrySet()) {\n          int[] freqs = entry.getValue();\n          Map map = new HashMap();\n          map.put(\"term\", entry.getKey());\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75","date":1591744896,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (@SuppressWarnings({\"rawtypes\"})Future<NamedList> getTopTermsCall : callShards(getShards(zkHost, collection, streamContext))) {\n          @SuppressWarnings({\"rawtypes\"})\n          NamedList fullResp = getTopTermsCall.get();\n          @SuppressWarnings({\"rawtypes\"})\n          Map stResp = (Map)fullResp.get(\"significantTerms\");\n\n          List<String> terms = (List<String>)stResp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)stResp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)stResp.get(\"queryDocFreq\");\n          numDocs += (Integer)stResp.get(\"numDocs\");\n\n          SolrDocumentList searchResp = (SolrDocumentList) fullResp.get(\"response\");\n          resultCount += searchResp.getNumFound();\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\"})\n        List<Map> maps = new ArrayList<>();\n\n        for(Map.Entry<String, int[]> entry : mergeFreqs.entrySet()) {\n          int[] freqs = entry.getValue();\n          @SuppressWarnings({\"rawtypes\"})\n          Map map = new HashMap();\n          map.put(\"term\", entry.getKey());\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList<>();\n        for (@SuppressWarnings({\"rawtypes\"})Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        tuples.add(Tuple.EOF());\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShards(zkHost, collection, streamContext))) {\n          NamedList fullResp = getTopTermsCall.get();\n          Map stResp = (Map)fullResp.get(\"significantTerms\");\n\n          List<String> terms = (List<String>)stResp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)stResp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)stResp.get(\"queryDocFreq\");\n          numDocs += (Integer)stResp.get(\"numDocs\");\n\n          SolrDocumentList searchResp = (SolrDocumentList) fullResp.get(\"response\");\n          resultCount += searchResp.getNumFound();\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map> maps = new ArrayList();\n\n        for(Map.Entry<String, int[]> entry : mergeFreqs.entrySet()) {\n          int[] freqs = entry.getValue();\n          Map map = new HashMap();\n          map.put(\"term\", entry.getKey());\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList();\n        for (Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        tuples.add(Tuple.EOF());\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06eb5f96c63fb4bd8b194a33fd050326145d5070","date":1595538555,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SignificantTermsStream#read().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (@SuppressWarnings({\"rawtypes\"})Future<NamedList> getTopTermsCall : callShards(getShards(zkHost, collection, streamContext))) {\n          @SuppressWarnings({\"rawtypes\"})\n          NamedList fullResp = getTopTermsCall.get();\n          @SuppressWarnings({\"rawtypes\"})\n          Map stResp = (Map)fullResp.get(\"significantTerms\");\n\n          List<String> terms = (List<String>)stResp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)stResp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)stResp.get(\"queryDocFreq\");\n          numDocs += (Integer)stResp.get(\"numDocs\");\n\n          SolrDocumentList searchResp = (SolrDocumentList) fullResp.get(\"response\");\n          resultCount += searchResp.getNumFound();\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        List<Map<String, Object>> maps = new ArrayList<>();\n\n        for(Map.Entry<String, int[]> entry : mergeFreqs.entrySet()) {\n          int[] freqs = entry.getValue();\n          Map<String, Object> map = new HashMap<>();\n          map.put(\"term\", entry.getKey());\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList<>();\n        for (Map<String, Object> map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        tuples.add(Tuple.EOF());\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, int[]> mergeFreqs = new HashMap<>();\n        long numDocs = 0;\n        long resultCount = 0;\n        for (@SuppressWarnings({\"rawtypes\"})Future<NamedList> getTopTermsCall : callShards(getShards(zkHost, collection, streamContext))) {\n          @SuppressWarnings({\"rawtypes\"})\n          NamedList fullResp = getTopTermsCall.get();\n          @SuppressWarnings({\"rawtypes\"})\n          Map stResp = (Map)fullResp.get(\"significantTerms\");\n\n          List<String> terms = (List<String>)stResp.get(\"sterms\");\n          List<Integer> docFreqs = (List<Integer>)stResp.get(\"docFreq\");\n          List<Integer> queryDocFreqs = (List<Integer>)stResp.get(\"queryDocFreq\");\n          numDocs += (Integer)stResp.get(\"numDocs\");\n\n          SolrDocumentList searchResp = (SolrDocumentList) fullResp.get(\"response\");\n          resultCount += searchResp.getNumFound();\n\n          for (int i = 0; i < terms.size(); i++) {\n            String term = terms.get(i);\n            int docFreq = docFreqs.get(i);\n            int queryDocFreq = queryDocFreqs.get(i);\n            if(!mergeFreqs.containsKey(term)) {\n              mergeFreqs.put(term, new int[2]);\n            }\n\n            int[] freqs = mergeFreqs.get(term);\n            freqs[0] += docFreq;\n            freqs[1] += queryDocFreq;\n          }\n        }\n\n        @SuppressWarnings({\"rawtypes\"})\n        List<Map> maps = new ArrayList<>();\n\n        for(Map.Entry<String, int[]> entry : mergeFreqs.entrySet()) {\n          int[] freqs = entry.getValue();\n          @SuppressWarnings({\"rawtypes\"})\n          Map map = new HashMap();\n          map.put(\"term\", entry.getKey());\n          map.put(\"background\", freqs[0]);\n          map.put(\"foreground\", freqs[1]);\n\n          float score = (float)(Math.log(freqs[1])+1.0) * (float) (Math.log(((float)(numDocs + 1)) / (freqs[0] + 1)) + 1.0);\n\n          map.put(\"score\", score);\n          maps.add(map);\n        }\n\n        Collections.sort(maps, new ScoreComp());\n        List<Tuple> tuples = new ArrayList<>();\n        for (@SuppressWarnings({\"rawtypes\"})Map map : maps) {\n          if (tuples.size() == numTerms) break;\n          tuples.add(new Tuple(map));\n        }\n\n        tuples.add(Tuple.EOF());\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["3bfa0f7f6fca863376793e8c93f38bf996014a46"],"3e5922fb6b9f0e49b31ce0436420a7f4392031c4":["0083b99694eda9623bc01747fd55949a79af54fa"],"3bfa0f7f6fca863376793e8c93f38bf996014a46":["3e5922fb6b9f0e49b31ce0436420a7f4392031c4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06eb5f96c63fb4bd8b194a33fd050326145d5070":["2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75"],"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75":["804a8d5358fe7b7563b85ee7838714d720b89272"],"804a8d5358fe7b7563b85ee7838714d720b89272":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"],"f67c3a1123a063e580a2e6ec51b9eb7c273666ce":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06eb5f96c63fb4bd8b194a33fd050326145d5070"],"0083b99694eda9623bc01747fd55949a79af54fa":["f67c3a1123a063e580a2e6ec51b9eb7c273666ce"],"b0b597c65628ca9e73913a07e81691f8229bae35":["3bfa0f7f6fca863376793e8c93f38bf996014a46","7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"]},"commit2Childs":{"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["804a8d5358fe7b7563b85ee7838714d720b89272","b0b597c65628ca9e73913a07e81691f8229bae35"],"3e5922fb6b9f0e49b31ce0436420a7f4392031c4":["3bfa0f7f6fca863376793e8c93f38bf996014a46"],"3bfa0f7f6fca863376793e8c93f38bf996014a46":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f67c3a1123a063e580a2e6ec51b9eb7c273666ce"],"06eb5f96c63fb4bd8b194a33fd050326145d5070":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75":["06eb5f96c63fb4bd8b194a33fd050326145d5070"],"804a8d5358fe7b7563b85ee7838714d720b89272":["2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75"],"f67c3a1123a063e580a2e6ec51b9eb7c273666ce":["0083b99694eda9623bc01747fd55949a79af54fa"],"0083b99694eda9623bc01747fd55949a79af54fa":["3e5922fb6b9f0e49b31ce0436420a7f4392031c4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}