{"path":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletes#addNumericUpdate(NumericUpdate,int).mjava","commits":[{"id":"e072d0b1fc19e0533d8ce432eed245196bca6fde","date":1379265112,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletes#addNumericUpdate(NumericUpdate,int).mjava","pathOld":"/dev/null","sourceNew":"  public void addNumericUpdate(NumericUpdate update, int docIDUpto) {\n    Map<String,NumericUpdate> termUpdates = numericUpdates.get(update.term);\n    if (termUpdates == null) {\n      termUpdates = new HashMap<String,NumericUpdate>();\n      numericUpdates.put(update.term, termUpdates);\n      bytesUsed.addAndGet(BYTES_PER_NUMERIC_UPDATE_TERM_ENTRY);\n    }\n    final NumericUpdate current = termUpdates.get(update.field);\n    if (current != null && docIDUpto < current.docIDUpto) {\n      // Only record the new number if it's greater than or equal to the current\n      // one. This is important because if multiple threads are replacing the\n      // same doc at nearly the same time, it's possible that one thread that\n      // got a higher docID is scheduled before the other threads.\n      return;\n    }\n\n    update.docIDUpto = docIDUpto;\n    termUpdates.put(update.field, update);\n    numNumericUpdates.incrementAndGet();\n    if (current == null) {\n      bytesUsed.addAndGet(BYTES_PER_NUMERIC_UPDATE_ENTRY + update.sizeInBytes());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cff1deb788b9babb942b20707a93e1ab902ce37","date":1380805349,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletes#addNumericUpdate(NumericUpdate,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletes#addNumericUpdate(NumericUpdate,int).mjava","sourceNew":"  public void addNumericUpdate(NumericUpdate update, int docIDUpto) {\n    LinkedHashMap<Term,NumericUpdate> fieldUpdates = numericUpdates.get(update.field);\n    if (fieldUpdates == null) {\n      fieldUpdates = new LinkedHashMap<Term,NumericUpdate>();\n      numericUpdates.put(update.field, fieldUpdates);\n      bytesUsed.addAndGet(BYTES_PER_NUMERIC_FIELD_ENTRY);\n    }\n    final NumericUpdate current = fieldUpdates.get(update.term);\n    if (current != null && docIDUpto < current.docIDUpto) {\n      // Only record the new number if it's greater than or equal to the current\n      // one. This is important because if multiple threads are replacing the\n      // same doc at nearly the same time, it's possible that one thread that\n      // got a higher docID is scheduled before the other threads.\n      return;\n    }\n\n    update.docIDUpto = docIDUpto;\n    // since it's a LinkedHashMap, we must first remove the Term entry so that\n    // it's added last (we're interested in insertion-order).\n    if (current != null) {\n      fieldUpdates.remove(update.term);\n    }\n    fieldUpdates.put(update.term, update);\n    numNumericUpdates.incrementAndGet();\n    if (current == null) {\n      bytesUsed.addAndGet(BYTES_PER_NUMERIC_UPDATE_ENTRY + update.sizeInBytes());\n    }\n  }\n\n","sourceOld":"  public void addNumericUpdate(NumericUpdate update, int docIDUpto) {\n    Map<String,NumericUpdate> termUpdates = numericUpdates.get(update.term);\n    if (termUpdates == null) {\n      termUpdates = new HashMap<String,NumericUpdate>();\n      numericUpdates.put(update.term, termUpdates);\n      bytesUsed.addAndGet(BYTES_PER_NUMERIC_UPDATE_TERM_ENTRY);\n    }\n    final NumericUpdate current = termUpdates.get(update.field);\n    if (current != null && docIDUpto < current.docIDUpto) {\n      // Only record the new number if it's greater than or equal to the current\n      // one. This is important because if multiple threads are replacing the\n      // same doc at nearly the same time, it's possible that one thread that\n      // got a higher docID is scheduled before the other threads.\n      return;\n    }\n\n    update.docIDUpto = docIDUpto;\n    termUpdates.put(update.field, update);\n    numNumericUpdates.incrementAndGet();\n    if (current == null) {\n      bytesUsed.addAndGet(BYTES_PER_NUMERIC_UPDATE_ENTRY + update.sizeInBytes());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdates#addNumericUpdate(NumericUpdate,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletes#addNumericUpdate(NumericUpdate,int).mjava","sourceNew":"  public void addNumericUpdate(NumericUpdate update, int docIDUpto) {\n    LinkedHashMap<Term,NumericUpdate> fieldUpdates = numericUpdates.get(update.field);\n    if (fieldUpdates == null) {\n      fieldUpdates = new LinkedHashMap<Term,NumericUpdate>();\n      numericUpdates.put(update.field, fieldUpdates);\n      bytesUsed.addAndGet(BYTES_PER_NUMERIC_FIELD_ENTRY);\n    }\n    final NumericUpdate current = fieldUpdates.get(update.term);\n    if (current != null && docIDUpto < current.docIDUpto) {\n      // Only record the new number if it's greater than or equal to the current\n      // one. This is important because if multiple threads are replacing the\n      // same doc at nearly the same time, it's possible that one thread that\n      // got a higher docID is scheduled before the other threads.\n      return;\n    }\n\n    update.docIDUpto = docIDUpto;\n    // since it's a LinkedHashMap, we must first remove the Term entry so that\n    // it's added last (we're interested in insertion-order).\n    if (current != null) {\n      fieldUpdates.remove(update.term);\n    }\n    fieldUpdates.put(update.term, update);\n    numNumericUpdates.incrementAndGet();\n    if (current == null) {\n      bytesUsed.addAndGet(BYTES_PER_NUMERIC_UPDATE_ENTRY + update.sizeInBytes());\n    }\n  }\n\n","sourceOld":"  public void addNumericUpdate(NumericUpdate update, int docIDUpto) {\n    LinkedHashMap<Term,NumericUpdate> fieldUpdates = numericUpdates.get(update.field);\n    if (fieldUpdates == null) {\n      fieldUpdates = new LinkedHashMap<Term,NumericUpdate>();\n      numericUpdates.put(update.field, fieldUpdates);\n      bytesUsed.addAndGet(BYTES_PER_NUMERIC_FIELD_ENTRY);\n    }\n    final NumericUpdate current = fieldUpdates.get(update.term);\n    if (current != null && docIDUpto < current.docIDUpto) {\n      // Only record the new number if it's greater than or equal to the current\n      // one. This is important because if multiple threads are replacing the\n      // same doc at nearly the same time, it's possible that one thread that\n      // got a higher docID is scheduled before the other threads.\n      return;\n    }\n\n    update.docIDUpto = docIDUpto;\n    // since it's a LinkedHashMap, we must first remove the Term entry so that\n    // it's added last (we're interested in insertion-order).\n    if (current != null) {\n      fieldUpdates.remove(update.term);\n    }\n    fieldUpdates.put(update.term, update);\n    numNumericUpdates.incrementAndGet();\n    if (current == null) {\n      bytesUsed.addAndGet(BYTES_PER_NUMERIC_UPDATE_ENTRY + update.sizeInBytes());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e072d0b1fc19e0533d8ce432eed245196bca6fde":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1cff1deb788b9babb942b20707a93e1ab902ce37":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["1cff1deb788b9babb942b20707a93e1ab902ce37"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"]},"commit2Childs":{"e072d0b1fc19e0533d8ce432eed245196bca6fde":["1cff1deb788b9babb942b20707a93e1ab902ce37"],"1cff1deb788b9babb942b20707a93e1ab902ce37":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}