{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int,int,boolean).mjava","commits":[{"id":"0ba222c174ec1943d8d14d012d1d6e24a1cc4972","date":1351522220,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int,int,boolean).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int).mjava","sourceNew":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   * @param allowSepEdit if true, the token separater is allowed to be an edit (so words may be split/joined) (see default {@link #DEFAULT_ALLOW_SEP_EDIT})\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        int maxEdits, boolean transpositions, int nonFuzzyPrefix,\n                        int minFuzzyLength, boolean allowSepEdit) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n    this.allowSepEdit = allowSepEdit;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   *   \n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE}.\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param minPrefix length of common (non-fuzzy) prefix\n   *          \n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n      int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions, int maxEdits, boolean transpositions, int minPrefix) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (minPrefix < 0) {\n      throw new IllegalArgumentException(\"minPrefix must not be < 0\");\n    }\n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.minPrefix = minPrefix;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31b5edc7f41e0c481513ce8881696e3e042ff493","date":1351528983,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int,int).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int,int,boolean).mjava","sourceNew":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        int maxEdits, boolean transpositions, int nonFuzzyPrefix,\n                        int minFuzzyLength) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   * @param allowSepEdit if true, the token separater is allowed to be an edit (so words may be split/joined) (see default {@link #DEFAULT_ALLOW_SEP_EDIT})\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        int maxEdits, boolean transpositions, int nonFuzzyPrefix,\n                        int minFuzzyLength, boolean allowSepEdit) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n    this.allowSepEdit = allowSepEdit;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6","date":1374158194,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int,int,boolean).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int,int).mjava","sourceNew":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   * @param unicodeAware operate Unicode code points instead of bytes.\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        int maxEdits, boolean transpositions, int nonFuzzyPrefix,\n                        int minFuzzyLength, boolean unicodeAware) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n    this.unicodeAware = unicodeAware;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        int maxEdits, boolean transpositions, int nonFuzzyPrefix,\n                        int minFuzzyLength) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":1,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int,int,boolean).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int,int).mjava","sourceNew":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   * @param unicodeAware operate Unicode code points instead of bytes.\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        int maxEdits, boolean transpositions, int nonFuzzyPrefix,\n                        int minFuzzyLength, boolean unicodeAware) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n    this.unicodeAware = unicodeAware;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        int maxEdits, boolean transpositions, int nonFuzzyPrefix,\n                        int minFuzzyLength) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4e0095ef720d1b8e7406847147af69f19af3ab6","date":1383131477,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,boolean,int,boolean,int,int,boolean).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FuzzySuggester#FuzzySuggester(Analyzer,Analyzer,int,int,int,int,boolean,int,int,boolean).mjava","sourceNew":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param preservePositionIncrements Whether position holes should appear in the automaton\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   * @param unicodeAware operate Unicode code points instead of bytes.\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        boolean preservePositionIncrements, int maxEdits, boolean transpositions,\n                        int nonFuzzyPrefix, int minFuzzyLength, boolean unicodeAware) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions, preservePositionIncrements);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n    this.unicodeAware = unicodeAware;\n  }\n\n","sourceOld":"  /**\n   * Creates a {@link FuzzySuggester} instance.\n   * \n   * @param indexAnalyzer Analyzer that will be used for\n   *        analyzing suggestions while building the index.\n   * @param queryAnalyzer Analyzer that will be used for\n   *        analyzing query text during lookup\n   * @param options see {@link #EXACT_FIRST}, {@link #PRESERVE_SEP}\n   * @param maxSurfaceFormsPerAnalyzedForm Maximum number of\n   *        surface forms to keep for a single analyzed form.\n   *        When there are too many surface forms we discard the\n   *        lowest weighted ones.\n   * @param maxGraphExpansions Maximum number of graph paths\n   *        to expand from the analyzed form.  Set this to -1 for\n   *        no limit.\n   * @param maxEdits must be >= 0 and <= {@link LevenshteinAutomata#MAXIMUM_SUPPORTED_DISTANCE} .\n   * @param transpositions <code>true</code> if transpositions should be treated as a primitive \n   *        edit operation. If this is false, comparisons will implement the classic\n   *        Levenshtein algorithm.\n   * @param nonFuzzyPrefix length of common (non-fuzzy) prefix (see default {@link #DEFAULT_NON_FUZZY_PREFIX}\n   * @param minFuzzyLength minimum length of lookup key before any edits are allowed (see default {@link #DEFAULT_MIN_FUZZY_LENGTH})\n   * @param unicodeAware operate Unicode code points instead of bytes.\n   */\n  public FuzzySuggester(Analyzer indexAnalyzer, Analyzer queryAnalyzer,\n                        int options, int maxSurfaceFormsPerAnalyzedForm, int maxGraphExpansions,\n                        int maxEdits, boolean transpositions, int nonFuzzyPrefix,\n                        int minFuzzyLength, boolean unicodeAware) {\n    super(indexAnalyzer, queryAnalyzer, options, maxSurfaceFormsPerAnalyzedForm, maxGraphExpansions);\n    if (maxEdits < 0 || maxEdits > LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE) {\n      throw new IllegalArgumentException(\"maxEdits must be between 0 and \" + LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE);\n    }\n    if (nonFuzzyPrefix < 0) {\n      throw new IllegalArgumentException(\"nonFuzzyPrefix must not be >= 0 (got \" + nonFuzzyPrefix + \")\");\n    }\n    if (minFuzzyLength < 0) {\n      throw new IllegalArgumentException(\"minFuzzyLength must not be >= 0 (got \" + minFuzzyLength + \")\");\n    }\n    \n    this.maxEdits = maxEdits;\n    this.transpositions = transpositions;\n    this.nonFuzzyPrefix = nonFuzzyPrefix;\n    this.minFuzzyLength = minFuzzyLength;\n    this.unicodeAware = unicodeAware;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0ba222c174ec1943d8d14d012d1d6e24a1cc4972":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"31b5edc7f41e0c481513ce8881696e3e042ff493":["0ba222c174ec1943d8d14d012d1d6e24a1cc4972"],"d4e0095ef720d1b8e7406847147af69f19af3ab6":["2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4e0095ef720d1b8e7406847147af69f19af3ab6"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ba222c174ec1943d8d14d012d1d6e24a1cc4972","2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"0ba222c174ec1943d8d14d012d1d6e24a1cc4972":["31b5edc7f41e0c481513ce8881696e3e042ff493"],"2efd1b8e67185b5bb2dbdfa435b9f085a0c659f6":["d4e0095ef720d1b8e7406847147af69f19af3ab6"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"31b5edc7f41e0c481513ce8881696e3e042ff493":[],"d4e0095ef720d1b8e7406847147af69f19af3ab6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","31b5edc7f41e0c481513ce8881696e3e042ff493","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}