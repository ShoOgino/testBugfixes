{"path":"sandbox/contributions/webcrawler-LARM/src/HTTPClient/HTTPConnection#assembleHeaders(Request,ByteArrayOutputStream).mjava","commits":[{"id":"05d36e0b328ec96237035fbcca240e73631396e5","date":1020520725,"type":0,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/src/HTTPClient/HTTPConnection#assembleHeaders(Request,ByteArrayOutputStream).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * This writes out the headers on the <var>hdr_buf</var> . It takes special\n     * precautions for the following headers: <DL> <DT>Content-type<DI>This is\n     * only written if the request has an entity. If the request has an entity\n     * and no content-type header was given for the request it defaults to\n     * \"application/octet-stream\" <DT>Content-length<DI>This header is generated\n     * if the request has an entity and the entity isn't being sent with the\n     * Transfer-Encoding \"chunked\". <DT>User-Agent <DI>If not present it will be\n     * generated with the current HTTPClient version strings. Otherwise the\n     * version string is appended to the given User-Agent string. <DT>Connection\n     * <DI>This header is only written if no proxy is used. If no connection\n     * header is specified and the server is not known to understand HTTP/1.1 or\n     * later then a \"Connection: keep-alive\" header is generated. <DT>\n     * Proxy-Connection<DI>This header is only written if a proxy is used. If no\n     * connection header is specified and the proxy is not known to understand\n     * HTTP/1.1 or later then a \"Proxy-Connection: keep-alive\" header is\n     * generated. <DT>Keep-Alive <DI>This header is only written if the\n     * Connection or Proxy-Connection header contains the Keep-Alive token. <DT>\n     * Expect <DI>If there is no entity and this header contains the\n     * \"100-continue\" token then this token is removed. before writing the\n     * header. <DT>TE <DI>If this header does not exist, it is created; else if\n     * the \"trailers\" token is not specified this token is added; else the\n     * header is not touched. </DL> Furthermore, it escapes various characters\n     * in request-URI.\n     *\n     * @param req              the Request\n     * @param hdr_buf          the buffer onto which to write the headers\n     * @return                 an array of headers; the first element contains\n     *      the the value of the Connection or Proxy-Connectin header, the\n     *      second element the value of the Expect header.\n     * @exception IOException  if writing on <var>hdr_buf</var> generates an an\n     *      IOException, or if an error occurs during parsing of a header\n     */\n    private String[] assembleHeaders(Request req,\n            ByteArrayOutputStream hdr_buf)\n        throws IOException\n    {\n        DataOutputStream dataout = new DataOutputStream(hdr_buf);\n        String[] con_hdrs = {\"\", \"\"};\n        NVPair[] hdrs = req.getHeaders();\n\n        // remember various headers\n\n        int ho_idx = -1;\n\n        // remember various headers\n\n        int\n                ct_idx = -1;\n\n        // remember various headers\n\n        int\n                ua_idx = -1;\n\n        // remember various headers\n\n        int\n                co_idx = -1;\n\n        // remember various headers\n\n        int\n                pc_idx = -1;\n\n        // remember various headers\n\n        int\n                ka_idx = -1;\n\n        // remember various headers\n\n        int\n                ex_idx = -1;\n\n        // remember various headers\n\n        int\n                te_idx = -1;\n\n        // remember various headers\n\n        int\n                tc_idx = -1;\n\n        // remember various headers\n\n        int\n                ug_idx = -1;\n        for (int idx = 0; idx < hdrs.length; idx++)\n        {\n            String name = hdrs[idx].getName().trim().toLowerCase();\n            if (name.equals(\"host\"))\n            {\n                ho_idx = idx;\n            }\n            else if (name.equals(\"content-type\"))\n            {\n                ct_idx = idx;\n            }\n            else if (name.equals(\"user-agent\"))\n            {\n                ua_idx = idx;\n            }\n            else if (name.equals(\"connection\"))\n            {\n                co_idx = idx;\n            }\n            else if (name.equals(\"proxy-connection\"))\n            {\n                pc_idx = idx;\n            }\n            else if (name.equals(\"keep-alive\"))\n            {\n                ka_idx = idx;\n            }\n            else if (name.equals(\"expect\"))\n            {\n                ex_idx = idx;\n            }\n            else if (name.equals(\"te\"))\n            {\n                te_idx = idx;\n            }\n            else if (name.equals(\"transfer-encoding\"))\n            {\n                tc_idx = idx;\n            }\n            else if (name.equals(\"upgrade\"))\n            {\n                ug_idx = idx;\n            }\n        }\n\n        // Generate request line and Host header\n\n        String file = Util.escapeUnsafeChars(req.getRequestURI());\n        if (Proxy_Host != null && Protocol != HTTPS && !file.equals(\"*\"))\n        {\n            dataout.writeBytes(req.getMethod() + \" http://\" + Host + \":\" + Port +\n                    file + \" \" + RequestProtocolVersion + \"\\r\\n\");\n        }\n        else\n        {\n            dataout.writeBytes(req.getMethod() + \" \" + file + \" \" +\n                    RequestProtocolVersion + \"\\r\\n\");\n        }\n\n        String h_hdr = (ho_idx >= 0) ? hdrs[ho_idx].getValue().trim() : Host;\n        if (Port != URI.defaultPort(getProtocol()))\n        {\n            dataout.writeBytes(\"Host: \" + h_hdr + \":\" + Port + \"\\r\\n\");\n        }\n        else\n        {\n            // Netscape-Enterprise has some bugs...\n            dataout.writeBytes(\"Host: \" + h_hdr + \"\\r\\n\");\n        }\n\n        /*\n         *  What follows is the setup for persistent connections. We default\n         *  to doing persistent connections for both HTTP/1.0 and HTTP/1.1,\n         *  unless we're using a proxy server and HTTP/1.0 in which case we\n         *  must make sure we don't do persistence (because of the problem of\n         *  1.0 proxies blindly passing the Connection header on).\n         *\n         *  Note: there is a \"Proxy-Connection\" header for use with proxies.\n         *  This however is only understood by Netscape and Netapp caches.\n         *  Furthermore, it suffers from the same problem as the Connection\n         *  header in HTTP/1.0 except that at least two proxies must be\n         *  involved. But I've taken the risk now and decided to send the\n         *  Proxy-Connection header. If I get complaints I'll remove it again.\n         *\n         *  In any case, with this header we can now modify the above to send\n         *  the Proxy-Connection header whenever we wouldn't send the normal\n         *  Connection header.\n         */\n        String co_hdr = null;\n        if (!(ServProtVersKnown && ServerProtocolVersion >= HTTP_1_1 &&\n                co_idx == -1))\n        {\n            if (co_idx == -1)\n            {\n                // no connection header given by user\n                co_hdr = \"Keep-Alive\";\n                con_hdrs[0] = \"Keep-Alive\";\n            }\n            else\n            {\n                con_hdrs[0] = hdrs[co_idx].getValue().trim();\n                co_hdr = con_hdrs[0];\n            }\n\n            try\n            {\n                if (ka_idx != -1 &&\n                        Util.hasToken(con_hdrs[0], \"keep-alive\"))\n                {\n                    dataout.writeBytes(\"Keep-Alive: \" +\n                            hdrs[ka_idx].getValue().trim() + \"\\r\\n\");\n                }\n            }\n            catch (ParseException pe)\n            {\n                throw new IOException(pe.toString());\n            }\n        }\n\n        if ((Proxy_Host != null && Protocol != HTTPS) &&\n                !(ServProtVersKnown && ServerProtocolVersion >= HTTP_1_1))\n        {\n            if (co_hdr != null)\n            {\n                dataout.writeBytes(\"Proxy-Connection: \");\n                dataout.writeBytes(co_hdr);\n                dataout.writeBytes(\"\\r\\n\");\n                co_hdr = null;\n            }\n        }\n\n        if (co_hdr != null)\n        {\n            try\n            {\n                if (!Util.hasToken(co_hdr, \"TE\"))\n                {\n                    co_hdr += \", TE\";\n                }\n            }\n            catch (ParseException pe)\n            {\n                throw new IOException(pe.toString());\n            }\n        }\n        else\n        {\n            co_hdr = \"TE\";\n        }\n\n        if (ug_idx != -1)\n        {\n            co_hdr += \", Upgrade\";\n        }\n\n        if (co_hdr != null)\n        {\n            dataout.writeBytes(\"Connection: \");\n            dataout.writeBytes(co_hdr);\n            dataout.writeBytes(\"\\r\\n\");\n        }\n\n        // handle TE header\n\n        if (te_idx != -1)\n        {\n            dataout.writeBytes(\"TE: \");\n            Vector pte;\n            try\n            {\n                pte = Util.parseHeader(hdrs[te_idx].getValue());\n            }\n            catch (ParseException pe)\n            {\n                throw new IOException(pe.toString());\n            }\n\n            if (!pte.contains(new HttpHeaderElement(\"trailers\")))\n            {\n                dataout.writeBytes(\"trailers, \");\n            }\n\n            dataout.writeBytes(hdrs[te_idx].getValue().trim() + \"\\r\\n\");\n        }\n        else\n        {\n            dataout.writeBytes(\"TE: trailers\\r\\n\");\n        }\n\n        // User-Agent\n\n        if (ua_idx != -1)\n        {\n            dataout.writeBytes(\"User-Agent: \" + hdrs[ua_idx].getValue().trim() + \"\\r\\n\");\n        }\n        else\n        {\n            dataout.writeBytes(\"User-Agent: \" + version + \"\\r\\n\");\n        }\n\n        // Write out any headers left\n\n        for (int idx = 0; idx < hdrs.length; idx++)\n        {\n            if (idx != ct_idx && idx != ua_idx && idx != co_idx &&\n                    idx != pc_idx && idx != ka_idx && idx != ex_idx &&\n                    idx != te_idx && idx != ho_idx)\n            {\n                dataout.writeBytes(hdrs[idx].getName().trim() + \": \" +\n                        hdrs[idx].getValue().trim() + \"\\r\\n\");\n            }\n        }\n\n        // Handle Content-type, Content-length and Expect headers\n\n        if (req.getData() != null || req.getStream() != null)\n        {\n            dataout.writeBytes(\"Content-type: \");\n            if (ct_idx != -1)\n            {\n                dataout.writeBytes(hdrs[ct_idx].getValue().trim());\n            }\n            else\n            {\n                dataout.writeBytes(\"application/octet-stream\");\n            }\n            dataout.writeBytes(\"\\r\\n\");\n\n            if (req.getData() != null)\n            {\n                dataout.writeBytes(\"Content-length: \" + req.getData().length +\n                        \"\\r\\n\");\n            }\n            else if (req.getStream().getLength() != -1 && tc_idx == -1)\n            {\n                dataout.writeBytes(\"Content-length: \" +\n                        req.getStream().getLength() + \"\\r\\n\");\n            }\n\n            if (ex_idx != -1)\n            {\n                con_hdrs[1] = hdrs[ex_idx].getValue().trim();\n                dataout.writeBytes(\"Expect: \" + con_hdrs[1] + \"\\r\\n\");\n            }\n        }\n        else if (ex_idx != -1)\n        {\n            Vector expect_tokens;\n            try\n            {\n                expect_tokens = Util.parseHeader(hdrs[ex_idx].getValue());\n            }\n            catch (ParseException pe)\n            {\n                throw new IOException(pe.toString());\n            }\n\n            // remove any 100-continue tokens\n\n            HttpHeaderElement cont = new HttpHeaderElement(\"100-continue\");\n            while (expect_tokens.removeElement(cont))\n            {\n                ;\n            }\n\n            // write out header if any tokens left\n\n            if (!expect_tokens.isEmpty())\n            {\n                con_hdrs[1] = Util.assembleHeader(expect_tokens);\n                dataout.writeBytes(\"Expect: \" + con_hdrs[1] + \"\\r\\n\");\n            }\n        }\n\n        dataout.writeBytes(\"\\r\\n\");\n        // end of header\n\n        return con_hdrs;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"afc16d717d9ed1a8e45371668ca6de674164d624","date":1103345442,"type":4,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"/dev/null","pathOld":"sandbox/contributions/webcrawler-LARM/src/HTTPClient/HTTPConnection#assembleHeaders(Request,ByteArrayOutputStream).mjava","sourceNew":null,"sourceOld":"    /**\n     * This writes out the headers on the <var>hdr_buf</var> . It takes special\n     * precautions for the following headers: <DL> <DT>Content-type<DI>This is\n     * only written if the request has an entity. If the request has an entity\n     * and no content-type header was given for the request it defaults to\n     * \"application/octet-stream\" <DT>Content-length<DI>This header is generated\n     * if the request has an entity and the entity isn't being sent with the\n     * Transfer-Encoding \"chunked\". <DT>User-Agent <DI>If not present it will be\n     * generated with the current HTTPClient version strings. Otherwise the\n     * version string is appended to the given User-Agent string. <DT>Connection\n     * <DI>This header is only written if no proxy is used. If no connection\n     * header is specified and the server is not known to understand HTTP/1.1 or\n     * later then a \"Connection: keep-alive\" header is generated. <DT>\n     * Proxy-Connection<DI>This header is only written if a proxy is used. If no\n     * connection header is specified and the proxy is not known to understand\n     * HTTP/1.1 or later then a \"Proxy-Connection: keep-alive\" header is\n     * generated. <DT>Keep-Alive <DI>This header is only written if the\n     * Connection or Proxy-Connection header contains the Keep-Alive token. <DT>\n     * Expect <DI>If there is no entity and this header contains the\n     * \"100-continue\" token then this token is removed. before writing the\n     * header. <DT>TE <DI>If this header does not exist, it is created; else if\n     * the \"trailers\" token is not specified this token is added; else the\n     * header is not touched. </DL> Furthermore, it escapes various characters\n     * in request-URI.\n     *\n     * @param req              the Request\n     * @param hdr_buf          the buffer onto which to write the headers\n     * @return                 an array of headers; the first element contains\n     *      the the value of the Connection or Proxy-Connectin header, the\n     *      second element the value of the Expect header.\n     * @exception IOException  if writing on <var>hdr_buf</var> generates an an\n     *      IOException, or if an error occurs during parsing of a header\n     */\n    private String[] assembleHeaders(Request req,\n            ByteArrayOutputStream hdr_buf)\n        throws IOException\n    {\n        DataOutputStream dataout = new DataOutputStream(hdr_buf);\n        String[] con_hdrs = {\"\", \"\"};\n        NVPair[] hdrs = req.getHeaders();\n\n        // remember various headers\n\n        int ho_idx = -1;\n\n        // remember various headers\n\n        int\n                ct_idx = -1;\n\n        // remember various headers\n\n        int\n                ua_idx = -1;\n\n        // remember various headers\n\n        int\n                co_idx = -1;\n\n        // remember various headers\n\n        int\n                pc_idx = -1;\n\n        // remember various headers\n\n        int\n                ka_idx = -1;\n\n        // remember various headers\n\n        int\n                ex_idx = -1;\n\n        // remember various headers\n\n        int\n                te_idx = -1;\n\n        // remember various headers\n\n        int\n                tc_idx = -1;\n\n        // remember various headers\n\n        int\n                ug_idx = -1;\n        for (int idx = 0; idx < hdrs.length; idx++)\n        {\n            String name = hdrs[idx].getName().trim().toLowerCase();\n            if (name.equals(\"host\"))\n            {\n                ho_idx = idx;\n            }\n            else if (name.equals(\"content-type\"))\n            {\n                ct_idx = idx;\n            }\n            else if (name.equals(\"user-agent\"))\n            {\n                ua_idx = idx;\n            }\n            else if (name.equals(\"connection\"))\n            {\n                co_idx = idx;\n            }\n            else if (name.equals(\"proxy-connection\"))\n            {\n                pc_idx = idx;\n            }\n            else if (name.equals(\"keep-alive\"))\n            {\n                ka_idx = idx;\n            }\n            else if (name.equals(\"expect\"))\n            {\n                ex_idx = idx;\n            }\n            else if (name.equals(\"te\"))\n            {\n                te_idx = idx;\n            }\n            else if (name.equals(\"transfer-encoding\"))\n            {\n                tc_idx = idx;\n            }\n            else if (name.equals(\"upgrade\"))\n            {\n                ug_idx = idx;\n            }\n        }\n\n        // Generate request line and Host header\n\n        String file = Util.escapeUnsafeChars(req.getRequestURI());\n        if (Proxy_Host != null && Protocol != HTTPS && !file.equals(\"*\"))\n        {\n            dataout.writeBytes(req.getMethod() + \" http://\" + Host + \":\" + Port +\n                    file + \" \" + RequestProtocolVersion + \"\\r\\n\");\n        }\n        else\n        {\n            dataout.writeBytes(req.getMethod() + \" \" + file + \" \" +\n                    RequestProtocolVersion + \"\\r\\n\");\n        }\n\n        String h_hdr = (ho_idx >= 0) ? hdrs[ho_idx].getValue().trim() : Host;\n        if (Port != URI.defaultPort(getProtocol()))\n        {\n            dataout.writeBytes(\"Host: \" + h_hdr + \":\" + Port + \"\\r\\n\");\n        }\n        else\n        {\n            // Netscape-Enterprise has some bugs...\n            dataout.writeBytes(\"Host: \" + h_hdr + \"\\r\\n\");\n        }\n\n        /*\n         *  What follows is the setup for persistent connections. We default\n         *  to doing persistent connections for both HTTP/1.0 and HTTP/1.1,\n         *  unless we're using a proxy server and HTTP/1.0 in which case we\n         *  must make sure we don't do persistence (because of the problem of\n         *  1.0 proxies blindly passing the Connection header on).\n         *\n         *  Note: there is a \"Proxy-Connection\" header for use with proxies.\n         *  This however is only understood by Netscape and Netapp caches.\n         *  Furthermore, it suffers from the same problem as the Connection\n         *  header in HTTP/1.0 except that at least two proxies must be\n         *  involved. But I've taken the risk now and decided to send the\n         *  Proxy-Connection header. If I get complaints I'll remove it again.\n         *\n         *  In any case, with this header we can now modify the above to send\n         *  the Proxy-Connection header whenever we wouldn't send the normal\n         *  Connection header.\n         */\n        String co_hdr = null;\n        if (!(ServProtVersKnown && ServerProtocolVersion >= HTTP_1_1 &&\n                co_idx == -1))\n        {\n            if (co_idx == -1)\n            {\n                // no connection header given by user\n                co_hdr = \"Keep-Alive\";\n                con_hdrs[0] = \"Keep-Alive\";\n            }\n            else\n            {\n                con_hdrs[0] = hdrs[co_idx].getValue().trim();\n                co_hdr = con_hdrs[0];\n            }\n\n            try\n            {\n                if (ka_idx != -1 &&\n                        Util.hasToken(con_hdrs[0], \"keep-alive\"))\n                {\n                    dataout.writeBytes(\"Keep-Alive: \" +\n                            hdrs[ka_idx].getValue().trim() + \"\\r\\n\");\n                }\n            }\n            catch (ParseException pe)\n            {\n                throw new IOException(pe.toString());\n            }\n        }\n\n        if ((Proxy_Host != null && Protocol != HTTPS) &&\n                !(ServProtVersKnown && ServerProtocolVersion >= HTTP_1_1))\n        {\n            if (co_hdr != null)\n            {\n                dataout.writeBytes(\"Proxy-Connection: \");\n                dataout.writeBytes(co_hdr);\n                dataout.writeBytes(\"\\r\\n\");\n                co_hdr = null;\n            }\n        }\n\n        if (co_hdr != null)\n        {\n            try\n            {\n                if (!Util.hasToken(co_hdr, \"TE\"))\n                {\n                    co_hdr += \", TE\";\n                }\n            }\n            catch (ParseException pe)\n            {\n                throw new IOException(pe.toString());\n            }\n        }\n        else\n        {\n            co_hdr = \"TE\";\n        }\n\n        if (ug_idx != -1)\n        {\n            co_hdr += \", Upgrade\";\n        }\n\n        if (co_hdr != null)\n        {\n            dataout.writeBytes(\"Connection: \");\n            dataout.writeBytes(co_hdr);\n            dataout.writeBytes(\"\\r\\n\");\n        }\n\n        // handle TE header\n\n        if (te_idx != -1)\n        {\n            dataout.writeBytes(\"TE: \");\n            Vector pte;\n            try\n            {\n                pte = Util.parseHeader(hdrs[te_idx].getValue());\n            }\n            catch (ParseException pe)\n            {\n                throw new IOException(pe.toString());\n            }\n\n            if (!pte.contains(new HttpHeaderElement(\"trailers\")))\n            {\n                dataout.writeBytes(\"trailers, \");\n            }\n\n            dataout.writeBytes(hdrs[te_idx].getValue().trim() + \"\\r\\n\");\n        }\n        else\n        {\n            dataout.writeBytes(\"TE: trailers\\r\\n\");\n        }\n\n        // User-Agent\n\n        if (ua_idx != -1)\n        {\n            dataout.writeBytes(\"User-Agent: \" + hdrs[ua_idx].getValue().trim() + \"\\r\\n\");\n        }\n        else\n        {\n            dataout.writeBytes(\"User-Agent: \" + version + \"\\r\\n\");\n        }\n\n        // Write out any headers left\n\n        for (int idx = 0; idx < hdrs.length; idx++)\n        {\n            if (idx != ct_idx && idx != ua_idx && idx != co_idx &&\n                    idx != pc_idx && idx != ka_idx && idx != ex_idx &&\n                    idx != te_idx && idx != ho_idx)\n            {\n                dataout.writeBytes(hdrs[idx].getName().trim() + \": \" +\n                        hdrs[idx].getValue().trim() + \"\\r\\n\");\n            }\n        }\n\n        // Handle Content-type, Content-length and Expect headers\n\n        if (req.getData() != null || req.getStream() != null)\n        {\n            dataout.writeBytes(\"Content-type: \");\n            if (ct_idx != -1)\n            {\n                dataout.writeBytes(hdrs[ct_idx].getValue().trim());\n            }\n            else\n            {\n                dataout.writeBytes(\"application/octet-stream\");\n            }\n            dataout.writeBytes(\"\\r\\n\");\n\n            if (req.getData() != null)\n            {\n                dataout.writeBytes(\"Content-length: \" + req.getData().length +\n                        \"\\r\\n\");\n            }\n            else if (req.getStream().getLength() != -1 && tc_idx == -1)\n            {\n                dataout.writeBytes(\"Content-length: \" +\n                        req.getStream().getLength() + \"\\r\\n\");\n            }\n\n            if (ex_idx != -1)\n            {\n                con_hdrs[1] = hdrs[ex_idx].getValue().trim();\n                dataout.writeBytes(\"Expect: \" + con_hdrs[1] + \"\\r\\n\");\n            }\n        }\n        else if (ex_idx != -1)\n        {\n            Vector expect_tokens;\n            try\n            {\n                expect_tokens = Util.parseHeader(hdrs[ex_idx].getValue());\n            }\n            catch (ParseException pe)\n            {\n                throw new IOException(pe.toString());\n            }\n\n            // remove any 100-continue tokens\n\n            HttpHeaderElement cont = new HttpHeaderElement(\"100-continue\");\n            while (expect_tokens.removeElement(cont))\n            {\n                ;\n            }\n\n            // write out header if any tokens left\n\n            if (!expect_tokens.isEmpty())\n            {\n                con_hdrs[1] = Util.assembleHeader(expect_tokens);\n                dataout.writeBytes(\"Expect: \" + con_hdrs[1] + \"\\r\\n\");\n            }\n        }\n\n        dataout.writeBytes(\"\\r\\n\");\n        // end of header\n\n        return con_hdrs;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"afc16d717d9ed1a8e45371668ca6de674164d624":["05d36e0b328ec96237035fbcca240e73631396e5"],"05d36e0b328ec96237035fbcca240e73631396e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["afc16d717d9ed1a8e45371668ca6de674164d624"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["05d36e0b328ec96237035fbcca240e73631396e5"],"afc16d717d9ed1a8e45371668ca6de674164d624":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"05d36e0b328ec96237035fbcca240e73631396e5":["afc16d717d9ed1a8e45371668ca6de674164d624"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}