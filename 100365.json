{"path":"solr/core/src/test/org/apache/solr/schema/TestPointFields#[T-extends-Comparable[T]]_doTestPointFieldSort(String,List[T]).mjava","commits":[{"id":"b89c0b1a887eabf9facdf2c5d2df5e284c6d6daa","date":1496877670,"type":1,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestPointFields#[T-extends-Comparable[T]]_doTestPointFieldSort(String,List[T]).mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestPointFields#doTestPointFieldSort(String,String...).mjava","sourceNew":"  /**\n   * For each value, creates a doc with that value in the specified field and then asserts that\n   * asc/desc sorts on that field succeeds and that the docs are in the (relatively) expected order\n   *\n   * @param field name of field to sort on\n   * @param values list of values in ascending order\n   */\n  private <T extends Comparable<T>> void doTestPointFieldSort(String field, List<T> values) throws Exception {\n    assert values != null && 2 <= values.size();\n \n    final List<SolrInputDocument> docs = new ArrayList<>(values.size());\n    final String[] ascXpathChecks = new String[values.size() + 1];\n    final String[] descXpathChecks = new String[values.size() + 1];\n    ascXpathChecks[values.size()] = \"//*[@numFound='\" + values.size() + \"']\";\n    descXpathChecks[values.size()] = \"//*[@numFound='\" + values.size() + \"']\";\n    \n    boolean missingFirst = field.endsWith(\"_sml\") == false;\n    \n    List<PosVal<T>> ascendingPosVals = toAscendingPosVals(values, missingFirst);\n    for (int i = ascendingPosVals.size() - 1 ; i >= 0 ; --i) {\n      T value = ascendingPosVals.get(i).val;\n      if (value == null) {\n        docs.add(sdoc(\"id\", String.valueOf(i))); // null => missing value\n      } else {\n        docs.add(sdoc(\"id\", String.valueOf(i), field, String.valueOf(value)));\n      }\n      // reminder: xpath array indexes start at 1\n      ascXpathChecks[i]= \"//result/doc[\"+ (1 + i)+\"]/str[@name='id'][.='\"+i+\"']\";\n    }\n    List<PosVal<T>> descendingPosVals = toDescendingPosVals\n        (ascendingPosVals.stream().map(pv->pv.val).collect(Collectors.toList()), missingFirst);\n    for (int i = descendingPosVals.size() - 1 ; i >= 0 ; --i) {\n      descXpathChecks[i]= \"//result/doc[\" + (i + 1) + \"]/str[@name='id'][.='\" + descendingPosVals.get(i).pos + \"']\";\n    }\n    \n    // ensure doc add order doesn't affect results\n    Collections.shuffle(docs, random());\n    for (SolrInputDocument doc : docs) {\n      assertU(adoc(doc));\n    }\n    assertU(commit());\n\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id, \" + field, \"sort\", field + \" asc, id asc\"), \n            ascXpathChecks);\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id, \" + field, \"sort\", field + \" desc, id desc\"), \n            descXpathChecks);\n        \n    clearIndex();\n    assertU(commit());\n  }\n\n","sourceOld":"  /**\n   * For each value, creates a doc with that value in the specified field and then asserts that\n   * asc/desc sorts on that field succeeds and that the docs are in the (relatively) expected order\n   *\n   * @param field name of field to sort on\n   * @param values list of values in ascending order\n   */\n  private void doTestPointFieldSort(String field, String... values) throws Exception {\n    assert values != null && 2 <= values.length;\n\n    // TODO: need to add sort missing coverage...\n    //\n    // idea: accept \"null\" as possible value for sort missing tests ?\n    //\n    // need to account for possibility that multiple nulls will be in non deterministic order\n    // always using secondary sort on id seems prudent ... handles any \"dups\" in values[]\n    \n    final List<SolrInputDocument> docs = new ArrayList<>(values.length);\n    final String[] ascXpathChecks = new String[values.length + 1];\n    final String[] descXpathChecks = new String[values.length + 1];\n    ascXpathChecks[values.length] = \"//*[@numFound='\" + values.length + \"']\";\n    descXpathChecks[values.length] = \"//*[@numFound='\" + values.length + \"']\";\n    \n    for (int i = values.length-1; i >= 0; i--) {\n      docs.add(sdoc(\"id\", String.valueOf(i), field, String.valueOf(values[i])));\n      // reminder: xpath array indexes start at 1\n      ascXpathChecks[i]= \"//result/doc[\"+ (1 + i)+\"]/str[@name='id'][.='\"+i+\"']\";\n      descXpathChecks[i]= \"//result/doc[\"+ (values.length - i) +\"]/str[@name='id'][.='\"+i+\"']\";\n    }\n    \n    // ensure doc add order doesn't affect results\n    Collections.shuffle(docs, random());\n    for (SolrInputDocument doc : docs) {\n      assertU(adoc(doc));\n    }\n    assertU(commit());\n\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id\", \"sort\", field + \" asc\"), \n            ascXpathChecks);\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id\", \"sort\", field + \" desc\"), \n            descXpathChecks);\n\n        \n    clearIndex();\n    assertU(commit());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f344bb33ca91f48e99c061980115b46fa84fc8f5","date":1496903283,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestPointFields#[T-extends-Comparable[T]]_doTestPointFieldSort(String,List[T]).mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestPointFields#doTestPointFieldSort(String,String...).mjava","sourceNew":"  /**\n   * For each value, creates a doc with that value in the specified field and then asserts that\n   * asc/desc sorts on that field succeeds and that the docs are in the (relatively) expected order\n   *\n   * @param field name of field to sort on\n   * @param values list of values in ascending order\n   */\n  private <T extends Comparable<T>> void doTestPointFieldSort(String field, List<T> values) throws Exception {\n    assert values != null && 2 <= values.size();\n \n    final List<SolrInputDocument> docs = new ArrayList<>(values.size());\n    final String[] ascXpathChecks = new String[values.size() + 1];\n    final String[] descXpathChecks = new String[values.size() + 1];\n    ascXpathChecks[values.size()] = \"//*[@numFound='\" + values.size() + \"']\";\n    descXpathChecks[values.size()] = \"//*[@numFound='\" + values.size() + \"']\";\n    \n    boolean missingFirst = field.endsWith(\"_sml\") == false;\n    \n    List<PosVal<T>> ascendingPosVals = toAscendingPosVals(values, missingFirst);\n    for (int i = ascendingPosVals.size() - 1 ; i >= 0 ; --i) {\n      T value = ascendingPosVals.get(i).val;\n      if (value == null) {\n        docs.add(sdoc(\"id\", String.valueOf(i))); // null => missing value\n      } else {\n        docs.add(sdoc(\"id\", String.valueOf(i), field, String.valueOf(value)));\n      }\n      // reminder: xpath array indexes start at 1\n      ascXpathChecks[i]= \"//result/doc[\"+ (1 + i)+\"]/str[@name='id'][.='\"+i+\"']\";\n    }\n    List<PosVal<T>> descendingPosVals = toDescendingPosVals\n        (ascendingPosVals.stream().map(pv->pv.val).collect(Collectors.toList()), missingFirst);\n    for (int i = descendingPosVals.size() - 1 ; i >= 0 ; --i) {\n      descXpathChecks[i]= \"//result/doc[\" + (i + 1) + \"]/str[@name='id'][.='\" + descendingPosVals.get(i).pos + \"']\";\n    }\n    \n    // ensure doc add order doesn't affect results\n    Collections.shuffle(docs, random());\n    for (SolrInputDocument doc : docs) {\n      assertU(adoc(doc));\n    }\n    assertU(commit());\n\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id, \" + field, \"sort\", field + \" asc, id asc\"), \n            ascXpathChecks);\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id, \" + field, \"sort\", field + \" desc, id desc\"), \n            descXpathChecks);\n        \n    clearIndex();\n    assertU(commit());\n  }\n\n","sourceOld":"  /**\n   * For each value, creates a doc with that value in the specified field and then asserts that\n   * asc/desc sorts on that field succeeds and that the docs are in the (relatively) expected order\n   *\n   * @param field name of field to sort on\n   * @param values list of values in ascending order\n   */\n  private void doTestPointFieldSort(String field, String... values) throws Exception {\n    assert values != null && 2 <= values.length;\n\n    // TODO: need to add sort missing coverage...\n    //\n    // idea: accept \"null\" as possible value for sort missing tests ?\n    //\n    // need to account for possibility that multiple nulls will be in non deterministic order\n    // always using secondary sort on id seems prudent ... handles any \"dups\" in values[]\n    \n    final List<SolrInputDocument> docs = new ArrayList<>(values.length);\n    final String[] ascXpathChecks = new String[values.length + 1];\n    final String[] descXpathChecks = new String[values.length + 1];\n    ascXpathChecks[values.length] = \"//*[@numFound='\" + values.length + \"']\";\n    descXpathChecks[values.length] = \"//*[@numFound='\" + values.length + \"']\";\n    \n    for (int i = values.length-1; i >= 0; i--) {\n      docs.add(sdoc(\"id\", String.valueOf(i), field, String.valueOf(values[i])));\n      // reminder: xpath array indexes start at 1\n      ascXpathChecks[i]= \"//result/doc[\"+ (1 + i)+\"]/str[@name='id'][.='\"+i+\"']\";\n      descXpathChecks[i]= \"//result/doc[\"+ (values.length - i) +\"]/str[@name='id'][.='\"+i+\"']\";\n    }\n    \n    // ensure doc add order doesn't affect results\n    Collections.shuffle(docs, random());\n    for (SolrInputDocument doc : docs) {\n      assertU(adoc(doc));\n    }\n    assertU(commit());\n\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id\", \"sort\", field + \" asc\"), \n            ascXpathChecks);\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id\", \"sort\", field + \" desc\"), \n            descXpathChecks);\n\n        \n    clearIndex();\n    assertU(commit());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":1,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestPointFields#[T-extends-Comparable[T]]_doTestPointFieldSort(String,List[T]).mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestPointFields#doTestPointFieldSort(String,String...).mjava","sourceNew":"  /**\n   * For each value, creates a doc with that value in the specified field and then asserts that\n   * asc/desc sorts on that field succeeds and that the docs are in the (relatively) expected order\n   *\n   * @param field name of field to sort on\n   * @param values list of values in ascending order\n   */\n  private <T extends Comparable<T>> void doTestPointFieldSort(String field, List<T> values) throws Exception {\n    assert values != null && 2 <= values.size();\n \n    final List<SolrInputDocument> docs = new ArrayList<>(values.size());\n    final String[] ascXpathChecks = new String[values.size() + 1];\n    final String[] descXpathChecks = new String[values.size() + 1];\n    ascXpathChecks[values.size()] = \"//*[@numFound='\" + values.size() + \"']\";\n    descXpathChecks[values.size()] = \"//*[@numFound='\" + values.size() + \"']\";\n    \n    boolean missingFirst = field.endsWith(\"_sml\") == false;\n    \n    List<PosVal<T>> ascendingPosVals = toAscendingPosVals(values, missingFirst);\n    for (int i = ascendingPosVals.size() - 1 ; i >= 0 ; --i) {\n      T value = ascendingPosVals.get(i).val;\n      if (value == null) {\n        docs.add(sdoc(\"id\", String.valueOf(i))); // null => missing value\n      } else {\n        docs.add(sdoc(\"id\", String.valueOf(i), field, String.valueOf(value)));\n      }\n      // reminder: xpath array indexes start at 1\n      ascXpathChecks[i]= \"//result/doc[\"+ (1 + i)+\"]/str[@name='id'][.='\"+i+\"']\";\n    }\n    List<PosVal<T>> descendingPosVals = toDescendingPosVals\n        (ascendingPosVals.stream().map(pv->pv.val).collect(Collectors.toList()), missingFirst);\n    for (int i = descendingPosVals.size() - 1 ; i >= 0 ; --i) {\n      descXpathChecks[i]= \"//result/doc[\" + (i + 1) + \"]/str[@name='id'][.='\" + descendingPosVals.get(i).pos + \"']\";\n    }\n    \n    // ensure doc add order doesn't affect results\n    Collections.shuffle(docs, random());\n    for (SolrInputDocument doc : docs) {\n      assertU(adoc(doc));\n    }\n    assertU(commit());\n\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id, \" + field, \"sort\", field + \" asc, id asc\"), \n            ascXpathChecks);\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id, \" + field, \"sort\", field + \" desc, id desc\"), \n            descXpathChecks);\n        \n    clearIndex();\n    assertU(commit());\n  }\n\n","sourceOld":"  /**\n   * For each value, creates a doc with that value in the specified field and then asserts that\n   * asc/desc sorts on that field succeeds and that the docs are in the (relatively) expected order\n   *\n   * @param field name of field to sort on\n   * @param values list of values in ascending order\n   */\n  private void doTestPointFieldSort(String field, String... values) throws Exception {\n    assert values != null && 2 <= values.length;\n\n    // TODO: need to add sort missing coverage...\n    //\n    // idea: accept \"null\" as possible value for sort missing tests ?\n    //\n    // need to account for possibility that multiple nulls will be in non deterministic order\n    // always using secondary sort on id seems prudent ... handles any \"dups\" in values[]\n    \n    final List<SolrInputDocument> docs = new ArrayList<>(values.length);\n    final String[] ascXpathChecks = new String[values.length + 1];\n    final String[] descXpathChecks = new String[values.length + 1];\n    ascXpathChecks[values.length] = \"//*[@numFound='\" + values.length + \"']\";\n    descXpathChecks[values.length] = \"//*[@numFound='\" + values.length + \"']\";\n    \n    for (int i = values.length-1; i >= 0; i--) {\n      docs.add(sdoc(\"id\", String.valueOf(i), field, String.valueOf(values[i])));\n      // reminder: xpath array indexes start at 1\n      ascXpathChecks[i]= \"//result/doc[\"+ (1 + i)+\"]/str[@name='id'][.='\"+i+\"']\";\n      descXpathChecks[i]= \"//result/doc[\"+ (values.length - i) +\"]/str[@name='id'][.='\"+i+\"']\";\n    }\n    \n    // ensure doc add order doesn't affect results\n    Collections.shuffle(docs, random());\n    for (SolrInputDocument doc : docs) {\n      assertU(adoc(doc));\n    }\n    assertU(commit());\n\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id\", \"sort\", field + \" asc\"), \n            ascXpathChecks);\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id\", \"sort\", field + \" desc\"), \n            descXpathChecks);\n\n        \n    clearIndex();\n    assertU(commit());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestPointFields#[T-extends-Comparable[T]]_doTestPointFieldSort(String,List[T]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * For each value, creates a doc with that value in the specified field and then asserts that\n   * asc/desc sorts on that field succeeds and that the docs are in the (relatively) expected order\n   *\n   * @param field name of field to sort on\n   * @param values list of values in ascending order\n   */\n  private <T extends Comparable<T>> void doTestPointFieldSort(String field, List<T> values) throws Exception {\n    assert values != null && 2 <= values.size();\n \n    final List<SolrInputDocument> docs = new ArrayList<>(values.size());\n    final String[] ascXpathChecks = new String[values.size() + 1];\n    final String[] descXpathChecks = new String[values.size() + 1];\n    ascXpathChecks[values.size()] = \"//*[@numFound='\" + values.size() + \"']\";\n    descXpathChecks[values.size()] = \"//*[@numFound='\" + values.size() + \"']\";\n    \n    boolean missingFirst = field.endsWith(\"_sml\") == false;\n    \n    List<PosVal<T>> ascendingPosVals = toAscendingPosVals(values, missingFirst);\n    for (int i = ascendingPosVals.size() - 1 ; i >= 0 ; --i) {\n      T value = ascendingPosVals.get(i).val;\n      if (value == null) {\n        docs.add(sdoc(\"id\", String.valueOf(i))); // null => missing value\n      } else {\n        docs.add(sdoc(\"id\", String.valueOf(i), field, String.valueOf(value)));\n      }\n      // reminder: xpath array indexes start at 1\n      ascXpathChecks[i]= \"//result/doc[\"+ (1 + i)+\"]/str[@name='id'][.='\"+i+\"']\";\n    }\n    List<PosVal<T>> descendingPosVals = toDescendingPosVals\n        (ascendingPosVals.stream().map(pv->pv.val).collect(Collectors.toList()), missingFirst);\n    for (int i = descendingPosVals.size() - 1 ; i >= 0 ; --i) {\n      descXpathChecks[i]= \"//result/doc[\" + (i + 1) + \"]/str[@name='id'][.='\" + descendingPosVals.get(i).pos + \"']\";\n    }\n    \n    // ensure doc add order doesn't affect results\n    Collections.shuffle(docs, random());\n    for (SolrInputDocument doc : docs) {\n      assertU(adoc(doc));\n    }\n    assertU(commit());\n\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id, \" + field, \"sort\", field + \" asc, id asc\"), \n            ascXpathChecks);\n    assertQ(req(\"q\", \"*:*\", \"fl\", \"id, \" + field, \"sort\", field + \" desc, id desc\"), \n            descXpathChecks);\n        \n    clearIndex();\n    assertU(commit());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89c0b1a887eabf9facdf2c5d2df5e284c6d6daa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b89c0b1a887eabf9facdf2c5d2df5e284c6d6daa"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f344bb33ca91f48e99c061980115b46fa84fc8f5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"b89c0b1a887eabf9facdf2c5d2df5e284c6d6daa":["f344bb33ca91f48e99c061980115b46fa84fc8f5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89c0b1a887eabf9facdf2c5d2df5e284c6d6daa","f344bb33ca91f48e99c061980115b46fa84fc8f5","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"f344bb33ca91f48e99c061980115b46fa84fc8f5":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}