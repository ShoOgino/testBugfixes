{"path":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundFile(true); // why?\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundDocStore(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundFile(true); // why?\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundDocStore(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7ab99e8c71442b92c320e218141dee04a9b91ce8","date":1269203801,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundDocStore(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundFile(true); // why?\n          ((LogMergePolicy) writer.getMergePolicy()).setUseCompoundDocStore(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8dc26bfa5ebbc55b5a04fbec545dfcec647b046b","date":1280297653,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundDocStore(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5","date":1292695408,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundDocStore(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundDocStore(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01e5948db9a07144112d2f08f28ca2e3cd880348","date":1301759232,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((TieredMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45669a651c970812a680841b97a77cce06af559f","date":1301922222,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((TieredMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((TieredMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","pathOld":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((TieredMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((LogMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44d6f0ab53c1962856b9f48dedb7a2a6cc18905c","date":1310389132,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/contrib/wordnet/src/java/org/apache/lucene/wordnet/Syns2Index#index(String,Map[String,List[String]],Map[String,List[String]]).mjava","sourceNew":null,"sourceOld":"    /**\n     * Forms a Lucene index based on the 2 maps.\n     *\n     * @param indexDir the directory where the index should be created\n     * @param word2Nums\n     * @param num2Words\n     */\n    private static void index(String indexDir, Map<String,List<String>> word2Nums, Map<String,List<String>> num2Words)\n        throws Throwable\n    {\n        int row = 0;\n        int mod = 1;\n        FSDirectory dir = FSDirectory.open(new File(indexDir));\n        try {\n\n          // override the specific index if it already exists\n          IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(\n              Version.LUCENE_CURRENT, ana).setOpenMode(OpenMode.CREATE));\n          ((TieredMergePolicy) writer.getConfig().getMergePolicy()).setUseCompoundFile(true); // why?\n          Iterator<String> i1 = word2Nums.keySet().iterator();\n          while (i1.hasNext()) // for each word\n          {\n              String g = i1.next();\n              Document doc = new Document();\n\n              int n = index(word2Nums, num2Words, g, doc);\n              if (n > 0)\n              {\n          doc.add( new Field( F_WORD, g, Field.Store.YES, Field.Index.NOT_ANALYZED));\n                  if ((++row % mod) == 0)\n                  {\n                      o.println(\"\\trow=\" + row + \"/\" + word2Nums.size() + \" doc= \" + doc);\n                      mod *= 2;\n                  }\n                  writer.addDocument(doc);\n              } // else degenerate\n          }\n          o.println( \"Optimizing..\");\n          writer.optimize();\n          writer.close();\n        } finally {\n          dir.close();\n        }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"01e5948db9a07144112d2f08f28ca2e3cd880348":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"7ab99e8c71442b92c320e218141dee04a9b91ce8":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a3776dccca01c11e7046323cfad46a3b4a471233":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5","01e5948db9a07144112d2f08f28ca2e3cd880348"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","01e5948db9a07144112d2f08f28ca2e3cd880348"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["7ab99e8c71442b92c320e218141dee04a9b91ce8","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"44d6f0ab53c1962856b9f48dedb7a2a6cc18905c":["01e5948db9a07144112d2f08f28ca2e3cd880348"],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["7ab99e8c71442b92c320e218141dee04a9b91ce8"],"8dc26bfa5ebbc55b5a04fbec545dfcec647b046b":["7ab99e8c71442b92c320e218141dee04a9b91ce8"],"45669a651c970812a680841b97a77cce06af559f":["8dc26bfa5ebbc55b5a04fbec545dfcec647b046b","01e5948db9a07144112d2f08f28ca2e3cd880348"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["44d6f0ab53c1962856b9f48dedb7a2a6cc18905c"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"01e5948db9a07144112d2f08f28ca2e3cd880348":["a3776dccca01c11e7046323cfad46a3b4a471233","135621f3a0670a9394eb563224a3b76cc4dddc0f","44d6f0ab53c1962856b9f48dedb7a2a6cc18905c","45669a651c970812a680841b97a77cce06af559f"],"7ab99e8c71442b92c320e218141dee04a9b91ce8":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5","8dc26bfa5ebbc55b5a04fbec545dfcec647b046b"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["01e5948db9a07144112d2f08f28ca2e3cd880348","a3776dccca01c11e7046323cfad46a3b4a471233","ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"44d6f0ab53c1962856b9f48dedb7a2a6cc18905c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8dc26bfa5ebbc55b5a04fbec545dfcec647b046b":["45669a651c970812a680841b97a77cce06af559f"],"45669a651c970812a680841b97a77cce06af559f":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["7ab99e8c71442b92c320e218141dee04a9b91ce8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3776dccca01c11e7046323cfad46a3b4a471233","135621f3a0670a9394eb563224a3b76cc4dddc0f","45669a651c970812a680841b97a77cce06af559f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}