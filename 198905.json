{"path":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","commits":[{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","pathOld":"/dev/null","sourceNew":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n    if (names.isEmpty()) {\n      return;\n    }\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + names + \"\\\"\");\n      }\n      directory.deleteFiles(names);\n    } catch (NoSuchFileException | FileNotFoundException e) {  // if delete fails\n      // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n      if (Constants.WINDOWS) {\n        // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state:\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1","date":1454513757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","sourceNew":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \\\"\" + names + \"\\\"\");\n    }\n\n    // nocommit put annoying windows-specific segments_N heroics back?\n\n    for(String name : names) {\n      try {\n        directory.deleteFile(name);\n      } catch (NoSuchFileException | FileNotFoundException e) {\n        // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n        if (Constants.WINDOWS) {\n          // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state, and falsely\n          // return NSFE/FNFE\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n    if (names.isEmpty()) {\n      return;\n    }\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + names + \"\\\"\");\n      }\n      directory.deleteFiles(names);\n    } catch (NoSuchFileException | FileNotFoundException e) {  // if delete fails\n      // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n      if (Constants.WINDOWS) {\n        // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state:\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b457e7ac6faeb9e91a9dd5faaf0e2c7286faac","date":1454606266,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","sourceNew":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \\\"\" + names + \"\\\"\");\n    }\n\n    for(String name : names) {\n      try {\n        directory.deleteFile(name);\n      } catch (NoSuchFileException | FileNotFoundException e) {\n        // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n\n        if (Constants.WINDOWS) {\n          // TODO: can we remove this OS-specific hacky logic?  If windows deleteFile is buggy, we should instead contain this workaround in\n          // a WindowsFSDirectory ...\n          // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state, and falsely\n          // return NSFE/FNFE\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \\\"\" + names + \"\\\"\");\n    }\n\n    // nocommit put annoying windows-specific segments_N heroics back?\n\n    for(String name : names) {\n      try {\n        directory.deleteFile(name);\n      } catch (NoSuchFileException | FileNotFoundException e) {\n        // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n        if (Constants.WINDOWS) {\n          // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state, and falsely\n          // return NSFE/FNFE\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","pathOld":"/dev/null","sourceNew":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \\\"\" + names + \"\\\"\");\n    }\n\n    for(String name : names) {\n      try {\n        directory.deleteFile(name);\n      } catch (NoSuchFileException | FileNotFoundException e) {\n        // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n\n        if (Constants.WINDOWS) {\n          // TODO: can we remove this OS-specific hacky logic?  If windows deleteFile is buggy, we should instead contain this workaround in\n          // a WindowsFSDirectory ...\n          // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state, and falsely\n          // return NSFE/FNFE\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","pathOld":"/dev/null","sourceNew":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \\\"\" + names + \"\\\"\");\n    }\n\n    for(String name : names) {\n      try {\n        directory.deleteFile(name);\n      } catch (NoSuchFileException | FileNotFoundException e) {\n        // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n\n        if (Constants.WINDOWS) {\n          // TODO: can we remove this OS-specific hacky logic?  If windows deleteFile is buggy, we should instead contain this workaround in\n          // a WindowsFSDirectory ...\n          // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state, and falsely\n          // return NSFE/FNFE\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":0,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","pathOld":"/dev/null","sourceNew":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \\\"\" + names + \"\\\"\");\n    }\n\n    for(String name : names) {\n      try {\n        directory.deleteFile(name);\n      } catch (NoSuchFileException | FileNotFoundException e) {\n        // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n\n        if (Constants.WINDOWS) {\n          // TODO: can we remove this OS-specific hacky logic?  If windows deleteFile is buggy, we should instead contain this workaround in\n          // a WindowsFSDirectory ...\n          // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state, and falsely\n          // return NSFE/FNFE\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cedcb3038bb218e20fc9c61e3b50642101e656e8","date":1454869299,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","sourceNew":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \" + names + \"\");\n    }\n\n    // We make two passes, first deleting any segments_N files, second deleting the rest.  We do this so that if we throw exc or JVM\n    // crashes during deletions, even when not on Windows, we don't leave the index in an \"apparently corrupt\" state:\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == false) {\n        continue;\n      }\n      directory.deleteFile(name);\n    }\n\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == true) {\n        continue;\n      }\n      directory.deleteFile(name);\n    }\n  }\n\n","sourceOld":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \\\"\" + names + \"\\\"\");\n    }\n\n    for(String name : names) {\n      try {\n        directory.deleteFile(name);\n      } catch (NoSuchFileException | FileNotFoundException e) {\n        // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n\n        if (Constants.WINDOWS) {\n          // TODO: can we remove this OS-specific hacky logic?  If windows deleteFile is buggy, we should instead contain this workaround in\n          // a WindowsFSDirectory ...\n          // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state, and falsely\n          // return NSFE/FNFE\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["4f0befec2c0666a2f1879aaa34f396573a0216c4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a8ec0889b27701f0ad90a25c95b75454e898cf3","date":1454871481,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","sourceNew":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \\\"\" + names + \"\\\"\");\n    }\n\n    // We make two passes, first deleting any segments_N files, second deleting all the rest.  We do this so that if we throw exc or JVM\n    // crashes during deletions, we don't leave the index in an \"apparently corrupt\" state:\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == false) {\n        continue;\n      }\n      try {\n        directory.deleteFile(name);\n      } catch (NoSuchFileException | FileNotFoundException e) {\n        // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n\n        if (Constants.WINDOWS) {\n          // TODO: can we remove this OS-specific hacky logic?  If windows deleteFile is buggy, we should instead contain this workaround in\n          // a WindowsFSDirectory ...\n          // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state, and falsely\n          // return NSFE/FNFE\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == true) {\n        continue;\n      }\n      try {\n        directory.deleteFile(name);\n      } catch (NoSuchFileException | FileNotFoundException e) {\n        // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n\n        if (Constants.WINDOWS) {\n          // TODO: can we remove this OS-specific hacky logic?  If windows deleteFile is buggy, we should instead contain this workaround in\n          // a WindowsFSDirectory ...\n          // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state, and falsely\n          // return NSFE/FNFE\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \\\"\" + names + \"\\\"\");\n    }\n\n    for(String name : names) {\n      try {\n        directory.deleteFile(name);\n      } catch (NoSuchFileException | FileNotFoundException e) {\n        // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n\n        if (Constants.WINDOWS) {\n          // TODO: can we remove this OS-specific hacky logic?  If windows deleteFile is buggy, we should instead contain this workaround in\n          // a WindowsFSDirectory ...\n          // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state, and falsely\n          // return NSFE/FNFE\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd75f58072bba84066e89d61bd7028de1bd5b632","date":1454871793,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","sourceNew":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \" + names + \"\");\n    }\n\n    // We make two passes, first deleting any segments_N files, second deleting the rest.  We do this so that if we throw exc or JVM\n    // crashes during deletions, even when not on Windows, we don't leave the index in an \"apparently corrupt\" state:\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == false) {\n        continue;\n      }\n      directory.deleteFile(name);\n    }\n\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == true) {\n        continue;\n      }\n      directory.deleteFile(name);\n    }\n  }\n\n","sourceOld":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \\\"\" + names + \"\\\"\");\n    }\n\n    // We make two passes, first deleting any segments_N files, second deleting all the rest.  We do this so that if we throw exc or JVM\n    // crashes during deletions, we don't leave the index in an \"apparently corrupt\" state:\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == false) {\n        continue;\n      }\n      try {\n        directory.deleteFile(name);\n      } catch (NoSuchFileException | FileNotFoundException e) {\n        // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n\n        if (Constants.WINDOWS) {\n          // TODO: can we remove this OS-specific hacky logic?  If windows deleteFile is buggy, we should instead contain this workaround in\n          // a WindowsFSDirectory ...\n          // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state, and falsely\n          // return NSFE/FNFE\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == true) {\n        continue;\n      }\n      try {\n        directory.deleteFile(name);\n      } catch (NoSuchFileException | FileNotFoundException e) {\n        // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n\n        if (Constants.WINDOWS) {\n          // TODO: can we remove this OS-specific hacky logic?  If windows deleteFile is buggy, we should instead contain this workaround in\n          // a WindowsFSDirectory ...\n          // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state, and falsely\n          // return NSFE/FNFE\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f0befec2c0666a2f1879aaa34f396573a0216c4","date":1454957645,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","sourceNew":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \" + names + \"\");\n    }\n\n    // We make two passes, first deleting any segments_N files, second deleting the rest.  We do this so that if we throw exc or JVM\n    // crashes during deletions, even when not on Windows, we don't leave the index in an \"apparently corrupt\" state:\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == false) {\n        continue;\n      }\n      deleteFile(name);\n    }\n\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == true) {\n        continue;\n      }\n      deleteFile(name);\n    }\n  }\n\n","sourceOld":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \" + names + \"\");\n    }\n\n    // We make two passes, first deleting any segments_N files, second deleting the rest.  We do this so that if we throw exc or JVM\n    // crashes during deletions, even when not on Windows, we don't leave the index in an \"apparently corrupt\" state:\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == false) {\n        continue;\n      }\n      directory.deleteFile(name);\n    }\n\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == true) {\n        continue;\n      }\n      directory.deleteFile(name);\n    }\n  }\n\n","bugFix":["cedcb3038bb218e20fc9c61e3b50642101e656e8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","sourceNew":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      if (names.size() > 0) {\n        infoStream.message(\"IFD\", \"delete \" + names + \"\");\n      }\n    }\n\n    // We make two passes, first deleting any segments_N files, second deleting the rest.  We do this so that if we throw exc or JVM\n    // crashes during deletions, even when not on Windows, we don't leave the index in an \"apparently corrupt\" state:\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == false) {\n        continue;\n      }\n      deleteFile(name);\n    }\n\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == true) {\n        continue;\n      }\n      deleteFile(name);\n    }\n  }\n\n","sourceOld":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \" + names + \"\");\n    }\n\n    // We make two passes, first deleting any segments_N files, second deleting the rest.  We do this so that if we throw exc or JVM\n    // crashes during deletions, even when not on Windows, we don't leave the index in an \"apparently corrupt\" state:\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == false) {\n        continue;\n      }\n      deleteFile(name);\n    }\n\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == true) {\n        continue;\n      }\n      deleteFile(name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","sourceNew":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      if (names.size() > 0) {\n        infoStream.message(\"IFD\", \"delete \" + names + \"\");\n      }\n    }\n\n    // We make two passes, first deleting any segments_N files, second deleting the rest.  We do this so that if we throw exc or JVM\n    // crashes during deletions, even when not on Windows, we don't leave the index in an \"apparently corrupt\" state:\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == false) {\n        continue;\n      }\n      deleteFile(name);\n    }\n\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == true) {\n        continue;\n      }\n      deleteFile(name);\n    }\n  }\n\n","sourceOld":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \" + names + \"\");\n    }\n\n    // We make two passes, first deleting any segments_N files, second deleting the rest.  We do this so that if we throw exc or JVM\n    // crashes during deletions, even when not on Windows, we don't leave the index in an \"apparently corrupt\" state:\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == false) {\n        continue;\n      }\n      deleteFile(name);\n    }\n\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == true) {\n        continue;\n      }\n      deleteFile(name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFiles(Collection[String]).mjava","sourceNew":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      if (names.size() > 0) {\n        infoStream.message(\"IFD\", \"delete \" + names + \"\");\n      }\n    }\n\n    // We make two passes, first deleting any segments_N files, second deleting the rest.  We do this so that if we throw exc or JVM\n    // crashes during deletions, even when not on Windows, we don't leave the index in an \"apparently corrupt\" state:\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == false) {\n        continue;\n      }\n      deleteFile(name);\n    }\n\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == true) {\n        continue;\n      }\n      deleteFile(name);\n    }\n  }\n\n","sourceOld":"  private void deleteFiles(Collection<String> names) throws IOException {\n    assert locked();\n    ensureOpen();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"delete \" + names + \"\");\n    }\n\n    // We make two passes, first deleting any segments_N files, second deleting the rest.  We do this so that if we throw exc or JVM\n    // crashes during deletions, even when not on Windows, we don't leave the index in an \"apparently corrupt\" state:\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == false) {\n        continue;\n      }\n      deleteFile(name);\n    }\n\n    for(String name : names) {\n      if (name.startsWith(IndexFileNames.SEGMENTS) == true) {\n        continue;\n      }\n      deleteFile(name);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4a8ec0889b27701f0ad90a25c95b75454e898cf3":["1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"cedcb3038bb218e20fc9c61e3b50642101e656e8":["5a207d19eac354d649c3f0e2cce070017c78125e"],"5a207d19eac354d649c3f0e2cce070017c78125e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b470f36a9372c97283360b1304eacbde22df6c0d"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["4f0befec2c0666a2f1879aaa34f396573a0216c4"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b470f36a9372c97283360b1304eacbde22df6c0d"],"4f0befec2c0666a2f1879aaa34f396573a0216c4":["cedcb3038bb218e20fc9c61e3b50642101e656e8"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["4f0befec2c0666a2f1879aaa34f396573a0216c4","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"b0b457e7ac6faeb9e91a9dd5faaf0e2c7286faac":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"28288370235ed02234a64753cdbf0c6ec096304a":["4f0befec2c0666a2f1879aaa34f396573a0216c4","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"dd75f58072bba84066e89d61bd7028de1bd5b632":["4a8ec0889b27701f0ad90a25c95b75454e898cf3","cedcb3038bb218e20fc9c61e3b50642101e656e8"],"b470f36a9372c97283360b1304eacbde22df6c0d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b0b457e7ac6faeb9e91a9dd5faaf0e2c7286faac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["28288370235ed02234a64753cdbf0c6ec096304a"]},"commit2Childs":{"4a8ec0889b27701f0ad90a25c95b75454e898cf3":["dd75f58072bba84066e89d61bd7028de1bd5b632"],"cedcb3038bb218e20fc9c61e3b50642101e656e8":["4f0befec2c0666a2f1879aaa34f396573a0216c4","dd75f58072bba84066e89d61bd7028de1bd5b632"],"5a207d19eac354d649c3f0e2cce070017c78125e":["cedcb3038bb218e20fc9c61e3b50642101e656e8"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["4a8ec0889b27701f0ad90a25c95b75454e898cf3"],"4f0befec2c0666a2f1879aaa34f396573a0216c4":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"b0b457e7ac6faeb9e91a9dd5faaf0e2c7286faac":["b470f36a9372c97283360b1304eacbde22df6c0d"],"28288370235ed02234a64753cdbf0c6ec096304a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8f4e2dcb5e470991d83a63c264bfe20880d3b3c1":["b0b457e7ac6faeb9e91a9dd5faaf0e2c7286faac"],"dd75f58072bba84066e89d61bd7028de1bd5b632":[],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3","b470f36a9372c97283360b1304eacbde22df6c0d","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["8f4e2dcb5e470991d83a63c264bfe20880d3b3c1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","dd75f58072bba84066e89d61bd7028de1bd5b632","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}