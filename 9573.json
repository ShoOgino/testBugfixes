{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#calcDeletes(List[Action]).mjava","commits":[{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":0,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#calcDeletes(List[Action]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Deletes some of the oldest collection(s) based on {@link TimeRoutedAlias#getAutoDeleteAgeMath()}. If\n   * getAutoDelteAgemath is not present then this method does nothing. Per documentation is relative to a\n   * collection being created. Therefore if nothing is being created, nothing is deleted.\n   * @param actions The previously calculated add action(s). This collection should not be modified within\n   *                this method.\n   */\n  private List<Action> calcDeletes(List<Action> actions) {\n    final String autoDeleteAgeMathStr = this.getAutoDeleteAgeMath();\n    if (autoDeleteAgeMathStr == null || actions .size() == 0) {\n      return Collections.emptyList();\n    }\n    if (actions.size() > 1) {\n      throw new IllegalStateException(\"We are not supposed to be creating more than one collection at a time\");\n    }\n\n    String deletionReferenceCollection = actions.get(0).targetCollection;\n    Instant deletionReferenceInstant = parseInstantFromCollectionName(getAliasName(), deletionReferenceCollection);\n    final Instant delBefore;\n    try {\n      delBefore = new DateMathParser(Date.from(computeNextCollTimestamp(deletionReferenceInstant)), this.getTimeZone()).parseMath(autoDeleteAgeMathStr).toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e); // note: should not happen by this point\n    }\n\n    List<Action> collectionsToDelete = new ArrayList<>();\n\n    //iterating from newest to oldest, find the first collection that has a time <= \"before\".  We keep this collection\n    // (and all newer to left) but we delete older collections, which are the ones that follow.\n    int numToKeep = 0;\n    DateTimeFormatter dtf = null;\n    if (log.isDebugEnabled()) {\n      dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.n\", Locale.ROOT);\n      dtf = dtf.withZone(ZoneId.of(\"UTC\"));\n    }\n    for (Map.Entry<Instant, String> parsedCollection : parsedCollectionsDesc) {\n      numToKeep++;\n      final Instant colInstant = parsedCollection.getKey();\n      if (colInstant.isBefore(delBefore) || colInstant.equals(delBefore)) {\n        if (log.isDebugEnabled()) { // don't perform formatting unless debugging\n          assert dtf != null;\n          log.debug(\"{} is equal to or before {} deletions may be required\", dtf.format(colInstant), dtf.format(delBefore));\n        }\n        break;\n      } else {\n        if (log.isDebugEnabled()) { // don't perform formatting unless debugging\n          assert dtf != null;\n          log.debug(\"{} is not before {} and will be retained\", dtf.format(colInstant), dtf.format(delBefore));\n        }\n      }\n    }\n\n    log.debug(\"Collections will be deleted... parsed collections={}\", parsedCollectionsDesc);\n    final List<String> targetList = parsedCollectionsDesc.stream().map(Map.Entry::getValue).collect(Collectors.toList());\n    log.debug(\"Iterating backwards on collection list to find deletions: {}\", targetList);\n    for (int i = parsedCollectionsDesc.size() - 1; i >= numToKeep; i--) {\n      String toDelete = targetList.get(i);\n      log.debug(\"Adding to TRA delete list:{}\", toDelete);\n\n      collectionsToDelete.add(new Action(this, ActionType.ENSURE_REMOVED, toDelete));\n    }\n    return collectionsToDelete;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4abf821a41a2fdca2a1dea148999931d22e20529","date":1587749643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#calcDeletes(List[Action]).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/TimeRoutedAlias#calcDeletes(List[Action]).mjava","sourceNew":"  /**\n   * Deletes some of the oldest collection(s) based on {@link TimeRoutedAlias#getAutoDeleteAgeMath()}. If\n   * getAutoDelteAgemath is not present then this method does nothing. Per documentation is relative to a\n   * collection being created. Therefore if nothing is being created, nothing is deleted.\n   * @param actions The previously calculated add action(s). This collection should not be modified within\n   *                this method.\n   */\n  private List<Action> calcDeletes(List<Action> actions) {\n    final String autoDeleteAgeMathStr = this.getAutoDeleteAgeMath();\n    if (autoDeleteAgeMathStr == null || actions .size() == 0) {\n      return Collections.emptyList();\n    }\n    if (actions.size() > 1) {\n      throw new IllegalStateException(\"We are not supposed to be creating more than one collection at a time\");\n    }\n\n    String deletionReferenceCollection = actions.get(0).targetCollection;\n    Instant deletionReferenceInstant = parseInstantFromCollectionName(getAliasName(), deletionReferenceCollection);\n    final Instant delBefore;\n    try {\n      delBefore = new DateMathParser(Date.from(computeNextCollTimestamp(deletionReferenceInstant)), this.getTimeZone()).parseMath(autoDeleteAgeMathStr).toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e); // note: should not happen by this point\n    }\n\n    List<Action> collectionsToDelete = new ArrayList<>();\n\n    //iterating from newest to oldest, find the first collection that has a time <= \"before\".  We keep this collection\n    // (and all newer to left) but we delete older collections, which are the ones that follow.\n    int numToKeep = 0;\n    DateTimeFormatter dtf = null;\n    if (log.isDebugEnabled()) {\n      dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.n\", Locale.ROOT);\n      dtf = dtf.withZone(ZoneId.of(\"UTC\"));\n    }\n    for (Map.Entry<Instant, String> parsedCollection : parsedCollectionsDesc) {\n      numToKeep++;\n      final Instant colInstant = parsedCollection.getKey();\n      if (colInstant.isBefore(delBefore) || colInstant.equals(delBefore)) {\n        if (log.isDebugEnabled()) { // don't perform formatting unless debugging\n          assert dtf != null;\n          if (log.isDebugEnabled()) {\n            log.debug(\"{} is equal to or before {} deletions may be required\", dtf.format(colInstant), dtf.format(delBefore));\n          }\n        }\n        break;\n      } else {\n        if (log.isDebugEnabled()) { // don't perform formatting unless debugging\n          assert dtf != null;\n          if (log.isDebugEnabled()) {\n            log.debug(\"{} is not before {} and will be retained\", dtf.format(colInstant), dtf.format(delBefore));\n          }\n        }\n      }\n    }\n\n    log.debug(\"Collections will be deleted... parsed collections={}\", parsedCollectionsDesc);\n    final List<String> targetList = parsedCollectionsDesc.stream().map(Map.Entry::getValue).collect(Collectors.toList());\n    log.debug(\"Iterating backwards on collection list to find deletions: {}\", targetList);\n    for (int i = parsedCollectionsDesc.size() - 1; i >= numToKeep; i--) {\n      String toDelete = targetList.get(i);\n      log.debug(\"Adding to TRA delete list:{}\", toDelete);\n\n      collectionsToDelete.add(new Action(this, ActionType.ENSURE_REMOVED, toDelete));\n    }\n    return collectionsToDelete;\n  }\n\n","sourceOld":"  /**\n   * Deletes some of the oldest collection(s) based on {@link TimeRoutedAlias#getAutoDeleteAgeMath()}. If\n   * getAutoDelteAgemath is not present then this method does nothing. Per documentation is relative to a\n   * collection being created. Therefore if nothing is being created, nothing is deleted.\n   * @param actions The previously calculated add action(s). This collection should not be modified within\n   *                this method.\n   */\n  private List<Action> calcDeletes(List<Action> actions) {\n    final String autoDeleteAgeMathStr = this.getAutoDeleteAgeMath();\n    if (autoDeleteAgeMathStr == null || actions .size() == 0) {\n      return Collections.emptyList();\n    }\n    if (actions.size() > 1) {\n      throw new IllegalStateException(\"We are not supposed to be creating more than one collection at a time\");\n    }\n\n    String deletionReferenceCollection = actions.get(0).targetCollection;\n    Instant deletionReferenceInstant = parseInstantFromCollectionName(getAliasName(), deletionReferenceCollection);\n    final Instant delBefore;\n    try {\n      delBefore = new DateMathParser(Date.from(computeNextCollTimestamp(deletionReferenceInstant)), this.getTimeZone()).parseMath(autoDeleteAgeMathStr).toInstant();\n    } catch (ParseException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e); // note: should not happen by this point\n    }\n\n    List<Action> collectionsToDelete = new ArrayList<>();\n\n    //iterating from newest to oldest, find the first collection that has a time <= \"before\".  We keep this collection\n    // (and all newer to left) but we delete older collections, which are the ones that follow.\n    int numToKeep = 0;\n    DateTimeFormatter dtf = null;\n    if (log.isDebugEnabled()) {\n      dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.n\", Locale.ROOT);\n      dtf = dtf.withZone(ZoneId.of(\"UTC\"));\n    }\n    for (Map.Entry<Instant, String> parsedCollection : parsedCollectionsDesc) {\n      numToKeep++;\n      final Instant colInstant = parsedCollection.getKey();\n      if (colInstant.isBefore(delBefore) || colInstant.equals(delBefore)) {\n        if (log.isDebugEnabled()) { // don't perform formatting unless debugging\n          assert dtf != null;\n          log.debug(\"{} is equal to or before {} deletions may be required\", dtf.format(colInstant), dtf.format(delBefore));\n        }\n        break;\n      } else {\n        if (log.isDebugEnabled()) { // don't perform formatting unless debugging\n          assert dtf != null;\n          log.debug(\"{} is not before {} and will be retained\", dtf.format(colInstant), dtf.format(delBefore));\n        }\n      }\n    }\n\n    log.debug(\"Collections will be deleted... parsed collections={}\", parsedCollectionsDesc);\n    final List<String> targetList = parsedCollectionsDesc.stream().map(Map.Entry::getValue).collect(Collectors.toList());\n    log.debug(\"Iterating backwards on collection list to find deletions: {}\", targetList);\n    for (int i = parsedCollectionsDesc.size() - 1; i >= numToKeep; i--) {\n      String toDelete = targetList.get(i);\n      log.debug(\"Adding to TRA delete list:{}\", toDelete);\n\n      collectionsToDelete.add(new Action(this, ActionType.ENSURE_REMOVED, toDelete));\n    }\n    return collectionsToDelete;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4abf821a41a2fdca2a1dea148999931d22e20529":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4abf821a41a2fdca2a1dea148999931d22e20529"]},"commit2Childs":{"4abf821a41a2fdca2a1dea148999931d22e20529":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["4abf821a41a2fdca2a1dea148999931d22e20529"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}