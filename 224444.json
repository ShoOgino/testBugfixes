{"path":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","commits":[{"id":"b24326411db492f92ea49f6fb947c90bc73cf19e","date":1298813468,"type":1,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputStream).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputStream is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"/dev/null","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"/dev/null","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19d49ad51733946a9e7f80686ca7dbc5964cfb95","date":1301602402,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"45669a651c970812a680841b97a77cce06af559f","date":1301922222,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    if (node==null) {\n      similarityFactory = new SimilarityFactory() {\n        @Override\n        public SimilarityProvider getSimilarityProvider() {\n          return IndexSearcher.getDefaultSimilarityProvider();\n        }\n      };\n      log.debug(\"using default similarity\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      if (obj instanceof SimilarityFactory) {\n        // configure a factory, get a similarity back\n        SolrParams params = SolrParams.toSolrParams(DOMUtil.childNodesToNamedList(node));\n        similarityFactory = (SimilarityFactory)obj;\n        similarityFactory.init(params);\n      } else {\n        // just like always, assume it's a SimilarityProvider and get a ClassCastException - reasonable error handling\n        similarityFactory = new SimilarityFactory() {\n          @Override\n          public SimilarityProvider getSimilarityProvider() {\n            return (SimilarityProvider) obj;\n          }\n        };\n      }\n      if (similarityFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityFactory);\n      }\n      log.debug(\"using similarity factory\" + similarityFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","pathOld":"solr/src/java/org/apache/solr/schema/IndexSchema#readSchema(InputSource).mjava","sourceNew":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","sourceOld":"  private void readSchema(InputSource is) {\n    log.info(\"Reading Solr Schema\");\n\n    try {\n      // pass the config resource loader to avoid building an empty one for no reason:\n      // in the current case though, the stream is valid so we wont load the resource by name\n      Config schemaConf = new Config(loader, \"schema\", is, \"/schema/\");\n      Document document = schemaConf.getDocument();\n      final XPath xpath = schemaConf.getXPath();\n      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();\n      Node nd = (Node) xpath.evaluate(\"/schema/@name\", document, XPathConstants.NODE);\n      if (nd==null) {\n        log.warn(\"schema has no name!\");\n      } else {\n        name = nd.getNodeValue();\n        log.info(\"Schema name=\" + name);\n      }\n\n      version = schemaConf.getFloat(\"/schema/@version\", 1.0f);\n\n      final IndexSchema schema = this;\n      AbstractPluginLoader<FieldType> fieldLoader = new AbstractPluginLoader<FieldType>( \"[schema.xml] fieldType\", true, true) {\n\n        @Override\n        protected FieldType create( ResourceLoader loader, String name, String className, Node node ) throws Exception\n        {\n          FieldType ft = (FieldType)loader.newInstance(className);\n          ft.setTypeName(name);\n\n          String expression = \"./analyzer[@type='query']\";\n          Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer queryAnalyzer = readAnalyzer(anode);\n\n          // An analyzer without a type specified, or with type=\"index\"\n          expression = \"./analyzer[not(@type)] | ./analyzer[@type='index']\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Analyzer analyzer = readAnalyzer(anode);\n          \n          // a custom similarity[Factory]\n          expression = \"./similarity\";\n          anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);\n          Similarity similarity = readSimilarity(anode);\n\n          if (queryAnalyzer==null) queryAnalyzer=analyzer;\n          if (analyzer==null) analyzer=queryAnalyzer;\n          if (analyzer!=null) {\n            ft.setAnalyzer(analyzer);\n            ft.setQueryAnalyzer(queryAnalyzer);\n          }\n          if (similarity!=null) {\n            ft.setSimilarity(similarity);\n          }\n          if (ft instanceof SchemaAware){\n            schemaAware.add((SchemaAware) ft);\n          }\n          return ft;\n        }\n        \n        @Override\n        protected void init(FieldType plugin, Node node) throws Exception {\n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \"name\",\"class\" );\n          plugin.setArgs(schema, params );\n        }\n\n        @Override\n        protected FieldType register(String name, FieldType plugin) throws Exception {\n          log.trace(\"fieldtype defined: \" + plugin );\n          return fieldTypes.put( name, plugin );\n        }\n      };\n      \n\n      String expression = \"/schema/types/fieldtype | /schema/types/fieldType\";\n      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n      fieldLoader.load( loader, nodes );\n\n      \n\n      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key\n      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();\n      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();\n      expression = \"/schema/fields/field | /schema/fields/dynamicField\";\n      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n\n        NamedNodeMap attrs = node.getAttributes();\n\n        String name = DOMUtil.getAttr(attrs,\"name\",\"field definition\");\n        log.trace(\"reading field def \"+name);\n        String type = DOMUtil.getAttr(attrs,\"type\",\"field \" + name);\n\n        FieldType ft = fieldTypes.get(type);\n        if (ft==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Unknown fieldtype '\" + type + \"' specified on field \" + name,false);\n        }\n\n        Map<String,String> args = DOMUtil.toMapExcept(attrs, \"name\", \"type\");\n        if( args.get( \"required\" ) != null ) {\n          explicitRequiredProp.put( name, Boolean.valueOf( args.get( \"required\" ) ) );\n        }\n\n        SchemaField f = SchemaField.create(name,ft,args);\n\n        if (node.getNodeName().equals(\"field\")) {\n          SchemaField old = fields.put(f.getName(),f);\n          if( old != null ) {\n            String msg = \"[schema.xml] Duplicate field definition for '\"\n              + f.getName() + \"' [[[\"+old.toString()+\"]]] and [[[\"+f.toString()+\"]]]\";\n            SolrException t = new SolrException(SolrException.ErrorCode.SERVER_ERROR, msg );\n            SolrException.logOnce(log,null,t);\n            SolrConfig.severeErrors.add( t );\n            throw t;\n          }\n          log.debug(\"field defined: \" + f);\n          if( f.getDefaultValue() != null ) {\n            log.debug(name+\" contains default value: \" + f.getDefaultValue());\n            fieldsWithDefaultValue.add( f );\n          }\n          if (f.isRequired()) {\n            log.debug(name+\" is required in this schema\");\n            requiredFields.add(f);\n          }\n        } else if (node.getNodeName().equals(\"dynamicField\")) {\n          // make sure nothing else has the same path\n          addDynamicField(dFields, f);\n        } else {\n          // we should never get here\n          throw new RuntimeException(\"Unknown field type\");\n        }\n      }\n      \n    //fields with default values are by definition required\n    //add them to required fields, and we only have to loop once\n    // in DocumentBuilder.getDoc()\n    requiredFields.addAll(getFieldsWithDefaultValue());\n\n\n    // OK, now sort the dynamic fields largest to smallest size so we don't get\n    // any false matches.  We want to act like a compiler tool and try and match\n    // the largest string possible.\n    Collections.sort(dFields);\n\n    log.trace(\"Dynamic Field Ordering:\" + dFields);\n\n    // stuff it in a normal array for faster access\n    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);\n\n    Node node = (Node) xpath.evaluate(\"/schema/similarity\", document, XPathConstants.NODE);\n    Similarity similarity = readSimilarity(node);\n    fallbackSimilarity = similarity == null ? new DefaultSimilarity() : similarity;\n\n    node = (Node) xpath.evaluate(\"/schema/similarityProvider\", document, XPathConstants.NODE);\n    if (node==null) {\n      final SolrSimilarityProvider provider = new SolrSimilarityProvider(this);\n      similarityProviderFactory = new SimilarityProviderFactory() {\n        @Override\n        public SolrSimilarityProvider getSimilarityProvider(IndexSchema schema) {\n          return provider;\n        }\n      };\n      log.debug(\"using default similarityProvider\");\n    } else {\n      final Object obj = loader.newInstance(((Element) node).getAttribute(\"class\"));\n      // just like always, assume it's a SimilarityProviderFactory and get a ClassCastException - reasonable error handling\n      // configure a factory, get a similarity back\n      NamedList<?> args = DOMUtil.childNodesToNamedList(node);\n      similarityProviderFactory = (SimilarityProviderFactory)obj;\n      similarityProviderFactory.init(args);\n      if (similarityProviderFactory instanceof SchemaAware){\n        schemaAware.add((SchemaAware) similarityProviderFactory);\n      }\n      log.debug(\"using similarityProvider factory\" + similarityProviderFactory.getClass().getName());\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/defaultSearchField/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no default search field specified in schema.\");\n    } else {\n      defaultSearchFieldName=node.getNodeValue().trim();\n      // throw exception if specified, but not found or not indexed\n      if (defaultSearchFieldName!=null) {\n        SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);\n        if ((defaultSearchField == null) || !defaultSearchField.indexed()) {\n          String msg =  \"default search field '\" + defaultSearchFieldName + \"' not defined or not indexed\" ;\n          throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, msg );\n        }\n      }\n      log.info(\"default search field is \"+defaultSearchFieldName);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/solrQueryParser/@defaultOperator\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.debug(\"using default query parser operator (OR)\");\n    } else {\n      queryParserDefaultOperator=node.getNodeValue().trim();\n      log.info(\"query parser default operator is \"+queryParserDefaultOperator);\n    }\n\n    node = (Node) xpath.evaluate(\"/schema/uniqueKey/text()\", document, XPathConstants.NODE);\n    if (node==null) {\n      log.warn(\"no uniqueKey specified in schema.\");\n    } else {\n      uniqueKeyField=getIndexedField(node.getNodeValue().trim());\n      if (!uniqueKeyField.stored()) {\n        log.error(\"uniqueKey is not stored - distributed search will not work\");\n      }\n      if (uniqueKeyField.multiValued()) {\n        log.error(\"uniqueKey should not be multivalued\");\n      }\n      uniqueKeyFieldName=uniqueKeyField.getName();\n      uniqueKeyFieldType=uniqueKeyField.getType();\n      log.info(\"unique key field: \"+uniqueKeyFieldName);\n      \n      // Unless the uniqueKeyField is marked 'required=false' then make sure it exists\n      if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {\n        uniqueKeyField.required = true;\n        requiredFields.add(uniqueKeyField);\n      }\n    }\n\n    /////////////// parse out copyField commands ///////////////\n    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();\n    // expression = \"/schema/copyField\";\n    \n    dynamicCopyFields = new DynamicCopy[] {};\n    expression = \"//copyField\";\n    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);\n\n      for (int i=0; i<nodes.getLength(); i++) {\n        node = nodes.item(i);\n        NamedNodeMap attrs = node.getAttributes();\n\n        String source = DOMUtil.getAttr(attrs,\"source\",\"copyField definition\");\n        String dest   = DOMUtil.getAttr(attrs,\"dest\",  \"copyField definition\");\n        String maxChars = DOMUtil.getAttr(attrs, \"maxChars\");\n        int maxCharsInt = CopyField.UNLIMITED;\n        if (maxChars != null) {\n          try {\n            maxCharsInt = Integer.parseInt(maxChars);\n          } catch (NumberFormatException e) {\n            log.warn(\"Couldn't parse maxChars attribute for copyField from \"\n                    + source + \" to \" + dest + \" as integer. The whole field will be copied.\");\n          }\n        }\n\n        registerCopyField(source, dest, maxCharsInt);\n     }\n      \n      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet())    {\n        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {\n          log.warn(\"Field \" + entry.getKey().name + \" is not multivalued \"+\n                      \"and destination for multiple copyFields (\"+\n                      entry.getValue()+\")\");\n        }\n      }\n      //Run the callbacks on SchemaAware now that everything else is done\n      for (SchemaAware aware : schemaAware) {\n        aware.inform(this);\n      }\n    } catch (SolrException e) {\n      SolrConfig.severeErrors.add( e );\n      throw e;\n    } catch(Exception e) {\n      // unexpected exception...\n      SolrConfig.severeErrors.add( e );\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\"Schema Parsing Failed\",e,false);\n    }\n\n    // create the field analyzers\n    refreshAnalyzers();\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b24326411db492f92ea49f6fb947c90bc73cf19e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b24326411db492f92ea49f6fb947c90bc73cf19e"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["19d49ad51733946a9e7f80686ca7dbc5964cfb95"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b24326411db492f92ea49f6fb947c90bc73cf19e"],"c26f00b574427b55127e869b935845554afde1fa":["19d49ad51733946a9e7f80686ca7dbc5964cfb95","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"19d49ad51733946a9e7f80686ca7dbc5964cfb95":["b24326411db492f92ea49f6fb947c90bc73cf19e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["d619839baa8ce5503e496b94a9e42ad6f079293f","19d49ad51733946a9e7f80686ca7dbc5964cfb95"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["19d49ad51733946a9e7f80686ca7dbc5964cfb95"],"45669a651c970812a680841b97a77cce06af559f":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","19d49ad51733946a9e7f80686ca7dbc5964cfb95"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"b24326411db492f92ea49f6fb947c90bc73cf19e":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f","19d49ad51733946a9e7f80686ca7dbc5964cfb95"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["45669a651c970812a680841b97a77cce06af559f"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b24326411db492f92ea49f6fb947c90bc73cf19e","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","d619839baa8ce5503e496b94a9e42ad6f079293f"],"19d49ad51733946a9e7f80686ca7dbc5964cfb95":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","135621f3a0670a9394eb563224a3b76cc4dddc0f","a258fbb26824fd104ed795e5d9033d2d040049ee","45669a651c970812a680841b97a77cce06af559f"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"45669a651c970812a680841b97a77cce06af559f":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["135621f3a0670a9394eb563224a3b76cc4dddc0f","a258fbb26824fd104ed795e5d9033d2d040049ee","45669a651c970812a680841b97a77cce06af559f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}