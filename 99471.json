{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,ClusterState).mjava","commits":[{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrServer#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbClient.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrServer.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrServer.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbServer.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrServer.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrServer.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbServer.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrServer.Rsp rsp = lbServer.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a20a867de92263c94258f9778db64a5efc7956d","date":1424955868,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbClient.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbClient.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7ca08c071cb75a8796c36ae6a1c90d7473c2a6df","date":1425554964,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,String,ClusterState).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, String collection, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbClient.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection,null);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbClient.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":4,"author":"Ryan Ernst","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#directUpdate(AbstractUpdateRequest,ClusterState).mjava","sourceNew":null,"sourceOld":"  private NamedList<Object> directUpdate(AbstractUpdateRequest request, ClusterState clusterState) throws SolrServerException {\n    UpdateRequest updateRequest = (UpdateRequest) request;\n    ModifiableSolrParams params = (ModifiableSolrParams) request.getParams();\n    ModifiableSolrParams routableParams = new ModifiableSolrParams();\n    ModifiableSolrParams nonRoutableParams = new ModifiableSolrParams();\n\n    if(params != null) {\n      nonRoutableParams.add(params);\n      routableParams.add(params);\n      for(String param : NON_ROUTABLE_PARAMS) {\n        routableParams.remove(param);\n      }\n    }\n\n    String collection = nonRoutableParams.get(UpdateParams.COLLECTION, defaultCollection);\n    if (collection == null) {\n      throw new SolrServerException(\"No collection param specified on request and no default collection has been set.\");\n    }\n\n\n    //Check to see if the collection is an alias.\n    Aliases aliases = zkStateReader.getAliases();\n    if(aliases != null) {\n      Map<String, String> collectionAliases = aliases.getCollectionAliasMap();\n      if(collectionAliases != null && collectionAliases.containsKey(collection)) {\n        collection = collectionAliases.get(collection);\n      }\n    }\n\n    DocCollection col = getDocCollection(clusterState, collection);\n\n    DocRouter router = col.getRouter();\n    \n    if (router instanceof ImplicitDocRouter) {\n      // short circuit as optimization\n      return null;\n    }\n\n    //Create the URL map, which is keyed on slice name.\n    //The value is a list of URLs for each replica in the slice.\n    //The first value in the list is the leader for the slice.\n    Map<String,List<String>> urlMap = buildUrlMap(col);\n    if (urlMap == null) {\n      // we could not find a leader yet - use unoptimized general path\n      return null;\n    }\n\n    NamedList<Throwable> exceptions = new NamedList<>();\n    NamedList<NamedList> shardResponses = new NamedList<>();\n\n    Map<String, LBHttpSolrClient.Req> routes = updateRequest.getRoutes(router, col, urlMap, routableParams, this.idField);\n    if (routes == null) {\n      return null;\n    }\n\n    long start = System.nanoTime();\n\n    if (parallelUpdates) {\n      final Map<String, Future<NamedList<?>>> responseFutures = new HashMap<>(routes.size());\n      for (final Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        final String url = entry.getKey();\n        final LBHttpSolrClient.Req lbRequest = entry.getValue();\n        responseFutures.put(url, threadPool.submit(new Callable<NamedList<?>>() {\n          @Override\n          public NamedList<?> call() throws Exception {\n            return lbClient.request(lbRequest).getResponse();\n          }\n        }));\n      }\n\n      for (final Map.Entry<String, Future<NamedList<?>>> entry: responseFutures.entrySet()) {\n        final String url = entry.getKey();\n        final Future<NamedList<?>> responseFuture = entry.getValue();\n        try {\n          shardResponses.add(url, responseFuture.get());\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(e);\n        } catch (ExecutionException e) {\n          exceptions.add(url, e.getCause());\n        }\n      }\n\n      if (exceptions.size() > 0) {\n        throw new RouteException(ErrorCode.SERVER_ERROR, exceptions, routes);\n      }\n    } else {\n      for (Map.Entry<String, LBHttpSolrClient.Req> entry : routes.entrySet()) {\n        String url = entry.getKey();\n        LBHttpSolrClient.Req lbRequest = entry.getValue();\n        try {\n          NamedList<Object> rsp = lbClient.request(lbRequest).getResponse();\n          shardResponses.add(url, rsp);\n        } catch (Exception e) {\n          throw new SolrServerException(e);\n        }\n      }\n    }\n\n    UpdateRequest nonRoutableRequest = null;\n    List<String> deleteQuery = updateRequest.getDeleteQuery();\n    if (deleteQuery != null && deleteQuery.size() > 0) {\n      UpdateRequest deleteQueryRequest = new UpdateRequest();\n      deleteQueryRequest.setDeleteQuery(deleteQuery);\n      nonRoutableRequest = deleteQueryRequest;\n    }\n    \n    Set<String> paramNames = nonRoutableParams.getParameterNames();\n    \n    Set<String> intersection = new HashSet<>(paramNames);\n    intersection.retainAll(NON_ROUTABLE_PARAMS);\n    \n    if (nonRoutableRequest != null || intersection.size() > 0) {\n      if (nonRoutableRequest == null) {\n        nonRoutableRequest = new UpdateRequest();\n      }\n      nonRoutableRequest.setParams(nonRoutableParams);\n      List<String> urlList = new ArrayList<>();\n      urlList.addAll(routes.keySet());\n      Collections.shuffle(urlList, rand);\n      LBHttpSolrClient.Req req = new LBHttpSolrClient.Req(nonRoutableRequest, urlList);\n      try {\n        LBHttpSolrClient.Rsp rsp = lbClient.request(req);\n        shardResponses.add(urlList.get(0), rsp.getResponse());\n      } catch (Exception e) {\n        throw new SolrException(ErrorCode.SERVER_ERROR, urlList.get(0), e);\n      }\n    }\n\n    long end = System.nanoTime();\n\n    RouteResponse rr =  condenseResponse(shardResponses, (long)((end - start)/1000000));\n    rr.setRouteResponses(shardResponses);\n    rr.setRoutes(routes);\n    return rr;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["bafca15d8e408346a67f4282ad1143b88023893b","7ca08c071cb75a8796c36ae6a1c90d7473c2a6df"],"0a20a867de92263c94258f9778db64a5efc7956d":["bafca15d8e408346a67f4282ad1143b88023893b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"bafca15d8e408346a67f4282ad1143b88023893b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7ca08c071cb75a8796c36ae6a1c90d7473c2a6df"],"7ca08c071cb75a8796c36ae6a1c90d7473c2a6df":["0a20a867de92263c94258f9778db64a5efc7956d"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0a20a867de92263c94258f9778db64a5efc7956d":["7ca08c071cb75a8796c36ae6a1c90d7473c2a6df"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bafca15d8e408346a67f4282ad1143b88023893b"],"bafca15d8e408346a67f4282ad1143b88023893b":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0a20a867de92263c94258f9778db64a5efc7956d"],"7ca08c071cb75a8796c36ae6a1c90d7473c2a6df":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}