{"path":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","commits":[{"id":"60596f28be69b10c37a56a303c2dbea07b2ca4ba","date":1425060541,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUFilterCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUFilterCache filterCache = new LRUFilterCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    SearcherManager mgr = new SearcherManager(w.w, random().nextBoolean(), new SearcherFactory());\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                filterCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Filter f = new QueryWrapperFilter(new TermQuery(new Term(\"color\", value)));\n                final Filter cached = filterCache.doCache(f, MAYBE_CACHE_POLICY);\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(new ConstantScoreQuery(cached), collector);\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(new ConstantScoreQuery(f), collector2);\n                assertEquals(collector.getTotalHits(), collector2.getTotalHits());\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    filterCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    filterCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"/dev/null","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e0dfae671422e7453a9199aa320f91427cd80d60","date":1427895926,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0c924d4069ef5a5bc479a493befe0121aada6896","date":1427901860,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aac61ee5b4492f174e60bd54939aba9539906edf","date":1461245473,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000));\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","date":1498031702,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":["60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final int totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7732a106554be0db3e03ac5211e46f6e0c285b8","date":1511975378,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean(), Float.POSITIVE_INFINITY);\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean(), Float.POSITIVE_INFINITY);\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"789fb338d3c53b4478938723d60f6623e764ca38","date":1521535944,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean(), Float.POSITIVE_INFINITY);\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","date":1521731438,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean(), Float.POSITIVE_INFINITY);\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits.value; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e708f948b384f9aa85c665caee4486eb2d9e197d","date":1533106881,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(q, new FilterCollector(collector2) {\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE; // will not use the cache because of scores\n                  }\n                });\n                final long totalHits2 = collector2.getTotalHits();\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                final long totalHits2 = searcher.search(q, 1).totalHits.value; // will not use the cache because of scores\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f740a4cb7f5949ddb40a1647671c4a997223312","date":1569677340,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(),\n        new NamedThreadFactory(\"TestLRUQueryCache\"));\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final SearcherFactory concurrentSearcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader, service);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n\n    final SearcherFactory[] searcherFactories = {searcherFactory, concurrentSearcherFactory};\n\n    for (SearcherFactory currentSearcherFactory : searcherFactories) {\n      final boolean applyDeletes = random().nextBoolean();\n      final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, currentSearcherFactory);\n      final AtomicBoolean indexing = new AtomicBoolean(true);\n      final AtomicReference<Throwable> error = new AtomicReference<>();\n      final int numDocs = atLeast(10000);\n      Thread[] threads = new Thread[3];\n      threads[0] = new Thread() {\n        public void run() {\n          Document doc = new Document();\n          StringField f = new StringField(\"color\", \"\", Store.NO);\n          doc.add(f);\n          for (int i = 0; indexing.get() && i < numDocs; ++i) {\n            f.setStringValue(RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\"}));\n            try {\n              w.addDocument(doc);\n              if ((i & 63) == 0) {\n                mgr.maybeRefresh();\n                if (rarely()) {\n                  queryCache.clear();\n                }\n                if (rarely()) {\n                  final String color = RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\"});\n                  w.deleteDocuments(new Term(\"color\", color));\n                }\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n              break;\n            }\n          }\n          indexing.set(false);\n        }\n      };\n      for (int i = 1; i < threads.length; ++i) {\n        threads[i] = new Thread() {\n          @Override\n          public void run() {\n            while (indexing.get()) {\n              try {\n                final IndexSearcher searcher = mgr.acquire();\n                try {\n                  final String value = RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\", \"green\"});\n                  final Query q = new TermQuery(new Term(\"color\", value));\n                  TotalHitCountCollector collector = new TotalHitCountCollector();\n                  searcher.search(q, collector); // will use the cache\n                  final int totalHits1 = collector.getTotalHits();\n                  TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                  searcher.search(q, new FilterCollector(collector2) {\n                    public ScoreMode scoreMode() {\n                      return ScoreMode.COMPLETE; // will not use the cache because of scores\n                    }\n                  });\n                  final long totalHits2 = collector2.getTotalHits();\n                  assertEquals(totalHits2, totalHits1);\n                } finally {\n                  mgr.release(searcher);\n                }\n              } catch (Throwable t) {\n                error.compareAndSet(null, t);\n              }\n            }\n          }\n        };\n      }\n\n      for (Thread thread : threads) {\n        thread.start();\n      }\n\n      for (Thread thread : threads) {\n        thread.join();\n      }\n\n      if (error.get() != null) {\n        throw error.get();\n      }\n      queryCache.assertConsistent();\n      mgr.close();\n    }\n\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n    service.shutdown();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(q, new FilterCollector(collector2) {\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE; // will not use the cache because of scores\n                  }\n                });\n                final long totalHits2 = collector2.getTotalHits();\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b9f74021389e2b32ee750fa5a24281c87951ec3","date":1569845983,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(),\n        new NamedThreadFactory(\"TestLRUQueryCache\"));\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final SearcherFactory concurrentSearcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader, service);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n\n    final SearcherFactory[] searcherFactories = {searcherFactory, concurrentSearcherFactory};\n\n    for (SearcherFactory currentSearcherFactory : searcherFactories) {\n      final boolean applyDeletes = random().nextBoolean();\n      final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, currentSearcherFactory);\n      final AtomicBoolean indexing = new AtomicBoolean(true);\n      final AtomicReference<Throwable> error = new AtomicReference<>();\n      final int numDocs = atLeast(10000);\n      Thread[] threads = new Thread[3];\n      threads[0] = new Thread() {\n        public void run() {\n          Document doc = new Document();\n          StringField f = new StringField(\"color\", \"\", Store.NO);\n          doc.add(f);\n          for (int i = 0; indexing.get() && i < numDocs; ++i) {\n            f.setStringValue(RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\"}));\n            try {\n              w.addDocument(doc);\n              if ((i & 63) == 0) {\n                mgr.maybeRefresh();\n                if (rarely()) {\n                  queryCache.clear();\n                }\n                if (rarely()) {\n                  final String color = RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\"});\n                  w.deleteDocuments(new Term(\"color\", color));\n                }\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n              break;\n            }\n          }\n          indexing.set(false);\n        }\n      };\n      for (int i = 1; i < threads.length; ++i) {\n        threads[i] = new Thread() {\n          @Override\n          public void run() {\n            while (indexing.get()) {\n              try {\n                final IndexSearcher searcher = mgr.acquire();\n                try {\n                  final String value = RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\", \"green\"});\n                  final Query q = new TermQuery(new Term(\"color\", value));\n                  TotalHitCountCollector collector = new TotalHitCountCollector();\n                  searcher.search(q, collector); // will use the cache\n                  final int totalHits1 = collector.getTotalHits();\n                  TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                  searcher.search(q, new FilterCollector(collector2) {\n                    public ScoreMode scoreMode() {\n                      return ScoreMode.COMPLETE; // will not use the cache because of scores\n                    }\n                  });\n                  final long totalHits2 = collector2.getTotalHits();\n                  assertEquals(totalHits2, totalHits1);\n                } finally {\n                  mgr.release(searcher);\n                }\n              } catch (Throwable t) {\n                error.compareAndSet(null, t);\n              }\n            }\n          }\n        };\n      }\n\n      for (Thread thread : threads) {\n        thread.start();\n      }\n\n      for (Thread thread : threads) {\n        thread.join();\n      }\n\n      if (error.get() != null) {\n        throw error.get();\n      }\n      queryCache.assertConsistent();\n      mgr.close();\n    }\n\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n    service.shutdown();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(q, new FilterCollector(collector2) {\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE; // will not use the cache because of scores\n                  }\n                });\n                final long totalHits2 = collector2.getTotalHits();\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"906d4da7e00f8453a5a024fe1ee92d6b14c0627f","date":1570006475,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(q, new FilterCollector(collector2) {\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE; // will not use the cache because of scores\n                  }\n                });\n                final long totalHits2 = collector2.getTotalHits();\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(),\n        new NamedThreadFactory(\"TestLRUQueryCache\"));\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final SearcherFactory concurrentSearcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader, service);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n\n    final SearcherFactory[] searcherFactories = {searcherFactory, concurrentSearcherFactory};\n\n    for (SearcherFactory currentSearcherFactory : searcherFactories) {\n      final boolean applyDeletes = random().nextBoolean();\n      final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, currentSearcherFactory);\n      final AtomicBoolean indexing = new AtomicBoolean(true);\n      final AtomicReference<Throwable> error = new AtomicReference<>();\n      final int numDocs = atLeast(10000);\n      Thread[] threads = new Thread[3];\n      threads[0] = new Thread() {\n        public void run() {\n          Document doc = new Document();\n          StringField f = new StringField(\"color\", \"\", Store.NO);\n          doc.add(f);\n          for (int i = 0; indexing.get() && i < numDocs; ++i) {\n            f.setStringValue(RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\"}));\n            try {\n              w.addDocument(doc);\n              if ((i & 63) == 0) {\n                mgr.maybeRefresh();\n                if (rarely()) {\n                  queryCache.clear();\n                }\n                if (rarely()) {\n                  final String color = RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\"});\n                  w.deleteDocuments(new Term(\"color\", color));\n                }\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n              break;\n            }\n          }\n          indexing.set(false);\n        }\n      };\n      for (int i = 1; i < threads.length; ++i) {\n        threads[i] = new Thread() {\n          @Override\n          public void run() {\n            while (indexing.get()) {\n              try {\n                final IndexSearcher searcher = mgr.acquire();\n                try {\n                  final String value = RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\", \"green\"});\n                  final Query q = new TermQuery(new Term(\"color\", value));\n                  TotalHitCountCollector collector = new TotalHitCountCollector();\n                  searcher.search(q, collector); // will use the cache\n                  final int totalHits1 = collector.getTotalHits();\n                  TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                  searcher.search(q, new FilterCollector(collector2) {\n                    public ScoreMode scoreMode() {\n                      return ScoreMode.COMPLETE; // will not use the cache because of scores\n                    }\n                  });\n                  final long totalHits2 = collector2.getTotalHits();\n                  assertEquals(totalHits2, totalHits1);\n                } finally {\n                  mgr.release(searcher);\n                }\n              } catch (Throwable t) {\n                error.compareAndSet(null, t);\n              }\n            }\n          }\n        };\n      }\n\n      for (Thread thread : threads) {\n        thread.start();\n      }\n\n      for (Thread thread : threads) {\n        thread.join();\n      }\n\n      if (error.get() != null) {\n        throw error.get();\n      }\n      queryCache.assertConsistent();\n      mgr.close();\n    }\n\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n    service.shutdown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(q, new FilterCollector(collector2) {\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE; // will not use the cache because of scores\n                  }\n                });\n                final long totalHits2 = collector2.getTotalHits();\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(),\n        new NamedThreadFactory(\"TestLRUQueryCache\"));\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final SearcherFactory concurrentSearcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader, service);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n\n    final SearcherFactory[] searcherFactories = {searcherFactory, concurrentSearcherFactory};\n\n    for (SearcherFactory currentSearcherFactory : searcherFactories) {\n      final boolean applyDeletes = random().nextBoolean();\n      final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, currentSearcherFactory);\n      final AtomicBoolean indexing = new AtomicBoolean(true);\n      final AtomicReference<Throwable> error = new AtomicReference<>();\n      final int numDocs = atLeast(10000);\n      Thread[] threads = new Thread[3];\n      threads[0] = new Thread() {\n        public void run() {\n          Document doc = new Document();\n          StringField f = new StringField(\"color\", \"\", Store.NO);\n          doc.add(f);\n          for (int i = 0; indexing.get() && i < numDocs; ++i) {\n            f.setStringValue(RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\"}));\n            try {\n              w.addDocument(doc);\n              if ((i & 63) == 0) {\n                mgr.maybeRefresh();\n                if (rarely()) {\n                  queryCache.clear();\n                }\n                if (rarely()) {\n                  final String color = RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\"});\n                  w.deleteDocuments(new Term(\"color\", color));\n                }\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n              break;\n            }\n          }\n          indexing.set(false);\n        }\n      };\n      for (int i = 1; i < threads.length; ++i) {\n        threads[i] = new Thread() {\n          @Override\n          public void run() {\n            while (indexing.get()) {\n              try {\n                final IndexSearcher searcher = mgr.acquire();\n                try {\n                  final String value = RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\", \"green\"});\n                  final Query q = new TermQuery(new Term(\"color\", value));\n                  TotalHitCountCollector collector = new TotalHitCountCollector();\n                  searcher.search(q, collector); // will use the cache\n                  final int totalHits1 = collector.getTotalHits();\n                  TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                  searcher.search(q, new FilterCollector(collector2) {\n                    public ScoreMode scoreMode() {\n                      return ScoreMode.COMPLETE; // will not use the cache because of scores\n                    }\n                  });\n                  final long totalHits2 = collector2.getTotalHits();\n                  assertEquals(totalHits2, totalHits1);\n                } finally {\n                  mgr.release(searcher);\n                }\n              } catch (Throwable t) {\n                error.compareAndSet(null, t);\n              }\n            }\n          }\n        };\n      }\n\n      for (Thread thread : threads) {\n        thread.start();\n      }\n\n      for (Thread thread : threads) {\n        thread.join();\n      }\n\n      if (error.get() != null) {\n        throw error.get();\n      }\n      queryCache.assertConsistent();\n      mgr.close();\n    }\n\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n    service.shutdown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5754bd6f04f13b67e9575f8b226a0303c31c7d5","date":1573506453,"type":3,"author":"ginger","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean(), Float.POSITIVE_INFINITY);\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(q, new FilterCollector(collector2) {\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE; // will not use the cache because of scores\n                  }\n                });\n                final long totalHits2 = collector2.getTotalHits();\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean());\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(q, new FilterCollector(collector2) {\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE; // will not use the cache because of scores\n                  }\n                });\n                final long totalHits2 = collector2.getTotalHits();\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fbdd90cd58912788fecb1044df8f566a4420e59","date":1574749923,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean(), Float.POSITIVE_INFINITY);\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(),\n        new NamedThreadFactory(\"TestLRUQueryCache\"));\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final SearcherFactory concurrentSearcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader, service);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n\n    final SearcherFactory[] searcherFactories = {searcherFactory, concurrentSearcherFactory};\n\n    for (SearcherFactory currentSearcherFactory : searcherFactories) {\n      final boolean applyDeletes = random().nextBoolean();\n      final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, currentSearcherFactory);\n      final AtomicBoolean indexing = new AtomicBoolean(true);\n      final AtomicReference<Throwable> error = new AtomicReference<>();\n      final int numDocs = atLeast(10000);\n      Thread[] threads = new Thread[3];\n      threads[0] = new Thread() {\n        public void run() {\n          Document doc = new Document();\n          StringField f = new StringField(\"color\", \"\", Store.NO);\n          doc.add(f);\n          for (int i = 0; indexing.get() && i < numDocs; ++i) {\n            f.setStringValue(RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\"}));\n            try {\n              w.addDocument(doc);\n              if ((i & 63) == 0) {\n                mgr.maybeRefresh();\n                if (rarely()) {\n                  queryCache.clear();\n                }\n                if (rarely()) {\n                  final String color = RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\"});\n                  w.deleteDocuments(new Term(\"color\", color));\n                }\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n              break;\n            }\n          }\n          indexing.set(false);\n        }\n      };\n      for (int i = 1; i < threads.length; ++i) {\n        threads[i] = new Thread() {\n          @Override\n          public void run() {\n            while (indexing.get()) {\n              try {\n                final IndexSearcher searcher = mgr.acquire();\n                try {\n                  final String value = RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\", \"green\"});\n                  final Query q = new TermQuery(new Term(\"color\", value));\n                  TotalHitCountCollector collector = new TotalHitCountCollector();\n                  searcher.search(q, collector); // will use the cache\n                  final int totalHits1 = collector.getTotalHits();\n                  TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                  searcher.search(q, new FilterCollector(collector2) {\n                    public ScoreMode scoreMode() {\n                      return ScoreMode.COMPLETE; // will not use the cache because of scores\n                    }\n                  });\n                  final long totalHits2 = collector2.getTotalHits();\n                  assertEquals(totalHits2, totalHits1);\n                } finally {\n                  mgr.release(searcher);\n                }\n              } catch (Throwable t) {\n                error.compareAndSet(null, t);\n              }\n            }\n          }\n        };\n      }\n\n      for (Thread thread : threads) {\n        thread.start();\n      }\n\n      for (Thread thread : threads) {\n        thread.join();\n      }\n\n      if (error.get() != null) {\n        throw error.get();\n      }\n      queryCache.assertConsistent();\n      mgr.close();\n    }\n\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n    service.shutdown();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean(), Float.POSITIVE_INFINITY);\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(q, new FilterCollector(collector2) {\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE; // will not use the cache because of scores\n                  }\n                });\n                final long totalHits2 = collector2.getTotalHits();\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bbc355b3e849ee4a34763155bb78e638d625419","date":1574952532,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean(), Float.POSITIVE_INFINITY);\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(q, new FilterCollector(collector2) {\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE; // will not use the cache because of scores\n                  }\n                });\n                final long totalHits2 = collector2.getTotalHits();\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean(), Float.POSITIVE_INFINITY);\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue<Runnable>(),\n        new NamedThreadFactory(\"TestLRUQueryCache\"));\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final SearcherFactory concurrentSearcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader, service);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n\n    final SearcherFactory[] searcherFactories = {searcherFactory, concurrentSearcherFactory};\n\n    for (SearcherFactory currentSearcherFactory : searcherFactories) {\n      final boolean applyDeletes = random().nextBoolean();\n      final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, currentSearcherFactory);\n      final AtomicBoolean indexing = new AtomicBoolean(true);\n      final AtomicReference<Throwable> error = new AtomicReference<>();\n      final int numDocs = atLeast(10000);\n      Thread[] threads = new Thread[3];\n      threads[0] = new Thread() {\n        public void run() {\n          Document doc = new Document();\n          StringField f = new StringField(\"color\", \"\", Store.NO);\n          doc.add(f);\n          for (int i = 0; indexing.get() && i < numDocs; ++i) {\n            f.setStringValue(RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\"}));\n            try {\n              w.addDocument(doc);\n              if ((i & 63) == 0) {\n                mgr.maybeRefresh();\n                if (rarely()) {\n                  queryCache.clear();\n                }\n                if (rarely()) {\n                  final String color = RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\"});\n                  w.deleteDocuments(new Term(\"color\", color));\n                }\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n              break;\n            }\n          }\n          indexing.set(false);\n        }\n      };\n      for (int i = 1; i < threads.length; ++i) {\n        threads[i] = new Thread() {\n          @Override\n          public void run() {\n            while (indexing.get()) {\n              try {\n                final IndexSearcher searcher = mgr.acquire();\n                try {\n                  final String value = RandomPicks.randomFrom(random(), new String[]{\"blue\", \"red\", \"yellow\", \"green\"});\n                  final Query q = new TermQuery(new Term(\"color\", value));\n                  TotalHitCountCollector collector = new TotalHitCountCollector();\n                  searcher.search(q, collector); // will use the cache\n                  final int totalHits1 = collector.getTotalHits();\n                  TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                  searcher.search(q, new FilterCollector(collector2) {\n                    public ScoreMode scoreMode() {\n                      return ScoreMode.COMPLETE; // will not use the cache because of scores\n                    }\n                  });\n                  final long totalHits2 = collector2.getTotalHits();\n                  assertEquals(totalHits2, totalHits1);\n                } finally {\n                  mgr.release(searcher);\n                }\n              } catch (Throwable t) {\n                error.compareAndSet(null, t);\n              }\n            }\n          }\n        };\n      }\n\n      for (Thread thread : threads) {\n        thread.start();\n      }\n\n      for (Thread thread : threads) {\n        thread.join();\n      }\n\n      if (error.get() != null) {\n        throw error.get();\n      }\n      queryCache.assertConsistent();\n      mgr.close();\n    }\n\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n    service.shutdown();\n  }\n\n","bugFix":null,"bugIntro":["71da933d30aea361ccc224d6544c451cbf49916d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71da933d30aea361ccc224d6544c451cbf49916d","date":1579874339,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean(), Float.POSITIVE_INFINITY);\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(1000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(q, new FilterCollector(collector2) {\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE; // will not use the cache because of scores\n                  }\n                });\n                final long totalHits2 = collector2.getTotalHits();\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean(), Float.POSITIVE_INFINITY);\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(10000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(q, new FilterCollector(collector2) {\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE; // will not use the cache because of scores\n                  }\n                });\n                final long totalHits2 = collector2.getTotalHits();\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":["9bbc355b3e849ee4a34763155bb78e638d625419"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c37ab80ad12b466f3dc92e4baa7b0cbf9aded429","date":1590107358,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache#testConcurrency().mjava","sourceNew":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean(), Float.POSITIVE_INFINITY);\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(1000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(q, new FilterCollector(collector2) {\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE; // will not use the cache because of scores\n                  }\n                });\n                final long totalHits2 = collector2.getTotalHits();\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    try {\n      if (error.get() != null) {\n        throw error.get();\n      }\n      queryCache.assertConsistent();\n    } finally {\n      mgr.close();\n      w.close();\n      dir.close();\n      queryCache.assertConsistent();\n    }\n  }\n\n","sourceOld":"  public void testConcurrency() throws Throwable {\n    final LRUQueryCache queryCache = new LRUQueryCache(1 + random().nextInt(20), 1 + random().nextInt(10000), context -> random().nextBoolean(), Float.POSITIVE_INFINITY);\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final SearcherFactory searcherFactory = new SearcherFactory() {\n      @Override\n      public IndexSearcher newSearcher(IndexReader reader, IndexReader previous) throws IOException {\n        IndexSearcher searcher = new IndexSearcher(reader);\n        searcher.setQueryCachingPolicy(MAYBE_CACHE_POLICY);\n        searcher.setQueryCache(queryCache);\n        return searcher;\n      }\n    };\n    final boolean applyDeletes = random().nextBoolean();\n    final SearcherManager mgr = new SearcherManager(w.w, applyDeletes, false, searcherFactory);\n    final AtomicBoolean indexing = new AtomicBoolean(true);\n    final AtomicReference<Throwable> error = new AtomicReference<>();\n    final int numDocs = atLeast(1000);\n    Thread[] threads = new Thread[3];\n    threads[0] = new Thread() {\n      public void run() {\n        Document doc = new Document();\n        StringField f = new StringField(\"color\", \"\", Store.NO);\n        doc.add(f);\n        for (int i = 0; indexing.get() && i < numDocs; ++i) {\n          f.setStringValue(RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"}));\n          try {\n            w.addDocument(doc);\n            if ((i & 63) == 0) {\n              mgr.maybeRefresh();\n              if (rarely()) {\n                queryCache.clear();\n              }\n              if (rarely()) {\n                final String color = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\"});\n                w.deleteDocuments(new Term(\"color\", color));\n              }\n            }\n          } catch (Throwable t) {\n            error.compareAndSet(null, t);\n            break;\n          }\n        }\n        indexing.set(false);\n      }\n    };\n    for (int i = 1; i < threads.length; ++i) {\n      threads[i] = new Thread() {\n        @Override\n        public void run() {\n          while (indexing.get()) {\n            try {\n              final IndexSearcher searcher = mgr.acquire();\n              try {\n                final String value = RandomPicks.randomFrom(random(), new String[] {\"blue\", \"red\", \"yellow\", \"green\"});\n                final Query q = new TermQuery(new Term(\"color\", value));\n                TotalHitCountCollector collector = new TotalHitCountCollector();\n                searcher.search(q, collector); // will use the cache\n                final int totalHits1 = collector.getTotalHits();\n                TotalHitCountCollector collector2 = new TotalHitCountCollector();\n                searcher.search(q, new FilterCollector(collector2) {\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE; // will not use the cache because of scores\n                  }\n                });\n                final long totalHits2 = collector2.getTotalHits();\n                assertEquals(totalHits2, totalHits1);\n              } finally {\n                mgr.release(searcher);\n              }\n            } catch (Throwable t) {\n              error.compareAndSet(null, t);\n            }\n          }\n        }\n      };\n    }\n\n    for (Thread thread : threads) {\n      thread.start();\n    }\n\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    if (error.get() != null) {\n      throw error.get();\n    }\n    queryCache.assertConsistent();\n    mgr.close();\n    w.close();\n    dir.close();\n    queryCache.assertConsistent();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["1aad05eeff7818b0833c02ac6b743aa72054963b","789fb338d3c53b4478938723d60f6623e764ca38"],"e708f948b384f9aa85c665caee4486eb2d9e197d":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["aac61ee5b4492f174e60bd54939aba9539906edf"],"c37ab80ad12b466f3dc92e4baa7b0cbf9aded429":["71da933d30aea361ccc224d6544c451cbf49916d"],"0c924d4069ef5a5bc479a493befe0121aada6896":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","e0dfae671422e7453a9199aa320f91427cd80d60"],"e0dfae671422e7453a9199aa320f91427cd80d60":["60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["28288370235ed02234a64753cdbf0c6ec096304a","c7732a106554be0db3e03ac5211e46f6e0c285b8"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"789fb338d3c53b4478938723d60f6623e764ca38":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"6f740a4cb7f5949ddb40a1647671c4a997223312":["e708f948b384f9aa85c665caee4486eb2d9e197d"],"9bbc355b3e849ee4a34763155bb78e638d625419":["1fbdd90cd58912788fecb1044df8f566a4420e59"],"68496c2200e559fb7802f7575427b7a482659afb":["e0dfae671422e7453a9199aa320f91427cd80d60","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"4b9f74021389e2b32ee750fa5a24281c87951ec3":["e708f948b384f9aa85c665caee4486eb2d9e197d","6f740a4cb7f5949ddb40a1647671c4a997223312"],"906d4da7e00f8453a5a024fe1ee92d6b14c0627f":["6f740a4cb7f5949ddb40a1647671c4a997223312"],"aac61ee5b4492f174e60bd54939aba9539906edf":["68496c2200e559fb7802f7575427b7a482659afb"],"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b5754bd6f04f13b67e9575f8b226a0303c31c7d5":["906d4da7e00f8453a5a024fe1ee92d6b14c0627f"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["aac61ee5b4492f174e60bd54939aba9539906edf","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"28288370235ed02234a64753cdbf0c6ec096304a":["aac61ee5b4492f174e60bd54939aba9539906edf","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"1fbdd90cd58912788fecb1044df8f566a4420e59":["b5754bd6f04f13b67e9575f8b226a0303c31c7d5"],"c7732a106554be0db3e03ac5211e46f6e0c285b8":["28288370235ed02234a64753cdbf0c6ec096304a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c37ab80ad12b466f3dc92e4baa7b0cbf9aded429"],"71da933d30aea361ccc224d6544c451cbf49916d":["9bbc355b3e849ee4a34763155bb78e638d625419"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["e0dfae671422e7453a9199aa320f91427cd80d60"],"b0b597c65628ca9e73913a07e81691f8229bae35":["4b9f74021389e2b32ee750fa5a24281c87951ec3","906d4da7e00f8453a5a024fe1ee92d6b14c0627f"]},"commit2Childs":{"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"e708f948b384f9aa85c665caee4486eb2d9e197d":["6f740a4cb7f5949ddb40a1647671c4a997223312","4b9f74021389e2b32ee750fa5a24281c87951ec3"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"c37ab80ad12b466f3dc92e4baa7b0cbf9aded429":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0c924d4069ef5a5bc479a493befe0121aada6896":[],"e0dfae671422e7453a9199aa320f91427cd80d60":["0c924d4069ef5a5bc479a493befe0121aada6896","68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","789fb338d3c53b4478938723d60f6623e764ca38"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["0c924d4069ef5a5bc479a493befe0121aada6896"],"789fb338d3c53b4478938723d60f6623e764ca38":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"6f740a4cb7f5949ddb40a1647671c4a997223312":["4b9f74021389e2b32ee750fa5a24281c87951ec3","906d4da7e00f8453a5a024fe1ee92d6b14c0627f"],"9bbc355b3e849ee4a34763155bb78e638d625419":["71da933d30aea361ccc224d6544c451cbf49916d"],"68496c2200e559fb7802f7575427b7a482659afb":["aac61ee5b4492f174e60bd54939aba9539906edf"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["e708f948b384f9aa85c665caee4486eb2d9e197d"],"4b9f74021389e2b32ee750fa5a24281c87951ec3":["b0b597c65628ca9e73913a07e81691f8229bae35"],"906d4da7e00f8453a5a024fe1ee92d6b14c0627f":["b5754bd6f04f13b67e9575f8b226a0303c31c7d5","b0b597c65628ca9e73913a07e81691f8229bae35"],"aac61ee5b4492f174e60bd54939aba9539906edf":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["e0dfae671422e7453a9199aa320f91427cd80d60","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"b5754bd6f04f13b67e9575f8b226a0303c31c7d5":["1fbdd90cd58912788fecb1044df8f566a4420e59"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["1aad05eeff7818b0833c02ac6b743aa72054963b","c7732a106554be0db3e03ac5211e46f6e0c285b8"],"c7732a106554be0db3e03ac5211e46f6e0c285b8":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"1fbdd90cd58912788fecb1044df8f566a4420e59":["9bbc355b3e849ee4a34763155bb78e638d625419"],"71da933d30aea361ccc224d6544c451cbf49916d":["c37ab80ad12b466f3dc92e4baa7b0cbf9aded429"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["0c924d4069ef5a5bc479a493befe0121aada6896","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}