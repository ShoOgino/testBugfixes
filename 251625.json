{"path":"src/java/org/apache/solr/util/plugin/AbstractPluginLoader#load(NodeList).mjava","commits":[{"id":"a4cc0532e82274748c1910318b92089c5604e48a","date":1183443010,"type":0,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/util/plugin/AbstractPluginLoader#load(NodeList).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Given a NodeList from XML, this will\n   */\n  public T load( NodeList nodes )\n  {\n    List<PluginInitInfo> info = new ArrayList<PluginInitInfo>();\n    T defaultPlugin = null;\n    \n    if (nodes !=null ) {\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name       = DOMUtil.getAttr(node,\"name\", type);\n          String className  = DOMUtil.getAttr(node,\"class\", type);\n          String defaultStr = DOMUtil.getAttr(node,\"default\", null );\n          \n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \n              \"name\",\"class\" );\n  \n          T plugin = create(name, className, params, node );\n          log.info(\"created \"+name+\": \" + plugin.getClass().getName() );\n          \n          // Either initialize now or wait till everything has been registered\n          if( preRegister ) {\n            info.add( new PluginInitInfo( plugin, params, node ) );\n          }\n          else {\n            init( plugin, params, node );\n          }\n          \n          T old = register( name, plugin );\n          if( old != null ) {\n            throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple \"+type+\" registered to the same name: \"+name+\" ignoring: \"+old );\n          }\n          \n          if( defaultStr != null && Boolean.parseBoolean( defaultStr ) ) {\n            if( defaultPlugin != null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple default \"+type+\" plugins: \"+defaultPlugin + \" AND \" + name );\n            }\n            defaultPlugin = plugin;\n          }\n        }\n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    // If everything needs to be registered *first*, this will initialize later\n    for( PluginInitInfo pinfo : info ) {\n      try {\n        init( pinfo.plugin, pinfo.params, pinfo.node );\n      }\n      catch( Exception ex ) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    return defaultPlugin;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"110bbd9ae9f8b3ce3aa98c0c3e12de621c76ed78","date":1183449681,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/util/plugin/AbstractPluginLoader#load(NodeList).mjava","pathOld":"src/java/org/apache/solr/util/plugin/AbstractPluginLoader#load(NodeList).mjava","sourceNew":"  /**\n   * Given a NodeList from XML in the form:\n   * \n   *  <plugins>\n   *    <plugin name=\"name1\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *  </plugins>\n   * \n   * This will initialize and register each plugin from the list.  A class will \n   * be generated for each class name and registered to the given name.\n   * \n   * If 'preRegister' is true, each plugin will be registered *before* it is initialized\n   * This may be useful for implementations that need to inspect other registered \n   * plugins at startup.\n   * \n   * One (and only one) plugin may declare itself to be the 'default' plugin using:\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" default=\"true\">\n   * If a default element is defined, it will be returned from this function.\n   * \n   */\n  public T load( NodeList nodes )\n  {\n    List<PluginInitInfo> info = new ArrayList<PluginInitInfo>();\n    T defaultPlugin = null;\n    \n    if (nodes !=null ) {\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name       = DOMUtil.getAttr(node,\"name\", type);\n          String className  = DOMUtil.getAttr(node,\"class\", type);\n          String defaultStr = DOMUtil.getAttr(node,\"default\", null );\n          \n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \n              \"name\",\"class\" );\n  \n          T plugin = create(name, className, params, node );\n          log.info(\"created \"+name+\": \" + plugin.getClass().getName() );\n          \n          // Either initialize now or wait till everything has been registered\n          if( preRegister ) {\n            info.add( new PluginInitInfo( plugin, params, node ) );\n          }\n          else {\n            init( plugin, params, node );\n          }\n          \n          T old = register( name, plugin );\n          if( old != null ) {\n            throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple \"+type+\" registered to the same name: \"+name+\" ignoring: \"+old );\n          }\n          \n          if( defaultStr != null && Boolean.parseBoolean( defaultStr ) ) {\n            if( defaultPlugin != null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple default \"+type+\" plugins: \"+defaultPlugin + \" AND \" + name );\n            }\n            defaultPlugin = plugin;\n          }\n        }\n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    // If everything needs to be registered *first*, this will initialize later\n    for( PluginInitInfo pinfo : info ) {\n      try {\n        init( pinfo.plugin, pinfo.params, pinfo.node );\n      }\n      catch( Exception ex ) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    return defaultPlugin;\n  }\n\n","sourceOld":"  /**\n   * Given a NodeList from XML, this will\n   */\n  public T load( NodeList nodes )\n  {\n    List<PluginInitInfo> info = new ArrayList<PluginInitInfo>();\n    T defaultPlugin = null;\n    \n    if (nodes !=null ) {\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name       = DOMUtil.getAttr(node,\"name\", type);\n          String className  = DOMUtil.getAttr(node,\"class\", type);\n          String defaultStr = DOMUtil.getAttr(node,\"default\", null );\n          \n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \n              \"name\",\"class\" );\n  \n          T plugin = create(name, className, params, node );\n          log.info(\"created \"+name+\": \" + plugin.getClass().getName() );\n          \n          // Either initialize now or wait till everything has been registered\n          if( preRegister ) {\n            info.add( new PluginInitInfo( plugin, params, node ) );\n          }\n          else {\n            init( plugin, params, node );\n          }\n          \n          T old = register( name, plugin );\n          if( old != null ) {\n            throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple \"+type+\" registered to the same name: \"+name+\" ignoring: \"+old );\n          }\n          \n          if( defaultStr != null && Boolean.parseBoolean( defaultStr ) ) {\n            if( defaultPlugin != null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple default \"+type+\" plugins: \"+defaultPlugin + \" AND \" + name );\n            }\n            defaultPlugin = plugin;\n          }\n        }\n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    // If everything needs to be registered *first*, this will initialize later\n    for( PluginInitInfo pinfo : info ) {\n      try {\n        init( pinfo.plugin, pinfo.params, pinfo.node );\n      }\n      catch( Exception ex ) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    return defaultPlugin;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1","date":1183450581,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/util/plugin/AbstractPluginLoader#load(NodeList).mjava","pathOld":"src/java/org/apache/solr/util/plugin/AbstractPluginLoader#load(NodeList).mjava","sourceNew":"  /**\n   * Given a NodeList from XML in the form:\n   * \n   *  <plugins>\n   *    <plugin name=\"name1\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *  </plugins>\n   * \n   * This will initialize and register each plugin from the list.  A class will \n   * be generated for each class name and registered to the given name.\n   * \n   * If 'preRegister' is true, each plugin will be registered *before* it is initialized\n   * This may be useful for implementations that need to inspect other registered \n   * plugins at startup.\n   * \n   * One (and only one) plugin may declare itself to be the 'default' plugin using:\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" default=\"true\">\n   * If a default element is defined, it will be returned from this function.\n   * \n   */\n  public T load( NodeList nodes )\n  {\n    List<PluginInitInfo> info = new ArrayList<PluginInitInfo>();\n    T defaultPlugin = null;\n    \n    if (nodes !=null ) {\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name       = DOMUtil.getAttr(node,\"name\", type);\n          String className  = DOMUtil.getAttr(node,\"class\", type);\n          String defaultStr = DOMUtil.getAttr(node,\"default\", null );\n            \n          T plugin = create(name, className, node );\n          log.info(\"created \"+name+\": \" + plugin.getClass().getName() );\n          \n          // Either initialize now or wait till everything has been registered\n          if( preRegister ) {\n            info.add( new PluginInitInfo( plugin, node ) );\n          }\n          else {\n            init( plugin, node );\n          }\n          \n          T old = register( name, plugin );\n          if( old != null ) {\n            throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple \"+type+\" registered to the same name: \"+name+\" ignoring: \"+old );\n          }\n          \n          if( defaultStr != null && Boolean.parseBoolean( defaultStr ) ) {\n            if( defaultPlugin != null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple default \"+type+\" plugins: \"+defaultPlugin + \" AND \" + name );\n            }\n            defaultPlugin = plugin;\n          }\n        }\n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    // If everything needs to be registered *first*, this will initialize later\n    for( PluginInitInfo pinfo : info ) {\n      try {\n        init( pinfo.plugin, pinfo.node );\n      }\n      catch( Exception ex ) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    return defaultPlugin;\n  }\n\n","sourceOld":"  /**\n   * Given a NodeList from XML in the form:\n   * \n   *  <plugins>\n   *    <plugin name=\"name1\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *  </plugins>\n   * \n   * This will initialize and register each plugin from the list.  A class will \n   * be generated for each class name and registered to the given name.\n   * \n   * If 'preRegister' is true, each plugin will be registered *before* it is initialized\n   * This may be useful for implementations that need to inspect other registered \n   * plugins at startup.\n   * \n   * One (and only one) plugin may declare itself to be the 'default' plugin using:\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" default=\"true\">\n   * If a default element is defined, it will be returned from this function.\n   * \n   */\n  public T load( NodeList nodes )\n  {\n    List<PluginInitInfo> info = new ArrayList<PluginInitInfo>();\n    T defaultPlugin = null;\n    \n    if (nodes !=null ) {\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name       = DOMUtil.getAttr(node,\"name\", type);\n          String className  = DOMUtil.getAttr(node,\"class\", type);\n          String defaultStr = DOMUtil.getAttr(node,\"default\", null );\n          \n          Map<String,String> params = DOMUtil.toMapExcept( node.getAttributes(), \n              \"name\",\"class\" );\n  \n          T plugin = create(name, className, params, node );\n          log.info(\"created \"+name+\": \" + plugin.getClass().getName() );\n          \n          // Either initialize now or wait till everything has been registered\n          if( preRegister ) {\n            info.add( new PluginInitInfo( plugin, params, node ) );\n          }\n          else {\n            init( plugin, params, node );\n          }\n          \n          T old = register( name, plugin );\n          if( old != null ) {\n            throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple \"+type+\" registered to the same name: \"+name+\" ignoring: \"+old );\n          }\n          \n          if( defaultStr != null && Boolean.parseBoolean( defaultStr ) ) {\n            if( defaultPlugin != null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple default \"+type+\" plugins: \"+defaultPlugin + \" AND \" + name );\n            }\n            defaultPlugin = plugin;\n          }\n        }\n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    // If everything needs to be registered *first*, this will initialize later\n    for( PluginInitInfo pinfo : info ) {\n      try {\n        init( pinfo.plugin, pinfo.params, pinfo.node );\n      }\n      catch( Exception ex ) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    return defaultPlugin;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6589002090bd74db749eef5befe2f447c0e3dd49","date":1184345280,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/util/plugin/AbstractPluginLoader#load(NodeList).mjava","pathOld":"src/java/org/apache/solr/util/plugin/AbstractPluginLoader#load(NodeList).mjava","sourceNew":"  /**\n   * Given a NodeList from XML in the form:\n   * \n   *  <plugins>\n   *    <plugin name=\"name1\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *  </plugins>\n   * \n   * This will initialize and register each plugin from the list.  A class will \n   * be generated for each class name and registered to the given name.\n   * \n   * If 'preRegister' is true, each plugin will be registered *before* it is initialized\n   * This may be useful for implementations that need to inspect other registered \n   * plugins at startup.\n   * \n   * One (and only one) plugin may declare itself to be the 'default' plugin using:\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" default=\"true\">\n   * If a default element is defined, it will be returned from this function.\n   * \n   */\n  public T load( NodeList nodes )\n  {\n    List<PluginInitInfo> info = new ArrayList<PluginInitInfo>();\n    T defaultPlugin = null;\n    \n    if (nodes !=null ) {\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name       = DOMUtil.getAttr(node,\"name\", requireName?type:null);\n          String className  = DOMUtil.getAttr(node,\"class\", type);\n          String defaultStr = DOMUtil.getAttr(node,\"default\", null );\n            \n          T plugin = create(name, className, node );\n          log.info(\"created \"+name+\": \" + plugin.getClass().getName() );\n          \n          // Either initialize now or wait till everything has been registered\n          if( preRegister ) {\n            info.add( new PluginInitInfo( plugin, node ) );\n          }\n          else {\n            init( plugin, node );\n          }\n          \n          T old = register( name, plugin );\n          if( old != null ) {\n            throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple \"+type+\" registered to the same name: \"+name+\" ignoring: \"+old );\n          }\n          \n          if( defaultStr != null && Boolean.parseBoolean( defaultStr ) ) {\n            if( defaultPlugin != null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple default \"+type+\" plugins: \"+defaultPlugin + \" AND \" + name );\n            }\n            defaultPlugin = plugin;\n          }\n        }\n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    // If everything needs to be registered *first*, this will initialize later\n    for( PluginInitInfo pinfo : info ) {\n      try {\n        init( pinfo.plugin, pinfo.node );\n      }\n      catch( Exception ex ) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    return defaultPlugin;\n  }\n\n","sourceOld":"  /**\n   * Given a NodeList from XML in the form:\n   * \n   *  <plugins>\n   *    <plugin name=\"name1\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *  </plugins>\n   * \n   * This will initialize and register each plugin from the list.  A class will \n   * be generated for each class name and registered to the given name.\n   * \n   * If 'preRegister' is true, each plugin will be registered *before* it is initialized\n   * This may be useful for implementations that need to inspect other registered \n   * plugins at startup.\n   * \n   * One (and only one) plugin may declare itself to be the 'default' plugin using:\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" default=\"true\">\n   * If a default element is defined, it will be returned from this function.\n   * \n   */\n  public T load( NodeList nodes )\n  {\n    List<PluginInitInfo> info = new ArrayList<PluginInitInfo>();\n    T defaultPlugin = null;\n    \n    if (nodes !=null ) {\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name       = DOMUtil.getAttr(node,\"name\", type);\n          String className  = DOMUtil.getAttr(node,\"class\", type);\n          String defaultStr = DOMUtil.getAttr(node,\"default\", null );\n            \n          T plugin = create(name, className, node );\n          log.info(\"created \"+name+\": \" + plugin.getClass().getName() );\n          \n          // Either initialize now or wait till everything has been registered\n          if( preRegister ) {\n            info.add( new PluginInitInfo( plugin, node ) );\n          }\n          else {\n            init( plugin, node );\n          }\n          \n          T old = register( name, plugin );\n          if( old != null ) {\n            throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple \"+type+\" registered to the same name: \"+name+\" ignoring: \"+old );\n          }\n          \n          if( defaultStr != null && Boolean.parseBoolean( defaultStr ) ) {\n            if( defaultPlugin != null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple default \"+type+\" plugins: \"+defaultPlugin + \" AND \" + name );\n            }\n            defaultPlugin = plugin;\n          }\n        }\n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    // If everything needs to be registered *first*, this will initialize later\n    for( PluginInitInfo pinfo : info ) {\n      try {\n        init( pinfo.plugin, pinfo.node );\n      }\n      catch( Exception ex ) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    return defaultPlugin;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d6338c87060be5f66757a94945975f3bbd377a9","date":1189278234,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/util/plugin/AbstractPluginLoader#load(NodeList).mjava","pathOld":"src/java/org/apache/solr/util/plugin/AbstractPluginLoader#load(NodeList).mjava","sourceNew":"  /**\n   * Given a NodeList from XML in the form:\n   * \n   *  <plugins>\n   *    <plugin name=\"name1\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *  </plugins>\n   * \n   * This will initialize and register each plugin from the list.  A class will \n   * be generated for each class name and registered to the given name.\n   * \n   * If 'preRegister' is true, each plugin will be registered *before* it is initialized\n   * This may be useful for implementations that need to inspect other registered \n   * plugins at startup.\n   * \n   * One (and only one) plugin may declare itself to be the 'default' plugin using:\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" default=\"true\">\n   * If a default element is defined, it will be returned from this function.\n   * \n   */\n  public T load( NodeList nodes ) {\n    return load(null, nodes);\n  }\n\n","sourceOld":"  /**\n   * Given a NodeList from XML in the form:\n   * \n   *  <plugins>\n   *    <plugin name=\"name1\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *  </plugins>\n   * \n   * This will initialize and register each plugin from the list.  A class will \n   * be generated for each class name and registered to the given name.\n   * \n   * If 'preRegister' is true, each plugin will be registered *before* it is initialized\n   * This may be useful for implementations that need to inspect other registered \n   * plugins at startup.\n   * \n   * One (and only one) plugin may declare itself to be the 'default' plugin using:\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" default=\"true\">\n   * If a default element is defined, it will be returned from this function.\n   * \n   */\n  public T load( NodeList nodes )\n  {\n    List<PluginInitInfo> info = new ArrayList<PluginInitInfo>();\n    T defaultPlugin = null;\n    \n    if (nodes !=null ) {\n      for (int i=0; i<nodes.getLength(); i++) {\n        Node node = nodes.item(i);\n  \n        // In a production environment, we can tolerate an error in some request handlers, \n        // still load the others, and have a working system.\n        try {\n          String name       = DOMUtil.getAttr(node,\"name\", requireName?type:null);\n          String className  = DOMUtil.getAttr(node,\"class\", type);\n          String defaultStr = DOMUtil.getAttr(node,\"default\", null );\n            \n          T plugin = create(name, className, node );\n          log.info(\"created \"+name+\": \" + plugin.getClass().getName() );\n          \n          // Either initialize now or wait till everything has been registered\n          if( preRegister ) {\n            info.add( new PluginInitInfo( plugin, node ) );\n          }\n          else {\n            init( plugin, node );\n          }\n          \n          T old = register( name, plugin );\n          if( old != null ) {\n            throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple \"+type+\" registered to the same name: \"+name+\" ignoring: \"+old );\n          }\n          \n          if( defaultStr != null && Boolean.parseBoolean( defaultStr ) ) {\n            if( defaultPlugin != null ) {\n              throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, \n                \"Multiple default \"+type+\" plugins: \"+defaultPlugin + \" AND \" + name );\n            }\n            defaultPlugin = plugin;\n          }\n        }\n        catch (Exception e) {\n          SolrConfig.severeErrors.add( e );\n          SolrException.logOnce(log,null,e);\n        }\n      }\n    }\n    \n    // If everything needs to be registered *first*, this will initialize later\n    for( PluginInitInfo pinfo : info ) {\n      try {\n        init( pinfo.plugin, pinfo.node );\n      }\n      catch( Exception ex ) {\n        SolrConfig.severeErrors.add( ex );\n        SolrException.logOnce(log,null,ex);\n      }\n    }\n    return defaultPlugin;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7","date":1189312484,"type":4,"author":"Ryan McKinley","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/solr/util/plugin/AbstractPluginLoader#load(NodeList).mjava","sourceNew":null,"sourceOld":"  /**\n   * Given a NodeList from XML in the form:\n   * \n   *  <plugins>\n   *    <plugin name=\"name1\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" >\n   *      ...\n   *    </plugin>\n   *  </plugins>\n   * \n   * This will initialize and register each plugin from the list.  A class will \n   * be generated for each class name and registered to the given name.\n   * \n   * If 'preRegister' is true, each plugin will be registered *before* it is initialized\n   * This may be useful for implementations that need to inspect other registered \n   * plugins at startup.\n   * \n   * One (and only one) plugin may declare itself to be the 'default' plugin using:\n   *    <plugin name=\"name2\" class=\"solr.ClassName\" default=\"true\">\n   * If a default element is defined, it will be returned from this function.\n   * \n   */\n  public T load( NodeList nodes ) {\n    return load(null, nodes);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6d6338c87060be5f66757a94945975f3bbd377a9":["6589002090bd74db749eef5befe2f447c0e3dd49"],"29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1":["110bbd9ae9f8b3ce3aa98c0c3e12de621c76ed78"],"a4cc0532e82274748c1910318b92089c5604e48a":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"6589002090bd74db749eef5befe2f447c0e3dd49":["29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1"],"94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7":["6d6338c87060be5f66757a94945975f3bbd377a9"],"110bbd9ae9f8b3ce3aa98c0c3e12de621c76ed78":["a4cc0532e82274748c1910318b92089c5604e48a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"6d6338c87060be5f66757a94945975f3bbd377a9":["94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7"],"29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1":["6589002090bd74db749eef5befe2f447c0e3dd49"],"a4cc0532e82274748c1910318b92089c5604e48a":["110bbd9ae9f8b3ce3aa98c0c3e12de621c76ed78"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["a4cc0532e82274748c1910318b92089c5604e48a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6589002090bd74db749eef5befe2f447c0e3dd49":["6d6338c87060be5f66757a94945975f3bbd377a9"],"94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7":[],"110bbd9ae9f8b3ce3aa98c0c3e12de621c76ed78":["29633c90dc51f05e4bbfe2e9f1991cdeee08b2d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["94fdcbef0182cbb32b3519de6a3d7d4d7bcb11d7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}