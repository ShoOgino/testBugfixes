{"path":"solr/core/src/java/org/apache/solr/handler/component/PhrasesIdentificationComponent#scoreAndAddResultsToResponse(ResponseBuilder,PhrasesContextData).mjava","commits":[{"id":"0d1411e62d30c460b09c6f3643df82daa10a27cc","date":1536256256,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PhrasesIdentificationComponent#scoreAndAddResultsToResponse(ResponseBuilder,PhrasesContextData).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Helper method (suitable for both single node &amp; distributed coordinator node) to \n   * score, sort, and format the end user response once all phrases have been populated with stats.\n   */\n  private void scoreAndAddResultsToResponse(final ResponseBuilder rb, final PhrasesContextData contextData) {\n    assert null != contextData : \"Should not be called if no phrase data to use\";\n    if (null == contextData) {\n      // if prepare didn't give us anything to work with, then we should do nothing\n      return;\n    }\n    \n    SimpleOrderedMap<Object> output = new SimpleOrderedMap<>();\n    rb.rsp.add(\"phrases\", output);\n    output.add(\"input\", contextData.rawInput);\n\n    if (0 == contextData.allPhrases.size()) {\n      // w/o any phrases, the summary is just the input again...\n      output.add(\"summary\", contextData.rawInput);\n      output.add(\"details\", Collections.<Object>emptyList());\n      return;\n    }\n    \n    Phrase.populateScores(contextData);\n    final int maxPosition = contextData.allPhrases.get(contextData.allPhrases.size()-1).getPositionEnd();\n    \n    final List<Phrase> validScoringPhrasesSorted = contextData.allPhrases.stream()\n      // TODO: ideally this cut off of \"0.0\" should be a request option...\n      // so users can tune how aggresive/conservative they want to be in finding phrases\n      // but for that to be useful, we need:\n      //  - more hard & fast documentation about the \"range\" of scores that may be returned\n      //  - \"useful\" scores for single words\n      .filter(p -> 0.0D < p.getTotalScore())\n      .sorted(Comparator.comparing((p -> p.getTotalScore()), Collections.reverseOrder()))\n      .collect(Collectors.toList());\n\n    // we want to return only high scoring phrases that don't overlap w/higher scoring phrase\n    final BitSet positionsCovered = new BitSet(maxPosition+1);\n    final List<Phrase> results = new ArrayList<>(maxPosition);\n    for (Phrase phrase : validScoringPhrasesSorted) {\n      final BitSet phrasePositions = phrase.getPositionsBitSet();\n      \n      if (! phrasePositions.intersects(positionsCovered)) {\n        // we can use this phrase, record it...\n        positionsCovered.or(phrasePositions);\n        results.add(phrase);\n      } // else: overlaps higher scoring position(s), skip this phrase\n      \n      if (positionsCovered.cardinality() == maxPosition+1) {\n        // all positions are covered, so we can bail out and skip the rest\n        break;\n      }\n    }\n    \n    // a \"quick summary\" of the suggested parsing\n    output.add(\"summary\", contextData.summarize(results));\n    // useful user level info on every (high scoring) phrase found (in current, descending score, order)\n    output.add(\"details\", results.stream()\n               .map(p -> p.getDetails()).collect(Collectors.toList()));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0d1411e62d30c460b09c6f3643df82daa10a27cc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0d1411e62d30c460b09c6f3643df82daa10a27cc"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d1411e62d30c460b09c6f3643df82daa10a27cc"],"0d1411e62d30c460b09c6f3643df82daa10a27cc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}